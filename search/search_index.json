{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"griffe \u00a4 Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Work in progress! Requirements \u00a4 Griffe requires Python 3.8 or above. To install Python 3.8, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - bash ) \" # install Python 3.8 pyenv install 3 .8.12 # make it available globally pyenv global system 3 .8.12 Installation \u00a4 With pip : python3.8 -m pip install griffe With pipx : python3.8 -m pip install --user pipx pipx install --python python3.8 griffe Usage \u00a4 On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples. Todo \u00a4 Design: Navigable trees (nodes and data) Extension system Performance Loader/Visitor: Docstrings Line numbers Parsing: see below Labels Attribute: ? Function: ? Class: ? Module: ? Modules Classes Bases (parent classes) Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring Decorators Functions Parameters Return annotation (names, constants, attributes) Decorators Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Attributes (variables/constants) Docstrings Value Name resolution Per-object scope Load external packages resursively (indirections/aliases) Resolve everything that is an ast.Name Resolve names inside more complex expressions? Calls, exprs, etc. Lines collection (lines for each module) Extension system Node-visiting extensions Post-processing extensions Docstrings parsers Structured format Styles Google RST Numpy epydoc New Markdown-based format? For graceful degradation Serializer: JSON Nested Flat API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Overview"},{"location":"#griffe","text":"Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Work in progress!","title":"griffe"},{"location":"#requirements","text":"Griffe requires Python 3.8 or above. To install Python 3.8, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - bash ) \" # install Python 3.8 pyenv install 3 .8.12 # make it available globally pyenv global system 3 .8.12","title":"Requirements"},{"location":"#installation","text":"With pip : python3.8 -m pip install griffe With pipx : python3.8 -m pip install --user pipx pipx install --python python3.8 griffe","title":"Installation"},{"location":"#usage","text":"On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples.","title":"Usage"},{"location":"#todo","text":"Design: Navigable trees (nodes and data) Extension system Performance Loader/Visitor: Docstrings Line numbers Parsing: see below Labels Attribute: ? Function: ? Class: ? Module: ? Modules Classes Bases (parent classes) Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring Decorators Functions Parameters Return annotation (names, constants, attributes) Decorators Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Attributes (variables/constants) Docstrings Value Name resolution Per-object scope Load external packages resursively (indirections/aliases) Resolve everything that is an ast.Name Resolve names inside more complex expressions? Calls, exprs, etc. Lines collection (lines for each module) Extension system Node-visiting extensions Post-processing extensions Docstrings parsers Structured format Styles Google RST Numpy epydoc New Markdown-based format? For graceful degradation Serializer: JSON Nested Flat API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Todo"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.7.1 - 2021-12-28 \u00a4 Compare with 0.7.0 Code Refactoring \u00a4 Only log warning if async mode is used ( 356e848 by Timoth\u00e9e Mazzucotelli). 0.7.0 - 2021-12-28 \u00a4 Compare with 0.6.0 Features \u00a4 Support more nodes on Python 3.7 ( 7f2c4ec by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Don't crash on syntax errors and log an error ( 10bb6b1 by Timoth\u00e9e Mazzucotelli). 0.6.0 - 2021-12-27 \u00a4 Compare with 0.5.0 Features \u00a4 Support more AST nodes ( cd1b305 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Use annotation getter for base classes ( 8b1a7ed by Timoth\u00e9e Mazzucotelli). 0.5.0 - 2021-12-20 \u00a4 Compare with 0.4.0 Features \u00a4 Add support for Python 3.7 ( 4535adc by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Don't propagate aliases of an alias ( 8af48f8 by Timoth\u00e9e Mazzucotelli). Don't reassign members defined in except clauses ( d918b4e by Timoth\u00e9e Mazzucotelli). 0.4.0 - 2021-11-28 \u00a4 Compare with 0.3.0 Features \u00a4 Add a prototype 'hybrid' extension ( 8cb3c16 by Timoth\u00e9e Mazzucotelli). Allow passing extensions config as JSON on the CLI ( 9a7fa8b by Timoth\u00e9e Mazzucotelli). Support names for returns, yields and receives sections items ( 1c5a4c9 by Timoth\u00e9e Mazzucotelli). Store aliases on each object ( 91ba643 by Timoth\u00e9e Mazzucotelli). Support in[tro]spection ( 3a0587d by Timoth\u00e9e Mazzucotelli). Support multiple return, yield and receive items ( 0fc70cb by Timoth\u00e9e Mazzucotelli). Support namespace packages ( 2414c8e by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Fix extensions loader ( 78fb70b by Timoth\u00e9e Mazzucotelli). Avoid visiting/inspecting multiple times ( 75a8a8b by Timoth\u00e9e Mazzucotelli). Set modules collection attribute earlier ( 592c0bd by Timoth\u00e9e Mazzucotelli). Support inequality nodes ( b0ed247 by Timoth\u00e9e Mazzucotelli). Handle Div nodes for values ( 272e4d6 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Set log level to INFO ( 718e73e by Timoth\u00e9e Mazzucotelli). Add target setter ( 7f0064c by Timoth\u00e9e Mazzucotelli). Reorganize conditions ( 15ab876 by Timoth\u00e9e Mazzucotelli). Avoid recursion loops ( ea6acec by Timoth\u00e9e Mazzucotelli). Update aliases when replacing a member ( 99a0f8b by Timoth\u00e9e Mazzucotelli). Reorganize code ( 31fcdb1 by Timoth\u00e9e Mazzucotelli). Replace DocstringException with DocstringRaise ( d5ed87a by Timoth\u00e9e Mazzucotelli). Refactor loaders ( d9b94bb by Timoth\u00e9e Mazzucotelli). Improve typing ( e08bcfa by Timoth\u00e9e Mazzucotelli). 0.3.0 - 2021-11-21 \u00a4 Compare with 0.2.0 Features \u00a4 Handle aliases and their resolution ( 67ae903 by Timoth\u00e9e Mazzucotelli). Resolve annotations in docstrings ( 847384a by Timoth\u00e9e Mazzucotelli). Resolve annotations ( 6451eff by Timoth\u00e9e Mazzucotelli). Add lines property to objects ( 7daf7db by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each object ( 07a1d2e by Timoth\u00e9e Mazzucotelli). Get attributes annotations from parent ( 003b990 by Timoth\u00e9e Mazzucotelli). Draft extensions loader ( 17ccd03 by Timoth\u00e9e Mazzucotelli). Add properties to objects ( 0ec301a by Timoth\u00e9e Mazzucotelli). Handle .pth files when searching modules ( 2a2e182 by Timoth\u00e9e Mazzucotelli). Add default property to docstring parameters ( 6298ba3 by Timoth\u00e9e Mazzucotelli). Accept RST and Numpy parsers ( 1cf147d by Timoth\u00e9e Mazzucotelli). Support data (attributes/variables) ( dce84d1 by Timoth\u00e9e Mazzucotelli). Add Numpy-style parser ( ad5b72d by Timoth\u00e9e Mazzucotelli). Support more section kinds in Google-style ( 9d3d047 by Timoth\u00e9e Mazzucotelli). Add docstring section kinds ( b270483 by Timoth\u00e9e Mazzucotelli). Accept initial arguments when creating container ( 90c5956 by Timoth\u00e9e Mazzucotelli). Add an RST-style docstring parser ( 742e7b2 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Improve JSON encoder perfs ( 6a78eb0 by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Handle serialization of Posix paths ( 3a66b95 by Timoth\u00e9e Mazzucotelli). Fix list annotation getter ( 5ae800a by Timoth\u00e9e Mazzucotelli). Show accurate line number in Google warnings ( 2953590 by Timoth\u00e9e Mazzucotelli). Fix assignment names getters ( 6990846 by Timoth\u00e9e Mazzucotelli). Fix async loader (passing parent) ( 57e866e by Timoth\u00e9e Mazzucotelli). Fix exception name ( 4b8b85d by Timoth\u00e9e Mazzucotelli). Fix Google sections titles logic ( 87dd329 by Timoth\u00e9e Mazzucotelli). Prepend current module to base classes (still needs resolution) ( a4b1dee by Timoth\u00e9e Mazzucotelli). Fix Google admonition regex ( 3902e74 by Timoth\u00e9e Mazzucotelli). Fix docstring getter ( 1442eba by Timoth\u00e9e Mazzucotelli). Fix getting arguments defaults in the Google-style parser ( 67adbaf by Timoth\u00e9e Mazzucotelli). Fix getting arguments annotations in the Google-style parser ( 8bcbfba by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Export parsers and main function in docstrings module ( 96469da by Timoth\u00e9e Mazzucotelli). Remove top exports ( cd76694 by Timoth\u00e9e Mazzucotelli). Reorganize exceptions ( 7f9b805 by Timoth\u00e9e Mazzucotelli). Avoid circular import ( ef27dcd by Timoth\u00e9e Mazzucotelli). Rename index to [new] offset ( c07cc7d by Timoth\u00e9e Mazzucotelli). Reorganize code ( 5f4fff2 by Timoth\u00e9e Mazzucotelli). Use keyword only parameters ( d34edd6 by Timoth\u00e9e Mazzucotelli). Default to no parsing for serialization ( 8fecd9e by Timoth\u00e9e Mazzucotelli). Always extend AST ( c227ae6 by Timoth\u00e9e Mazzucotelli). Set default for kwargs parameters ( 7a0b85e by Timoth\u00e9e Mazzucotelli). Rename visitor method ( 3e0c43c by Timoth\u00e9e Mazzucotelli). Improve typing ( ac86f17 by Timoth\u00e9e Mazzucotelli). Fix typo ( a9ed6e9 by Timoth\u00e9e Mazzucotelli). Rewrite ParameterKind ( 90249df by Timoth\u00e9e Mazzucotelli). Add bool methods to docstrings and objects ( 548f72e by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each docstring ( 752e084 by Timoth\u00e9e Mazzucotelli). Skip attribute assignments ( e9cc2cd by Timoth\u00e9e Mazzucotelli). Improve visitor getters ( 2ea88c0 by Timoth\u00e9e Mazzucotelli). Use relative filepath in docstring warnings ( e894df7 by Timoth\u00e9e Mazzucotelli). Set submodules parent earlier ( 53767c0 by Timoth\u00e9e Mazzucotelli). Rename Data to Attribute ( febc12e by Timoth\u00e9e Mazzucotelli). Rename arguments to parameters ( 957856c by Timoth\u00e9e Mazzucotelli). Improve annotation support ( 5b2262f by Timoth\u00e9e Mazzucotelli). Always set parent ( cae85de by Timoth\u00e9e Mazzucotelli). Factorize function handling ( dfece1c by Timoth\u00e9e Mazzucotelli). Privatize stuff, fix loggers ( 5513ed5 by Timoth\u00e9e Mazzucotelli). Use keyword only arguments ( e853fe9 by Timoth\u00e9e Mazzucotelli). Set default values for Argument arguments ( d5cccaa by Timoth\u00e9e Mazzucotelli). Swallow extra parsing options ( 3d9ebe7 by Timoth\u00e9e Mazzucotelli). Rename start_index argument to offset ( dd88358 by Timoth\u00e9e Mazzucotelli). Reuse parsers warn function ( 03dfdd3 by Timoth\u00e9e Mazzucotelli). 0.2.0 - 2021-09-25 \u00a4 Compare with 0.1.0 Features \u00a4 Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli). 0.1.0 - 2021-09-09 \u00a4 Compare with first commit Features \u00a4 Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#071-2021-12-28","text":"Compare with 0.7.0","title":"0.7.1 - 2021-12-28"},{"location":"changelog/#code-refactoring","text":"Only log warning if async mode is used ( 356e848 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#070-2021-12-28","text":"Compare with 0.6.0","title":"0.7.0 - 2021-12-28"},{"location":"changelog/#features","text":"Support more nodes on Python 3.7 ( 7f2c4ec by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_1","text":"Don't crash on syntax errors and log an error ( 10bb6b1 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#060-2021-12-27","text":"Compare with 0.5.0","title":"0.6.0 - 2021-12-27"},{"location":"changelog/#features_1","text":"Support more AST nodes ( cd1b305 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_2","text":"Use annotation getter for base classes ( 8b1a7ed by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#050-2021-12-20","text":"Compare with 0.4.0","title":"0.5.0 - 2021-12-20"},{"location":"changelog/#features_2","text":"Add support for Python 3.7 ( 4535adc by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes","text":"Don't propagate aliases of an alias ( 8af48f8 by Timoth\u00e9e Mazzucotelli). Don't reassign members defined in except clauses ( d918b4e by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#040-2021-11-28","text":"Compare with 0.3.0","title":"0.4.0 - 2021-11-28"},{"location":"changelog/#features_3","text":"Add a prototype 'hybrid' extension ( 8cb3c16 by Timoth\u00e9e Mazzucotelli). Allow passing extensions config as JSON on the CLI ( 9a7fa8b by Timoth\u00e9e Mazzucotelli). Support names for returns, yields and receives sections items ( 1c5a4c9 by Timoth\u00e9e Mazzucotelli). Store aliases on each object ( 91ba643 by Timoth\u00e9e Mazzucotelli). Support in[tro]spection ( 3a0587d by Timoth\u00e9e Mazzucotelli). Support multiple return, yield and receive items ( 0fc70cb by Timoth\u00e9e Mazzucotelli). Support namespace packages ( 2414c8e by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_1","text":"Fix extensions loader ( 78fb70b by Timoth\u00e9e Mazzucotelli). Avoid visiting/inspecting multiple times ( 75a8a8b by Timoth\u00e9e Mazzucotelli). Set modules collection attribute earlier ( 592c0bd by Timoth\u00e9e Mazzucotelli). Support inequality nodes ( b0ed247 by Timoth\u00e9e Mazzucotelli). Handle Div nodes for values ( 272e4d6 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_3","text":"Set log level to INFO ( 718e73e by Timoth\u00e9e Mazzucotelli). Add target setter ( 7f0064c by Timoth\u00e9e Mazzucotelli). Reorganize conditions ( 15ab876 by Timoth\u00e9e Mazzucotelli). Avoid recursion loops ( ea6acec by Timoth\u00e9e Mazzucotelli). Update aliases when replacing a member ( 99a0f8b by Timoth\u00e9e Mazzucotelli). Reorganize code ( 31fcdb1 by Timoth\u00e9e Mazzucotelli). Replace DocstringException with DocstringRaise ( d5ed87a by Timoth\u00e9e Mazzucotelli). Refactor loaders ( d9b94bb by Timoth\u00e9e Mazzucotelli). Improve typing ( e08bcfa by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#030-2021-11-21","text":"Compare with 0.2.0","title":"0.3.0 - 2021-11-21"},{"location":"changelog/#features_4","text":"Handle aliases and their resolution ( 67ae903 by Timoth\u00e9e Mazzucotelli). Resolve annotations in docstrings ( 847384a by Timoth\u00e9e Mazzucotelli). Resolve annotations ( 6451eff by Timoth\u00e9e Mazzucotelli). Add lines property to objects ( 7daf7db by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each object ( 07a1d2e by Timoth\u00e9e Mazzucotelli). Get attributes annotations from parent ( 003b990 by Timoth\u00e9e Mazzucotelli). Draft extensions loader ( 17ccd03 by Timoth\u00e9e Mazzucotelli). Add properties to objects ( 0ec301a by Timoth\u00e9e Mazzucotelli). Handle .pth files when searching modules ( 2a2e182 by Timoth\u00e9e Mazzucotelli). Add default property to docstring parameters ( 6298ba3 by Timoth\u00e9e Mazzucotelli). Accept RST and Numpy parsers ( 1cf147d by Timoth\u00e9e Mazzucotelli). Support data (attributes/variables) ( dce84d1 by Timoth\u00e9e Mazzucotelli). Add Numpy-style parser ( ad5b72d by Timoth\u00e9e Mazzucotelli). Support more section kinds in Google-style ( 9d3d047 by Timoth\u00e9e Mazzucotelli). Add docstring section kinds ( b270483 by Timoth\u00e9e Mazzucotelli). Accept initial arguments when creating container ( 90c5956 by Timoth\u00e9e Mazzucotelli). Add an RST-style docstring parser ( 742e7b2 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements","text":"Improve JSON encoder perfs ( 6a78eb0 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#bug-fixes_2","text":"Handle serialization of Posix paths ( 3a66b95 by Timoth\u00e9e Mazzucotelli). Fix list annotation getter ( 5ae800a by Timoth\u00e9e Mazzucotelli). Show accurate line number in Google warnings ( 2953590 by Timoth\u00e9e Mazzucotelli). Fix assignment names getters ( 6990846 by Timoth\u00e9e Mazzucotelli). Fix async loader (passing parent) ( 57e866e by Timoth\u00e9e Mazzucotelli). Fix exception name ( 4b8b85d by Timoth\u00e9e Mazzucotelli). Fix Google sections titles logic ( 87dd329 by Timoth\u00e9e Mazzucotelli). Prepend current module to base classes (still needs resolution) ( a4b1dee by Timoth\u00e9e Mazzucotelli). Fix Google admonition regex ( 3902e74 by Timoth\u00e9e Mazzucotelli). Fix docstring getter ( 1442eba by Timoth\u00e9e Mazzucotelli). Fix getting arguments defaults in the Google-style parser ( 67adbaf by Timoth\u00e9e Mazzucotelli). Fix getting arguments annotations in the Google-style parser ( 8bcbfba by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_4","text":"Export parsers and main function in docstrings module ( 96469da by Timoth\u00e9e Mazzucotelli). Remove top exports ( cd76694 by Timoth\u00e9e Mazzucotelli). Reorganize exceptions ( 7f9b805 by Timoth\u00e9e Mazzucotelli). Avoid circular import ( ef27dcd by Timoth\u00e9e Mazzucotelli). Rename index to [new] offset ( c07cc7d by Timoth\u00e9e Mazzucotelli). Reorganize code ( 5f4fff2 by Timoth\u00e9e Mazzucotelli). Use keyword only parameters ( d34edd6 by Timoth\u00e9e Mazzucotelli). Default to no parsing for serialization ( 8fecd9e by Timoth\u00e9e Mazzucotelli). Always extend AST ( c227ae6 by Timoth\u00e9e Mazzucotelli). Set default for kwargs parameters ( 7a0b85e by Timoth\u00e9e Mazzucotelli). Rename visitor method ( 3e0c43c by Timoth\u00e9e Mazzucotelli). Improve typing ( ac86f17 by Timoth\u00e9e Mazzucotelli). Fix typo ( a9ed6e9 by Timoth\u00e9e Mazzucotelli). Rewrite ParameterKind ( 90249df by Timoth\u00e9e Mazzucotelli). Add bool methods to docstrings and objects ( 548f72e by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each docstring ( 752e084 by Timoth\u00e9e Mazzucotelli). Skip attribute assignments ( e9cc2cd by Timoth\u00e9e Mazzucotelli). Improve visitor getters ( 2ea88c0 by Timoth\u00e9e Mazzucotelli). Use relative filepath in docstring warnings ( e894df7 by Timoth\u00e9e Mazzucotelli). Set submodules parent earlier ( 53767c0 by Timoth\u00e9e Mazzucotelli). Rename Data to Attribute ( febc12e by Timoth\u00e9e Mazzucotelli). Rename arguments to parameters ( 957856c by Timoth\u00e9e Mazzucotelli). Improve annotation support ( 5b2262f by Timoth\u00e9e Mazzucotelli). Always set parent ( cae85de by Timoth\u00e9e Mazzucotelli). Factorize function handling ( dfece1c by Timoth\u00e9e Mazzucotelli). Privatize stuff, fix loggers ( 5513ed5 by Timoth\u00e9e Mazzucotelli). Use keyword only arguments ( e853fe9 by Timoth\u00e9e Mazzucotelli). Set default values for Argument arguments ( d5cccaa by Timoth\u00e9e Mazzucotelli). Swallow extra parsing options ( 3d9ebe7 by Timoth\u00e9e Mazzucotelli). Rename start_index argument to offset ( dd88358 by Timoth\u00e9e Mazzucotelli). Reuse parsers warn function ( 03dfdd3 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#020-2021-09-25","text":"Compare with 0.1.0","title":"0.2.0 - 2021-09-25"},{"location":"changelog/#features_5","text":"Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements_1","text":"Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#010-2021-09-09","text":"Compare with first commit","title":"0.1.0 - 2021-09-09"},{"location":"changelog/#features_6","text":"Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build griffe . Thank you! python | pdm | copier-pdm Direct dependencies \u00a4 aiofiles | autoflake | black | cached_property | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | markdown-callouts | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | safety | toml | types-aiofiles | types-markdown | types-toml | wps-light Indirect dependencies \u00a4 ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | idna | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typed-ast | typing-extensions | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build griffe . Thank you! python | pdm | copier-pdm","title":"Credits"},{"location":"credits/#direct-dependencies","text":"aiofiles | autoflake | black | cached_property | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | markdown-callouts | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | safety | toml | types-aiofiles | types-markdown | types-toml | wps-light","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | idna | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typed-ast | typing-extensions | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2021, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"usage/","text":"Usage \u00a4 On the command line \u00a4 Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError . With Python \u00a4 Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) If you don't want to recurse in the submodules: fastapi = griffe . load_module ( \"fastapi\" , recursive = False ) Extensions \u00a4 You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import Extension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( Extension ): when = When . visit_stops def visit_ClassDef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE> methods to visit nodes of certain types, and act on their properties. Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not call the .generic_visit(node) method in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children (what the generic_visit does). You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_FunctionDef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, data See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit/inspection: When.before_all . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is not yet instantiated. before the children visit/inspection: When.before_children . If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is now instantiated. Children have not yet been visited/inspected. after the children visit/inspection: When.after_children . Children have now been visited/inspected. after the visit/inspection: When.after_all See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . after_children By default, it will run the extension after the visit/inspection of the node: that's when the full data for this node and its children is loaded. Nodes Add alias And AnnAssign arg arguments Assert Assign AsyncFor AsyncFunctionDef AsyncWith Attribute AugAssign Await BinOp BitAnd BitOr BitXor BoolOp Break Bytes 1 Call ClassDef Compare comprehension Constant Continue Del Delete Dict DictComp Div Ellipsis 1 Eq ExceptHandler Expr Expression 1 ExtSlice 2 FloorDiv For FormattedValue FunctionDef GeneratorExp Global Gt GtE If IfExp Import ImportFrom In Index 2 Interactive 3 Invert Is IsNot JoinedStr keyword Lambda List ListComp Load LShift Lt LtE Match MatchAs match_case MatchClass MatchMapping MatchOr MatchSequence MatchSingleton MatchStar MatchValue MatMult Mod Module 3 Mult Name NameConstant 1 NamedExpr Nonlocal Not NotEq NotIn Num 1 Or Pass pattern 3 Pow Print 4 Raise Return RShift Set SetComp Slice Starred Store Str 1 Sub Subscript Try TryExcept 5 TryFinally 6 Tuple UAdd UnaryOp USub While With withitem Yield YieldFrom Deprecated since Python 3.8. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Deprecated since Python 3.9. \u21a9 \u21a9 Not documented. \u21a9 \u21a9 \u21a9 print became a builtin (instead of a keyword) in Python 3. \u21a9 Now ExceptHandler , in the handlers attribute of Try nodes. \u21a9 Now a list of expressions in the finalbody attribute of Try nodes. \u21a9","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#on-the-command-line","text":"Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError .","title":"On the command line"},{"location":"usage/#with-python","text":"Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) If you don't want to recurse in the submodules: fastapi = griffe . load_module ( \"fastapi\" , recursive = False )","title":"With Python"},{"location":"usage/#extensions","text":"You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import Extension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( Extension ): when = When . visit_stops def visit_ClassDef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE> methods to visit nodes of certain types, and act on their properties. Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not call the .generic_visit(node) method in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children (what the generic_visit does). You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_FunctionDef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, data See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit/inspection: When.before_all . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is not yet instantiated. before the children visit/inspection: When.before_children . If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is now instantiated. Children have not yet been visited/inspected. after the children visit/inspection: When.after_children . Children have now been visited/inspected. after the visit/inspection: When.after_all See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . after_children By default, it will run the extension after the visit/inspection of the node: that's when the full data for this node and its children is loaded. Nodes Add alias And AnnAssign arg arguments Assert Assign AsyncFor AsyncFunctionDef AsyncWith Attribute AugAssign Await BinOp BitAnd BitOr BitXor BoolOp Break Bytes 1 Call ClassDef Compare comprehension Constant Continue Del Delete Dict DictComp Div Ellipsis 1 Eq ExceptHandler Expr Expression 1 ExtSlice 2 FloorDiv For FormattedValue FunctionDef GeneratorExp Global Gt GtE If IfExp Import ImportFrom In Index 2 Interactive 3 Invert Is IsNot JoinedStr keyword Lambda List ListComp Load LShift Lt LtE Match MatchAs match_case MatchClass MatchMapping MatchOr MatchSequence MatchSingleton MatchStar MatchValue MatMult Mod Module 3 Mult Name NameConstant 1 NamedExpr Nonlocal Not NotEq NotIn Num 1 Or Pass pattern 3 Pow Print 4 Raise Return RShift Set SetComp Slice Starred Store Str 1 Sub Subscript Try TryExcept 5 TryFinally 6 Tuple UAdd UnaryOp USub While With withitem Yield YieldFrom Deprecated since Python 3.8. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Deprecated since Python 3.9. \u21a9 \u21a9 Not documented. \u21a9 \u21a9 \u21a9 print became a builtin (instead of a keyword) in Python 3. \u21a9 Now ExceptHandler , in the handlers attribute of Try nodes. \u21a9 Now a list of expressions in the finalbody attribute of Try nodes. \u21a9","title":"Extensions"},{"location":"reference/SUMMARY/","text":"griffe agents base extensions base hybrid inspector nodes visitor cli collections dataclasses docstrings dataclasses google markdown numpy parsers rst utils encoders exceptions expressions loader logger mixins","title":"SUMMARY"},{"location":"reference/griffe/","text":"griffe package. Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.","title":"griffe"},{"location":"reference/griffe/cli/","text":"Module that contains the command line application. get_parser () \u00a4 Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async-loader\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-a\" , \"--append-sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-e\" , \"--extensions\" , default = {}, type = json . loads , help = \"A list of extensions to use.\" , ) parser . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {{package}}.\" , ) parser . add_argument ( \"-d\" , \"--docstyle\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) parser . add_argument ( \"-D\" , \"--docopts\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser main ( args = None ) \u00a4 Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\"Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = logging . INFO ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . append_sys_path : search . extend ( sys . path ) extensions = load_extensions ( opts . extensions ) if opts . async_loader : loop = asyncio . get_event_loop () coroutine = _load_packages_async ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) packages = loop . run_until_complete ( coroutine ) else : packages = _load_packages ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output ) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"cli"},{"location":"reference/griffe/cli/#griffe.cli.get_parser","text":"Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async-loader\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-a\" , \"--append-sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-e\" , \"--extensions\" , default = {}, type = json . loads , help = \"A list of extensions to use.\" , ) parser . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {{package}}.\" , ) parser . add_argument ( \"-d\" , \"--docstyle\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) parser . add_argument ( \"-D\" , \"--docopts\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser","title":"get_parser()"},{"location":"reference/griffe/cli/#griffe.cli.main","text":"Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\"Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = logging . INFO ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . append_sys_path : search . extend ( sys . path ) extensions = load_extensions ( opts . extensions ) if opts . async_loader : loop = asyncio . get_event_loop () coroutine = _load_packages_async ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) packages = loop . run_until_complete ( coroutine ) else : packages = _load_packages ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output ) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"main()"},{"location":"reference/griffe/collections/","text":"This module stores collections of data, useful during parsing. LinesCollection \u00a4 A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class LinesCollection : \"\"\"A simple dictionary containing the modules source code lines.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {} def __getitem__ ( self , key : Path ) -> list [ str ]: return self . _data [ key ] def __setitem__ ( self , key : Path , value : list [ str ]) -> None : self . _data [ key ] = value def __bool__ ( self ): return True # TODO: remove once Python 3.7 support is dropped @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table __init__ ( self ) \u00a4 Initialize the collection. Source code in griffe/collections.py 21 22 23 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {} tokens ( self , path ) \u00a4 Tokenize the code. Parameters: path ( Path ) \u2013 The filepath to get the tokens of. Returns: tuple [ list [ tokenize . TokenInfo ], defaultdict ] \u2013 A token list and a mapping of tokens by line number. Source code in griffe/collections.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table ModulesCollection ( GetMembersMixin , SetCollectionMembersMixin ) \u00a4 A collection of modules, allowing easy access to members. Source code in griffe/collections.py 53 54 55 56 57 58 59 60 61 62 63 64 class ModulesCollection ( GetMembersMixin , SetCollectionMembersMixin ): \"\"\"A collection of modules, allowing easy access to members.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {} def __bool__ ( self ): return True def __contains__ ( self , item : Any ) -> bool : return item in self . members __init__ ( self ) \u00a4 Initialize the collection. Source code in griffe/collections.py 56 57 58 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"collections"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection","text":"A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class LinesCollection : \"\"\"A simple dictionary containing the modules source code lines.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {} def __getitem__ ( self , key : Path ) -> list [ str ]: return self . _data [ key ] def __setitem__ ( self , key : Path , value : list [ str ]) -> None : self . _data [ key ] = value def __bool__ ( self ): return True # TODO: remove once Python 3.7 support is dropped @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table","title":"LinesCollection"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.__init__","text":"Initialize the collection. Source code in griffe/collections.py 21 22 23 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {}","title":"__init__()"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.tokens","text":"Tokenize the code. Parameters: path ( Path ) \u2013 The filepath to get the tokens of. Returns: tuple [ list [ tokenize . TokenInfo ], defaultdict ] \u2013 A token list and a mapping of tokens by line number. Source code in griffe/collections.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table","title":"tokens()"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection","text":"A collection of modules, allowing easy access to members. Source code in griffe/collections.py 53 54 55 56 57 58 59 60 61 62 63 64 class ModulesCollection ( GetMembersMixin , SetCollectionMembersMixin ): \"\"\"A collection of modules, allowing easy access to members.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {} def __bool__ ( self ): return True def __contains__ ( self , item : Any ) -> bool : return item in self . members","title":"ModulesCollection"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.__init__","text":"Initialize the collection. Source code in griffe/collections.py 56 57 58 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"__init__()"},{"location":"reference/griffe/dataclasses/","text":"This module contains the data classes that represent Python objects. The different objects are modules, classes, functions, and attribute (variables like module/class/instance attributes). Alias ( ObjectAliasMixin ) \u00a4 This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent \u2013 The alias parent. Source code in griffe/dataclasses.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 class Alias ( ObjectAliasMixin ): \"\"\"This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: - line numbers are those of the alias, not the target - the path is the alias path, not the canonical one - the name can be different from the target's - if the target can be resolved, the kind is the target's kind - if the target cannot be resolved, the kind becomes [Kind.ALIAS][griffe.dataclasses.Kind] Attributes: name: The alias name. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" is_alias : bool = True def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path if self . parent is not None : target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent def __getattr__ ( self , name : str ) -> Any : # forward everything to the target return getattr ( self . target , name ) def __getitem__ ( self , key ): # not handled by __getattr__ return self . target [ key ] def __setitem__ ( self , key , value ): # not handled by __getattr__ self . target [ key ] = value @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS @property def parent ( self ) -> Module | Class | None : \"\"\"Return the parent of this alias. Returns: The parent. \"\"\" return self . _parent @parent . setter def parent ( self , value : Module | Class ) -> None : self . _parent = value if self . resolved : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just checked the target is not None @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent @property def target ( self ) -> Object | Alias : \"\"\"Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: The resolved target. \"\"\" if not self . resolved : self . resolve_target () return self . _target # type: ignore[return-value] # cannot return None, exception is raised @target . setter def target ( self , value : Object | Alias ) -> None : self . _target = value if self . parent is not None : self . _target . aliases [ self . path ] = self def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base __init__ ( self , name , target , * , lineno = None , endlineno = None , parent = None ) \u00a4 Initialize the alias. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path if self . parent is not None : target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent as_dict ( self , full = False , ** kwargs ) \u00a4 Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base kind ( self ) \u00a4 Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind. Source code in griffe/dataclasses.py 725 726 727 728 729 730 731 732 733 734 735 736 @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS modules_collection ( self ) \u00a4 Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 762 763 764 765 766 767 768 769 770 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent path ( self ) \u00a4 Return the dotted path / import path of this object. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 753 754 755 756 757 758 759 760 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent resolve_target ( self ) \u00a4 Resolve the target. Raises: AliasResolutionError \u2013 When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. Source code in griffe/dataclasses.py 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target resolved ( self ) \u00a4 Tell whether this alias' target is resolved. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 809 810 811 812 813 814 815 816 @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None Attribute ( Object ) \u00a4 The class representing a Python module/class/instance attribute. Source code in griffe/dataclasses.py 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 class Attribute ( Object ): \"\"\"The class representing a Python module/class/instance attribute.\"\"\" kind = Kind . ATTRIBUTE def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base __init__ ( self , * args , value = None , annotation = None , ** kwargs ) \u00a4 Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base Class ( Object ) \u00a4 The class representing a Python class. Source code in griffe/dataclasses.py 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 class Class ( Object ): \"\"\"The class representing a Python class.\"\"\" kind = Kind . CLASS def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base __init__ ( self , * args , bases = None , decorators = None , ** kwargs ) \u00a4 Initialize the class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression | str ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] as_dict ( self , ** kwargs ) \u00a4 Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 979 980 981 982 983 984 985 986 987 988 989 990 991 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base Decorator \u00a4 This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Decorator : \"\"\"This class represents decorators. Attributes: lineno: The starting line number. endlineno: The ending line number. \"\"\" def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } __init__ ( self , lineno , endlineno ) \u00a4 Initialize the decorator. Parameters: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 57 58 59 60 61 62 63 64 65 def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno as_dict ( self , ** kwargs ) \u00a4 Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } Docstring \u00a4 This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. Source code in griffe/dataclasses.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Docstring : \"\"\"This class represents docstrings. Attributes: value: The actual documentation string, cleaned up. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. \"\"\" def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} def __bool__ ( self ): return bool ( self . value ) @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base __init__ ( self , value , * , lineno = None , endlineno = None , parent = None , parser = None , parser_options = None ) \u00a4 Initialize the docstring. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} as_dict ( self , full = False , docstring_parser = None , ** kwargs ) \u00a4 Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base lines ( self ) \u00a4 Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines. Source code in griffe/dataclasses.py 122 123 124 125 126 127 128 129 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) parse ( self , parser = None , ** options ) \u00a4 Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 140 141 142 143 144 145 146 147 148 149 150 151 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) parsed ( self ) \u00a4 Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 131 132 133 134 135 136 137 138 @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () Function ( Object ) \u00a4 The class representing a Python function. Source code in griffe/dataclasses.py 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 class Function ( Object ): \"\"\"The class representing a Python function.\"\"\" kind = Kind . FUNCTION def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base __init__ ( self , * args , parameters = None , returns = None , decorators = None , ** kwargs ) \u00a4 Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base Kind ( enum . Enum ) \u00a4 Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind. Source code in griffe/dataclasses.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class Kind ( enum . Enum ): \"\"\"Enumeration of the different objects kinds. Attributes: MODULE: The module kind. CLASS: The class kind. FUNCTION: The function kind. ATTRIBUTE: The attribute kind. \"\"\" MODULE : str = \"module\" CLASS : str = \"class\" FUNCTION : str = \"function\" ATTRIBUTE : str = \"attribute\" ALIAS : str = \"alias\" Module ( Object ) \u00a4 The class representing a Python module. Source code in griffe/dataclasses.py 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 class Module ( Object ): \"\"\"The class representing a Python module.\"\"\" kind = Kind . MODULE def __init__ ( self , * args : Any , filepath : Path | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | None = filepath def __repr__ ( self ) -> str : try : return f \"<Module( { self . filepath !r} )>\" except BuiltinModuleError : return f \"<Module( { self . name !r} )>\" @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" try : return self . filepath . name == \"__init__.py\" except BuiltinModuleError : return False @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return not self . parent and self . filepath . is_dir () except BuiltinModuleError : return False @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and self . filepath . is_dir () and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base __init__ ( self , * args , filepath = None , ** kwargs ) \u00a4 Initialize the module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path | None ) \u2013 The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 850 851 852 853 854 855 856 857 858 859 def __init__ ( self , * args : Any , filepath : Path | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | None = filepath as_dict ( self , ** kwargs ) \u00a4 Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 941 942 943 944 945 946 947 948 949 950 951 952 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base filepath ( self ) \u00a4 Get the file path of this module. Raises: BuiltinModuleError \u2013 When the instance filepath is None. Returns: Path \u2013 The module's file path. Source code in griffe/dataclasses.py 867 868 869 870 871 872 873 874 875 876 877 878 879 @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath is_init_module ( self ) \u00a4 Tell if this module is an __init__.py module. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 881 882 883 884 885 886 887 888 889 890 891 @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" try : return self . filepath . name == \"__init__.py\" except BuiltinModuleError : return False is_namespace_package ( self ) \u00a4 Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 911 912 913 914 915 916 917 918 919 920 921 @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return not self . parent and self . filepath . is_dir () except BuiltinModuleError : return False is_namespace_subpackage ( self ) \u00a4 Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and self . filepath . is_dir () and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False is_package ( self ) \u00a4 Tell if this module is a package (top module). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 893 894 895 896 897 898 899 900 @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module is_subpackage ( self ) \u00a4 Tell if this module is a subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 902 903 904 905 906 907 908 909 @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module Object ( GetMembersMixin , SetMembersMixin , ObjectAliasMixin ) \u00a4 An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Source code in griffe/dataclasses.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 class Object ( GetMembersMixin , SetMembersMixin , ObjectAliasMixin ): \"\"\"An abstract class representing a Python object. Attributes: kind: The object kind. name: The object name. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent, or None if it is the top module. members: The object members. labels: The object labels. \"\"\" kind : Kind is_alias : bool = False def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self def __repr__ ( self ) -> str : return f \"< { self . __class__ . __name__ } ( { self . name !r} , { self . lineno !r} , { self . endlineno !r} )>\" def __bool__ ( self ): return bool ( self . docstring ) or any ( self . members . values ()) def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc] @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc] @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc] @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc] @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError # TODO: rename to top_module (for packages collection and package property) @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if not self . parent : return self . name return \".\" . join (( self . parent . path , self . name )) @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno if self . lineno is None or self . endlineno is None : return self . lines_collection [ filepath ] return self . lines_collection [ filepath ][ self . lineno - 1 : self . endlineno ] @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base # TODO: remove once Python 3.7 support is dropped @property def _endlineno ( self ) -> int : if self . kind is Kind . MODULE : return len ( self . lines_collection [ self . filepath ]) tokens , tokens_by_line = self . lines_collection . tokens ( self . filepath ) first_token_index = tokens_by_line [ self . lineno ][ 0 ] blockfinder = inspect . BlockFinder () with suppress ( inspect . EndOfBlock , IndentationError ): for token in tokens [ first_token_index :]: blockfinder . tokeneater ( * token ) return blockfinder . last __init__ ( self , name , * , lineno = None , endlineno = None , docstring = None , parent = None , lines_collection = None , modules_collection = None ) \u00a4 Initialize the object. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self as_dict ( self , full = False , ** kwargs ) \u00a4 Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base attributes ( self ) \u00a4 Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes. Source code in griffe/dataclasses.py 438 439 440 441 442 443 444 445 @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc] canonical_path ( self ) \u00a4 Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 510 511 512 513 514 515 516 517 518 519 520 521 @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if not self . parent : return self . name return \".\" . join (( self . parent . path , self . name )) classes ( self ) \u00a4 Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes. Source code in griffe/dataclasses.py 420 421 422 423 424 425 426 427 @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc] filepath ( self ) \u00a4 Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 476 477 478 479 480 481 482 483 484 485 486 487 488 @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath filter_members ( self , * predicates ) \u00a4 Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members functions ( self ) \u00a4 Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions. Source code in griffe/dataclasses.py 429 430 431 432 433 434 435 436 @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc] has_labels ( self , labels ) \u00a4 Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 383 384 385 386 387 388 389 390 391 392 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) is_kind ( self , kind ) \u00a4 Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Raises: ValueError \u2013 When an empty set is given as argument. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind lines ( self ) \u00a4 Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines. Source code in griffe/dataclasses.py 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno if self . lineno is None or self . endlineno is None : return self . lines_collection [ filepath ] return self . lines_collection [ filepath ][ self . lineno - 1 : self . endlineno ] lines_collection ( self ) \u00a4 Return the lines collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: LinesCollection \u2013 A lines collection. Source code in griffe/dataclasses.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection member_is_exported ( self , member , explicitely = True ) \u00a4 Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports module ( self ) \u00a4 Return the parent module of this object. Raises: ValueError \u2013 When the object is not a module and does not have a parent. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError modules ( self ) \u00a4 Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules. Source code in griffe/dataclasses.py 411 412 413 414 415 416 417 418 @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc] modules_collection ( self ) \u00a4 Return the modules collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection package ( self ) \u00a4 Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 464 465 466 467 468 469 470 471 472 473 474 @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module path ( self ) \u00a4 Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 499 500 501 502 503 504 505 506 507 508 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path relative_filepath ( self ) \u00a4 Return the file path where this object was defined, relative to the top module path. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 490 491 492 493 494 495 496 497 @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) resolve ( self , name ) \u00a4 Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Raises: NameResolutionError \u2013 When the name could not be resolved. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) source ( self ) \u00a4 Return the source code of this object. Returns: str \u2013 The source code. Source code in griffe/dataclasses.py 575 576 577 578 579 580 581 582 @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) Parameter \u00a4 This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class Parameter : \"\"\"This class represent a function parameter. Attributes: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , } __init__ ( self , name , * , annotation = None , kind = None , default = None ) \u00a4 Initialize the parameter. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default as_dict ( self , ** kwargs ) \u00a4 Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , } ParameterKind ( enum . Enum ) \u00a4 Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter. Source code in griffe/dataclasses.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ParameterKind ( enum . Enum ): \"\"\"Enumeration of the different parameter kinds. Attributes: positional_only: Positional-only parameter. positional_or_keyword: Positional or keyword parameter. var_positional: Variadic positional parameter. keyword_only: Keyword-only parameter. var_keyword: Variadic keyword parameter. \"\"\" positional_only : str = \"positional-only\" positional_or_keyword : str = \"positional or keyword\" var_positional : str = \"variadic positional\" keyword_only : str = \"keyword-only\" var_keyword : str = \"variadic keyword\" Parameters \u00a4 This class is a container for parameters. It allows to get parameters using their position (index) or their name. Source code in griffe/dataclasses.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class Parameters : \"\"\"This class is a container for parameters. It allows to get parameters using their position (index) or their name. \"\"\" def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) def __getitem__ ( self , name_or_index : int | str ) -> Parameter : if isinstance ( name_or_index , int ): return self . _parameters_list [ name_or_index ] return self . _parameters_dict [ name_or_index ] def __len__ ( self ): return len ( self . _parameters_list ) def __iter__ ( self ): return iter ( self . _parameters_list ) def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" ) __init__ ( self , * parameters ) \u00a4 Initialize the parameters container. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 228 229 230 231 232 233 234 235 236 237 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) add ( self , parameter ) \u00a4 Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Raises: ValueError \u2013 When a parameter with the same name is already present. Source code in griffe/dataclasses.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"dataclasses"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias","text":"This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent \u2013 The alias parent. Source code in griffe/dataclasses.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 class Alias ( ObjectAliasMixin ): \"\"\"This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: - line numbers are those of the alias, not the target - the path is the alias path, not the canonical one - the name can be different from the target's - if the target can be resolved, the kind is the target's kind - if the target cannot be resolved, the kind becomes [Kind.ALIAS][griffe.dataclasses.Kind] Attributes: name: The alias name. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" is_alias : bool = True def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path if self . parent is not None : target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent def __getattr__ ( self , name : str ) -> Any : # forward everything to the target return getattr ( self . target , name ) def __getitem__ ( self , key ): # not handled by __getattr__ return self . target [ key ] def __setitem__ ( self , key , value ): # not handled by __getattr__ self . target [ key ] = value @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS @property def parent ( self ) -> Module | Class | None : \"\"\"Return the parent of this alias. Returns: The parent. \"\"\" return self . _parent @parent . setter def parent ( self , value : Module | Class ) -> None : self . _parent = value if self . resolved : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just checked the target is not None @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent @property def target ( self ) -> Object | Alias : \"\"\"Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: The resolved target. \"\"\" if not self . resolved : self . resolve_target () return self . _target # type: ignore[return-value] # cannot return None, exception is raised @target . setter def target ( self , value : Object | Alias ) -> None : self . _target = value if self . parent is not None : self . _target . aliases [ self . path ] = self def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base","title":"Alias"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.__init__","text":"Initialize the alias. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path if self . parent is not None : target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.as_dict","text":"Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.kind","text":"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind. Source code in griffe/dataclasses.py 725 726 727 728 729 730 731 732 733 734 735 736 @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS","title":"kind()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.modules_collection","text":"Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 762 763 764 765 766 767 768 769 770 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent","title":"modules_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.path","text":"Return the dotted path / import path of this object. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 753 754 755 756 757 758 759 760 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent","title":"path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolve_target","text":"Resolve the target. Raises: AliasResolutionError \u2013 When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. Source code in griffe/dataclasses.py 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target","title":"resolve_target()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolved","text":"Tell whether this alias' target is resolved. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 809 810 811 812 813 814 815 816 @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None","title":"resolved()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute","text":"The class representing a Python module/class/instance attribute. Source code in griffe/dataclasses.py 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 class Attribute ( Object ): \"\"\"The class representing a Python module/class/instance attribute.\"\"\" kind = Kind . ATTRIBUTE def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base","title":"Attribute"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.__init__","text":"Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.as_dict","text":"Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class","text":"The class representing a Python class. Source code in griffe/dataclasses.py 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 class Class ( Object ): \"\"\"The class representing a Python class.\"\"\" kind = Kind . CLASS def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base","title":"Class"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.__init__","text":"Initialize the class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression | str ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or []","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.as_dict","text":"Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 979 980 981 982 983 984 985 986 987 988 989 990 991 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator","text":"This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Decorator : \"\"\"This class represents decorators. Attributes: lineno: The starting line number. endlineno: The ending line number. \"\"\" def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , }","title":"Decorator"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.__init__","text":"Initialize the decorator. Parameters: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 57 58 59 60 61 62 63 64 65 def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.as_dict","text":"Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring","text":"This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. Source code in griffe/dataclasses.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Docstring : \"\"\"This class represents docstrings. Attributes: value: The actual documentation string, cleaned up. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. \"\"\" def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} def __bool__ ( self ): return bool ( self . value ) @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base","title":"Docstring"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.__init__","text":"Initialize the docstring. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {}","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.as_dict","text":"Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.lines","text":"Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines. Source code in griffe/dataclasses.py 122 123 124 125 126 127 128 129 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" )","title":"lines()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parse","text":"Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 140 141 142 143 144 145 146 147 148 149 150 151 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options ))","title":"parse()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parsed","text":"Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 131 132 133 134 135 136 137 138 @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse ()","title":"parsed()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function","text":"The class representing a Python function. Source code in griffe/dataclasses.py 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 class Function ( Object ): \"\"\"The class representing a Python function.\"\"\" kind = Kind . FUNCTION def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base","title":"Function"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.__init__","text":"Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or []","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.as_dict","text":"Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind","text":"Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind. Source code in griffe/dataclasses.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class Kind ( enum . Enum ): \"\"\"Enumeration of the different objects kinds. Attributes: MODULE: The module kind. CLASS: The class kind. FUNCTION: The function kind. ATTRIBUTE: The attribute kind. \"\"\" MODULE : str = \"module\" CLASS : str = \"class\" FUNCTION : str = \"function\" ATTRIBUTE : str = \"attribute\" ALIAS : str = \"alias\"","title":"Kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module","text":"The class representing a Python module. Source code in griffe/dataclasses.py 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 class Module ( Object ): \"\"\"The class representing a Python module.\"\"\" kind = Kind . MODULE def __init__ ( self , * args : Any , filepath : Path | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | None = filepath def __repr__ ( self ) -> str : try : return f \"<Module( { self . filepath !r} )>\" except BuiltinModuleError : return f \"<Module( { self . name !r} )>\" @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" try : return self . filepath . name == \"__init__.py\" except BuiltinModuleError : return False @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return not self . parent and self . filepath . is_dir () except BuiltinModuleError : return False @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and self . filepath . is_dir () and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base","title":"Module"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.__init__","text":"Initialize the module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path | None ) \u2013 The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 850 851 852 853 854 855 856 857 858 859 def __init__ ( self , * args : Any , filepath : Path | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | None = filepath","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.as_dict","text":"Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 941 942 943 944 945 946 947 948 949 950 951 952 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.filepath","text":"Get the file path of this module. Raises: BuiltinModuleError \u2013 When the instance filepath is None. Returns: Path \u2013 The module's file path. Source code in griffe/dataclasses.py 867 868 869 870 871 872 873 874 875 876 877 878 879 @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath","title":"filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_init_module","text":"Tell if this module is an __init__.py module. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 881 882 883 884 885 886 887 888 889 890 891 @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" try : return self . filepath . name == \"__init__.py\" except BuiltinModuleError : return False","title":"is_init_module()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_package","text":"Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 911 912 913 914 915 916 917 918 919 920 921 @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return not self . parent and self . filepath . is_dir () except BuiltinModuleError : return False","title":"is_namespace_package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_subpackage","text":"Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and self . filepath . is_dir () and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False","title":"is_namespace_subpackage()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_package","text":"Tell if this module is a package (top module). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 893 894 895 896 897 898 899 900 @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module","title":"is_package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_subpackage","text":"Tell if this module is a subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 902 903 904 905 906 907 908 909 @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module","title":"is_subpackage()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object","text":"An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Source code in griffe/dataclasses.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 class Object ( GetMembersMixin , SetMembersMixin , ObjectAliasMixin ): \"\"\"An abstract class representing a Python object. Attributes: kind: The object kind. name: The object name. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent, or None if it is the top module. members: The object members. labels: The object labels. \"\"\" kind : Kind is_alias : bool = False def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self def __repr__ ( self ) -> str : return f \"< { self . __class__ . __name__ } ( { self . name !r} , { self . lineno !r} , { self . endlineno !r} )>\" def __bool__ ( self ): return bool ( self . docstring ) or any ( self . members . values ()) def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc] @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc] @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc] @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc] @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError # TODO: rename to top_module (for packages collection and package property) @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if not self . parent : return self . name return \".\" . join (( self . parent . path , self . name )) @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno if self . lineno is None or self . endlineno is None : return self . lines_collection [ filepath ] return self . lines_collection [ filepath ][ self . lineno - 1 : self . endlineno ] @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base # TODO: remove once Python 3.7 support is dropped @property def _endlineno ( self ) -> int : if self . kind is Kind . MODULE : return len ( self . lines_collection [ self . filepath ]) tokens , tokens_by_line = self . lines_collection . tokens ( self . filepath ) first_token_index = tokens_by_line [ self . lineno ][ 0 ] blockfinder = inspect . BlockFinder () with suppress ( inspect . EndOfBlock , IndentationError ): for token in tokens [ first_token_index :]: blockfinder . tokeneater ( * token ) return blockfinder . last","title":"Object"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.__init__","text":"Initialize the object. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.as_dict","text":"Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.attributes","text":"Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes. Source code in griffe/dataclasses.py 438 439 440 441 442 443 444 445 @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc]","title":"attributes()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.canonical_path","text":"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 510 511 512 513 514 515 516 517 518 519 520 521 @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if not self . parent : return self . name return \".\" . join (( self . parent . path , self . name ))","title":"canonical_path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.classes","text":"Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes. Source code in griffe/dataclasses.py 420 421 422 423 424 425 426 427 @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc]","title":"classes()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filepath","text":"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 476 477 478 479 480 481 482 483 484 485 486 487 488 @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath","title":"filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filter_members","text":"Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members","title":"filter_members()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.functions","text":"Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions. Source code in griffe/dataclasses.py 429 430 431 432 433 434 435 436 @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc]","title":"functions()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_labels","text":"Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 383 384 385 386 387 388 389 390 391 392 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels )","title":"has_labels()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_kind","text":"Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Raises: ValueError \u2013 When an empty set is given as argument. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind","title":"is_kind()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines","text":"Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines. Source code in griffe/dataclasses.py 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno if self . lineno is None or self . endlineno is None : return self . lines_collection [ filepath ] return self . lines_collection [ filepath ][ self . lineno - 1 : self . endlineno ]","title":"lines()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines_collection","text":"Return the lines collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: LinesCollection \u2013 A lines collection. Source code in griffe/dataclasses.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection","title":"lines_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.member_is_exported","text":"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports","title":"member_is_exported()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.module","text":"Return the parent module of this object. Raises: ValueError \u2013 When the object is not a module and does not have a parent. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError","title":"module()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules","text":"Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules. Source code in griffe/dataclasses.py 411 412 413 414 415 416 417 418 @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc]","title":"modules()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules_collection","text":"Return the modules collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection","title":"modules_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.package","text":"Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 464 465 466 467 468 469 470 471 472 473 474 @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module","title":"package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.path","text":"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 499 500 501 502 503 504 505 506 507 508 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path","title":"path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.relative_filepath","text":"Return the file path where this object was defined, relative to the top module path. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 490 491 492 493 494 495 496 497 @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent )","title":"relative_filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.resolve","text":"Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Raises: NameResolutionError \u2013 When the name could not be resolved. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name )","title":"resolve()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.source","text":"Return the source code of this object. Returns: str \u2013 The source code. Source code in griffe/dataclasses.py 575 576 577 578 579 580 581 582 @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines ))","title":"source()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter","text":"This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class Parameter : \"\"\"This class represent a function parameter. Attributes: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , }","title":"Parameter"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.__init__","text":"Initialize the parameter. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.as_dict","text":"Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind","text":"Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter. Source code in griffe/dataclasses.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ParameterKind ( enum . Enum ): \"\"\"Enumeration of the different parameter kinds. Attributes: positional_only: Positional-only parameter. positional_or_keyword: Positional or keyword parameter. var_positional: Variadic positional parameter. keyword_only: Keyword-only parameter. var_keyword: Variadic keyword parameter. \"\"\" positional_only : str = \"positional-only\" positional_or_keyword : str = \"positional or keyword\" var_positional : str = \"variadic positional\" keyword_only : str = \"keyword-only\" var_keyword : str = \"variadic keyword\"","title":"ParameterKind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters","text":"This class is a container for parameters. It allows to get parameters using their position (index) or their name. Source code in griffe/dataclasses.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class Parameters : \"\"\"This class is a container for parameters. It allows to get parameters using their position (index) or their name. \"\"\" def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) def __getitem__ ( self , name_or_index : int | str ) -> Parameter : if isinstance ( name_or_index , int ): return self . _parameters_list [ name_or_index ] return self . _parameters_dict [ name_or_index ] def __len__ ( self ): return len ( self . _parameters_list ) def __iter__ ( self ): return iter ( self . _parameters_list ) def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"Parameters"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.__init__","text":"Initialize the parameters container. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 228 229 230 231 232 233 234 235 236 237 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter )","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.add","text":"Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Raises: ValueError \u2013 When a parameter with the same name is already present. Source code in griffe/dataclasses.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"add()"},{"location":"reference/griffe/encoders/","text":"This module contains data encoders/serializers and decoders/deserializers. Json see the encoder and decoder . Encoder ( json . JSONEncoder ) \u00a4 JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: Source code in griffe/encoders.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class Encoder ( json . JSONEncoder ): \"\"\"JSON encoder. JSON encoders are not used directly, but through the [`json.dump`][] or [`json.dumps`][] methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json.dumps(..., cls=Encoder, full=True, **kwargs) \"\"\" def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj ) __init__ ( self , * args , full = False , docstring_parser = None , docstring_options = None , ** kwargs ) \u00a4 Initialize the encoder. Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} default ( self , obj ) \u00a4 Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 70 71 72 73 74 75 76 77 78 79 80 81 82 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj ) decoder ( obj_dict ) \u00a4 Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Object \u2013 An instance of a data class. Source code in griffe/encoders.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Object : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( name = obj_dict [ \"name\" ], filepath = Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) elif kind == Kind . ATTRIBUTE : return Attribute ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) return obj_dict","title":"encoders"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder","text":"JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: Source code in griffe/encoders.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class Encoder ( json . JSONEncoder ): \"\"\"JSON encoder. JSON encoders are not used directly, but through the [`json.dump`][] or [`json.dumps`][] methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json.dumps(..., cls=Encoder, full=True, **kwargs) \"\"\" def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj )","title":"Encoder"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder.__init__","text":"Initialize the encoder. Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {}","title":"__init__()"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder.default","text":"Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 70 71 72 73 74 75 76 77 78 79 80 81 82 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj )","title":"default()"},{"location":"reference/griffe/encoders/#griffe.encoders.decoder","text":"Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Object \u2013 An instance of a data class. Source code in griffe/encoders.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Object : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( name = obj_dict [ \"name\" ], filepath = Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) elif kind == Kind . ATTRIBUTE : return Attribute ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) return obj_dict","title":"decoder()"},{"location":"reference/griffe/exceptions/","text":"This module contains all the exceptions specific to Griffe. AliasResolutionError ( GriffeError ) \u00a4 Exception for alias that cannot be resolved. Source code in griffe/exceptions.py 20 21 22 23 24 25 26 27 28 29 30 class AliasResolutionError ( GriffeError ): \"\"\"Exception for alias that cannot be resolved.\"\"\" def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"could not resolve { self . target_path } \" ) __init__ ( self , target_path ) \u00a4 Initialize the exception. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 23 24 25 26 27 28 29 30 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"could not resolve { self . target_path } \" ) BuiltinModuleError ( GriffeError ) \u00a4 Exception raised when trying to access the filepath of a builtin module. Source code in griffe/exceptions.py 41 42 class BuiltinModuleError ( GriffeError ): \"\"\"Exception raised when trying to access the filepath of a builtin module.\"\"\" ExtensionError ( GriffeError ) \u00a4 Base class for errors raised by extensions. Source code in griffe/exceptions.py 45 46 class ExtensionError ( GriffeError ): \"\"\"Base class for errors raised by extensions.\"\"\" GriffeError ( Exception ) \u00a4 The base exception for all Griffe errors. Source code in griffe/exceptions.py 4 5 class GriffeError ( Exception ): \"\"\"The base exception for all Griffe errors.\"\"\" LastNodeError ( GriffeError ) \u00a4 Exception raised when trying to access a next or previous node. Source code in griffe/exceptions.py 33 34 class LastNodeError ( GriffeError ): \"\"\"Exception raised when trying to access a next or previous node.\"\"\" NameResolutionError ( GriffeError ) \u00a4 Exception for names that cannot be resolved in a object scope. Source code in griffe/exceptions.py 8 9 class NameResolutionError ( GriffeError ): \"\"\"Exception for names that cannot be resolved in a object scope.\"\"\" RootNodeError ( GriffeError ) \u00a4 Exception raised when trying to use siblings properties on a root node. Source code in griffe/exceptions.py 37 38 class RootNodeError ( GriffeError ): \"\"\"Exception raised when trying to use siblings properties on a root node.\"\"\" UnhandledPthFileError ( GriffeError ) \u00a4 Exception for unhandled .path files, when searching modules. Source code in griffe/exceptions.py 12 13 class UnhandledPthFileError ( GriffeError ): \"\"\"Exception for unhandled .path files, when searching modules.\"\"\" UnimportableModuleError ( GriffeError ) \u00a4 Exception for modules that cannot be imported. Source code in griffe/exceptions.py 16 17 class UnimportableModuleError ( GriffeError ): \"\"\"Exception for modules that cannot be imported.\"\"\"","title":"exceptions"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError","text":"Exception for alias that cannot be resolved. Source code in griffe/exceptions.py 20 21 22 23 24 25 26 27 28 29 30 class AliasResolutionError ( GriffeError ): \"\"\"Exception for alias that cannot be resolved.\"\"\" def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"could not resolve { self . target_path } \" )","title":"AliasResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError.__init__","text":"Initialize the exception. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 23 24 25 26 27 28 29 30 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"could not resolve { self . target_path } \" )","title":"__init__()"},{"location":"reference/griffe/exceptions/#griffe.exceptions.BuiltinModuleError","text":"Exception raised when trying to access the filepath of a builtin module. Source code in griffe/exceptions.py 41 42 class BuiltinModuleError ( GriffeError ): \"\"\"Exception raised when trying to access the filepath of a builtin module.\"\"\"","title":"BuiltinModuleError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionError","text":"Base class for errors raised by extensions. Source code in griffe/exceptions.py 45 46 class ExtensionError ( GriffeError ): \"\"\"Base class for errors raised by extensions.\"\"\"","title":"ExtensionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.GriffeError","text":"The base exception for all Griffe errors. Source code in griffe/exceptions.py 4 5 class GriffeError ( Exception ): \"\"\"The base exception for all Griffe errors.\"\"\"","title":"GriffeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LastNodeError","text":"Exception raised when trying to access a next or previous node. Source code in griffe/exceptions.py 33 34 class LastNodeError ( GriffeError ): \"\"\"Exception raised when trying to access a next or previous node.\"\"\"","title":"LastNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.NameResolutionError","text":"Exception for names that cannot be resolved in a object scope. Source code in griffe/exceptions.py 8 9 class NameResolutionError ( GriffeError ): \"\"\"Exception for names that cannot be resolved in a object scope.\"\"\"","title":"NameResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.RootNodeError","text":"Exception raised when trying to use siblings properties on a root node. Source code in griffe/exceptions.py 37 38 class RootNodeError ( GriffeError ): \"\"\"Exception raised when trying to use siblings properties on a root node.\"\"\"","title":"RootNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnhandledPthFileError","text":"Exception for unhandled .path files, when searching modules. Source code in griffe/exceptions.py 12 13 class UnhandledPthFileError ( GriffeError ): \"\"\"Exception for unhandled .path files, when searching modules.\"\"\"","title":"UnhandledPthFileError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnimportableModuleError","text":"Exception for modules that cannot be imported. Source code in griffe/exceptions.py 16 17 class UnimportableModuleError ( GriffeError ): \"\"\"Exception for modules that cannot be imported.\"\"\"","title":"UnimportableModuleError"},{"location":"reference/griffe/expressions/","text":"This module contains the data classes that represent resolvable names and expressions. Expression ( list ) \u00a4 This class represents a Python expression. For example, it can represents complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Source code in griffe/expressions.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class Expression ( list ): # noqa: WPS600 \"\"\"This class represents a Python expression. For example, it can represents complex annotations such as: - `Optional[Dict[str, Tuple[int, bool]]]` - `str | Callable | list[int]` Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. \"\"\" def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) # for value in values: # if isinstance(value, Expression): # self.extend(value) # else: # self.append(value) def __str__ ( self ): return \"\" . join ( str ( element ) for element in self ) @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self ) @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\" def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ] __init__ ( self , * values ) \u00a4 Initialize the expression. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 90 91 92 93 94 95 96 97 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) full ( self ) \u00a4 Return self as a string. This property is only useful to the AST utils. Returns: str \u2013 Self as a string. Source code in griffe/expressions.py 107 108 109 110 111 112 113 114 115 116 @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self ) is_tuple ( self ) \u00a4 Tell whether this expression represents a tuple. Returns: bool \u2013 True or False. Source code in griffe/expressions.py 118 119 120 121 122 123 124 125 @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\" tuple_item ( self , nth ) \u00a4 Return the n-th item of this tuple expression. Parameters: nth ( int ) \u2013 The item number. Returns: str | Name \u2013 A string or name. Source code in griffe/expressions.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ] Name \u00a4 This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Source code in griffe/expressions.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Name : \"\"\"This class represents a Python object identified by a name in a given scope. Attributes: source: The name as written in the source code. \"\"\" def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full def __repr__ ( self ) -> str : return f \"Name(source= { self . source !r} , full= { self . full !r} )\" def __str__ ( self ) -> str : return self . source @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full } __init__ ( self , source , full ) \u00a4 Initialize the name. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full as_dict ( self , ** kwargs ) \u00a4 Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 66 67 68 69 70 71 72 73 74 75 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full } brief ( self ) \u00a4 Return the brief source name. Returns: str \u2013 The last part of the source name. Source code in griffe/expressions.py 57 58 59 60 61 62 63 64 @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ] full ( self ) \u00a4 Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source. Source code in griffe/expressions.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full","title":"expressions"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression","text":"This class represents a Python expression. For example, it can represents complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Source code in griffe/expressions.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class Expression ( list ): # noqa: WPS600 \"\"\"This class represents a Python expression. For example, it can represents complex annotations such as: - `Optional[Dict[str, Tuple[int, bool]]]` - `str | Callable | list[int]` Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. \"\"\" def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) # for value in values: # if isinstance(value, Expression): # self.extend(value) # else: # self.append(value) def __str__ ( self ): return \"\" . join ( str ( element ) for element in self ) @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self ) @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\" def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ]","title":"Expression"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.__init__","text":"Initialize the expression. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 90 91 92 93 94 95 96 97 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values )","title":"__init__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.full","text":"Return self as a string. This property is only useful to the AST utils. Returns: str \u2013 Self as a string. Source code in griffe/expressions.py 107 108 109 110 111 112 113 114 115 116 @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self )","title":"full()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_tuple","text":"Tell whether this expression represents a tuple. Returns: bool \u2013 True or False. Source code in griffe/expressions.py 118 119 120 121 122 123 124 125 @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\"","title":"is_tuple()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.tuple_item","text":"Return the n-th item of this tuple expression. Parameters: nth ( int ) \u2013 The item number. Returns: str | Name \u2013 A string or name. Source code in griffe/expressions.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ]","title":"tuple_item()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name","text":"This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Source code in griffe/expressions.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Name : \"\"\"This class represents a Python object identified by a name in a given scope. Attributes: source: The name as written in the source code. \"\"\" def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full def __repr__ ( self ) -> str : return f \"Name(source= { self . source !r} , full= { self . full !r} )\" def __str__ ( self ) -> str : return self . source @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full }","title":"Name"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.__init__","text":"Initialize the name. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full","title":"__init__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.as_dict","text":"Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 66 67 68 69 70 71 72 73 74 75 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full }","title":"as_dict()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.brief","text":"Return the brief source name. Returns: str \u2013 The last part of the source name. Source code in griffe/expressions.py 57 58 59 60 61 62 63 64 @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ]","title":"brief()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.full","text":"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source. Source code in griffe/expressions.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full","title":"full()"},{"location":"reference/griffe/loader/","text":"This module contains the code allowing to find module and load their data. from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) AsyncGriffeLoader ( _BaseGriffeLoader ) \u00a4 The asynchronous Griffe loader, allowing to load data from modules. Source code in griffe/loader.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class AsyncGriffeLoader ( _BaseGriffeLoader ): \"\"\"The asynchronous Griffe loader, allowing to load data from modules.\"\"\" async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths ) top_module = await self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] async def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore[union-attr] # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): await self . load_module ( package ) else : success &= await self . follow_aliases ( member ) # type: ignore[arg-type] # we know it's an object return success async def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) try : code = await _get_async_reader ()( module_path ) except OSError : module = self . _create_module ( module_name , module_path ) else : module = self . _visit_module ( code , module_name , module_path , parent ) if submodules : await self . _load_submodules ( module ) return module async def _load_submodules ( self , module : Module ) -> None : await asyncio . gather ( * [ self . _load_submodule ( module , subparts , subpath ) for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ) ] ) async def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : try : member_parent = self . _member_parent ( module , subparts , subpath ) except UnimportableModuleError as error : logger . debug ( str ( error )) else : member_parent [ subparts [ - 1 ]] = await self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent ) follow_aliases ( self , obj , only_exported = True ) \u00a4 Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 Only try to resolve an alias if it is explicitely exported. Returns: bool \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 async def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore[union-attr] # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): await self . load_module ( package ) else : success &= await self . follow_aliases ( member ) # type: ignore[arg-type] # we know it's an object return success load_module ( self , module , submodules = True , search_paths = None ) \u00a4 Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Module \u2013 A module. Source code in griffe/loader.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths ) top_module = await self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] GriffeLoader ( _BaseGriffeLoader ) \u00a4 The Griffe loader, allowing to load data from modules. Source code in griffe/loader.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 class GriffeLoader ( _BaseGriffeLoader ): \"\"\"The Griffe loader, allowing to load data from modules.\"\"\" def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" if module in _builtin_modules : module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths ) top_module = self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index] def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore[union-attr] # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore[arg-type] # we know it's an object return success def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) try : code = module_path . read_text () except OSError : module = self . _create_module ( module_name , module_path ) else : module = self . _visit_module ( code , module_name , module_path , parent ) if submodules : self . _load_submodules ( module ) return module def _load_submodules ( self , module : Module ) -> None : for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ): self . _load_submodule ( module , subparts , subpath ) def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : try : member_parent = self . _member_parent ( module , subparts , subpath ) except UnimportableModuleError as error : logger . warning ( f \" { error } . Missing __init__ module?\" ) return try : member_parent [ subparts [ - 1 ]] = self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent ) except SyntaxError : message = traceback . format_exc ( limit = 0 ) . replace ( \"SyntaxError: invalid syntax\" , \"\" ) . strip () logger . error ( f \"Syntax error: { message } \" ) follow_aliases ( self , obj , only_exported = True ) \u00a4 Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 Only try to resolve an alias if it is explicitely exported. Returns: bool \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore[union-attr] # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore[arg-type] # we know it's an object return success load_module ( self , module , submodules = True , search_paths = None ) \u00a4 Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Module \u2013 A module. Source code in griffe/loader.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" if module in _builtin_modules : module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths ) top_module = self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index] _BaseGriffeLoader \u00a4 Source code in griffe/loader.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class _BaseGriffeLoader : def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () patch_ast () def _create_module ( self , module_name : str , module_path : Path ) -> Module : return Module ( module_name , filepath = module_path , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) def _visit_module ( self , code : str , module_name : str , module_path : Path , parent : Module | None = None ) -> Module : self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) return visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) def _inspect_module ( self , module_name : str , filepath : Path | None = None , parent : Module | None = None ) -> Module : return inspect ( module_name , filepath = filepath , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) def _member_parent ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> Module : parent_parts = subparts [: - 1 ] try : return module [ parent_parts ] except KeyError : if module . is_namespace_package or module . is_namespace_subpackage : member_parent = Module ( subparts [ 0 ], filepath = subpath . parent , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) module [ parent_parts ] = member_parent return member_parent raise UnimportableModuleError ( f \" { subpath } is not importable\" ) __init__ ( self , extensions = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 Initialize the loader. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/loader.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () patch_ast () find_module ( module_name , search_paths = None ) \u00a4 Find a module in a given list of paths or in sys.path . Parameters: module_name ( str ) \u2013 The module name. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Raises: ModuleNotFoundError \u2013 When the module cannot be found. Returns: Path \u2013 The module file path. Source code in griffe/loader.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def find_module ( module_name : str , search_paths : Sequence [ str | Path ] | None = None ) -> Path : # noqa: WPS231 \"\"\"Find a module in a given list of paths or in `sys.path`. Parameters: module_name: The module name. search_paths: The paths to search into. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" # optimization: pre-compute Paths to relieve CPU when joining paths search = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] parts = module_name . split ( \".\" ) # always search a .pth file first using the first part for path in search : top_pth = Path ( f \" { parts [ 0 ] } .pth\" ) abs_top_pth = path / top_pth if abs_top_pth . exists (): with suppress ( UnhandledPthFileError ): location = _handle_pth_file ( abs_top_pth ) if location . suffix == \".py\" : location = location . parent search = [ location . parent ] # TODO: possible optimization # always break if exists? break # resume regular search filepaths = [ Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .pth\" ), Path ( * parts ), # namespace packages, try last ] for path in search : # noqa: WPS440 for choice in filepaths : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): if abs_path . name . endswith ( \".pth\" ): try : return _handle_pth_file ( abs_path ) except UnhandledPthFileError as error : raise ModuleNotFoundError ( module_name ) from error return abs_path raise ModuleNotFoundError ( module_name ) find_module_or_path ( module , search_paths = None ) \u00a4 Find the name and path of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module ( str | Path ) \u2013 The module name or path. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Raises: FileNotFoundError \u2013 When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist ModuleNotFoundError \u2013 When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file Returns: tuple [ str , Path ] \u2013 The name of the module (or package) and its path. Source code in griffe/loader.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 def find_module_or_path ( module : str | Path , search_paths : Sequence [ str | Path ] | None = None , ) -> tuple [ str , Path ]: \"\"\"Find the name and path of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module: The module name or path. search_paths: The paths to search into. Raises: FileNotFoundError: When a Path was passed and the module could not be found: - the directory has no `__init__.py` file in it - the path does not exist ModuleNotFoundError: When a string was passed and the module could not be found: - no `module/__init__.py` - no `module.py` - no `module.pth` - no `module` directory (namespace packages) - or unsupported .pth file Returns: The name of the module (or package) and its path. \"\"\" if isinstance ( module , Path ): # programatically passed a Path, try only that module_name , module_path = _module_name_path ( module ) else : # passed a string (from CLI or Python code), try both try : module_name , module_path = _module_name_path ( Path ( module )) except FileNotFoundError : module_name = module module_path = find_module ( module_name , search_paths = search_paths ) return module_name , module_path iter_submodules ( path ) \u00a4 Iterate on a module's submodules, if any. Parameters: path ( Path ) \u2013 The module path. Yields: name_parts ( Iterator [ NamePartsAndPathType ] ) \u2013 The parts of a submodule name. filepath ( Iterator [ NamePartsAndPathType ] ) \u2013 A submodule filepath. Source code in griffe/loader.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def iter_submodules ( path : Path ) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS234 \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. Yields: name_parts: The parts of a submodule name. filepath: A submodule filepath. \"\"\" if path . name == \"__init__.py\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix == \".py\" : return for subpath in path . rglob ( \"*.py\" ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . name == \"__init__.py\" : # optimization: since it's a relative path, # if it has only one part and is named __init__.py, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath else : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath","title":"loader"},{"location":"reference/griffe/loader/#griffe.loader.AsyncGriffeLoader","text":"The asynchronous Griffe loader, allowing to load data from modules. Source code in griffe/loader.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class AsyncGriffeLoader ( _BaseGriffeLoader ): \"\"\"The asynchronous Griffe loader, allowing to load data from modules.\"\"\" async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths ) top_module = await self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] async def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore[union-attr] # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): await self . load_module ( package ) else : success &= await self . follow_aliases ( member ) # type: ignore[arg-type] # we know it's an object return success async def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) try : code = await _get_async_reader ()( module_path ) except OSError : module = self . _create_module ( module_name , module_path ) else : module = self . _visit_module ( code , module_name , module_path , parent ) if submodules : await self . _load_submodules ( module ) return module async def _load_submodules ( self , module : Module ) -> None : await asyncio . gather ( * [ self . _load_submodule ( module , subparts , subpath ) for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ) ] ) async def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : try : member_parent = self . _member_parent ( module , subparts , subpath ) except UnimportableModuleError as error : logger . debug ( str ( error )) else : member_parent [ subparts [ - 1 ]] = await self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent )","title":"AsyncGriffeLoader"},{"location":"reference/griffe/loader/#griffe.loader.AsyncGriffeLoader.follow_aliases","text":"Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 Only try to resolve an alias if it is explicitely exported. Returns: bool \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 async def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore[union-attr] # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): await self . load_module ( package ) else : success &= await self . follow_aliases ( member ) # type: ignore[arg-type] # we know it's an object return success","title":"follow_aliases()"},{"location":"reference/griffe/loader/#griffe.loader.AsyncGriffeLoader.load_module","text":"Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Module \u2013 A module. Source code in griffe/loader.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths ) top_module = await self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ]","title":"load_module()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader","text":"The Griffe loader, allowing to load data from modules. Source code in griffe/loader.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 class GriffeLoader ( _BaseGriffeLoader ): \"\"\"The Griffe loader, allowing to load data from modules.\"\"\" def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" if module in _builtin_modules : module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths ) top_module = self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index] def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore[union-attr] # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore[arg-type] # we know it's an object return success def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) try : code = module_path . read_text () except OSError : module = self . _create_module ( module_name , module_path ) else : module = self . _visit_module ( code , module_name , module_path , parent ) if submodules : self . _load_submodules ( module ) return module def _load_submodules ( self , module : Module ) -> None : for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ): self . _load_submodule ( module , subparts , subpath ) def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : try : member_parent = self . _member_parent ( module , subparts , subpath ) except UnimportableModuleError as error : logger . warning ( f \" { error } . Missing __init__ module?\" ) return try : member_parent [ subparts [ - 1 ]] = self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent ) except SyntaxError : message = traceback . format_exc ( limit = 0 ) . replace ( \"SyntaxError: invalid syntax\" , \"\" ) . strip () logger . error ( f \"Syntax error: { message } \" )","title":"GriffeLoader"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.follow_aliases","text":"Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 Only try to resolve an alias if it is explicitely exported. Returns: bool \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore[union-attr] # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore[arg-type] # we know it's an object return success","title":"follow_aliases()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.load_module","text":"Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Module \u2013 A module. Source code in griffe/loader.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" if module in _builtin_modules : module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths ) top_module = self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index]","title":"load_module()"},{"location":"reference/griffe/loader/#griffe.loader._BaseGriffeLoader","text":"Source code in griffe/loader.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class _BaseGriffeLoader : def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () patch_ast () def _create_module ( self , module_name : str , module_path : Path ) -> Module : return Module ( module_name , filepath = module_path , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) def _visit_module ( self , code : str , module_name : str , module_path : Path , parent : Module | None = None ) -> Module : self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) return visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) def _inspect_module ( self , module_name : str , filepath : Path | None = None , parent : Module | None = None ) -> Module : return inspect ( module_name , filepath = filepath , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) def _member_parent ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> Module : parent_parts = subparts [: - 1 ] try : return module [ parent_parts ] except KeyError : if module . is_namespace_package or module . is_namespace_subpackage : member_parent = Module ( subparts [ 0 ], filepath = subpath . parent , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) module [ parent_parts ] = member_parent return member_parent raise UnimportableModuleError ( f \" { subpath } is not importable\" )","title":"_BaseGriffeLoader"},{"location":"reference/griffe/loader/#griffe.loader._BaseGriffeLoader.__init__","text":"Initialize the loader. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/loader.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () patch_ast ()","title":"__init__()"},{"location":"reference/griffe/loader/#griffe.loader.find_module","text":"Find a module in a given list of paths or in sys.path . Parameters: module_name ( str ) \u2013 The module name. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Raises: ModuleNotFoundError \u2013 When the module cannot be found. Returns: Path \u2013 The module file path. Source code in griffe/loader.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def find_module ( module_name : str , search_paths : Sequence [ str | Path ] | None = None ) -> Path : # noqa: WPS231 \"\"\"Find a module in a given list of paths or in `sys.path`. Parameters: module_name: The module name. search_paths: The paths to search into. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" # optimization: pre-compute Paths to relieve CPU when joining paths search = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] parts = module_name . split ( \".\" ) # always search a .pth file first using the first part for path in search : top_pth = Path ( f \" { parts [ 0 ] } .pth\" ) abs_top_pth = path / top_pth if abs_top_pth . exists (): with suppress ( UnhandledPthFileError ): location = _handle_pth_file ( abs_top_pth ) if location . suffix == \".py\" : location = location . parent search = [ location . parent ] # TODO: possible optimization # always break if exists? break # resume regular search filepaths = [ Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .pth\" ), Path ( * parts ), # namespace packages, try last ] for path in search : # noqa: WPS440 for choice in filepaths : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): if abs_path . name . endswith ( \".pth\" ): try : return _handle_pth_file ( abs_path ) except UnhandledPthFileError as error : raise ModuleNotFoundError ( module_name ) from error return abs_path raise ModuleNotFoundError ( module_name )","title":"find_module()"},{"location":"reference/griffe/loader/#griffe.loader.find_module_or_path","text":"Find the name and path of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module ( str | Path ) \u2013 The module name or path. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Raises: FileNotFoundError \u2013 When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist ModuleNotFoundError \u2013 When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file Returns: tuple [ str , Path ] \u2013 The name of the module (or package) and its path. Source code in griffe/loader.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 def find_module_or_path ( module : str | Path , search_paths : Sequence [ str | Path ] | None = None , ) -> tuple [ str , Path ]: \"\"\"Find the name and path of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module: The module name or path. search_paths: The paths to search into. Raises: FileNotFoundError: When a Path was passed and the module could not be found: - the directory has no `__init__.py` file in it - the path does not exist ModuleNotFoundError: When a string was passed and the module could not be found: - no `module/__init__.py` - no `module.py` - no `module.pth` - no `module` directory (namespace packages) - or unsupported .pth file Returns: The name of the module (or package) and its path. \"\"\" if isinstance ( module , Path ): # programatically passed a Path, try only that module_name , module_path = _module_name_path ( module ) else : # passed a string (from CLI or Python code), try both try : module_name , module_path = _module_name_path ( Path ( module )) except FileNotFoundError : module_name = module module_path = find_module ( module_name , search_paths = search_paths ) return module_name , module_path","title":"find_module_or_path()"},{"location":"reference/griffe/loader/#griffe.loader.iter_submodules","text":"Iterate on a module's submodules, if any. Parameters: path ( Path ) \u2013 The module path. Yields: name_parts ( Iterator [ NamePartsAndPathType ] ) \u2013 The parts of a submodule name. filepath ( Iterator [ NamePartsAndPathType ] ) \u2013 A submodule filepath. Source code in griffe/loader.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def iter_submodules ( path : Path ) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS234 \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. Yields: name_parts: The parts of a submodule name. filepath: A submodule filepath. \"\"\" if path . name == \"__init__.py\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix == \".py\" : return for subpath in path . rglob ( \"*.py\" ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . name == \"__init__.py\" : # optimization: since it's a relative path, # if it has only one part and is named __init__.py, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath else : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath","title":"iter_submodules()"},{"location":"reference/griffe/logger/","text":"This module contains logging utilities. We provide the get_logger function so dependant libraries can patch it as they see fit. For example, to fit in the MkDocs logging configuration import logging from griffe import logger as griffe_logger class LoggerAdapter ( logging . LoggerAdapter ): def __init__ ( self , prefix , logger ): super () . __init__ ( logger , {}) self . prefix = prefix def process ( self , msg , kwargs ): return f \" { self . prefix } : { msg } \" , kwargs def get_logger ( name ): logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) return LoggerAdapter ( name , logger ) griffe_logger . get_logger = get_logger get_logger ( name ) \u00a4 Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: logging . Logger \u2013 The logger. Source code in griffe/logger.py 33 34 35 36 37 38 39 40 41 42 def get_logger ( name : str ) -> logging . Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return logging . getLogger ( name )","title":"logger"},{"location":"reference/griffe/logger/#griffe.logger.get_logger","text":"Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: logging . Logger \u2013 The logger. Source code in griffe/logger.py 33 34 35 36 37 38 39 40 41 42 def get_logger ( name : str ) -> logging . Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return logging . getLogger ( name )","title":"get_logger()"},{"location":"reference/griffe/mixins/","text":"This module contains some mixins classes about accessing and setting members. GetMembersMixin \u00a4 This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance. Source code in griffe/mixins.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class GetMembersMixin : \"\"\"This mixin adds a `__getitem__` method to a class. It makes it easier to access members of an object. The method expects a `members` attribute/property to be available on the instance. \"\"\" def __getitem__ ( self , key : str | Sequence [ str ]) -> Any : if isinstance ( key , str ): if not key : return self parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : return self if len ( parts ) == 1 : return self . members [ parts [ 0 ]] # type: ignore[attr-defined] return self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined] ObjectAliasMixin \u00a4 A mixin for methods that appear both in objects and aliases, unchanged. Source code in griffe/mixins.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class ObjectAliasMixin : \"\"\"A mixin for methods that appear both in objects and aliases, unchanged.\"\"\" def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined] @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined] is_explicitely_exported ( self ) \u00a4 Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 99 100 101 102 103 104 105 106 @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) is_exported ( self , explicitely = True ) \u00a4 Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 88 89 90 91 92 93 94 95 96 97 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined] is_implicitely_exported ( self ) \u00a4 Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 108 109 110 111 112 113 114 115 @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined] SetCollectionMembersMixin \u00a4 This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its _modules_collection attribute is set as well. Source code in griffe/mixins.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class SetCollectionMembersMixin : \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `_modules_collection` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] for alias in self . members [ name ] . aliases . values (): # type: ignore[attr-defined] alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . _modules_collection = self # noqa: WPS437 else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined] SetMembersMixin \u00a4 This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well. Source code in griffe/mixins.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class SetMembersMixin : \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `parent` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] member = self . members [ name ] # type: ignore[attr-defined] if not member . is_alias : for alias in member . aliases . values (): alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . parent = self else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined]","title":"mixins"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin","text":"This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance. Source code in griffe/mixins.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class GetMembersMixin : \"\"\"This mixin adds a `__getitem__` method to a class. It makes it easier to access members of an object. The method expects a `members` attribute/property to be available on the instance. \"\"\" def __getitem__ ( self , key : str | Sequence [ str ]) -> Any : if isinstance ( key , str ): if not key : return self parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : return self if len ( parts ) == 1 : return self . members [ parts [ 0 ]] # type: ignore[attr-defined] return self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined]","title":"GetMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin","text":"A mixin for methods that appear both in objects and aliases, unchanged. Source code in griffe/mixins.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class ObjectAliasMixin : \"\"\"A mixin for methods that appear both in objects and aliases, unchanged.\"\"\" def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined] @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined]","title":"ObjectAliasMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_explicitely_exported","text":"Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 99 100 101 102 103 104 105 106 @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True )","title":"is_explicitely_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_exported","text":"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 88 89 90 91 92 93 94 95 96 97 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined]","title":"is_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_implicitely_exported","text":"Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 108 109 110 111 112 113 114 115 @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined]","title":"is_implicitely_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.SetCollectionMembersMixin","text":"This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its _modules_collection attribute is set as well. Source code in griffe/mixins.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class SetCollectionMembersMixin : \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `_modules_collection` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] for alias in self . members [ name ] . aliases . values (): # type: ignore[attr-defined] alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . _modules_collection = self # noqa: WPS437 else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined]","title":"SetCollectionMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin","text":"This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well. Source code in griffe/mixins.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class SetMembersMixin : \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `parent` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] member = self . members [ name ] # type: ignore[attr-defined] if not member . is_alias : for alias in member . aliases . values (): alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . parent = self else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined]","title":"SetMembersMixin"},{"location":"reference/griffe/agents/","text":"These modules contain the different agents that are able to extract data.","title":"agents"},{"location":"reference/griffe/agents/base/","text":"This module contains the base classes for dealing with extensions. BaseInspector \u00a4 The base class for inspectors. Source code in griffe/agents/base.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class BaseInspector : \"\"\"The base class for inspectors.\"\"\" def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node ) def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\" for child in node . children : self . inspect ( child ) generic_inspect ( self , node ) \u00a4 Inspect the children of a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect (its children). Source code in griffe/agents/base.py 42 43 44 45 46 47 48 49 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\" for child in node . children : self . inspect ( child ) inspect ( self , node ) \u00a4 Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/base.py 34 35 36 37 38 39 40 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node ) BaseVisitor \u00a4 The base class for visitors. Source code in griffe/agents/base.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class BaseVisitor : \"\"\"The base class for visitors.\"\"\" def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined] def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\" for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) generic_visit ( self , node ) \u00a4 Visit the children of a node. Parameters: node ( ast . AST ) \u2013 The node to visit (its children). Source code in griffe/agents/base.py 21 22 23 24 25 26 27 28 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\" for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) visit ( self , node ) \u00a4 Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/base.py 13 14 15 16 17 18 19 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined]","title":"base"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector","text":"The base class for inspectors. Source code in griffe/agents/base.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class BaseInspector : \"\"\"The base class for inspectors.\"\"\" def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node ) def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\" for child in node . children : self . inspect ( child )","title":"BaseInspector"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.generic_inspect","text":"Inspect the children of a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect (its children). Source code in griffe/agents/base.py 42 43 44 45 46 47 48 49 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\" for child in node . children : self . inspect ( child )","title":"generic_inspect()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.inspect","text":"Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/base.py 34 35 36 37 38 39 40 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node )","title":"inspect()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor","text":"The base class for visitors. Source code in griffe/agents/base.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class BaseVisitor : \"\"\"The base class for visitors.\"\"\" def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined] def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\" for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child )","title":"BaseVisitor"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.generic_visit","text":"Visit the children of a node. Parameters: node ( ast . AST ) \u2013 The node to visit (its children). Source code in griffe/agents/base.py 21 22 23 24 25 26 27 28 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\" for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child )","title":"generic_visit()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.visit","text":"Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/base.py 13 14 15 16 17 18 19 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined]","title":"visit()"},{"location":"reference/griffe/agents/inspector/","text":"This module defines introspection mechanisms. Sometimes we cannot get the source code of a module or an object, typically built-in modules like itertools . The only way to know what they are made of is to actually import them and inspect their contents. Sometimes, even if the source code is available, loading the object is desired because it was created or modified dynamically, and our node visitor is not powerful enough to infer all these dynamic modifications. In this case, we always try to visit the code first, and only then we load the object to update the data with introspection. This module exposes a public function, inspect() , which inspects the module using inspect.getmembers() , and returns a new Module instance, populating its members recursively, by using a NodeVisitor -like class. The inspection agent works similarly to the regular \"node visitor\" agent, in that it maintains a state with the current object being handled, and recursively handle its members. Inspector ( BaseInspector ) \u00a4 This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. Source code in griffe/agents/inspector.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 class Inspector ( BaseInspector ): # noqa: WPS338 \"\"\"This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. \"\"\" def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () def _get_docstring ( self , node : ObjectNode ) -> Docstring | None : value = getdoc ( node . obj ) if value is None : return None return Docstring ( value , parser = self . docstring_parser , parser_options = self . docstring_options , ) def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: A module instance. \"\"\" top_node = ObjectNode ( __import__ ( self . module_name ), self . module_name ) self . inspect ( top_node ) return self . current . module def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node ) def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) super () . generic_inspect ( node ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node ) def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node ) def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment] def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" }) def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" }) def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" }) def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" }) def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" }) def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" }) def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ValueError : parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter ) for parameter in signature . parameters . values ()]) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = return_annotation and get_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node ) def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) value = repr ( node . obj ) docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj ) __init__ ( self , module_name , filepath , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None ) \u00a4 Initialize the inspector. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path | None ) \u2013 The optional filepath. extensions ( Extensions ) \u2013 Extensions to use when inspecting. parent ( Module | None ) \u2013 The module parent. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Source code in griffe/agents/inspector.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () generic_inspect ( self , node ) \u00a4 Extend the base generic inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 148 149 150 151 152 153 154 155 156 157 158 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) super () . generic_inspect ( node ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node ) get_module ( self ) \u00a4 Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: Module \u2013 A module instance. Source code in griffe/agents/inspector.py 124 125 126 127 128 129 130 131 132 133 134 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: A module instance. \"\"\" top_node = ObjectNode ( __import__ ( self . module_name ), self . module_name ) self . inspect ( top_node ) return self . current . module handle_attribute ( self , node , annotation = None ) \u00a4 Handle an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. annotation ( str | Name | Expression | None ) \u2013 A potentiel annotation. Source code in griffe/agents/inspector.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) value = repr ( node . obj ) docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj ) handle_function ( self , node , labels = None ) \u00a4 Handle a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/inspector.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ValueError : parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter ) for parameter in signature . parameters . values ()]) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = return_annotation and get_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function inspect ( self , node ) \u00a4 Extend the base inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 136 137 138 139 140 141 142 143 144 145 146 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node ) inspect_attribute ( self , node ) \u00a4 Inspect an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 287 288 289 290 291 292 293 def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node ) inspect_cached_property ( self , node ) \u00a4 Inspect a cached property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 241 242 243 244 245 246 247 def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" }) inspect_class ( self , node ) \u00a4 Inspect a class. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment] inspect_classmethod ( self , node ) \u00a4 Inspect a class method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 201 202 203 204 205 206 207 def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" }) inspect_coroutine ( self , node ) \u00a4 Inspect a coroutine. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 225 226 227 228 229 230 231 def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" }) inspect_function ( self , node ) \u00a4 Inspect a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 233 234 235 236 237 238 239 def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) inspect_method ( self , node ) \u00a4 Inspect a method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 217 218 219 220 221 222 223 def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) inspect_method_descriptor ( self , node ) \u00a4 Inspect a method descriptor. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 209 210 211 212 213 214 215 def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" }) inspect_module ( self , node ) \u00a4 Inspect a module. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node ) inspect_property ( self , node ) \u00a4 Inspect a property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 249 250 251 252 253 254 255 def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" }) inspect_staticmethod ( self , node ) \u00a4 Inspect a static method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 193 194 195 196 197 198 199 def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" }) inspect ( module_name , * , filepath = None , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None ) \u00a4 Inspect a module. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path | None ) \u2013 The module file path. extensions ( Extensions | None ) \u2013 The extensions to use when inspecting the module. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/inspector.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def inspect ( module_name : str , * , filepath : Path | None = None , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Inspect a module. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. extensions: The extensions to use when inspecting the module. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" return Inspector ( module_name , filepath , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ()","title":"inspector"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector","text":"This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. Source code in griffe/agents/inspector.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 class Inspector ( BaseInspector ): # noqa: WPS338 \"\"\"This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. \"\"\" def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () def _get_docstring ( self , node : ObjectNode ) -> Docstring | None : value = getdoc ( node . obj ) if value is None : return None return Docstring ( value , parser = self . docstring_parser , parser_options = self . docstring_options , ) def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: A module instance. \"\"\" top_node = ObjectNode ( __import__ ( self . module_name ), self . module_name ) self . inspect ( top_node ) return self . current . module def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node ) def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) super () . generic_inspect ( node ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node ) def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node ) def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment] def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" }) def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" }) def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" }) def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" }) def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" }) def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" }) def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ValueError : parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter ) for parameter in signature . parameters . values ()]) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = return_annotation and get_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node ) def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) value = repr ( node . obj ) docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj )","title":"Inspector"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.__init__","text":"Initialize the inspector. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path | None ) \u2013 The optional filepath. extensions ( Extensions ) \u2013 Extensions to use when inspecting. parent ( Module | None ) \u2013 The module parent. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Source code in griffe/agents/inspector.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection ()","title":"__init__()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.generic_inspect","text":"Extend the base generic inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 148 149 150 151 152 153 154 155 156 157 158 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) super () . generic_inspect ( node ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node )","title":"generic_inspect()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.get_module","text":"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: Module \u2013 A module instance. Source code in griffe/agents/inspector.py 124 125 126 127 128 129 130 131 132 133 134 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: A module instance. \"\"\" top_node = ObjectNode ( __import__ ( self . module_name ), self . module_name ) self . inspect ( top_node ) return self . current . module","title":"get_module()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_attribute","text":"Handle an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. annotation ( str | Name | Expression | None ) \u2013 A potentiel annotation. Source code in griffe/agents/inspector.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) value = repr ( node . obj ) docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj )","title":"handle_attribute()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_function","text":"Handle a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/inspector.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ValueError : parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter ) for parameter in signature . parameters . values ()]) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = return_annotation and get_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function","title":"handle_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect","text":"Extend the base inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 136 137 138 139 140 141 142 143 144 145 146 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node )","title":"inspect()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_attribute","text":"Inspect an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 287 288 289 290 291 292 293 def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node )","title":"inspect_attribute()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_cached_property","text":"Inspect a cached property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 241 242 243 244 245 246 247 def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" })","title":"inspect_cached_property()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_class","text":"Inspect a class. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"inspect_class()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_classmethod","text":"Inspect a class method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 201 202 203 204 205 206 207 def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" })","title":"inspect_classmethod()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_coroutine","text":"Inspect a coroutine. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 225 226 227 228 229 230 231 def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" })","title":"inspect_coroutine()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_function","text":"Inspect a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 233 234 235 236 237 238 239 def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node )","title":"inspect_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method","text":"Inspect a method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 217 218 219 220 221 222 223 def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node )","title":"inspect_method()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method_descriptor","text":"Inspect a method descriptor. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 209 210 211 212 213 214 215 def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" })","title":"inspect_method_descriptor()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_module","text":"Inspect a module. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node )","title":"inspect_module()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_property","text":"Inspect a property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 249 250 251 252 253 254 255 def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" })","title":"inspect_property()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_staticmethod","text":"Inspect a static method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 193 194 195 196 197 198 199 def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" })","title":"inspect_staticmethod()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.inspect","text":"Inspect a module. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path | None ) \u2013 The module file path. extensions ( Extensions | None ) \u2013 The extensions to use when inspecting the module. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/inspector.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def inspect ( module_name : str , * , filepath : Path | None = None , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Inspect a module. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. extensions: The extensions to use when inspecting the module. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" return Inspector ( module_name , filepath , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ()","title":"inspect()"},{"location":"reference/griffe/agents/nodes/","text":"This module contains utilities for extracting information from AST nodes. ASTNode \u00a4 This class is dynamically added to the bases of each AST node class. Source code in griffe/agents/nodes.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 class ASTNode : \"\"\"This class is dynamically added to the bases of each AST node class.\"\"\" parent : ASTNode # TODO: remove once Python 3.7 support is dropped if sys . version_info < ( 3 , 8 ): # noqa: WPS604 end_lineno = property ( lambda node : None ) @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower () @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ] @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :] @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ] @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error children ( self ) \u00a4 Build and return the children of this node. Returns: Sequence [ ASTNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children first_child ( self ) \u00a4 Return the first child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error kind ( self ) \u00a4 Return the kind of this node. Returns: str \u2013 The node kind. Source code in griffe/agents/nodes.py 103 104 105 106 107 108 109 110 @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower () last_child ( self ) \u00a4 Return the lasts child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error next ( self ) \u00a4 Return the next sibling of this node. Raises: LastNodeError \u2013 When the node does not have next siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error next_siblings ( self ) \u00a4 Return the next siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The next siblings. Source code in griffe/agents/nodes.py 161 162 163 164 165 166 167 168 169 170 @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :] position ( self ) \u00a4 Tell the position of this node amongst its siblings. Raises: RootNodeError \u2013 When the node doesn't have a parent. Returns: int \u2013 The node position amongst its siblings. Source code in griffe/agents/nodes.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error previous ( self ) \u00a4 Return the previous sibling of this node. Raises: LastNodeError \u2013 When the node does not have previous siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error previous_siblings ( self ) \u00a4 Return the previous siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The previous siblings. Source code in griffe/agents/nodes.py 150 151 152 153 154 155 156 157 158 159 @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ] siblings ( self ) \u00a4 Return the siblings of this node. Returns: Sequence [ ASTNode ] \u2013 The siblings. Source code in griffe/agents/nodes.py 172 173 174 175 176 177 178 179 @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ] ObjectKind ( enum . Enum ) \u00a4 Enumeration for the different kinds of objects. Source code in griffe/agents/nodes.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 class ObjectKind ( enum . Enum ): \"\"\"Enumeration for the different kinds of objects.\"\"\" MODULE : str = \"module\" CLASS : str = \"class\" STATICMETHOD : str = \"staticmethod\" CLASSMETHOD : str = \"classmethod\" METHOD_DESCRIPTOR : str = \"method_descriptor\" METHOD : str = \"method\" COROUTINE : str = \"coroutine\" FUNCTION : str = \"function\" CACHED_PROPERTY : str = \"cached_property\" PROPERTY : str = \"property\" ATTRIBUTE : str = \"attribute\" def __str__ ( self ) -> str : return self . value ObjectNode \u00a4 Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj ( Any ) \u2013 The actual Python object. name ( str ) \u2013 The Python object's name. parent ( ObjectNode | None ) \u2013 The parent node. Source code in griffe/agents/nodes.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 class ObjectNode : \"\"\"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj: The actual Python object. name: The Python object's name. parent: The parent node. \"\"\" def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent def __repr__ ( self ) -> str : return f \"ObjectNode(name= { self . name !r} )\" @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( member ): children . append ( ObjectNode ( member , name , parent = self )) return children @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj ) @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj ) @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj ) @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj ) @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property ) @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class ) @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type ) @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj ) @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if not self . parent : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod ) @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if not self . parent : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod ) @cached_property def _ids ( self ) -> set [ int ]: if self . parent is None : return { id ( self )} return { id ( self )} | self . parent . _ids # noqa: WPS437 def _pick_member ( self , member : Any ) -> bool : return member is not type and member is not object and id ( member ) not in self . _ids __init__ ( self , obj , name , parent = None ) \u00a4 Initialize the object. Parameters: obj ( Any ) \u2013 A Python object. name ( str ) \u2013 The object's name. parent ( ObjectNode | None ) \u2013 The object's parent node. Source code in griffe/agents/nodes.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent children ( self ) \u00a4 Build and return the children of this node. Returns: Sequence [ ObjectNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 329 330 331 332 333 334 335 336 337 338 339 340 @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( member ): children . append ( ObjectNode ( member , name , parent = self )) return children is_cached_property ( self ) \u00a4 Tell if this node's object is a cached property. Returns: bool \u2013 If this node's object is a cached property. Source code in griffe/agents/nodes.py 392 393 394 395 396 397 398 399 400 @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property ) is_class ( self ) \u00a4 Tell if this node's object is a class. Returns: bool \u2013 If this node's object is a class. Source code in griffe/agents/nodes.py 352 353 354 355 356 357 358 359 360 @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj ) is_classmethod ( self ) \u00a4 Tell if this node's object is a classmethod. Returns: bool \u2013 If this node's object is a classmethod. Source code in griffe/agents/nodes.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if not self . parent : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod ) is_coroutine ( self ) \u00a4 Tell if this node's object is a coroutine. Returns: bool \u2013 If this node's object is a coroutine. Source code in griffe/agents/nodes.py 372 373 374 375 376 377 378 379 380 @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj ) is_function ( self ) \u00a4 Tell if this node's object is a function. Returns: bool \u2013 If this node's object is a function. Source code in griffe/agents/nodes.py 362 363 364 365 366 367 368 369 370 @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj ) is_method ( self ) \u00a4 Tell if this node's object is a method. Returns: bool \u2013 If this node's object is a method. Source code in griffe/agents/nodes.py 412 413 414 415 416 417 418 419 420 421 @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type ) is_method_descriptor ( self ) \u00a4 Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: bool \u2013 If this node's object is a method descriptor. Source code in griffe/agents/nodes.py 423 424 425 426 427 428 429 430 431 432 433 434 @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj ) is_module ( self ) \u00a4 Tell if this node's object is a module. Returns: bool \u2013 The root of the tree. Source code in griffe/agents/nodes.py 342 343 344 345 346 347 348 349 350 @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj ) is_property ( self ) \u00a4 Tell if this node's object is a property. Returns: bool \u2013 If this node's object is a property. Source code in griffe/agents/nodes.py 382 383 384 385 386 387 388 389 390 @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property is_staticmethod ( self ) \u00a4 Tell if this node's object is a staticmethod. Returns: bool \u2013 If this node's object is a staticmethod. Source code in griffe/agents/nodes.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if not self . parent : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod ) kind ( self ) \u00a4 Return the kind of this node. Returns: ObjectKind \u2013 The node kind. Source code in griffe/agents/nodes.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE parent_is_class ( self ) \u00a4 Tell if the object of this node's parent is a class. Returns: bool \u2013 If the object of this node's parent is a class. Source code in griffe/agents/nodes.py 402 403 404 405 406 407 408 409 410 @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class ) get_annotation ( node , parent ) \u00a4 Extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 604 605 606 607 608 609 610 611 612 613 614 615 616 def get_annotation ( node : AST | None , parent : Module | Class ) -> str | Name | Expression | None : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" if node is None : return None return _get_annotation ( node , parent ) get_docstring ( node , strict = False ) \u00a4 Extract a docstring. Parameters: node ( AST ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/agents/nodes.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def get_docstring ( node : AST , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore[attr-defined] doc = node . body [ 0 ] . value # type: ignore[attr-defined] else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno # type: ignore[attr-defined] if isinstance ( doc , NodeStr ): return doc . s , doc . lineno , doc . end_lineno # type: ignore[attr-defined] return None , None , None get_instance_names ( node ) \u00a4 Extract names from an assignment node, only for instance attributes. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def get_instance_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )] get_name ( node ) \u00a4 Extract name from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: str \u2013 A list of names. Source code in griffe/agents/nodes.py 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 def get_name ( node : AST ) -> str : \"\"\"Extract name from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_name_map [ type ( node )]( node ) get_names ( node ) \u00a4 Extract names from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def get_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map [ type ( node )]( node ) get_parameter_default ( node , filepath , lines_collection ) \u00a4 Extract the default value of a function parameter. Parameters: node ( AST ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/agents/nodes.py 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 def get_parameter_default ( node : AST , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None if isinstance ( node , NodeConstant ): return repr ( node . value ) if isinstance ( node , NodeName ): return node . id if node . lineno == node . end_lineno : # type: ignore[attr-defined] return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # type: ignore[attr-defined] # TODO: handle multiple line defaults return None get_value ( node ) \u00a4 Extract a complex value as a string. Parameters: node ( AST ) \u2013 The node to extract the value from. Returns: str \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 996 997 998 999 1000 1001 1002 1003 1004 1005 def get_value ( node : AST ) -> str : \"\"\"Extract a complex value as a string. Parameters: node: The node to extract the value from. Returns: The unparsed code of the node. \"\"\" return _node_value_map [ type ( node )]( node )","title":"nodes"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode","text":"This class is dynamically added to the bases of each AST node class. Source code in griffe/agents/nodes.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 class ASTNode : \"\"\"This class is dynamically added to the bases of each AST node class.\"\"\" parent : ASTNode # TODO: remove once Python 3.7 support is dropped if sys . version_info < ( 3 , 8 ): # noqa: WPS604 end_lineno = property ( lambda node : None ) @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower () @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ] @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :] @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ] @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error","title":"ASTNode"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.children","text":"Build and return the children of this node. Returns: Sequence [ ASTNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children","title":"children()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.first_child","text":"Return the first child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error","title":"first_child()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.kind","text":"Return the kind of this node. Returns: str \u2013 The node kind. Source code in griffe/agents/nodes.py 103 104 105 106 107 108 109 110 @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower ()","title":"kind()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.last_child","text":"Return the lasts child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error","title":"last_child()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next","text":"Return the next sibling of this node. Raises: LastNodeError \u2013 When the node does not have next siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error","title":"next()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next_siblings","text":"Return the next siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The next siblings. Source code in griffe/agents/nodes.py 161 162 163 164 165 166 167 168 169 170 @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :]","title":"next_siblings()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.position","text":"Tell the position of this node amongst its siblings. Raises: RootNodeError \u2013 When the node doesn't have a parent. Returns: int \u2013 The node position amongst its siblings. Source code in griffe/agents/nodes.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error","title":"position()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous","text":"Return the previous sibling of this node. Raises: LastNodeError \u2013 When the node does not have previous siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error","title":"previous()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous_siblings","text":"Return the previous siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The previous siblings. Source code in griffe/agents/nodes.py 150 151 152 153 154 155 156 157 158 159 @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ]","title":"previous_siblings()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.siblings","text":"Return the siblings of this node. Returns: Sequence [ ASTNode ] \u2013 The siblings. Source code in griffe/agents/nodes.py 172 173 174 175 176 177 178 179 @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ]","title":"siblings()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind","text":"Enumeration for the different kinds of objects. Source code in griffe/agents/nodes.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 class ObjectKind ( enum . Enum ): \"\"\"Enumeration for the different kinds of objects.\"\"\" MODULE : str = \"module\" CLASS : str = \"class\" STATICMETHOD : str = \"staticmethod\" CLASSMETHOD : str = \"classmethod\" METHOD_DESCRIPTOR : str = \"method_descriptor\" METHOD : str = \"method\" COROUTINE : str = \"coroutine\" FUNCTION : str = \"function\" CACHED_PROPERTY : str = \"cached_property\" PROPERTY : str = \"property\" ATTRIBUTE : str = \"attribute\" def __str__ ( self ) -> str : return self . value","title":"ObjectKind"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode","text":"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj ( Any ) \u2013 The actual Python object. name ( str ) \u2013 The Python object's name. parent ( ObjectNode | None ) \u2013 The parent node. Source code in griffe/agents/nodes.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 class ObjectNode : \"\"\"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj: The actual Python object. name: The Python object's name. parent: The parent node. \"\"\" def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent def __repr__ ( self ) -> str : return f \"ObjectNode(name= { self . name !r} )\" @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( member ): children . append ( ObjectNode ( member , name , parent = self )) return children @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj ) @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj ) @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj ) @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj ) @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property ) @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class ) @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type ) @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj ) @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if not self . parent : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod ) @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if not self . parent : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod ) @cached_property def _ids ( self ) -> set [ int ]: if self . parent is None : return { id ( self )} return { id ( self )} | self . parent . _ids # noqa: WPS437 def _pick_member ( self , member : Any ) -> bool : return member is not type and member is not object and id ( member ) not in self . _ids","title":"ObjectNode"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.__init__","text":"Initialize the object. Parameters: obj ( Any ) \u2013 A Python object. name ( str ) \u2013 The object's name. parent ( ObjectNode | None ) \u2013 The object's parent node. Source code in griffe/agents/nodes.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent","title":"__init__()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.children","text":"Build and return the children of this node. Returns: Sequence [ ObjectNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 329 330 331 332 333 334 335 336 337 338 339 340 @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( member ): children . append ( ObjectNode ( member , name , parent = self )) return children","title":"children()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_cached_property","text":"Tell if this node's object is a cached property. Returns: bool \u2013 If this node's object is a cached property. Source code in griffe/agents/nodes.py 392 393 394 395 396 397 398 399 400 @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property )","title":"is_cached_property()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_class","text":"Tell if this node's object is a class. Returns: bool \u2013 If this node's object is a class. Source code in griffe/agents/nodes.py 352 353 354 355 356 357 358 359 360 @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj )","title":"is_class()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_classmethod","text":"Tell if this node's object is a classmethod. Returns: bool \u2013 If this node's object is a classmethod. Source code in griffe/agents/nodes.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if not self . parent : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod )","title":"is_classmethod()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_coroutine","text":"Tell if this node's object is a coroutine. Returns: bool \u2013 If this node's object is a coroutine. Source code in griffe/agents/nodes.py 372 373 374 375 376 377 378 379 380 @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj )","title":"is_coroutine()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_function","text":"Tell if this node's object is a function. Returns: bool \u2013 If this node's object is a function. Source code in griffe/agents/nodes.py 362 363 364 365 366 367 368 369 370 @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj )","title":"is_function()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method","text":"Tell if this node's object is a method. Returns: bool \u2013 If this node's object is a method. Source code in griffe/agents/nodes.py 412 413 414 415 416 417 418 419 420 421 @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type )","title":"is_method()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method_descriptor","text":"Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: bool \u2013 If this node's object is a method descriptor. Source code in griffe/agents/nodes.py 423 424 425 426 427 428 429 430 431 432 433 434 @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj )","title":"is_method_descriptor()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_module","text":"Tell if this node's object is a module. Returns: bool \u2013 The root of the tree. Source code in griffe/agents/nodes.py 342 343 344 345 346 347 348 349 350 @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj )","title":"is_module()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_property","text":"Tell if this node's object is a property. Returns: bool \u2013 If this node's object is a property. Source code in griffe/agents/nodes.py 382 383 384 385 386 387 388 389 390 @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property","title":"is_property()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_staticmethod","text":"Tell if this node's object is a staticmethod. Returns: bool \u2013 If this node's object is a staticmethod. Source code in griffe/agents/nodes.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if not self . parent : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod )","title":"is_staticmethod()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.kind","text":"Return the kind of this node. Returns: ObjectKind \u2013 The node kind. Source code in griffe/agents/nodes.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE","title":"kind()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.parent_is_class","text":"Tell if the object of this node's parent is a class. Returns: bool \u2013 If the object of this node's parent is a class. Source code in griffe/agents/nodes.py 402 403 404 405 406 407 408 409 410 @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class )","title":"parent_is_class()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_annotation","text":"Extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 604 605 606 607 608 609 610 611 612 613 614 615 616 def get_annotation ( node : AST | None , parent : Module | Class ) -> str | Name | Expression | None : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" if node is None : return None return _get_annotation ( node , parent )","title":"get_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_docstring","text":"Extract a docstring. Parameters: node ( AST ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/agents/nodes.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def get_docstring ( node : AST , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore[attr-defined] doc = node . body [ 0 ] . value # type: ignore[attr-defined] else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno # type: ignore[attr-defined] if isinstance ( doc , NodeStr ): return doc . s , doc . lineno , doc . end_lineno # type: ignore[attr-defined] return None , None , None","title":"get_docstring()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_instance_names","text":"Extract names from an assignment node, only for instance attributes. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def get_instance_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )]","title":"get_instance_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_name","text":"Extract name from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: str \u2013 A list of names. Source code in griffe/agents/nodes.py 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 def get_name ( node : AST ) -> str : \"\"\"Extract name from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_name_map [ type ( node )]( node )","title":"get_name()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_names","text":"Extract names from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def get_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map [ type ( node )]( node )","title":"get_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_parameter_default","text":"Extract the default value of a function parameter. Parameters: node ( AST ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/agents/nodes.py 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 def get_parameter_default ( node : AST , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None if isinstance ( node , NodeConstant ): return repr ( node . value ) if isinstance ( node , NodeName ): return node . id if node . lineno == node . end_lineno : # type: ignore[attr-defined] return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # type: ignore[attr-defined] # TODO: handle multiple line defaults return None","title":"get_parameter_default()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_value","text":"Extract a complex value as a string. Parameters: node ( AST ) \u2013 The node to extract the value from. Returns: str \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 996 997 998 999 1000 1001 1002 1003 1004 1005 def get_value ( node : AST ) -> str : \"\"\"Extract a complex value as a string. Parameters: node: The node to extract the value from. Returns: The unparsed code of the node. \"\"\" return _node_value_map [ type ( node )]( node )","title":"get_value()"},{"location":"reference/griffe/agents/visitor/","text":"Code parsing and data extraction utilies. This module exposes a public function, visit() , which parses the module code using parse() , and returns a new Module instance, populating its members recursively, by using a NodeVisitor -like class. Visitor ( BaseVisitor ) \u00a4 This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. Source code in griffe/agents/visitor.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 class Visitor ( BaseVisitor ): # noqa: WPS338 \"\"\"This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. \"\"\" def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () def _get_docstring ( self , node : ast . AST , strict : bool = False ) -> Docstring | None : value , lineno , endlineno = get_docstring ( node , strict = strict ) if value is None : return None return Docstring ( value , lineno = lineno , endlineno = endlineno , parser = self . docstring_parser , parser_options = self . docstring_options , ) def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node ) def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) super () . generic_visit ( node ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node ) def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node ) def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node ) def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" }) def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name . split ( \".\" , 1 )[ 0 ] alias_name = name . asname or alias_path self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) def visit_importfrom ( self , node : ast . ImportFrom ) -> None : \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_name = name . asname or name . name alias_path = f \" { node . module } . { name . name } \" self . current . imports [ name . asname or name . name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times: check for try/excepts # TODO: might be better to inspect if isinstance ( node . parent , ast . ExceptHandler ): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = { elt . value for elt in node . value . elts } # type: ignore[union-attr] def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node ) def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current )) __init__ ( self , module_name , filepath , code , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 Initialize the visitor. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path ) \u2013 The module filepath. code ( str ) \u2013 The module source code. extensions ( Extensions ) \u2013 The extensions to use when visiting. parent ( Module | None ) \u2013 An optional parent for the final module object. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/agents/visitor.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () generic_visit ( self , node ) \u00a4 Extend the base generic visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 171 172 173 174 175 176 177 178 179 180 181 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) super () . generic_visit ( node ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node ) get_module ( self ) \u00a4 Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: Module \u2013 A module instance. Source code in griffe/agents/visitor.py 145 146 147 148 149 150 151 152 153 154 155 156 157 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module handle_attribute ( self , node , annotation = None ) \u00a4 Handle an attribute (assignment) node. Parameters: node ( ast . Assign | ast . AnnAssign ) \u2013 The node to visit. annotation ( str | Name | Expression | None ) \u2013 A potential annotation. Source code in griffe/agents/visitor.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times: check for try/excepts # TODO: might be better to inspect if isinstance ( node . parent , ast . ExceptHandler ): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = { elt . value for elt in node . value . elts } # type: ignore[union-attr] handle_function ( self , node , labels = None ) \u00a4 Handle a function definition node. Parameters: node ( ast . AsyncFunctionDef | ast . FunctionDef ) \u2013 The node to visit. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/visitor.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] visit ( self , node ) \u00a4 Extend the base visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 159 160 161 162 163 164 165 166 167 168 169 def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node ) visit_annassign ( self , node ) \u00a4 Visit an annotated assignment node. Parameters: node ( ast . AnnAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 481 482 483 484 485 486 487 def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current )) visit_assign ( self , node ) \u00a4 Visit an assignment node. Parameters: node ( ast . Assign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 473 474 475 476 477 478 479 def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node ) visit_asyncfunctiondef ( self , node ) \u00a4 Visit an async function definition node. Parameters: node ( ast . AsyncFunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 356 357 358 359 360 361 362 def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" }) visit_classdef ( self , node ) \u00a4 Visit a class definition node. Parameters: node ( ast . ClassDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] visit_functiondef ( self , node ) \u00a4 Visit a function definition node. Parameters: node ( ast . FunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 348 349 350 351 352 353 354 def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node ) visit_import ( self , node ) \u00a4 Visit an import node. Parameters: node ( ast . Import ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name . split ( \".\" , 1 )[ 0 ] alias_name = name . asname or alias_path self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) visit_importfrom ( self , node ) \u00a4 Visit an \"import from\" node. Parameters: node ( ast . ImportFrom ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def visit_importfrom ( self , node : ast . ImportFrom ) -> None : \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_name = name . asname or name . name alias_path = f \" { node . module } . { name . name } \" self . current . imports [ name . asname or name . name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) visit_module ( self , node ) \u00a4 Visit a module node. Parameters: node ( ast . Module ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node ) patch_ast () \u00a4 Extend the base ast.AST class to provide more functionality. Source code in griffe/agents/visitor.py 493 494 495 496 497 498 499 500 501 502 def patch_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if ast . AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , ASTNode ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442 visit ( module_name , filepath , code , * , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/visitor.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def visit ( module_name : str , filepath : Path , code : str , * , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. Returns: The module, with its members populated. \"\"\" return Visitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , ) . get_module ()","title":"visitor"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor","text":"This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. Source code in griffe/agents/visitor.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 class Visitor ( BaseVisitor ): # noqa: WPS338 \"\"\"This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. \"\"\" def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () def _get_docstring ( self , node : ast . AST , strict : bool = False ) -> Docstring | None : value , lineno , endlineno = get_docstring ( node , strict = strict ) if value is None : return None return Docstring ( value , lineno = lineno , endlineno = endlineno , parser = self . docstring_parser , parser_options = self . docstring_options , ) def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node ) def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) super () . generic_visit ( node ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node ) def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node ) def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node ) def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" }) def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name . split ( \".\" , 1 )[ 0 ] alias_name = name . asname or alias_path self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) def visit_importfrom ( self , node : ast . ImportFrom ) -> None : \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_name = name . asname or name . name alias_path = f \" { node . module } . { name . name } \" self . current . imports [ name . asname or name . name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times: check for try/excepts # TODO: might be better to inspect if isinstance ( node . parent , ast . ExceptHandler ): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = { elt . value for elt in node . value . elts } # type: ignore[union-attr] def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node ) def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current ))","title":"Visitor"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.__init__","text":"Initialize the visitor. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path ) \u2013 The module filepath. code ( str ) \u2013 The module source code. extensions ( Extensions ) \u2013 The extensions to use when visiting. parent ( Module | None ) \u2013 An optional parent for the final module object. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/agents/visitor.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection ()","title":"__init__()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.generic_visit","text":"Extend the base generic visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 171 172 173 174 175 176 177 178 179 180 181 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) super () . generic_visit ( node ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node )","title":"generic_visit()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.get_module","text":"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: Module \u2013 A module instance. Source code in griffe/agents/visitor.py 145 146 147 148 149 150 151 152 153 154 155 156 157 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module","title":"get_module()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_attribute","text":"Handle an attribute (assignment) node. Parameters: node ( ast . Assign | ast . AnnAssign ) \u2013 The node to visit. annotation ( str | Name | Expression | None ) \u2013 A potential annotation. Source code in griffe/agents/visitor.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times: check for try/excepts # TODO: might be better to inspect if isinstance ( node . parent , ast . ExceptHandler ): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = { elt . value for elt in node . value . elts } # type: ignore[union-attr]","title":"handle_attribute()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_function","text":"Handle a function definition node. Parameters: node ( ast . AsyncFunctionDef | ast . FunctionDef ) \u2013 The node to visit. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/visitor.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"handle_function()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit","text":"Extend the base visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 159 160 161 162 163 164 165 166 167 168 169 def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node )","title":"visit()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_annassign","text":"Visit an annotated assignment node. Parameters: node ( ast . AnnAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 481 482 483 484 485 486 487 def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current ))","title":"visit_annassign()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_assign","text":"Visit an assignment node. Parameters: node ( ast . Assign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 473 474 475 476 477 478 479 def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node )","title":"visit_assign()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_asyncfunctiondef","text":"Visit an async function definition node. Parameters: node ( ast . AsyncFunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 356 357 358 359 360 361 362 def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" })","title":"visit_asyncfunctiondef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_classdef","text":"Visit a class definition node. Parameters: node ( ast . ClassDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"visit_classdef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_functiondef","text":"Visit a function definition node. Parameters: node ( ast . FunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 348 349 350 351 352 353 354 def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node )","title":"visit_functiondef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_import","text":"Visit an import node. Parameters: node ( ast . Import ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name . split ( \".\" , 1 )[ 0 ] alias_name = name . asname or alias_path self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node )","title":"visit_import()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_importfrom","text":"Visit an \"import from\" node. Parameters: node ( ast . ImportFrom ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def visit_importfrom ( self , node : ast . ImportFrom ) -> None : \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_name = name . asname or name . name alias_path = f \" { node . module } . { name . name } \" self . current . imports [ name . asname or name . name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node )","title":"visit_importfrom()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_module","text":"Visit a module node. Parameters: node ( ast . Module ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node )","title":"visit_module()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.patch_ast","text":"Extend the base ast.AST class to provide more functionality. Source code in griffe/agents/visitor.py 493 494 495 496 497 498 499 500 501 502 def patch_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if ast . AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , ASTNode ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442","title":"patch_ast()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.visit","text":"Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/visitor.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def visit ( module_name : str , filepath : Path , code : str , * , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. Returns: The module, with its members populated. \"\"\" return Visitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , ) . get_module ()","title":"visit()"},{"location":"reference/griffe/agents/extensions/","text":"This module is the public interface to import elements from the base. Extension = Union [ VisitorExtension , InspectorExtension ] \u00a4 Extensions \u00a4 This class helps iterating on extensions that should run at different times. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class Extensions : \"\"\"This class helps iterating on extensions that should run at different times.\"\"\" def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ] __init__ ( self , * extensions ) \u00a4 Initialize the extensions container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 95 96 97 98 99 100 101 102 103 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) add ( self , * extensions ) \u00a4 Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 105 106 107 108 109 110 111 112 113 114 115 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) after_children_inspection ( self ) \u00a4 Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 199 200 201 202 203 204 205 206 @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] after_children_visit ( self ) \u00a4 Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 163 164 165 166 167 168 169 170 @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] after_inspection ( self ) \u00a4 Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 208 209 210 211 212 213 214 215 @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ] after_visit ( self ) \u00a4 Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 172 173 174 175 176 177 178 179 @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] attach_inspector ( self , parent_inspector ) \u00a4 Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 131 132 133 134 135 136 137 138 139 140 141 142 143 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self attach_visitor ( self , parent_visitor ) \u00a4 Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 117 118 119 120 121 122 123 124 125 126 127 128 129 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self before_children_inspection ( self ) \u00a4 Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 190 191 192 193 194 195 196 197 @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] before_children_visit ( self ) \u00a4 Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 154 155 156 157 158 159 160 161 @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] before_inspection ( self ) \u00a4 Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 181 182 183 184 185 186 187 188 @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] before_visit ( self ) \u00a4 Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 145 146 147 148 149 150 151 152 @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] When ( enum . Enum ) \u00a4 This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class When ( enum . Enum ): \"\"\"This enumeration contains the different times at which an extension is used. Attributes: before_all: For each node, before the visit/inspection. before_children: For each node, after the visit has started, and before the children visit/inspection. after_children: For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all: For each node, after the visit/inspection. \"\"\" before_all : int = 1 before_children : int = 2 after_children : int = 3 after_all : int = 4 load_extension ( extension ) \u00a4 Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" module = __import__ ( import_path , level = 0 ) ext_path = import_path . split ( \".\" )[ 1 :] ext_module = module for part in ext_path : ext_module = getattr ( ext_module , part ) # TODO: handle AttributeError return ext_module . Extension ( ** options ) load_extensions ( exts ) \u00a4 Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"extensions"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.Extension","text":"","title":"Extension"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.Extensions","text":"This class helps iterating on extensions that should run at different times. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class Extensions : \"\"\"This class helps iterating on extensions that should run at different times.\"\"\" def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ]","title":"Extensions"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.__init__","text":"Initialize the extensions container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 95 96 97 98 99 100 101 102 103 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions )","title":"__init__()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.add","text":"Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 105 106 107 108 109 110 111 112 113 114 115 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension )","title":"add()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_children_inspection","text":"Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 199 200 201 202 203 204 205 206 @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ]","title":"after_children_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_children_visit","text":"Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 163 164 165 166 167 168 169 170 @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ]","title":"after_children_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_inspection","text":"Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 208 209 210 211 212 213 214 215 @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ]","title":"after_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_visit","text":"Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 172 173 174 175 176 177 178 179 @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ]","title":"after_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.attach_inspector","text":"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 131 132 133 134 135 136 137 138 139 140 141 142 143 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self","title":"attach_inspector()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.attach_visitor","text":"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 117 118 119 120 121 122 123 124 125 126 127 128 129 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self","title":"attach_visitor()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_children_inspection","text":"Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 190 191 192 193 194 195 196 197 @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ]","title":"before_children_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_children_visit","text":"Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 154 155 156 157 158 159 160 161 @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ]","title":"before_children_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_inspection","text":"Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 181 182 183 184 185 186 187 188 @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ]","title":"before_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_visit","text":"Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 145 146 147 148 149 150 151 152 @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ]","title":"before_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.When","text":"This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class When ( enum . Enum ): \"\"\"This enumeration contains the different times at which an extension is used. Attributes: before_all: For each node, before the visit/inspection. before_children: For each node, after the visit has started, and before the children visit/inspection. after_children: For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all: For each node, after the visit/inspection. \"\"\" before_all : int = 1 before_children : int = 2 after_children : int = 3 after_all : int = 4","title":"When"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.load_extension","text":"Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" module = __import__ ( import_path , level = 0 ) ext_path = import_path . split ( \".\" )[ 1 :] ext_module = module for part in ext_path : ext_module = getattr ( ext_module , part ) # TODO: handle AttributeError return ext_module . Extension ( ** options )","title":"load_extension()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.load_extensions","text":"Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"load_extensions()"},{"location":"reference/griffe/agents/extensions/base/","text":"This module contains the base classes for dealing with extensions. Extensions \u00a4 This class helps iterating on extensions that should run at different times. Source code in griffe/agents/extensions/base.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 class Extensions : \"\"\"This class helps iterating on extensions that should run at different times.\"\"\" def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ] __init__ ( self , * extensions ) \u00a4 Initialize the extensions container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 95 96 97 98 99 100 101 102 103 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) add ( self , * extensions ) \u00a4 Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 105 106 107 108 109 110 111 112 113 114 115 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) after_children_inspection ( self ) \u00a4 Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 199 200 201 202 203 204 205 206 @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] after_children_visit ( self ) \u00a4 Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 163 164 165 166 167 168 169 170 @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] after_inspection ( self ) \u00a4 Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 208 209 210 211 212 213 214 215 @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ] after_visit ( self ) \u00a4 Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 172 173 174 175 176 177 178 179 @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] attach_inspector ( self , parent_inspector ) \u00a4 Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 131 132 133 134 135 136 137 138 139 140 141 142 143 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self attach_visitor ( self , parent_visitor ) \u00a4 Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 117 118 119 120 121 122 123 124 125 126 127 128 129 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self before_children_inspection ( self ) \u00a4 Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 190 191 192 193 194 195 196 197 @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] before_children_visit ( self ) \u00a4 Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 154 155 156 157 158 159 160 161 @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] before_inspection ( self ) \u00a4 Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 181 182 183 184 185 186 187 188 @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] before_visit ( self ) \u00a4 Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 145 146 147 148 149 150 151 152 @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] InspectorExtension ( BaseInspector ) \u00a4 The object inspector extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class InspectorExtension ( BaseInspector ): \"\"\"The object inspector extension base class, to inherit from.\"\"\" when : When def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment] def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node ) __init__ ( self ) \u00a4 Initialize the inspector extension. Source code in griffe/agents/extensions/base.py 67 68 69 70 def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment] attach ( self , inspector ) \u00a4 Attach the parent inspector to this extension. Parameters: inspector ( Inspector ) \u2013 The parent inspector. Source code in griffe/agents/extensions/base.py 72 73 74 75 76 77 78 def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector inspect ( self , node ) \u00a4 Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/extensions/base.py 80 81 82 83 84 85 86 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node ) VisitorExtension ( BaseVisitor ) \u00a4 The node visitor extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class VisitorExtension ( BaseVisitor ): \"\"\"The node visitor extension base class, to inherit from.\"\"\" when : When def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment] def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined] __init__ ( self ) \u00a4 Initialize the visitor extension. Source code in griffe/agents/extensions/base.py 40 41 42 43 def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment] attach ( self , visitor ) \u00a4 Attach the parent visitor to this extension. Parameters: visitor ( Visitor ) \u2013 The parent visitor. Source code in griffe/agents/extensions/base.py 45 46 47 48 49 50 51 def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor visit ( self , node ) \u00a4 Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/extensions/base.py 53 54 55 56 57 58 59 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined] When ( enum . Enum ) \u00a4 This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection. Source code in griffe/agents/extensions/base.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class When ( enum . Enum ): \"\"\"This enumeration contains the different times at which an extension is used. Attributes: before_all: For each node, before the visit/inspection. before_children: For each node, after the visit has started, and before the children visit/inspection. after_children: For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all: For each node, after the visit/inspection. \"\"\" before_all : int = 1 before_children : int = 2 after_children : int = 3 after_all : int = 4 load_extension ( extension ) \u00a4 Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" module = __import__ ( import_path , level = 0 ) ext_path = import_path . split ( \".\" )[ 1 :] ext_module = module for part in ext_path : ext_module = getattr ( ext_module , part ) # TODO: handle AttributeError return ext_module . Extension ( ** options ) load_extensions ( exts ) \u00a4 Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 258 259 260 261 262 263 264 265 266 267 268 269 270 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"base"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions","text":"This class helps iterating on extensions that should run at different times. Source code in griffe/agents/extensions/base.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 class Extensions : \"\"\"This class helps iterating on extensions that should run at different times.\"\"\" def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ]","title":"Extensions"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.__init__","text":"Initialize the extensions container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 95 96 97 98 99 100 101 102 103 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions )","title":"__init__()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.add","text":"Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 105 106 107 108 109 110 111 112 113 114 115 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension )","title":"add()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.after_children_inspection","text":"Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 199 200 201 202 203 204 205 206 @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ]","title":"after_children_inspection()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.after_children_visit","text":"Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 163 164 165 166 167 168 169 170 @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ]","title":"after_children_visit()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.after_inspection","text":"Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 208 209 210 211 212 213 214 215 @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ]","title":"after_inspection()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.after_visit","text":"Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 172 173 174 175 176 177 178 179 @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ]","title":"after_visit()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.attach_inspector","text":"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 131 132 133 134 135 136 137 138 139 140 141 142 143 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self","title":"attach_inspector()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.attach_visitor","text":"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 117 118 119 120 121 122 123 124 125 126 127 128 129 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self","title":"attach_visitor()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.before_children_inspection","text":"Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 190 191 192 193 194 195 196 197 @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ]","title":"before_children_inspection()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.before_children_visit","text":"Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 154 155 156 157 158 159 160 161 @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ]","title":"before_children_visit()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.before_inspection","text":"Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 181 182 183 184 185 186 187 188 @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ]","title":"before_inspection()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.Extensions.before_visit","text":"Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 145 146 147 148 149 150 151 152 @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ]","title":"before_visit()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.InspectorExtension","text":"The object inspector extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class InspectorExtension ( BaseInspector ): \"\"\"The object inspector extension base class, to inherit from.\"\"\" when : When def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment] def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node )","title":"InspectorExtension"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.InspectorExtension.__init__","text":"Initialize the inspector extension. Source code in griffe/agents/extensions/base.py 67 68 69 70 def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment]","title":"__init__()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.InspectorExtension.attach","text":"Attach the parent inspector to this extension. Parameters: inspector ( Inspector ) \u2013 The parent inspector. Source code in griffe/agents/extensions/base.py 72 73 74 75 76 77 78 def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector","title":"attach()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.InspectorExtension.inspect","text":"Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/extensions/base.py 80 81 82 83 84 85 86 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node )","title":"inspect()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.VisitorExtension","text":"The node visitor extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class VisitorExtension ( BaseVisitor ): \"\"\"The node visitor extension base class, to inherit from.\"\"\" when : When def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment] def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined]","title":"VisitorExtension"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.VisitorExtension.__init__","text":"Initialize the visitor extension. Source code in griffe/agents/extensions/base.py 40 41 42 43 def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment]","title":"__init__()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.VisitorExtension.attach","text":"Attach the parent visitor to this extension. Parameters: visitor ( Visitor ) \u2013 The parent visitor. Source code in griffe/agents/extensions/base.py 45 46 47 48 49 50 51 def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor","title":"attach()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.VisitorExtension.visit","text":"Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/extensions/base.py 53 54 55 56 57 58 59 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined]","title":"visit()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.When","text":"This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection. Source code in griffe/agents/extensions/base.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class When ( enum . Enum ): \"\"\"This enumeration contains the different times at which an extension is used. Attributes: before_all: For each node, before the visit/inspection. before_children: For each node, after the visit has started, and before the children visit/inspection. after_children: For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all: For each node, after the visit/inspection. \"\"\" before_all : int = 1 before_children : int = 2 after_children : int = 3 after_all : int = 4","title":"When"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.load_extension","text":"Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" module = __import__ ( import_path , level = 0 ) ext_path = import_path . split ( \".\" )[ 1 :] ext_module = module for part in ext_path : ext_module = getattr ( ext_module , part ) # TODO: handle AttributeError return ext_module . Extension ( ** options )","title":"load_extension()"},{"location":"reference/griffe/agents/extensions/base/#griffe.agents.extensions.base.load_extensions","text":"Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 258 259 260 261 262 263 264 265 266 267 268 269 270 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"load_extensions()"},{"location":"reference/griffe/agents/extensions/hybrid/","text":"This extension provides an hybrid behavior while loading data. HybridExtension ( VisitorExtension ) \u00a4 Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. Source code in griffe/agents/extensions/hybrid.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class HybridExtension ( VisitorExtension ): \"\"\"Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. \"\"\" when = When . after_all def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ () def attach ( self , visitor : Visitor ) -> None : # noqa: D102 super () . attach ( visitor ) self . _extension . attach ( visitor ) # type: ignore[arg-type] # tolerate hybrid behavior def visit ( self , node : ast . AST ) -> None : # noqa: D102 try : just_visited = self . visitor . current [ node . name ] # type: ignore[attr-defined] except ( KeyError , AttributeError , TypeError ): return if just_visited . is_alias : return module_path = just_visited . module . path module = __import__ ( module_path ) value = module for part in just_visited . path . split ( \".\" )[ 1 :]: try : value = getattr ( value , part ) except AttributeError : # can happen when an object is defined conditionally, # for example based on the Python version return object_node = ObjectNode ( value , name = node . name ) # type: ignore[attr-defined] self . _extension . inspect ( object_node ) __init__ ( self , extension ) \u00a4 Initialize the extension. Parameters: extension ( str | dict [ str , Any ] ) \u2013 The name or configuration of another extension. Raises: ExtensionError \u2013 When the passed extension is not an inspector extension. Source code in griffe/agents/extensions/hybrid.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ ()","title":"hybrid"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension","text":"Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. Source code in griffe/agents/extensions/hybrid.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class HybridExtension ( VisitorExtension ): \"\"\"Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. \"\"\" when = When . after_all def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ () def attach ( self , visitor : Visitor ) -> None : # noqa: D102 super () . attach ( visitor ) self . _extension . attach ( visitor ) # type: ignore[arg-type] # tolerate hybrid behavior def visit ( self , node : ast . AST ) -> None : # noqa: D102 try : just_visited = self . visitor . current [ node . name ] # type: ignore[attr-defined] except ( KeyError , AttributeError , TypeError ): return if just_visited . is_alias : return module_path = just_visited . module . path module = __import__ ( module_path ) value = module for part in just_visited . path . split ( \".\" )[ 1 :]: try : value = getattr ( value , part ) except AttributeError : # can happen when an object is defined conditionally, # for example based on the Python version return object_node = ObjectNode ( value , name = node . name ) # type: ignore[attr-defined] self . _extension . inspect ( object_node )","title":"HybridExtension"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension.__init__","text":"Initialize the extension. Parameters: extension ( str | dict [ str , Any ] ) \u2013 The name or configuration of another extension. Raises: ExtensionError \u2013 When the passed extension is not an inspector extension. Source code in griffe/agents/extensions/hybrid.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ ()","title":"__init__()"},{"location":"reference/griffe/docstrings/","text":"This module exposes objects related to docstrings. Parser ( enum . Enum ) \u00a4 Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\" parse ( docstring , parser , ** options ) \u00a4 Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"docstrings"},{"location":"reference/griffe/docstrings/#griffe.docstrings.Parser","text":"Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\"","title":"Parser"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parse","text":"Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/dataclasses/","text":"This module contains the dataclasses related to docstrings. DocstringAdmonition \u00a4 This base class represents admonitions. Attributes: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class DocstringAdmonition : \"\"\"This base class represents admonitions. Attributes: kind: The admonition kind. contents: The admonition contents. \"\"\" def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , } __init__ ( self , * , kind , contents ) \u00a4 Initialize the admonition. Parameters: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 71 72 73 74 75 76 77 78 79 def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents as_dict ( self , ** kwargs ) \u00a4 Return this admonition's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , } DocstringAttribute ( DocstringNamedElement ) \u00a4 This class represents a documented module/class attribute. Source code in griffe/docstrings/dataclasses.py 209 210 class DocstringAttribute ( DocstringNamedElement ): \"\"\"This class represents a documented module/class attribute.\"\"\" DocstringElement \u00a4 This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class DocstringElement : \"\"\"This base class represents annotated, nameless elements. Attributes: annotation: The element annotation, if any. description: The element description. \"\"\" def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , } __init__ ( self , * , description , annotation = None ) \u00a4 Initialize the element. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 104 105 106 107 108 109 110 111 112 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , } DocstringNamedElement ( DocstringElement ) \u00a4 This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Source code in griffe/docstrings/dataclasses.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 class DocstringNamedElement ( DocstringElement ): \"\"\"This base class represents annotated, named elements. Attributes: name: The element name. value: The element value, as a string, if any. \"\"\" def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base __init__ ( self , name , * , description , annotation = None , value = None ) \u00a4 Initialize the element. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base DocstringParameter ( DocstringNamedElement ) \u00a4 This class represent a documented function parameter. Source code in griffe/docstrings/dataclasses.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class DocstringParameter ( DocstringNamedElement ): \"\"\"This class represent a documented function parameter.\"\"\" @property def default ( self ): \"\"\"Return the default value of this parameter. Returns: The parameter's default. \"\"\" return self . value @default . setter def default ( self , value ): self . value = value DocstringRaise ( DocstringElement ) \u00a4 This class represents a documented raise value. Source code in griffe/docstrings/dataclasses.py 172 173 class DocstringRaise ( DocstringElement ): \"\"\"This class represents a documented raise value.\"\"\" DocstringReceive ( DocstringNamedElement ) \u00a4 This class represents a documented receive value. Source code in griffe/docstrings/dataclasses.py 188 189 class DocstringReceive ( DocstringNamedElement ): \"\"\"This class represents a documented receive value.\"\"\" DocstringReturn ( DocstringNamedElement ) \u00a4 This class represents a documented return value. Source code in griffe/docstrings/dataclasses.py 180 181 class DocstringReturn ( DocstringNamedElement ): \"\"\"This class represents a documented return value.\"\"\" DocstringSection \u00a4 Placeholder. Source code in griffe/docstrings/dataclasses.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class DocstringSection : \"\"\"Placeholder.\"\"\" def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base __init__ ( self , kind , value , title = None ) \u00a4 Initialize the section. Parameters: kind ( DocstringSectionKind ) \u2013 The section kind. value ( Any ) \u2013 The section value. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title as_dict ( self , ** kwargs ) \u00a4 Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base DocstringSectionKind ( enum . Enum ) \u00a4 The possible section kinds. Source code in griffe/docstrings/dataclasses.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DocstringSectionKind ( enum . Enum ): \"\"\"The possible section kinds.\"\"\" text = \"text\" parameters = \"parameters\" other_parameters = \"other parameters\" raises = \"raises\" warns = \"warns\" returns = \"returns\" yields = \"yields\" receives = \"receives\" examples = \"examples\" attributes = \"attributes\" deprecated = \"deprecated\" admonition = \"admonition\" DocstringWarn ( DocstringElement ) \u00a4 This class represents a documented warn value. Source code in griffe/docstrings/dataclasses.py 176 177 class DocstringWarn ( DocstringElement ): \"\"\"This class represents a documented warn value.\"\"\" DocstringYield ( DocstringNamedElement ) \u00a4 This class represents a documented yield value. Source code in griffe/docstrings/dataclasses.py 184 185 class DocstringYield ( DocstringNamedElement ): \"\"\"This class represents a documented yield value.\"\"\"","title":"dataclasses"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition","text":"This base class represents admonitions. Attributes: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class DocstringAdmonition : \"\"\"This base class represents admonitions. Attributes: kind: The admonition kind. contents: The admonition contents. \"\"\" def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , }","title":"DocstringAdmonition"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.__init__","text":"Initialize the admonition. Parameters: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 71 72 73 74 75 76 77 78 79 def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.as_dict","text":"Return this admonition's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , }","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAttribute","text":"This class represents a documented module/class attribute. Source code in griffe/docstrings/dataclasses.py 209 210 class DocstringAttribute ( DocstringNamedElement ): \"\"\"This class represents a documented module/class attribute.\"\"\"","title":"DocstringAttribute"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement","text":"This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class DocstringElement : \"\"\"This base class represents annotated, nameless elements. Attributes: annotation: The element annotation, if any. description: The element description. \"\"\" def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , }","title":"DocstringElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.__init__","text":"Initialize the element. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 104 105 106 107 108 109 110 111 112 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.as_dict","text":"Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , }","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement","text":"This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Source code in griffe/docstrings/dataclasses.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 class DocstringNamedElement ( DocstringElement ): \"\"\"This base class represents annotated, named elements. Attributes: name: The element name. value: The element value, as a string, if any. \"\"\" def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base","title":"DocstringNamedElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.__init__","text":"Initialize the element. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.as_dict","text":"Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter","text":"This class represent a documented function parameter. Source code in griffe/docstrings/dataclasses.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class DocstringParameter ( DocstringNamedElement ): \"\"\"This class represent a documented function parameter.\"\"\" @property def default ( self ): \"\"\"Return the default value of this parameter. Returns: The parameter's default. \"\"\" return self . value @default . setter def default ( self , value ): self . value = value","title":"DocstringParameter"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringRaise","text":"This class represents a documented raise value. Source code in griffe/docstrings/dataclasses.py 172 173 class DocstringRaise ( DocstringElement ): \"\"\"This class represents a documented raise value.\"\"\"","title":"DocstringRaise"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReceive","text":"This class represents a documented receive value. Source code in griffe/docstrings/dataclasses.py 188 189 class DocstringReceive ( DocstringNamedElement ): \"\"\"This class represents a documented receive value.\"\"\"","title":"DocstringReceive"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReturn","text":"This class represents a documented return value. Source code in griffe/docstrings/dataclasses.py 180 181 class DocstringReturn ( DocstringNamedElement ): \"\"\"This class represents a documented return value.\"\"\"","title":"DocstringReturn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection","text":"Placeholder. Source code in griffe/docstrings/dataclasses.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class DocstringSection : \"\"\"Placeholder.\"\"\" def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base","title":"DocstringSection"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.__init__","text":"Initialize the section. Parameters: kind ( DocstringSectionKind ) \u2013 The section kind. value ( Any ) \u2013 The section value. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.as_dict","text":"Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind","text":"The possible section kinds. Source code in griffe/docstrings/dataclasses.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DocstringSectionKind ( enum . Enum ): \"\"\"The possible section kinds.\"\"\" text = \"text\" parameters = \"parameters\" other_parameters = \"other parameters\" raises = \"raises\" warns = \"warns\" returns = \"returns\" yields = \"yields\" receives = \"receives\" examples = \"examples\" attributes = \"attributes\" deprecated = \"deprecated\" admonition = \"admonition\"","title":"DocstringSectionKind"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringWarn","text":"This class represents a documented warn value. Source code in griffe/docstrings/dataclasses.py 176 177 class DocstringWarn ( DocstringElement ): \"\"\"This class represents a documented warn value.\"\"\"","title":"DocstringWarn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringYield","text":"This class represents a documented yield value. Source code in griffe/docstrings/dataclasses.py 184 185 class DocstringYield ( DocstringNamedElement ): \"\"\"This class represents a documented yield value.\"\"\"","title":"DocstringYield"},{"location":"reference/griffe/docstrings/google/","text":"This module defines functions to parse Google-style docstrings into structured data. _RE_ADMONITION : Pattern = re . compile ( '^(?P<type>[ \\\\ w][ \\\\ s \\\\ w-]*):( \\\\ s+(?P<title>.+))?$' , re . I ) \u00a4 Regular expression to match admonitions, of the form TYPE: [TITLE] . _RE_NAME_ANNOTATION_DESCRIPTION : Pattern = re . compile ( '^(?:(?P<name> \\\\ w+)? \\\\ s*(?: \\\\ ((?P<type>.+) \\\\ ))?: \\\\ s*)?(?P<desc>.*)$' ) \u00a4 Regular expression to match name (type): Description in docstrings sections items. parse ( docstring , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : # TODO: once Python 3.7 is dropped, use walrus operator match = _RE_ADMONITION . match ( lines [ offset ]) if match : groups = match . groupdict () admonition_type = groups [ \"type\" ] . lower () if admonition_type in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type ]] section , offset = reader ( docstring , offset + 1 ) if section : section . title = groups [ \"title\" ] sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type , contents = contents ), title = groups [ \"title\" ], ) ) else : with suppress ( IndexError ): current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"google"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._RE_ADMONITION","text":"Regular expression to match admonitions, of the form TYPE: [TITLE] .","title":"_RE_ADMONITION"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._RE_NAME_ANNOTATION_DESCRIPTION","text":"Regular expression to match name (type): Description in docstrings sections items.","title":"_RE_NAME_ANNOTATION_DESCRIPTION"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : # TODO: once Python 3.7 is dropped, use walrus operator match = _RE_ADMONITION . match ( lines [ offset ]) if match : groups = match . groupdict () admonition_type = groups [ \"type\" ] . lower () if admonition_type in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type ]] section , offset = reader ( docstring , offset + 1 ) if section : section . title = groups [ \"title\" ] sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type , contents = contents ), title = groups [ \"title\" ], ) ) else : with suppress ( IndexError ): current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/markdown/","text":"This module defines functions and classes to parse Markdown docstrings into structured data.","title":"markdown"},{"location":"reference/griffe/docstrings/numpy/","text":"This module defines functions to parse Numpy-style docstrings into structured data. Based on https://numpydoc.readthedocs.io/en/latest/format.html , it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification. See also: this section feels too subjective (specially crafted as a standard for Numpy itself), and there are may ways to reference related items in a docstring, depending on the chosen markup. Methods: with a good documentation renderer, methods are easily made accessible or hidden. Griffe also has a goal of making the merging of inherited methods configurable (on/off). Warnings: this is just markup. Notes: again, just markup. References: again, just markup. Deprecated (revisited): we expect a title instead of an RST directive. Python has support for deprecating things, so it feels natural to structure deprecations. Parameters: obviously. Returns: obviously. Yields: obviously. Receives: less used than Yields, but very natural/Pythonic as well. Other parameters: used here as documentation for keyword parameters. Raises: obviously. Warns: less used than Raises, but very natural/Pythonic as well. Examples: obviously. Special handling for non-code-blocks >>> . Attributes: obviously. parse ( docstring , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"numpy"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/parsers/","text":"This module imports all the defined parsers. Parser ( enum . Enum ) \u00a4 Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 24 25 26 27 28 29 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\" parse ( docstring , parser , ** options ) \u00a4 Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parsers"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser","text":"Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 24 25 26 27 28 29 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\"","title":"Parser"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.parse","text":"Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/rst/","text":"This module defines functions to parse RST-style docstrings into structured data. Credits to Patrick Lannigan ( @plannigan ) who originally added the parser in the pytkdocs project . See https://github.com/mkdocstrings/pytkdocs/pull/71 . FieldType \u00a4 Maps directive names to parser functions. Source code in griffe/docstrings/rst.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @dataclass ( frozen = True ) class FieldType : \"\"\"Maps directive names to parser functions.\"\"\" names : FrozenSet [ str ] reader : Callable [[ Docstring , int , ParsedValues ], int ] def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names ) matches ( self , line ) \u00a4 Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/rst.py 46 47 48 49 50 51 52 53 54 55 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names ) ParsedDirective \u00a4 Directive information that has been parsed from a docstring. Source code in griffe/docstrings/rst.py 58 59 60 61 62 63 64 65 66 @dataclass class ParsedDirective : \"\"\"Directive information that has been parsed from a docstring.\"\"\" line : str next_index : int directive_parts : list [ str ] value : str invalid : bool = False ParsedValues \u00a4 Values parsed from the docstring to be used to produce sections. Source code in griffe/docstrings/rst.py 69 70 71 72 73 74 75 76 77 78 79 80 @dataclass class ParsedValues : \"\"\"Values parsed from the docstring to be used to produce sections.\"\"\" description : list [ str ] = field ( default_factory = list ) parameters : dict [ str , DocstringParameter ] = field ( default_factory = dict ) param_types : dict [ str , str ] = field ( default_factory = dict ) attributes : dict [ str , DocstringAttribute ] = field ( default_factory = dict ) attribute_types : dict [ str , str ] = field ( default_factory = dict ) exceptions : list [ DocstringRaise ] = field ( default_factory = list ) return_value : DocstringReturn | None = None return_type : str | None = None _consolidate_continuation_lines ( lines , offset ) \u00a4 Convert a docstring field into a single line if a line continuation exists. Parameters: lines ( list [ str ] ) \u2013 The docstring lines. offset ( int ) \u2013 The line number to start at. Returns: tuple [ str , int ] \u2013 A tuple containing the continued lines as a single string and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def _consolidate_continuation_lines ( lines : list [ str ], offset : int ) -> tuple [ str , int ]: \"\"\" Convert a docstring field into a single line if a line continuation exists. Parameters: lines: The docstring lines. offset: The line number to start at. Returns: A tuple containing the continued lines as a single string and the index at which to continue parsing. \"\"\" curr_line_index = offset block = [ lines [ curr_line_index ] . lstrip ()] # start processing after first item curr_line_index += 1 while curr_line_index < len ( lines ) and not lines [ curr_line_index ] . startswith ( \":\" ): block . append ( lines [ curr_line_index ] . lstrip ()) curr_line_index += 1 return \" \" . join ( block ) . rstrip ( \" \\n \" ), curr_line_index - 1 _consolidate_descriptive_type ( descriptive_type ) \u00a4 Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type ( str ) \u2013 Descriptions of an item's type. Returns: str \u2013 Type signature for descriptive type. Source code in griffe/docstrings/rst.py 433 434 435 436 437 438 439 440 441 442 443 444 def _consolidate_descriptive_type ( descriptive_type : str ) -> str : \"\"\"Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type: Descriptions of an item's type. Returns: Type signature for descriptive type. \"\"\" return descriptive_type . replace ( \" or \" , \" | \" ) _read_attribute ( docstring , offset , parsed_values ) \u00a4 Parse an attribute value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def _read_attribute ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an attribute value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index annotation = None # Annotation precedence: # - \"vartype\" directive type # - none parsed_attribute_type = parsed_values . attribute_types . get ( name ) if parsed_attribute_type is not None : annotation = parsed_attribute_type if name in parsed_values . attributes : _warn ( docstring , 0 , f \"Duplicate attribute entry for ' { name } '\" ) else : parsed_values . attributes [ name ] = DocstringAttribute ( name = name , annotation = annotation , description = parsed_directive . value , ) return parsed_directive . next_index _read_attribute_type ( docstring , offset , parsed_values ) \u00a4 Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def _read_attribute_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index attribute_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : attribute_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get attribute name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . attribute_types [ attribute_name ] = attribute_type attribute = parsed_values . attributes . get ( attribute_name ) if attribute is not None : if attribute . annotation is None : attribute . annotation = attribute_type else : _warn ( docstring , 0 , f \"Duplicate attribute information for ' { attribute_name } '\" ) return parsed_directive . next_index _read_exception ( docstring , offset , parsed_values ) \u00a4 Parse an exception value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 A tuple containing a DocstringSection (or None ) and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def _read_exception ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an exception value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: A tuple containing a `DocstringSection` (or `None`) and the index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : ex_type = parsed_directive . directive_parts [ 1 ] parsed_values . exceptions . append ( DocstringRaise ( annotation = ex_type , description = parsed_directive . value )) else : _warn ( docstring , 0 , f \"Failed to parse exception directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index _read_parameter ( docstring , offset , parsed_values ) \u00a4 Parse a parameter value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def _read_parameter ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index directive_type = None if len ( parsed_directive . directive_parts ) == 2 : # no type info name = parsed_directive . directive_parts [ 1 ] elif len ( parsed_directive . directive_parts ) == 3 : directive_type = parsed_directive . directive_parts [ 1 ] name = parsed_directive . directive_parts [ 2 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index if name in parsed_values . parameters : _warn ( docstring , 0 , f \"Duplicate parameter entry for ' { name } '\" ) return parsed_directive . next_index annotation = _determine_param_annotation ( docstring , name , directive_type , parsed_values ) default = _determine_param_default ( docstring , name ) parsed_values . parameters [ name ] = DocstringParameter ( name = name , annotation = annotation , description = parsed_directive . value , value = default , ) return parsed_directive . next_index _read_parameter_type ( docstring , offset , parsed_values ) \u00a4 Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def _read_parameter_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index param_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : param_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get parameter name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . param_types [ param_name ] = param_type param = parsed_values . parameters . get ( param_name ) if param is not None : if param . annotation is None : param . annotation = param_type else : _warn ( docstring , 0 , f \"Duplicate parameter information for ' { param_name } '\" ) return parsed_directive . next_index _read_return ( docstring , offset , parsed_values ) \u00a4 Parse an return value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def _read_return ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index # Annotation precedence: # - \"rtype\" directive type # - signature annotation # - None annotation : str | Name | Expression | None if parsed_values . return_type is not None : annotation = parsed_values . return_type else : try : annotation = docstring . parent . returns # type: ignore[union-attr] except AttributeError : _warn ( docstring , 0 , f \"No return type or annotation at ' { parsed_directive . line } '\" ) annotation = None # TODO: maybe support names parsed_values . return_value = DocstringReturn ( name = \"\" , annotation = annotation , description = parsed_directive . value ) return parsed_directive . next_index _read_return_type ( docstring , offset , parsed_values ) \u00a4 Parse an return type value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 def _read_return_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return type value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index return_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) parsed_values . return_type = return_type return_value = parsed_values . return_value if return_value is not None : return_value . annotation = return_type return parsed_directive . next_index _strip_blank_lines ( lines ) \u00a4 Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines ( list [ str ] ) \u2013 Lines to be stripped. Returns: list [ str ] \u2013 A list with the same contents, with any blank lines at the start or end removed. Source code in griffe/docstrings/rst.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def _strip_blank_lines ( lines : list [ str ]) -> list [ str ]: \"\"\"Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines: Lines to be stripped. Returns: A list with the same contents, with any blank lines at the start or end removed. \"\"\" if not lines : return lines # remove blank lines from the start and end content_found = False initial_content = 0 final_content = 0 for index , line in enumerate ( lines ): if line == \"\" or line . isspace (): if not content_found : initial_content += 1 else : content_found = True final_content = index return lines [ initial_content : final_content + 1 ] parse ( docstring , ** options ) \u00a4 Parse an RST-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/rst.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse an RST-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore[misc,operator] break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"rst"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.FieldType","text":"Maps directive names to parser functions. Source code in griffe/docstrings/rst.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @dataclass ( frozen = True ) class FieldType : \"\"\"Maps directive names to parser functions.\"\"\" names : FrozenSet [ str ] reader : Callable [[ Docstring , int , ParsedValues ], int ] def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names )","title":"FieldType"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.FieldType.matches","text":"Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/rst.py 46 47 48 49 50 51 52 53 54 55 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names )","title":"matches()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedDirective","text":"Directive information that has been parsed from a docstring. Source code in griffe/docstrings/rst.py 58 59 60 61 62 63 64 65 66 @dataclass class ParsedDirective : \"\"\"Directive information that has been parsed from a docstring.\"\"\" line : str next_index : int directive_parts : list [ str ] value : str invalid : bool = False","title":"ParsedDirective"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues","text":"Values parsed from the docstring to be used to produce sections. Source code in griffe/docstrings/rst.py 69 70 71 72 73 74 75 76 77 78 79 80 @dataclass class ParsedValues : \"\"\"Values parsed from the docstring to be used to produce sections.\"\"\" description : list [ str ] = field ( default_factory = list ) parameters : dict [ str , DocstringParameter ] = field ( default_factory = dict ) param_types : dict [ str , str ] = field ( default_factory = dict ) attributes : dict [ str , DocstringAttribute ] = field ( default_factory = dict ) attribute_types : dict [ str , str ] = field ( default_factory = dict ) exceptions : list [ DocstringRaise ] = field ( default_factory = list ) return_value : DocstringReturn | None = None return_type : str | None = None","title":"ParsedValues"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._consolidate_continuation_lines","text":"Convert a docstring field into a single line if a line continuation exists. Parameters: lines ( list [ str ] ) \u2013 The docstring lines. offset ( int ) \u2013 The line number to start at. Returns: tuple [ str , int ] \u2013 A tuple containing the continued lines as a single string and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def _consolidate_continuation_lines ( lines : list [ str ], offset : int ) -> tuple [ str , int ]: \"\"\" Convert a docstring field into a single line if a line continuation exists. Parameters: lines: The docstring lines. offset: The line number to start at. Returns: A tuple containing the continued lines as a single string and the index at which to continue parsing. \"\"\" curr_line_index = offset block = [ lines [ curr_line_index ] . lstrip ()] # start processing after first item curr_line_index += 1 while curr_line_index < len ( lines ) and not lines [ curr_line_index ] . startswith ( \":\" ): block . append ( lines [ curr_line_index ] . lstrip ()) curr_line_index += 1 return \" \" . join ( block ) . rstrip ( \" \\n \" ), curr_line_index - 1","title":"_consolidate_continuation_lines()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._consolidate_descriptive_type","text":"Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type ( str ) \u2013 Descriptions of an item's type. Returns: str \u2013 Type signature for descriptive type. Source code in griffe/docstrings/rst.py 433 434 435 436 437 438 439 440 441 442 443 444 def _consolidate_descriptive_type ( descriptive_type : str ) -> str : \"\"\"Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type: Descriptions of an item's type. Returns: Type signature for descriptive type. \"\"\" return descriptive_type . replace ( \" or \" , \" | \" )","title":"_consolidate_descriptive_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_attribute","text":"Parse an attribute value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def _read_attribute ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an attribute value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index annotation = None # Annotation precedence: # - \"vartype\" directive type # - none parsed_attribute_type = parsed_values . attribute_types . get ( name ) if parsed_attribute_type is not None : annotation = parsed_attribute_type if name in parsed_values . attributes : _warn ( docstring , 0 , f \"Duplicate attribute entry for ' { name } '\" ) else : parsed_values . attributes [ name ] = DocstringAttribute ( name = name , annotation = annotation , description = parsed_directive . value , ) return parsed_directive . next_index","title":"_read_attribute()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_attribute_type","text":"Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def _read_attribute_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index attribute_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : attribute_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get attribute name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . attribute_types [ attribute_name ] = attribute_type attribute = parsed_values . attributes . get ( attribute_name ) if attribute is not None : if attribute . annotation is None : attribute . annotation = attribute_type else : _warn ( docstring , 0 , f \"Duplicate attribute information for ' { attribute_name } '\" ) return parsed_directive . next_index","title":"_read_attribute_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_exception","text":"Parse an exception value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 A tuple containing a DocstringSection (or None ) and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def _read_exception ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an exception value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: A tuple containing a `DocstringSection` (or `None`) and the index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : ex_type = parsed_directive . directive_parts [ 1 ] parsed_values . exceptions . append ( DocstringRaise ( annotation = ex_type , description = parsed_directive . value )) else : _warn ( docstring , 0 , f \"Failed to parse exception directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index","title":"_read_exception()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_parameter","text":"Parse a parameter value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def _read_parameter ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index directive_type = None if len ( parsed_directive . directive_parts ) == 2 : # no type info name = parsed_directive . directive_parts [ 1 ] elif len ( parsed_directive . directive_parts ) == 3 : directive_type = parsed_directive . directive_parts [ 1 ] name = parsed_directive . directive_parts [ 2 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index if name in parsed_values . parameters : _warn ( docstring , 0 , f \"Duplicate parameter entry for ' { name } '\" ) return parsed_directive . next_index annotation = _determine_param_annotation ( docstring , name , directive_type , parsed_values ) default = _determine_param_default ( docstring , name ) parsed_values . parameters [ name ] = DocstringParameter ( name = name , annotation = annotation , description = parsed_directive . value , value = default , ) return parsed_directive . next_index","title":"_read_parameter()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_parameter_type","text":"Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def _read_parameter_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index param_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : param_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get parameter name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . param_types [ param_name ] = param_type param = parsed_values . parameters . get ( param_name ) if param is not None : if param . annotation is None : param . annotation = param_type else : _warn ( docstring , 0 , f \"Duplicate parameter information for ' { param_name } '\" ) return parsed_directive . next_index","title":"_read_parameter_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_return","text":"Parse an return value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def _read_return ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index # Annotation precedence: # - \"rtype\" directive type # - signature annotation # - None annotation : str | Name | Expression | None if parsed_values . return_type is not None : annotation = parsed_values . return_type else : try : annotation = docstring . parent . returns # type: ignore[union-attr] except AttributeError : _warn ( docstring , 0 , f \"No return type or annotation at ' { parsed_directive . line } '\" ) annotation = None # TODO: maybe support names parsed_values . return_value = DocstringReturn ( name = \"\" , annotation = annotation , description = parsed_directive . value ) return parsed_directive . next_index","title":"_read_return()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_return_type","text":"Parse an return type value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 def _read_return_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return type value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index return_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) parsed_values . return_type = return_type return_value = parsed_values . return_value if return_value is not None : return_value . annotation = return_type return parsed_directive . next_index","title":"_read_return_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._strip_blank_lines","text":"Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines ( list [ str ] ) \u2013 Lines to be stripped. Returns: list [ str ] \u2013 A list with the same contents, with any blank lines at the start or end removed. Source code in griffe/docstrings/rst.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def _strip_blank_lines ( lines : list [ str ]) -> list [ str ]: \"\"\"Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines: Lines to be stripped. Returns: A list with the same contents, with any blank lines at the start or end removed. \"\"\" if not lines : return lines # remove blank lines from the start and end content_found = False initial_content = 0 final_content = 0 for index , line in enumerate ( lines ): if line == \"\" or line . isspace (): if not content_found : initial_content += 1 else : content_found = True final_content = index return lines [ initial_content : final_content + 1 ]","title":"_strip_blank_lines()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.parse","text":"Parse an RST-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/rst.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse an RST-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore[misc,operator] break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"parse()"},{"location":"reference/griffe/docstrings/utils/","text":"This module contains utilities for docstrings parsers. warning ( name ) \u00a4 Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore[union-attr] except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { ( docstring . lineno or 0 ) + offset } : { message } \" ) return warn","title":"utils"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.warning","text":"Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore[union-attr] except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { ( docstring . lineno or 0 ) + offset } : { message } \" ) return warn","title":"warning()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}