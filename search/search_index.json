{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Griffe \u00a4 [![ci](https://github.com/mkdocstrings/griffe/workflows/ci/badge.svg)](https://github.com/mkdocstrings/griffe/actions?query=workflow%3Aci) [![documentation](https://img.shields.io/badge/docs-mkdocs%20material-blue.svg?style=flat)](https://mkdocstrings.github.io/griffe/) [![pypi version](https://img.shields.io/pypi/v/griffe.svg)](https://pypi.org/project/griffe/) [![gitpod](https://img.shields.io/badge/gitpod-workspace-blue.svg?style=flat)](https://gitpod.io/#https://github.com/mkdocstrings/griffe) [![gitter](https://badges.gitter.im/join%20chat.svg)](https://gitter.im/mkdocstrings/griffe) Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Griffe, pronounced \"grif\" ( /\u0261\u0281if/ ), is a french word that means \"claw\", but also \"signature\" in a familiar way. \"On reconna\u00eet bien l\u00e0 sa griffe.\" Installation \u00a4 With pip : pip install griffe With pipx : python3.7 -m pip install --user pipx pipx install griffe Usage \u00a4 On the command line , pass the names of packages to the griffe dump command: $ griffe dump httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Dumping data section for more examples. Or pass a relative path to the griffe check command: $ griffe check mypackage --verbose mypackage/mymodule.py:10: MyClass.mymethod(myparam): Parameter kind was changed: Old: positional or keyword New: keyword-only For src layouts: $ griffe check --search src mypackage --verbose src/mypackage/mymodule.py:10: MyClass.mymethod(myparam): Parameter kind was changed: Old: positional or keyword New: keyword-only See the API breakage section for more examples. With Python , loading a package: import griffe fastapi = griffe . load ( \"fastapi\" ) Finding breaking changes: import griffe previous = griffe . load_git ( \"mypackage\" , ref = \"0.2.0\" ) current = griffe . load ( \"mypackage\" ) for breakage in griffe . find_breaking_changes ( previous , current ): ... See the Loading data section for more examples. Todo \u00a4 Visitor/Inspector: Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Extensions Post-processing extensions Third-party libraries we could provide support for: Django support Marshmallow support Pydantic support Docstrings parsers epydoc New Markdown-based format? For graceful degradation Serializer: Flat JSON JSON schema API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed, added or changed base that changes MRO","title":"Overview"},{"location":"#griffe","text":"[![ci](https://github.com/mkdocstrings/griffe/workflows/ci/badge.svg)](https://github.com/mkdocstrings/griffe/actions?query=workflow%3Aci) [![documentation](https://img.shields.io/badge/docs-mkdocs%20material-blue.svg?style=flat)](https://mkdocstrings.github.io/griffe/) [![pypi version](https://img.shields.io/pypi/v/griffe.svg)](https://pypi.org/project/griffe/) [![gitpod](https://img.shields.io/badge/gitpod-workspace-blue.svg?style=flat)](https://gitpod.io/#https://github.com/mkdocstrings/griffe) [![gitter](https://badges.gitter.im/join%20chat.svg)](https://gitter.im/mkdocstrings/griffe) Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Griffe, pronounced \"grif\" ( /\u0261\u0281if/ ), is a french word that means \"claw\", but also \"signature\" in a familiar way. \"On reconna\u00eet bien l\u00e0 sa griffe.\"","title":"Griffe"},{"location":"#installation","text":"With pip : pip install griffe With pipx : python3.7 -m pip install --user pipx pipx install griffe","title":"Installation"},{"location":"#usage","text":"On the command line , pass the names of packages to the griffe dump command: $ griffe dump httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Dumping data section for more examples. Or pass a relative path to the griffe check command: $ griffe check mypackage --verbose mypackage/mymodule.py:10: MyClass.mymethod(myparam): Parameter kind was changed: Old: positional or keyword New: keyword-only For src layouts: $ griffe check --search src mypackage --verbose src/mypackage/mymodule.py:10: MyClass.mymethod(myparam): Parameter kind was changed: Old: positional or keyword New: keyword-only See the API breakage section for more examples. With Python , loading a package: import griffe fastapi = griffe . load ( \"fastapi\" ) Finding breaking changes: import griffe previous = griffe . load_git ( \"mypackage\" , ref = \"0.2.0\" ) current = griffe . load ( \"mypackage\" ) for breakage in griffe . find_breaking_changes ( previous , current ): ... See the Loading data section for more examples.","title":"Usage"},{"location":"#todo","text":"Visitor/Inspector: Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Extensions Post-processing extensions Third-party libraries we could provide support for: Django support Marshmallow support Pydantic support Docstrings parsers epydoc New Markdown-based format? For graceful degradation Serializer: Flat JSON JSON schema API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed, added or changed base that changes MRO","title":"Todo"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.24.1 - 2022-11-18 \u00a4 Compare with 0.24.0 Bug Fixes \u00a4 Support nested namespace packages ( d571f8f by Timoth\u00e9e Mazzucotelli). 0.24.0 - 2022-11-13 \u00a4 Compare with 0.23.0 The \"Breaking Changes\" and \"Deprecations\" sections are proudly written with the help of our new API breakage detection feature ! Many thanks to Talley Lambert ( @tlambert03 ) for the initial code allowing to compare two Griffe trees. Breaking changes \u00a4 All parameters of the load_git function, except module , are now keyword-only. Parameter try_relative_path of the load_git function was removed. Parameter commit was renamed ref in the load_git function. Parameter commit was renamed ref in the tmp_worktree helper, which will probably become private later. Parameters ref and repo switched positions in the tmp_worktree helper. All parameters of the resolve_aliases method are now keyword-only. Parameters only_exported and only_known_modules of the resolve_module_aliases method were removed. This method is most probably not used by anyone, and will probably be made private in the future. Deprecations \u00a4 Parameters only_exported and only_known_modules of the resolve_aliases method are deprecated in favor of their inverted counter-part implicit and external parameters. Example before: loader.resolve_aliases(only_exported=True, only_known_modules=True) Example after: loader.resolve_aliases(implicit=False, external=False) Features \u00a4 Add CLI command to check for API breakages ( 90bded4 by Timoth\u00e9e Mazzucotelli). Issue #75 , PR #105 Add function to find API breaking changes ( a4f1280 by Talley Lambert and Timoth\u00e9e Mazzucotelli). Issue #75 , PR #105 Bug Fixes \u00a4 Fix labels mismatch staticmethod-classmethod in inspector ( 25060f6 by Timoth\u00e9e Mazzucotelli). Issue #111 Prevent infinite loop while looking for package's parent folder ( f297f1a by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#72 Fix comparing names and expressions ( 07bffff by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Rename some parameters in Git module ( 9ad7a2c by Timoth\u00e9e Mazzucotelli). Set parameters as keyword-only ( 44c01be by Timoth\u00e9e Mazzucotelli). Remove stars from parameters names ( 91dce14 by Timoth\u00e9e Mazzucotelli). Refactor CLI to use subcommands ( 760b091 by Timoth\u00e9e Mazzucotelli). PR #110 Rename parameters used when resolving aliases ( 3d3a4eb by Timoth\u00e9e Mazzucotelli). 0.23.0 - 2022-10-26 \u00a4 Compare with 0.22.2 Features \u00a4 Support typing_extensions.overload ( c29fad5 by Nyuan Zhang). PR #108 Bug Fixes \u00a4 Log debug instead of errors when failing to parse NumPy annotations for additional sections ( 568ff60 by Sigurd Spieckermann). Issue #93 , PR #109 Don't strip too many parentheses around a call node ( bb5c5e7 by Timoth\u00e9e Mazzucotelli). PR #107 Guard against more alias resolution errors ( 2be135d by Timoth\u00e9e Mazzucotelli). Issue #83 , PR #103 0.22.2 - 2022-09-24 \u00a4 Compare with 0.22.1 Bug Fixes \u00a4 Log debug instead of errors when failing to parse Numpy annotations ( 75eeeda by Timoth\u00e9e Mazzucotelli). Issue #93 Don't crash on unsupported module names (containing dots) ( 6a57194 by Timoth\u00e9e Mazzucotelli). Issue #94 Show correct docstring line numbers on Python 3.7 ( edd4b6d by Timoth\u00e9e Mazzucotelli). Issue #98 Fix parsing of Numpy docstring with an Examples section at the end ( 3114727 by Timoth\u00e9e Mazzucotelli). Issue #97 Don't crash on unsupported item in __all__ (log a warning instead) ( 9e5df0a by Timoth\u00e9e Mazzucotelli). Issue #92 Prevent infinite recursion while expanding exports ( 68446f7 by Timoth\u00e9e Mazzucotelli). Add missing check while expanding wildcards ( 7e816ed by Timoth\u00e9e Mazzucotelli). 0.22.1 - 2022-09-10 \u00a4 Compare with 0.22.0 Bug Fixes \u00a4 Always use encoding=\"utf8\" when reading text files ( 3b279bf by Rudolf Byker). Issue #99 , PR #100 0.22.0 - 2022-06-28 \u00a4 Compare with 0.21.0 Features \u00a4 Support forward references ( 245daea by Timoth\u00e9e Mazzucotelli). Issue #86 Code Refactoring \u00a4 Safely parse annotations and values ( b023e2b by Timoth\u00e9e Mazzucotelli). 0.21.0 - 2022-06-25 \u00a4 Compare with 0.20.0 Features \u00a4 Add load_git function allowing to load data from a specific git ref ( b2c3946 by Talley Lambert). Issue #75 , PR #76 Bug Fixes \u00a4 Fix detecting and merging stubs for single-file packages ( 6a82542 by Talley Lambert). Issue #77 , PR #78 Fix parsing ExtSlice nodes when getting values ( b2fe968 by Timoth\u00e9e Mazzucotelli). Issue #87 Don't trigger alias resolution when merging stubs ( 2b88627 by Timoth\u00e9e Mazzucotelli). Issue #89 Fix handling of .pth files ( f212dd3 by Gabriel Dugny). Issue #84 , PR #85 0.20.0 - 2022-06-03 \u00a4 Compare with 0.19.3 Features \u00a4 Add as_json and from_json convenience methods on objects ( 5c3d751 by Talley Lambert). PR #74 Bug Fixes \u00a4 Fix unparsing of f-strings ( 9ca74bd by Timoth\u00e9e Mazzucotelli). Issue #80 Don't crash when overwriting a submodule with a wildcard imported attribute ( bfad1cc by Timoth\u00e9e Mazzucotelli). Issue #72 , #79 , mkdocstrings/mkdocstrings#438 0.19.3 - 2022-05-26 \u00a4 Compare with 0.19.2 Bug Fixes \u00a4 Support USub and UAdd nodes in annotations ( 1169c51 by Timoth\u00e9e Mazzucotelli). Issue #71 0.19.2 - 2022-05-18 \u00a4 Compare with 0.19.1 Bug Fixes \u00a4 Don't crash on single line docstrings with trailing whitespace (Google) ( 8d9ccd5 by Timoth\u00e9e Mazzucotelli). 0.19.1 - 2022-05-07 \u00a4 Compare with 0.19.0 Bug Fixes \u00a4 Don't crash on nested functions in __init__ methods ( cd5af43 by Timoth\u00e9e Mazzucotelli). Issue #68 0.19.0 - 2022-05-06 \u00a4 Compare with 0.18.0 Features \u00a4 Add load shortcut function for convenience ( f38a42d by Timoth\u00e9e Mazzucotelli). Support loading (and merging) *.pyi files ( 41518f4 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#404 Improve support for call nodes in annotations ( 45e5bf5 by Timoth\u00e9e Mazzucotelli). Issue #66 Support dataclass decorators on classes ( f579431 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Handle absence of values ( 190585d by Timoth\u00e9e Mazzucotelli). Simplify decorators to labels function ( 04e768f by Timoth\u00e9e Mazzucotelli). Always sort labels when serializing ( bd2504b by Timoth\u00e9e Mazzucotelli). 0.18.0 - 2022-04-19 \u00a4 Compare with 0.17.0 Features \u00a4 Add CLI option to disallow inspection ( 8f71a07 by Timoth\u00e9e Mazzucotelli). Support complex __all__ assignments ( 9a2128b by Timoth\u00e9e Mazzucotelli). Issue #40 Inherit class parameters from __init__ method ( e195593 by Fran\u00e7ois Rozet). Issue mkdocstrings/python#19 , PR #65 . It allows to write \"Parameters\" sections in the docstring of the class itself. Performance Improvements \u00a4 Avoid using __len__ as boolean method ( d465493 by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Don't crash on unhandle __all__ assignments ( cbc103c by Timoth\u00e9e Mazzucotelli). Handle empty packages names in CLI ( 52b51c4 by Timoth\u00e9e Mazzucotelli). Don't crash on Google parameters sections found in non-function docstrings ( 4a417bc by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#19 Code Refactoring \u00a4 Improve \"unknown parameter\" messages ( 7191799 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#423 Set property label on @cached_property -decoratored methods ( bc068f8 by Timoth\u00e9e Mazzucotelli). 0.17.0 - 2022-04-15 \u00a4 Compare with 0.16.0 Features \u00a4 Handle properties setters and deleters ( 50a4490 by Timoth\u00e9e Mazzucotelli). Handle typing.overload decorator ( 927bbd9 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#308 Set labels on functions using decorators ( 1c1feb2 by Timoth\u00e9e Mazzucotelli). Issue #47 Add runtime attribute to objects/aliases and handle type guarded objects ( 2f2a04e by Timoth\u00e9e Mazzucotelli). Issue #42 Support pkg-style namespace packages ( efba0c6 by Timoth\u00e9e Mazzucotelli). Issue #58 Code Refactoring \u00a4 Remove useless attribute ( c4a92b7 by Timoth\u00e9e Mazzucotelli). Improve Google warnings ( 641089a by Timoth\u00e9e Mazzucotelli). Remove useless import nodes generic visits ( f83fc8e by Timoth\u00e9e Mazzucotelli). 0.16.0 - 2022-04-09 \u00a4 Compare with 0.15.1 Features \u00a4 Warn about unknown parameters in Numpy docstrings ( 23f63f2 by Timoth\u00e9e Mazzucotelli). Warn about unknown parameters in Google docstrings ( 72be993 by Kevin Musgrave). Issue mkdocstrings/mkdocstrings#408 , PR #63 Bug Fixes \u00a4 Don't crash on unhandled AST nodes while parsing text annotations ( f3be3a6 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#416 0.15.1 - 2022-04-08 \u00a4 Compare with 0.15.0 Bug Fixes \u00a4 Don't overwrite existing (lower) members when expanding wildcards ( 9ff86e3 by Timoth\u00e9e Mazzucotelli). Don't insert admonition before current section (Google parser) ( 8d8a46f by Timoth\u00e9e Mazzucotelli). Handle aliases chains in has_docstrings method ( 77c6943 by Timoth\u00e9e Mazzucotelli). Actually check for docstrings recursively ( 15f4193 by Timoth\u00e9e Mazzucotelli). 0.15.0 - 2022-04-03 \u00a4 Compare with 0.14.1 Features \u00a4 Support ignore_init_summary in Numpy parser ( f8cd147 by Timoth\u00e9e Mazzucotelli). Issue #44 Enable cross-references for Numpy docstrings annotations ( e32a73c by Timoth\u00e9e Mazzucotelli). Issues #11 , #12 , #13 , #14 , #15 , #16 , #17 , #18 Retrieve annotations from parent in Numpy parser ( 8d4eae3 by Timoth\u00e9e Mazzucotelli). Issues #29 , #30 , #31 , #32 Parse annotations in Iterator/Generator for Google docstrings ( f0129ef by Timoth\u00e9e Mazzucotelli). Issue #28 Bug Fixes \u00a4 Fix missing \"receives\" entry in Google parser ( 35d63fb by Timoth\u00e9e Mazzucotelli). Fix serialization of Windows paths ( b7e8da8 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Be less strict on spacing around \":\" in Numpy docstrings ( aa592b5 by Timoth\u00e9e Mazzucotelli). Be less strict in Numpy regular expressions ( 603dc0e by Timoth\u00e9e Mazzucotelli). Rename variables in Numpy module ( 4407244 by Timoth\u00e9e Mazzucotelli). 0.14.1 - 2022-04-01 \u00a4 Compare with 0.14.0 Bug Fixes \u00a4 Retrieve default value for non-string parameters ( 15952ed by ThomasPJ). Issue #59 , issue mkdocstrings/python#8 , PR #60 Prevent infinite recursion while expanding wildcards ( 428628f by Timoth\u00e9e Mazzucotelli). Issue #57 0.14.0 - 2022-03-06 \u00a4 Compare with 0.13.2 Features \u00a4 Ignore __doc__ from parent classes ( 10aa59e by Will Da Silva). Issue #55 , PR #56 0.13.2 - 2022-03-01 \u00a4 Compare with 0.13.1 Bug Fixes \u00a4 Fix type regex in Numpy parser ( 3a10fda by Timoth\u00e9e Mazzucotelli). Current module must not be available in its members' scope ( 54f9688 by Timoth\u00e9e Mazzucotelli). Allow named sections after numpydoc examples ( a44d9c6 by Lucina). PR #54 0.13.1 - 2022-02-24 \u00a4 Compare with 0.13.0 Bug Fixes \u00a4 Don't cut through wildcard-expanded aliases chains ( 65dafa4 by Timoth\u00e9e Mazzucotelli). Fix docstrings warnings when there's no parent module ( e080549 by Timoth\u00e9e Mazzucotelli). Issue #51 Code Refactoring \u00a4 Use proper classes for docstrings sections ( 46eddac by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#3 , PR #52 0.13.0 - 2022-02-23 \u00a4 Compare with 0.12.6 Features \u00a4 Implement trim_doctest_flags for Google and Numpy ( 8057153 by Jeremy Goh). Issue mkdocstrings/mkdocstrings#386 , PR #48 Bug Fixes \u00a4 Rename keyword parameters to keyword arguments ( ce3eb6b by Jeremy Goh). 0.12.6 - 2022-02-18 \u00a4 Compare with 0.12.5 Bug Fixes \u00a4 Support starred parameters in Numpy docstrings ( 27f0fc2 by Timoth\u00e9e Mazzucotelli). Issue #43 0.12.5 - 2022-02-17 \u00a4 Compare with 0.12.4 Bug Fixes \u00a4 Fix getting line numbers on aliases ( 351750e by Timoth\u00e9e Mazzucotelli). 0.12.4 - 2022-02-16 \u00a4 Compare with 0.12.3 Bug Fixes \u00a4 Update target path when changing alias target ( 5eda646 by Timoth\u00e9e Mazzucotelli). Fix relative imports to absolute with wildcards ( 69500dd by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 Fix accessing members using tuples ( 87ff1df by Timoth\u00e9e Mazzucotelli). Fix recursive wildcard expansion ( 60e6edf by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 Only export submodules if they were imported ( 98c72db by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 0.12.3 - 2022-02-15 \u00a4 Compare with 0.12.2 Bug Fixes \u00a4 Always decode source as UTF8 ( 563469b by Timoth\u00e9e Mazzucotelli). Fix JSON encoder and decoder ( 3e768d6 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Improve error handling ( 7b15a51 by Timoth\u00e9e Mazzucotelli). 0.12.2 - 2022-02-13 \u00a4 Compare with 0.12.1 Bug Fixes \u00a4 Fix JSON unable to serialize docstring kind values ( 91e6719 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Make attribute labels more explicit ( 19eac2e by Timoth\u00e9e Mazzucotelli). 0.12.1 - 2022-02-12 \u00a4 Compare with 0.11.7 Features \u00a4 Add ignore_init_summary option to the Google parser ( 81f0333 by Timoth\u00e9e Mazzucotelli). Add is_KIND properties on objects ( 17a08cd by Timoth\u00e9e Mazzucotelli). 0.11.7 - 2022-02-12 \u00a4 Compare with 0.11.6 Bug Fixes \u00a4 Keep only first assignment in conditions ( 0104440 by Timoth\u00e9e Mazzucotelli). Support invert unary op in annotations ( 734ef55 by Timoth\u00e9e Mazzucotelli). Fix handling of missing modules during dynamic imports ( 7a3b383 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#380 Fix getting lines of compiled modules ( 899461b by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Get annotation with the same property on functions ( ecc7bba by Timoth\u00e9e Mazzucotelli). 0.11.6 - 2022-02-10 \u00a4 Compare with 0.11.5 Bug Fixes \u00a4 Fix infinite loop in Google parser ( 8b7b97b by Timoth\u00e9e Mazzucotelli). Issue #38 0.11.5 - 2022-02-08 \u00a4 Compare with 0.11.4 Bug Fixes \u00a4 Fix building title and kind of Google admonitions ( 87ab56c by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings#379 0.11.4 - 2022-02-07 \u00a4 Compare with 0.11.3 Bug Fixes \u00a4 Don't trigger alias resolution while checking docstrings presence ( dda72ea by Timoth\u00e9e Mazzucotelli). Issue #37 0.11.3 - 2022-02-05 \u00a4 Compare with 0.11.2 Bug Fixes \u00a4 Fix getting params defaults on Python 3.7 ( 0afd867 by Timoth\u00e9e Mazzucotelli). 0.11.2 - 2022-02-03 \u00a4 Compare with 0.11.1 Code Refactoring \u00a4 Factorize docstring annotation parser ( 19609be by Timoth\u00e9e Mazzucotelli). 0.11.1 - 2022-02-01 \u00a4 Compare with 0.11.0 Code Refactoring \u00a4 Rename RST parser to Sphinx ( a612cb1 by Timoth\u00e9e Mazzucotelli). 0.11.0 - 2022-01-31 \u00a4 Compare with 0.10.0 Features \u00a4 Support matrix multiplication operator in visitor ( 6129e17 by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Fix name resolution for inspected data ( ed3e7e5 by Timoth\u00e9e Mazzucotelli). Make importer actually able to import any nested object ( d007219 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Always use search paths to import modules ( a9a378f by Timoth\u00e9e Mazzucotelli). Split out module finder ( 7290642 by Timoth\u00e9e Mazzucotelli). 0.10.0 - 2022-01-14 \u00a4 Compare with 0.9.0 Bug Fixes \u00a4 Fix infinite recursion errors in alias resolver ( 133b4e4 by Timoth\u00e9e Mazzucotelli). Fix inspection of nodes children (aliases or not) ( bb354f2 by Timoth\u00e9e Mazzucotelli). Fix relative to absolute import conversion ( 464c39e by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Rename some CLI options ( 1323268 by Timoth\u00e9e Mazzucotelli). Return the loader the to main function ( 9c6317e by Timoth\u00e9e Mazzucotelli). Improve logging messages ( b8eb16e by Timoth\u00e9e Mazzucotelli). Skip inspection of some debug packages ( 4ee8968 by Timoth\u00e9e Mazzucotelli). Return ... instead of Ellipsis ( f9ae31d by Timoth\u00e9e Mazzucotelli). Catch attribute errors when cross-referencing docstring annotations ( 288803a by Timoth\u00e9e Mazzucotelli). Support dict methods in lines collection ( 1b0cb94 by Timoth\u00e9e Mazzucotelli). Features \u00a4 Compute and show some stats ( 1b8d0a1 by Timoth\u00e9e Mazzucotelli). Add CLI options for alias resolution ( 87a59cb by Timoth\u00e9e Mazzucotelli). Support Google raises annotations cross-refs ( 8006ae1 by Timoth\u00e9e Mazzucotelli). 0.9.0 - 2022-01-04 \u00a4 Compare with 0.8.0 Features \u00a4 Loader option to only follow aliases in known modules ( 879d91b by Timoth\u00e9e Mazzucotelli). Use aliases when inspecting too ( 60439ee by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Handle more errors when loading modules ( 1aa571a by Timoth\u00e9e Mazzucotelli). Handle more errors when getting signature ( 2db85e7 by Timoth\u00e9e Mazzucotelli). Fix checking parent truthfulness ( 6129e50 by Timoth\u00e9e Mazzucotelli). Fix getting subscript value ( 1699f12 by Timoth\u00e9e Mazzucotelli). Support yield nodes ( 7d536d5 by Timoth\u00e9e Mazzucotelli). Exclude some special low-level members that cause cyclic issues ( b54ab34 by Timoth\u00e9e Mazzucotelli). Fix transforming elements of signatures to annotations ( e278c11 by Timoth\u00e9e Mazzucotelli). Detect cyclic aliases and prevent resolution errors ( de5dd12 by Timoth\u00e9e Mazzucotelli). Don't crash while trying to get the representation of an attribute value ( 77ac55d by Timoth\u00e9e Mazzucotelli). Fix building value for joined strings ( 6154b69 by Timoth\u00e9e Mazzucotelli). Fix prevention of cycles while building objects nodes ( 48062ac by Timoth\u00e9e Mazzucotelli). Better handle relative imports ( 91b42de by Timoth\u00e9e Mazzucotelli). Fix Google parser missing lines ending with colon ( 2f7969c by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Improve alias resolution robustness ( e708139 by Timoth\u00e9e Mazzucotelli). Remove async loader for now ( acc5ecf by Timoth\u00e9e Mazzucotelli). Improve handling of Google admonitions ( 8aa5ed0 by Timoth\u00e9e Mazzucotelli). Better handling of import errors and system exits while inspecting modules ( 7ba1589 by Timoth\u00e9e Mazzucotelli). Empty generic visit/inspect methods in base classes ( 338760e by Timoth\u00e9e Mazzucotelli). 0.8.0 - 2022-01-02 \u00a4 Compare with 0.7.1 Features \u00a4 Support getting attribute annotation from parent in RST docstring parser ( 25db61a by Timoth\u00e9e Mazzucotelli). Handle relative imports ( 62b0927 by Timoth\u00e9e Mazzucotelli). Support wildcard imports ( 77a3cb7 by Timoth\u00e9e Mazzucotelli). Support configuring log level (CLI/env var) ( 839d78e by Timoth\u00e9e Mazzucotelli). Support loading *.py[cod] and *.so modules ( cd98a6f by Timoth\u00e9e Mazzucotelli). Support inspecting builtin functions/methods ( aa1fce3 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Handle extensions errors ( 11278ca by Timoth\u00e9e Mazzucotelli). Don't always try to find a module as a relative path ( e6df277 by Timoth\u00e9e Mazzucotelli). Improve loggers patching ( f4b262a by Timoth\u00e9e Mazzucotelli). Improve dynamic imports ( 2998195 by Timoth\u00e9e Mazzucotelli). 0.7.1 - 2021-12-28 \u00a4 Compare with 0.7.0 Code Refactoring \u00a4 Only log warning if async mode is used ( 356e848 by Timoth\u00e9e Mazzucotelli). 0.7.0 - 2021-12-28 \u00a4 Compare with 0.6.0 Features \u00a4 Support more nodes on Python 3.7 ( 7f2c4ec by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Don't crash on syntax errors and log an error ( 10bb6b1 by Timoth\u00e9e Mazzucotelli). 0.6.0 - 2021-12-27 \u00a4 Compare with 0.5.0 Features \u00a4 Support more AST nodes ( cd1b305 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Use annotation getter for base classes ( 8b1a7ed by Timoth\u00e9e Mazzucotelli). 0.5.0 - 2021-12-20 \u00a4 Compare with 0.4.0 Features \u00a4 Add support for Python 3.7 ( 4535adc by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Don't propagate aliases of an alias ( 8af48f8 by Timoth\u00e9e Mazzucotelli). Don't reassign members defined in except clauses ( d918b4e by Timoth\u00e9e Mazzucotelli). 0.4.0 - 2021-11-28 \u00a4 Compare with 0.3.0 Features \u00a4 Add a prototype 'hybrid' extension ( 8cb3c16 by Timoth\u00e9e Mazzucotelli). Allow passing extensions config as JSON on the CLI ( 9a7fa8b by Timoth\u00e9e Mazzucotelli). Support names for returns, yields and receives sections items ( 1c5a4c9 by Timoth\u00e9e Mazzucotelli). Store aliases on each object ( 91ba643 by Timoth\u00e9e Mazzucotelli). Support in[tro]spection ( 3a0587d by Timoth\u00e9e Mazzucotelli). Support multiple return, yield and receive items ( 0fc70cb by Timoth\u00e9e Mazzucotelli). Support namespace packages ( 2414c8e by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Fix extensions loader ( 78fb70b by Timoth\u00e9e Mazzucotelli). Avoid visiting/inspecting multiple times ( 75a8a8b by Timoth\u00e9e Mazzucotelli). Set modules collection attribute earlier ( 592c0bd by Timoth\u00e9e Mazzucotelli). Support inequality nodes ( b0ed247 by Timoth\u00e9e Mazzucotelli). Handle Div nodes for values ( 272e4d6 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Set log level to INFO ( 718e73e by Timoth\u00e9e Mazzucotelli). Add target setter ( 7f0064c by Timoth\u00e9e Mazzucotelli). Reorganize conditions ( 15ab876 by Timoth\u00e9e Mazzucotelli). Avoid recursion loops ( ea6acec by Timoth\u00e9e Mazzucotelli). Update aliases when replacing a member ( 99a0f8b by Timoth\u00e9e Mazzucotelli). Reorganize code ( 31fcdb1 by Timoth\u00e9e Mazzucotelli). Replace DocstringException with DocstringRaise ( d5ed87a by Timoth\u00e9e Mazzucotelli). Refactor loaders ( d9b94bb by Timoth\u00e9e Mazzucotelli). Improve typing ( e08bcfa by Timoth\u00e9e Mazzucotelli). 0.3.0 - 2021-11-21 \u00a4 Compare with 0.2.0 Features \u00a4 Handle aliases and their resolution ( 67ae903 by Timoth\u00e9e Mazzucotelli). Resolve annotations in docstrings ( 847384a by Timoth\u00e9e Mazzucotelli). Resolve annotations ( 6451eff by Timoth\u00e9e Mazzucotelli). Add lines property to objects ( 7daf7db by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each object ( 07a1d2e by Timoth\u00e9e Mazzucotelli). Get attributes annotations from parent ( 003b990 by Timoth\u00e9e Mazzucotelli). Draft extensions loader ( 17ccd03 by Timoth\u00e9e Mazzucotelli). Add properties to objects ( 0ec301a by Timoth\u00e9e Mazzucotelli). Handle .pth files when searching modules ( 2a2e182 by Timoth\u00e9e Mazzucotelli). Add default property to docstring parameters ( 6298ba3 by Timoth\u00e9e Mazzucotelli). Accept RST and Numpy parsers ( 1cf147d by Timoth\u00e9e Mazzucotelli). Support data (attributes/variables) ( dce84d1 by Timoth\u00e9e Mazzucotelli). Add Numpy-style parser ( ad5b72d by Timoth\u00e9e Mazzucotelli). Support more section kinds in Google-style ( 9d3d047 by Timoth\u00e9e Mazzucotelli). Add docstring section kinds ( b270483 by Timoth\u00e9e Mazzucotelli). Accept initial arguments when creating container ( 90c5956 by Timoth\u00e9e Mazzucotelli). Add an RST-style docstring parser ( 742e7b2 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Improve JSON encoder perfs ( 6a78eb0 by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Handle serialization of Posix paths ( 3a66b95 by Timoth\u00e9e Mazzucotelli). Fix list annotation getter ( 5ae800a by Timoth\u00e9e Mazzucotelli). Show accurate line number in Google warnings ( 2953590 by Timoth\u00e9e Mazzucotelli). Fix assignment names getters ( 6990846 by Timoth\u00e9e Mazzucotelli). Fix async loader (passing parent) ( 57e866e by Timoth\u00e9e Mazzucotelli). Fix exception name ( 4b8b85d by Timoth\u00e9e Mazzucotelli). Fix Google sections titles logic ( 87dd329 by Timoth\u00e9e Mazzucotelli). Prepend current module to base classes (still needs resolution) ( a4b1dee by Timoth\u00e9e Mazzucotelli). Fix Google admonition regex ( 3902e74 by Timoth\u00e9e Mazzucotelli). Fix docstring getter ( 1442eba by Timoth\u00e9e Mazzucotelli). Fix getting arguments defaults in the Google-style parser ( 67adbaf by Timoth\u00e9e Mazzucotelli). Fix getting arguments annotations in the Google-style parser ( 8bcbfba by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Export parsers and main function in docstrings module ( 96469da by Timoth\u00e9e Mazzucotelli). Remove top exports ( cd76694 by Timoth\u00e9e Mazzucotelli). Reorganize exceptions ( 7f9b805 by Timoth\u00e9e Mazzucotelli). Avoid circular import ( ef27dcd by Timoth\u00e9e Mazzucotelli). Rename index to [new] offset ( c07cc7d by Timoth\u00e9e Mazzucotelli). Reorganize code ( 5f4fff2 by Timoth\u00e9e Mazzucotelli). Use keyword only parameters ( d34edd6 by Timoth\u00e9e Mazzucotelli). Default to no parsing for serialization ( 8fecd9e by Timoth\u00e9e Mazzucotelli). Always extend AST ( c227ae6 by Timoth\u00e9e Mazzucotelli). Set default for kwargs parameters ( 7a0b85e by Timoth\u00e9e Mazzucotelli). Rename visitor method ( 3e0c43c by Timoth\u00e9e Mazzucotelli). Improve typing ( ac86f17 by Timoth\u00e9e Mazzucotelli). Fix typo ( a9ed6e9 by Timoth\u00e9e Mazzucotelli). Rewrite ParameterKind ( 90249df by Timoth\u00e9e Mazzucotelli). Add bool methods to docstrings and objects ( 548f72e by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each docstring ( 752e084 by Timoth\u00e9e Mazzucotelli). Skip attribute assignments ( e9cc2cd by Timoth\u00e9e Mazzucotelli). Improve visitor getters ( 2ea88c0 by Timoth\u00e9e Mazzucotelli). Use relative filepath in docstring warnings ( e894df7 by Timoth\u00e9e Mazzucotelli). Set submodules parent earlier ( 53767c0 by Timoth\u00e9e Mazzucotelli). Rename Data to Attribute ( febc12e by Timoth\u00e9e Mazzucotelli). Rename arguments to parameters ( 957856c by Timoth\u00e9e Mazzucotelli). Improve annotation support ( 5b2262f by Timoth\u00e9e Mazzucotelli). Always set parent ( cae85de by Timoth\u00e9e Mazzucotelli). Factorize function handling ( dfece1c by Timoth\u00e9e Mazzucotelli). Privatize stuff, fix loggers ( 5513ed5 by Timoth\u00e9e Mazzucotelli). Use keyword only arguments ( e853fe9 by Timoth\u00e9e Mazzucotelli). Set default values for Argument arguments ( d5cccaa by Timoth\u00e9e Mazzucotelli). Swallow extra parsing options ( 3d9ebe7 by Timoth\u00e9e Mazzucotelli). Rename start_index argument to offset ( dd88358 by Timoth\u00e9e Mazzucotelli). Reuse parsers warn function ( 03dfdd3 by Timoth\u00e9e Mazzucotelli). 0.2.0 - 2021-09-25 \u00a4 Compare with 0.1.0 Features \u00a4 Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli). 0.1.0 - 2021-09-09 \u00a4 Compare with first commit Features \u00a4 Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#0241-2022-11-18","text":"Compare with 0.24.0","title":"0.24.1 - 2022-11-18"},{"location":"changelog/#bug-fixes","text":"Support nested namespace packages ( d571f8f by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#0240-2022-11-13","text":"Compare with 0.23.0 The \"Breaking Changes\" and \"Deprecations\" sections are proudly written with the help of our new API breakage detection feature ! Many thanks to Talley Lambert ( @tlambert03 ) for the initial code allowing to compare two Griffe trees.","title":"0.24.0 - 2022-11-13"},{"location":"changelog/#breaking-changes","text":"All parameters of the load_git function, except module , are now keyword-only. Parameter try_relative_path of the load_git function was removed. Parameter commit was renamed ref in the load_git function. Parameter commit was renamed ref in the tmp_worktree helper, which will probably become private later. Parameters ref and repo switched positions in the tmp_worktree helper. All parameters of the resolve_aliases method are now keyword-only. Parameters only_exported and only_known_modules of the resolve_module_aliases method were removed. This method is most probably not used by anyone, and will probably be made private in the future.","title":"Breaking changes"},{"location":"changelog/#deprecations","text":"Parameters only_exported and only_known_modules of the resolve_aliases method are deprecated in favor of their inverted counter-part implicit and external parameters. Example before: loader.resolve_aliases(only_exported=True, only_known_modules=True) Example after: loader.resolve_aliases(implicit=False, external=False)","title":"Deprecations"},{"location":"changelog/#features","text":"Add CLI command to check for API breakages ( 90bded4 by Timoth\u00e9e Mazzucotelli). Issue #75 , PR #105 Add function to find API breaking changes ( a4f1280 by Talley Lambert and Timoth\u00e9e Mazzucotelli). Issue #75 , PR #105","title":"Features"},{"location":"changelog/#bug-fixes_1","text":"Fix labels mismatch staticmethod-classmethod in inspector ( 25060f6 by Timoth\u00e9e Mazzucotelli). Issue #111 Prevent infinite loop while looking for package's parent folder ( f297f1a by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#72 Fix comparing names and expressions ( 07bffff by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Rename some parameters in Git module ( 9ad7a2c by Timoth\u00e9e Mazzucotelli). Set parameters as keyword-only ( 44c01be by Timoth\u00e9e Mazzucotelli). Remove stars from parameters names ( 91dce14 by Timoth\u00e9e Mazzucotelli). Refactor CLI to use subcommands ( 760b091 by Timoth\u00e9e Mazzucotelli). PR #110 Rename parameters used when resolving aliases ( 3d3a4eb by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0230-2022-10-26","text":"Compare with 0.22.2","title":"0.23.0 - 2022-10-26"},{"location":"changelog/#features_1","text":"Support typing_extensions.overload ( c29fad5 by Nyuan Zhang). PR #108","title":"Features"},{"location":"changelog/#bug-fixes_2","text":"Log debug instead of errors when failing to parse NumPy annotations for additional sections ( 568ff60 by Sigurd Spieckermann). Issue #93 , PR #109 Don't strip too many parentheses around a call node ( bb5c5e7 by Timoth\u00e9e Mazzucotelli). PR #107 Guard against more alias resolution errors ( 2be135d by Timoth\u00e9e Mazzucotelli). Issue #83 , PR #103","title":"Bug Fixes"},{"location":"changelog/#0222-2022-09-24","text":"Compare with 0.22.1","title":"0.22.2 - 2022-09-24"},{"location":"changelog/#bug-fixes_3","text":"Log debug instead of errors when failing to parse Numpy annotations ( 75eeeda by Timoth\u00e9e Mazzucotelli). Issue #93 Don't crash on unsupported module names (containing dots) ( 6a57194 by Timoth\u00e9e Mazzucotelli). Issue #94 Show correct docstring line numbers on Python 3.7 ( edd4b6d by Timoth\u00e9e Mazzucotelli). Issue #98 Fix parsing of Numpy docstring with an Examples section at the end ( 3114727 by Timoth\u00e9e Mazzucotelli). Issue #97 Don't crash on unsupported item in __all__ (log a warning instead) ( 9e5df0a by Timoth\u00e9e Mazzucotelli). Issue #92 Prevent infinite recursion while expanding exports ( 68446f7 by Timoth\u00e9e Mazzucotelli). Add missing check while expanding wildcards ( 7e816ed by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#0221-2022-09-10","text":"Compare with 0.22.0","title":"0.22.1 - 2022-09-10"},{"location":"changelog/#bug-fixes_4","text":"Always use encoding=\"utf8\" when reading text files ( 3b279bf by Rudolf Byker). Issue #99 , PR #100","title":"Bug Fixes"},{"location":"changelog/#0220-2022-06-28","text":"Compare with 0.21.0","title":"0.22.0 - 2022-06-28"},{"location":"changelog/#features_2","text":"Support forward references ( 245daea by Timoth\u00e9e Mazzucotelli). Issue #86","title":"Features"},{"location":"changelog/#code-refactoring_1","text":"Safely parse annotations and values ( b023e2b by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0210-2022-06-25","text":"Compare with 0.20.0","title":"0.21.0 - 2022-06-25"},{"location":"changelog/#features_3","text":"Add load_git function allowing to load data from a specific git ref ( b2c3946 by Talley Lambert). Issue #75 , PR #76","title":"Features"},{"location":"changelog/#bug-fixes_5","text":"Fix detecting and merging stubs for single-file packages ( 6a82542 by Talley Lambert). Issue #77 , PR #78 Fix parsing ExtSlice nodes when getting values ( b2fe968 by Timoth\u00e9e Mazzucotelli). Issue #87 Don't trigger alias resolution when merging stubs ( 2b88627 by Timoth\u00e9e Mazzucotelli). Issue #89 Fix handling of .pth files ( f212dd3 by Gabriel Dugny). Issue #84 , PR #85","title":"Bug Fixes"},{"location":"changelog/#0200-2022-06-03","text":"Compare with 0.19.3","title":"0.20.0 - 2022-06-03"},{"location":"changelog/#features_4","text":"Add as_json and from_json convenience methods on objects ( 5c3d751 by Talley Lambert). PR #74","title":"Features"},{"location":"changelog/#bug-fixes_6","text":"Fix unparsing of f-strings ( 9ca74bd by Timoth\u00e9e Mazzucotelli). Issue #80 Don't crash when overwriting a submodule with a wildcard imported attribute ( bfad1cc by Timoth\u00e9e Mazzucotelli). Issue #72 , #79 , mkdocstrings/mkdocstrings#438","title":"Bug Fixes"},{"location":"changelog/#0193-2022-05-26","text":"Compare with 0.19.2","title":"0.19.3 - 2022-05-26"},{"location":"changelog/#bug-fixes_7","text":"Support USub and UAdd nodes in annotations ( 1169c51 by Timoth\u00e9e Mazzucotelli). Issue #71","title":"Bug Fixes"},{"location":"changelog/#0192-2022-05-18","text":"Compare with 0.19.1","title":"0.19.2 - 2022-05-18"},{"location":"changelog/#bug-fixes_8","text":"Don't crash on single line docstrings with trailing whitespace (Google) ( 8d9ccd5 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#0191-2022-05-07","text":"Compare with 0.19.0","title":"0.19.1 - 2022-05-07"},{"location":"changelog/#bug-fixes_9","text":"Don't crash on nested functions in __init__ methods ( cd5af43 by Timoth\u00e9e Mazzucotelli). Issue #68","title":"Bug Fixes"},{"location":"changelog/#0190-2022-05-06","text":"Compare with 0.18.0","title":"0.19.0 - 2022-05-06"},{"location":"changelog/#features_5","text":"Add load shortcut function for convenience ( f38a42d by Timoth\u00e9e Mazzucotelli). Support loading (and merging) *.pyi files ( 41518f4 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#404 Improve support for call nodes in annotations ( 45e5bf5 by Timoth\u00e9e Mazzucotelli). Issue #66 Support dataclass decorators on classes ( f579431 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_2","text":"Handle absence of values ( 190585d by Timoth\u00e9e Mazzucotelli). Simplify decorators to labels function ( 04e768f by Timoth\u00e9e Mazzucotelli). Always sort labels when serializing ( bd2504b by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0180-2022-04-19","text":"Compare with 0.17.0","title":"0.18.0 - 2022-04-19"},{"location":"changelog/#features_6","text":"Add CLI option to disallow inspection ( 8f71a07 by Timoth\u00e9e Mazzucotelli). Support complex __all__ assignments ( 9a2128b by Timoth\u00e9e Mazzucotelli). Issue #40 Inherit class parameters from __init__ method ( e195593 by Fran\u00e7ois Rozet). Issue mkdocstrings/python#19 , PR #65 . It allows to write \"Parameters\" sections in the docstring of the class itself.","title":"Features"},{"location":"changelog/#performance-improvements","text":"Avoid using __len__ as boolean method ( d465493 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#bug-fixes_10","text":"Don't crash on unhandle __all__ assignments ( cbc103c by Timoth\u00e9e Mazzucotelli). Handle empty packages names in CLI ( 52b51c4 by Timoth\u00e9e Mazzucotelli). Don't crash on Google parameters sections found in non-function docstrings ( 4a417bc by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#19","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_3","text":"Improve \"unknown parameter\" messages ( 7191799 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#423 Set property label on @cached_property -decoratored methods ( bc068f8 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0170-2022-04-15","text":"Compare with 0.16.0","title":"0.17.0 - 2022-04-15"},{"location":"changelog/#features_7","text":"Handle properties setters and deleters ( 50a4490 by Timoth\u00e9e Mazzucotelli). Handle typing.overload decorator ( 927bbd9 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#308 Set labels on functions using decorators ( 1c1feb2 by Timoth\u00e9e Mazzucotelli). Issue #47 Add runtime attribute to objects/aliases and handle type guarded objects ( 2f2a04e by Timoth\u00e9e Mazzucotelli). Issue #42 Support pkg-style namespace packages ( efba0c6 by Timoth\u00e9e Mazzucotelli). Issue #58","title":"Features"},{"location":"changelog/#code-refactoring_4","text":"Remove useless attribute ( c4a92b7 by Timoth\u00e9e Mazzucotelli). Improve Google warnings ( 641089a by Timoth\u00e9e Mazzucotelli). Remove useless import nodes generic visits ( f83fc8e by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0160-2022-04-09","text":"Compare with 0.15.1","title":"0.16.0 - 2022-04-09"},{"location":"changelog/#features_8","text":"Warn about unknown parameters in Numpy docstrings ( 23f63f2 by Timoth\u00e9e Mazzucotelli). Warn about unknown parameters in Google docstrings ( 72be993 by Kevin Musgrave). Issue mkdocstrings/mkdocstrings#408 , PR #63","title":"Features"},{"location":"changelog/#bug-fixes_11","text":"Don't crash on unhandled AST nodes while parsing text annotations ( f3be3a6 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#416","title":"Bug Fixes"},{"location":"changelog/#0151-2022-04-08","text":"Compare with 0.15.0","title":"0.15.1 - 2022-04-08"},{"location":"changelog/#bug-fixes_12","text":"Don't overwrite existing (lower) members when expanding wildcards ( 9ff86e3 by Timoth\u00e9e Mazzucotelli). Don't insert admonition before current section (Google parser) ( 8d8a46f by Timoth\u00e9e Mazzucotelli). Handle aliases chains in has_docstrings method ( 77c6943 by Timoth\u00e9e Mazzucotelli). Actually check for docstrings recursively ( 15f4193 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#0150-2022-04-03","text":"Compare with 0.14.1","title":"0.15.0 - 2022-04-03"},{"location":"changelog/#features_9","text":"Support ignore_init_summary in Numpy parser ( f8cd147 by Timoth\u00e9e Mazzucotelli). Issue #44 Enable cross-references for Numpy docstrings annotations ( e32a73c by Timoth\u00e9e Mazzucotelli). Issues #11 , #12 , #13 , #14 , #15 , #16 , #17 , #18 Retrieve annotations from parent in Numpy parser ( 8d4eae3 by Timoth\u00e9e Mazzucotelli). Issues #29 , #30 , #31 , #32 Parse annotations in Iterator/Generator for Google docstrings ( f0129ef by Timoth\u00e9e Mazzucotelli). Issue #28","title":"Features"},{"location":"changelog/#bug-fixes_13","text":"Fix missing \"receives\" entry in Google parser ( 35d63fb by Timoth\u00e9e Mazzucotelli). Fix serialization of Windows paths ( b7e8da8 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_5","text":"Be less strict on spacing around \":\" in Numpy docstrings ( aa592b5 by Timoth\u00e9e Mazzucotelli). Be less strict in Numpy regular expressions ( 603dc0e by Timoth\u00e9e Mazzucotelli). Rename variables in Numpy module ( 4407244 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0141-2022-04-01","text":"Compare with 0.14.0","title":"0.14.1 - 2022-04-01"},{"location":"changelog/#bug-fixes_14","text":"Retrieve default value for non-string parameters ( 15952ed by ThomasPJ). Issue #59 , issue mkdocstrings/python#8 , PR #60 Prevent infinite recursion while expanding wildcards ( 428628f by Timoth\u00e9e Mazzucotelli). Issue #57","title":"Bug Fixes"},{"location":"changelog/#0140-2022-03-06","text":"Compare with 0.13.2","title":"0.14.0 - 2022-03-06"},{"location":"changelog/#features_10","text":"Ignore __doc__ from parent classes ( 10aa59e by Will Da Silva). Issue #55 , PR #56","title":"Features"},{"location":"changelog/#0132-2022-03-01","text":"Compare with 0.13.1","title":"0.13.2 - 2022-03-01"},{"location":"changelog/#bug-fixes_15","text":"Fix type regex in Numpy parser ( 3a10fda by Timoth\u00e9e Mazzucotelli). Current module must not be available in its members' scope ( 54f9688 by Timoth\u00e9e Mazzucotelli). Allow named sections after numpydoc examples ( a44d9c6 by Lucina). PR #54","title":"Bug Fixes"},{"location":"changelog/#0131-2022-02-24","text":"Compare with 0.13.0","title":"0.13.1 - 2022-02-24"},{"location":"changelog/#bug-fixes_16","text":"Don't cut through wildcard-expanded aliases chains ( 65dafa4 by Timoth\u00e9e Mazzucotelli). Fix docstrings warnings when there's no parent module ( e080549 by Timoth\u00e9e Mazzucotelli). Issue #51","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_6","text":"Use proper classes for docstrings sections ( 46eddac by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#3 , PR #52","title":"Code Refactoring"},{"location":"changelog/#0130-2022-02-23","text":"Compare with 0.12.6","title":"0.13.0 - 2022-02-23"},{"location":"changelog/#features_11","text":"Implement trim_doctest_flags for Google and Numpy ( 8057153 by Jeremy Goh). Issue mkdocstrings/mkdocstrings#386 , PR #48","title":"Features"},{"location":"changelog/#bug-fixes_17","text":"Rename keyword parameters to keyword arguments ( ce3eb6b by Jeremy Goh).","title":"Bug Fixes"},{"location":"changelog/#0126-2022-02-18","text":"Compare with 0.12.5","title":"0.12.6 - 2022-02-18"},{"location":"changelog/#bug-fixes_18","text":"Support starred parameters in Numpy docstrings ( 27f0fc2 by Timoth\u00e9e Mazzucotelli). Issue #43","title":"Bug Fixes"},{"location":"changelog/#0125-2022-02-17","text":"Compare with 0.12.4","title":"0.12.5 - 2022-02-17"},{"location":"changelog/#bug-fixes_19","text":"Fix getting line numbers on aliases ( 351750e by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#0124-2022-02-16","text":"Compare with 0.12.3","title":"0.12.4 - 2022-02-16"},{"location":"changelog/#bug-fixes_20","text":"Update target path when changing alias target ( 5eda646 by Timoth\u00e9e Mazzucotelli). Fix relative imports to absolute with wildcards ( 69500dd by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 Fix accessing members using tuples ( 87ff1df by Timoth\u00e9e Mazzucotelli). Fix recursive wildcard expansion ( 60e6edf by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 Only export submodules if they were imported ( 98c72db by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382","title":"Bug Fixes"},{"location":"changelog/#0123-2022-02-15","text":"Compare with 0.12.2","title":"0.12.3 - 2022-02-15"},{"location":"changelog/#bug-fixes_21","text":"Always decode source as UTF8 ( 563469b by Timoth\u00e9e Mazzucotelli). Fix JSON encoder and decoder ( 3e768d6 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_7","text":"Improve error handling ( 7b15a51 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0122-2022-02-13","text":"Compare with 0.12.1","title":"0.12.2 - 2022-02-13"},{"location":"changelog/#bug-fixes_22","text":"Fix JSON unable to serialize docstring kind values ( 91e6719 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_8","text":"Make attribute labels more explicit ( 19eac2e by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0121-2022-02-12","text":"Compare with 0.11.7","title":"0.12.1 - 2022-02-12"},{"location":"changelog/#features_12","text":"Add ignore_init_summary option to the Google parser ( 81f0333 by Timoth\u00e9e Mazzucotelli). Add is_KIND properties on objects ( 17a08cd by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#0117-2022-02-12","text":"Compare with 0.11.6","title":"0.11.7 - 2022-02-12"},{"location":"changelog/#bug-fixes_23","text":"Keep only first assignment in conditions ( 0104440 by Timoth\u00e9e Mazzucotelli). Support invert unary op in annotations ( 734ef55 by Timoth\u00e9e Mazzucotelli). Fix handling of missing modules during dynamic imports ( 7a3b383 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#380 Fix getting lines of compiled modules ( 899461b by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_9","text":"Get annotation with the same property on functions ( ecc7bba by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0116-2022-02-10","text":"Compare with 0.11.5","title":"0.11.6 - 2022-02-10"},{"location":"changelog/#bug-fixes_24","text":"Fix infinite loop in Google parser ( 8b7b97b by Timoth\u00e9e Mazzucotelli). Issue #38","title":"Bug Fixes"},{"location":"changelog/#0115-2022-02-08","text":"Compare with 0.11.4","title":"0.11.5 - 2022-02-08"},{"location":"changelog/#bug-fixes_25","text":"Fix building title and kind of Google admonitions ( 87ab56c by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings#379","title":"Bug Fixes"},{"location":"changelog/#0114-2022-02-07","text":"Compare with 0.11.3","title":"0.11.4 - 2022-02-07"},{"location":"changelog/#bug-fixes_26","text":"Don't trigger alias resolution while checking docstrings presence ( dda72ea by Timoth\u00e9e Mazzucotelli). Issue #37","title":"Bug Fixes"},{"location":"changelog/#0113-2022-02-05","text":"Compare with 0.11.2","title":"0.11.3 - 2022-02-05"},{"location":"changelog/#bug-fixes_27","text":"Fix getting params defaults on Python 3.7 ( 0afd867 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#0112-2022-02-03","text":"Compare with 0.11.1","title":"0.11.2 - 2022-02-03"},{"location":"changelog/#code-refactoring_10","text":"Factorize docstring annotation parser ( 19609be by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0111-2022-02-01","text":"Compare with 0.11.0","title":"0.11.1 - 2022-02-01"},{"location":"changelog/#code-refactoring_11","text":"Rename RST parser to Sphinx ( a612cb1 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0110-2022-01-31","text":"Compare with 0.10.0","title":"0.11.0 - 2022-01-31"},{"location":"changelog/#features_13","text":"Support matrix multiplication operator in visitor ( 6129e17 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_28","text":"Fix name resolution for inspected data ( ed3e7e5 by Timoth\u00e9e Mazzucotelli). Make importer actually able to import any nested object ( d007219 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_12","text":"Always use search paths to import modules ( a9a378f by Timoth\u00e9e Mazzucotelli). Split out module finder ( 7290642 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0100-2022-01-14","text":"Compare with 0.9.0","title":"0.10.0 - 2022-01-14"},{"location":"changelog/#bug-fixes_29","text":"Fix infinite recursion errors in alias resolver ( 133b4e4 by Timoth\u00e9e Mazzucotelli). Fix inspection of nodes children (aliases or not) ( bb354f2 by Timoth\u00e9e Mazzucotelli). Fix relative to absolute import conversion ( 464c39e by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_13","text":"Rename some CLI options ( 1323268 by Timoth\u00e9e Mazzucotelli). Return the loader the to main function ( 9c6317e by Timoth\u00e9e Mazzucotelli). Improve logging messages ( b8eb16e by Timoth\u00e9e Mazzucotelli). Skip inspection of some debug packages ( 4ee8968 by Timoth\u00e9e Mazzucotelli). Return ... instead of Ellipsis ( f9ae31d by Timoth\u00e9e Mazzucotelli). Catch attribute errors when cross-referencing docstring annotations ( 288803a by Timoth\u00e9e Mazzucotelli). Support dict methods in lines collection ( 1b0cb94 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features_14","text":"Compute and show some stats ( 1b8d0a1 by Timoth\u00e9e Mazzucotelli). Add CLI options for alias resolution ( 87a59cb by Timoth\u00e9e Mazzucotelli). Support Google raises annotations cross-refs ( 8006ae1 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#090-2022-01-04","text":"Compare with 0.8.0","title":"0.9.0 - 2022-01-04"},{"location":"changelog/#features_15","text":"Loader option to only follow aliases in known modules ( 879d91b by Timoth\u00e9e Mazzucotelli). Use aliases when inspecting too ( 60439ee by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_30","text":"Handle more errors when loading modules ( 1aa571a by Timoth\u00e9e Mazzucotelli). Handle more errors when getting signature ( 2db85e7 by Timoth\u00e9e Mazzucotelli). Fix checking parent truthfulness ( 6129e50 by Timoth\u00e9e Mazzucotelli). Fix getting subscript value ( 1699f12 by Timoth\u00e9e Mazzucotelli). Support yield nodes ( 7d536d5 by Timoth\u00e9e Mazzucotelli). Exclude some special low-level members that cause cyclic issues ( b54ab34 by Timoth\u00e9e Mazzucotelli). Fix transforming elements of signatures to annotations ( e278c11 by Timoth\u00e9e Mazzucotelli). Detect cyclic aliases and prevent resolution errors ( de5dd12 by Timoth\u00e9e Mazzucotelli). Don't crash while trying to get the representation of an attribute value ( 77ac55d by Timoth\u00e9e Mazzucotelli). Fix building value for joined strings ( 6154b69 by Timoth\u00e9e Mazzucotelli). Fix prevention of cycles while building objects nodes ( 48062ac by Timoth\u00e9e Mazzucotelli). Better handle relative imports ( 91b42de by Timoth\u00e9e Mazzucotelli). Fix Google parser missing lines ending with colon ( 2f7969c by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_14","text":"Improve alias resolution robustness ( e708139 by Timoth\u00e9e Mazzucotelli). Remove async loader for now ( acc5ecf by Timoth\u00e9e Mazzucotelli). Improve handling of Google admonitions ( 8aa5ed0 by Timoth\u00e9e Mazzucotelli). Better handling of import errors and system exits while inspecting modules ( 7ba1589 by Timoth\u00e9e Mazzucotelli). Empty generic visit/inspect methods in base classes ( 338760e by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#080-2022-01-02","text":"Compare with 0.7.1","title":"0.8.0 - 2022-01-02"},{"location":"changelog/#features_16","text":"Support getting attribute annotation from parent in RST docstring parser ( 25db61a by Timoth\u00e9e Mazzucotelli). Handle relative imports ( 62b0927 by Timoth\u00e9e Mazzucotelli). Support wildcard imports ( 77a3cb7 by Timoth\u00e9e Mazzucotelli). Support configuring log level (CLI/env var) ( 839d78e by Timoth\u00e9e Mazzucotelli). Support loading *.py[cod] and *.so modules ( cd98a6f by Timoth\u00e9e Mazzucotelli). Support inspecting builtin functions/methods ( aa1fce3 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_15","text":"Handle extensions errors ( 11278ca by Timoth\u00e9e Mazzucotelli). Don't always try to find a module as a relative path ( e6df277 by Timoth\u00e9e Mazzucotelli). Improve loggers patching ( f4b262a by Timoth\u00e9e Mazzucotelli). Improve dynamic imports ( 2998195 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#071-2021-12-28","text":"Compare with 0.7.0","title":"0.7.1 - 2021-12-28"},{"location":"changelog/#code-refactoring_16","text":"Only log warning if async mode is used ( 356e848 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#070-2021-12-28","text":"Compare with 0.6.0","title":"0.7.0 - 2021-12-28"},{"location":"changelog/#features_17","text":"Support more nodes on Python 3.7 ( 7f2c4ec by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_17","text":"Don't crash on syntax errors and log an error ( 10bb6b1 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#060-2021-12-27","text":"Compare with 0.5.0","title":"0.6.0 - 2021-12-27"},{"location":"changelog/#features_18","text":"Support more AST nodes ( cd1b305 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_18","text":"Use annotation getter for base classes ( 8b1a7ed by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#050-2021-12-20","text":"Compare with 0.4.0","title":"0.5.0 - 2021-12-20"},{"location":"changelog/#features_19","text":"Add support for Python 3.7 ( 4535adc by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_31","text":"Don't propagate aliases of an alias ( 8af48f8 by Timoth\u00e9e Mazzucotelli). Don't reassign members defined in except clauses ( d918b4e by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#040-2021-11-28","text":"Compare with 0.3.0","title":"0.4.0 - 2021-11-28"},{"location":"changelog/#features_20","text":"Add a prototype 'hybrid' extension ( 8cb3c16 by Timoth\u00e9e Mazzucotelli). Allow passing extensions config as JSON on the CLI ( 9a7fa8b by Timoth\u00e9e Mazzucotelli). Support names for returns, yields and receives sections items ( 1c5a4c9 by Timoth\u00e9e Mazzucotelli). Store aliases on each object ( 91ba643 by Timoth\u00e9e Mazzucotelli). Support in[tro]spection ( 3a0587d by Timoth\u00e9e Mazzucotelli). Support multiple return, yield and receive items ( 0fc70cb by Timoth\u00e9e Mazzucotelli). Support namespace packages ( 2414c8e by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_32","text":"Fix extensions loader ( 78fb70b by Timoth\u00e9e Mazzucotelli). Avoid visiting/inspecting multiple times ( 75a8a8b by Timoth\u00e9e Mazzucotelli). Set modules collection attribute earlier ( 592c0bd by Timoth\u00e9e Mazzucotelli). Support inequality nodes ( b0ed247 by Timoth\u00e9e Mazzucotelli). Handle Div nodes for values ( 272e4d6 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_19","text":"Set log level to INFO ( 718e73e by Timoth\u00e9e Mazzucotelli). Add target setter ( 7f0064c by Timoth\u00e9e Mazzucotelli). Reorganize conditions ( 15ab876 by Timoth\u00e9e Mazzucotelli). Avoid recursion loops ( ea6acec by Timoth\u00e9e Mazzucotelli). Update aliases when replacing a member ( 99a0f8b by Timoth\u00e9e Mazzucotelli). Reorganize code ( 31fcdb1 by Timoth\u00e9e Mazzucotelli). Replace DocstringException with DocstringRaise ( d5ed87a by Timoth\u00e9e Mazzucotelli). Refactor loaders ( d9b94bb by Timoth\u00e9e Mazzucotelli). Improve typing ( e08bcfa by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#030-2021-11-21","text":"Compare with 0.2.0","title":"0.3.0 - 2021-11-21"},{"location":"changelog/#features_21","text":"Handle aliases and their resolution ( 67ae903 by Timoth\u00e9e Mazzucotelli). Resolve annotations in docstrings ( 847384a by Timoth\u00e9e Mazzucotelli). Resolve annotations ( 6451eff by Timoth\u00e9e Mazzucotelli). Add lines property to objects ( 7daf7db by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each object ( 07a1d2e by Timoth\u00e9e Mazzucotelli). Get attributes annotations from parent ( 003b990 by Timoth\u00e9e Mazzucotelli). Draft extensions loader ( 17ccd03 by Timoth\u00e9e Mazzucotelli). Add properties to objects ( 0ec301a by Timoth\u00e9e Mazzucotelli). Handle .pth files when searching modules ( 2a2e182 by Timoth\u00e9e Mazzucotelli). Add default property to docstring parameters ( 6298ba3 by Timoth\u00e9e Mazzucotelli). Accept RST and Numpy parsers ( 1cf147d by Timoth\u00e9e Mazzucotelli). Support data (attributes/variables) ( dce84d1 by Timoth\u00e9e Mazzucotelli). Add Numpy-style parser ( ad5b72d by Timoth\u00e9e Mazzucotelli). Support more section kinds in Google-style ( 9d3d047 by Timoth\u00e9e Mazzucotelli). Add docstring section kinds ( b270483 by Timoth\u00e9e Mazzucotelli). Accept initial arguments when creating container ( 90c5956 by Timoth\u00e9e Mazzucotelli). Add an RST-style docstring parser ( 742e7b2 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements_1","text":"Improve JSON encoder perfs ( 6a78eb0 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#bug-fixes_33","text":"Handle serialization of Posix paths ( 3a66b95 by Timoth\u00e9e Mazzucotelli). Fix list annotation getter ( 5ae800a by Timoth\u00e9e Mazzucotelli). Show accurate line number in Google warnings ( 2953590 by Timoth\u00e9e Mazzucotelli). Fix assignment names getters ( 6990846 by Timoth\u00e9e Mazzucotelli). Fix async loader (passing parent) ( 57e866e by Timoth\u00e9e Mazzucotelli). Fix exception name ( 4b8b85d by Timoth\u00e9e Mazzucotelli). Fix Google sections titles logic ( 87dd329 by Timoth\u00e9e Mazzucotelli). Prepend current module to base classes (still needs resolution) ( a4b1dee by Timoth\u00e9e Mazzucotelli). Fix Google admonition regex ( 3902e74 by Timoth\u00e9e Mazzucotelli). Fix docstring getter ( 1442eba by Timoth\u00e9e Mazzucotelli). Fix getting arguments defaults in the Google-style parser ( 67adbaf by Timoth\u00e9e Mazzucotelli). Fix getting arguments annotations in the Google-style parser ( 8bcbfba by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_20","text":"Export parsers and main function in docstrings module ( 96469da by Timoth\u00e9e Mazzucotelli). Remove top exports ( cd76694 by Timoth\u00e9e Mazzucotelli). Reorganize exceptions ( 7f9b805 by Timoth\u00e9e Mazzucotelli). Avoid circular import ( ef27dcd by Timoth\u00e9e Mazzucotelli). Rename index to [new] offset ( c07cc7d by Timoth\u00e9e Mazzucotelli). Reorganize code ( 5f4fff2 by Timoth\u00e9e Mazzucotelli). Use keyword only parameters ( d34edd6 by Timoth\u00e9e Mazzucotelli). Default to no parsing for serialization ( 8fecd9e by Timoth\u00e9e Mazzucotelli). Always extend AST ( c227ae6 by Timoth\u00e9e Mazzucotelli). Set default for kwargs parameters ( 7a0b85e by Timoth\u00e9e Mazzucotelli). Rename visitor method ( 3e0c43c by Timoth\u00e9e Mazzucotelli). Improve typing ( ac86f17 by Timoth\u00e9e Mazzucotelli). Fix typo ( a9ed6e9 by Timoth\u00e9e Mazzucotelli). Rewrite ParameterKind ( 90249df by Timoth\u00e9e Mazzucotelli). Add bool methods to docstrings and objects ( 548f72e by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each docstring ( 752e084 by Timoth\u00e9e Mazzucotelli). Skip attribute assignments ( e9cc2cd by Timoth\u00e9e Mazzucotelli). Improve visitor getters ( 2ea88c0 by Timoth\u00e9e Mazzucotelli). Use relative filepath in docstring warnings ( e894df7 by Timoth\u00e9e Mazzucotelli). Set submodules parent earlier ( 53767c0 by Timoth\u00e9e Mazzucotelli). Rename Data to Attribute ( febc12e by Timoth\u00e9e Mazzucotelli). Rename arguments to parameters ( 957856c by Timoth\u00e9e Mazzucotelli). Improve annotation support ( 5b2262f by Timoth\u00e9e Mazzucotelli). Always set parent ( cae85de by Timoth\u00e9e Mazzucotelli). Factorize function handling ( dfece1c by Timoth\u00e9e Mazzucotelli). Privatize stuff, fix loggers ( 5513ed5 by Timoth\u00e9e Mazzucotelli). Use keyword only arguments ( e853fe9 by Timoth\u00e9e Mazzucotelli). Set default values for Argument arguments ( d5cccaa by Timoth\u00e9e Mazzucotelli). Swallow extra parsing options ( 3d9ebe7 by Timoth\u00e9e Mazzucotelli). Rename start_index argument to offset ( dd88358 by Timoth\u00e9e Mazzucotelli). Reuse parsers warn function ( 03dfdd3 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#020-2021-09-25","text":"Compare with 0.1.0","title":"0.2.0 - 2021-09-25"},{"location":"changelog/#features_22","text":"Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements_2","text":"Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#010-2021-09-09","text":"Compare with first commit","title":"0.1.0 - 2021-09-09"},{"location":"changelog/#features_23","text":"Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"checking/","text":"Checking for API breakages \u00a4 Griffe is able to compare two snapshots of your project to detect API breakages between the old and the new snapshot. By snapshot we mean a specific point in your Git history. For example, you can ask Griffe to compare your current code against a specific tag. By default, Griffe will compare the current code to the latest tag: $ griffe check mypackage To specify another Git reference to check against, use the --against or -a option: $ griffe check mypackage -a 0 .2.0 You can specify a Git tag, commit (hash), or even a branch: Griffe will create a worktree at this reference in a temporary directory, and clean it up after finishing. If you want to also specify the base reference to use (instead of the current code), use the --base or -b option. Some examples: $ griffe check mypackage -b HEAD -a 2 .0.0 $ griffe check mypackage -b 2 .0.0 -a 1 .0.0 $ griffe check mypackage -b fix-issue-90 -a 1 .2.3 $ griffe check mypackage -b 8afcfd6e Important: Remember that the base is the most recent reference, and the one we compare it against is the oldest one. The package name you pass to griffe check must be found relatively to the repository root. For Griffe to find packages in subfolders, pass the parent subfolder to the --search or -s option. Example for src -layouts: $ griffe check -s src griffe Example in a monorepo, within a deeper file tree: $ griffe check -s back/services/identity-provider/src identity_provider Detected breakages \u00a4 In this section, we will describe the breakages that Griffe detects, giving some code examples and hints on how to properly communicate breakages with deprecation messages before actually releasing them. Obviously, these explanations and the value of the hints we provide depend on your definition of what is a public Python API. There is no clear and generally agreed upon definition of \"public Python API\". A public Python API might vary from one project to another. In essence, your public API is what you say it is. However, we do have conventions like prefixing objects with an underscore to tell users these objects are part of the private API, or internals, and therefore should not be used. For the rest, Griffe can detect changes that will trigger immedate errors in your users code', and changes that might cause issues in your users' code. Although the latter sound less impactful, they do have a serious impact, because they can silently change the behavior of your users' code, leading to issues that are hard to detect, understand and fix. Knowing that every change is a breaking change , the more we detect and document (potentially) breaking changes in our changelogs, the better. Parameter moved \u00a4 Positional parameter was moved. Moving the order of positional parameters can silently break your users' code. before # your code def greet ( prefix , name ): print ( prefix + \" \" + name ) # user's code greet ( \"hello\" , \"world\" ) after # your code def greet ( name , prefix ): print ( prefix + \" \" + name ) # user's code: no immediate error, broken behavior greet ( \"hello\" , \"world\" ) Note Moving required parameters around is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like TypeError . The function expects a number of arguments, and the developer pass it this same number of arguments: the contract is fullfilled. But parameters very often have specific meaning, and changing their order will silently lead (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes. Hint If you often add, move or remove parameters, consider making them keyword-only, so that their order doesn't matter. before def greet ( * , prefix , name ): print ( prefix + \" \" + name ) greet ( prefix = \"hello\" , name = \"world\" ) after def greet ( * , name , prefix ): print ( prefix + \" \" + name ) # still working as expected greet ( prefix = \"hello\" , name = \"world\" ) Parameter removed \u00a4 Parameter was removed. Removing a parameter can immediately break your users' code. before # your code def greet ( prefix , name ): print ( prefix + \" \" + name ) # user's code greet ( \"hello\" , \"world\" ) after # your code def greet ( name ): print ( \"hello \" + name ) # user's code: immediate error greet ( \"hello\" , \"world\" ) # even with keyword parameters: immediate error greet ( prefix = \"hello\" , name = \"world\" ) Hint Allow a deprecation period for the removed parameter by swallowing it in a variadic positional parameter, a variadic keyword parameter, or both. positional-only keyword-only positional or keyword before # your parameters are positional-only parameters (difficult deprecation) def greet ( prefix , name , / ): print ( prefix + \" \" + name ) greet ( \"hello\" , \"world\" ) after # swallow prefix using a variadic positional parameter def greet ( * args ): if len ( args ) == 2 : prefix , name = args elif len ( args ) == 1 : prefix = None name = args [ 0 ] else : raise ValueError ( \"missing parameter 'name'\" ) if prefix is not None : warnings . warn ( DeprecationWarning , \"prefix is deprecated\" ) print ( \"hello \" + name ) # still working as expected greet ( \"hello\" , \"world\" ) before # your parameters are keyword-only parameters (easy deprecation) def greet ( * , prefix , name ): print ( prefix + \" \" + name ) greet ( prefix = \"hello\" , name = \"world\" ) after # swallow prefix using a variadic keyword parameter def greet ( name , ** kwargs ): prefix = kwargs . get ( \"prefix\" , None ) if prefix is not None : warnings . warn ( DeprecationWarning , \"prefix is deprecated\" ) print ( \"hello \" + name ) # still working as expected greet ( prefix = \"hello\" , name = \"world\" ) before # your parameters are positional or keyword parameters (very difficult deprecation) def greet ( prefix , name ): print ( prefix + \" \" + name ) greet ( \"hello\" , name = \"world\" ) after # no other choice than swallowing both forms... # ignoring the deprecated parameter becomes quite complex def greet ( * args , ** kwargs ): if len ( args ) == 2 : prefix , name = args elif len ( args ) == 1 : prefix = None name = args [ 0 ] if \"name\" in kwargs : name = kwargs [ \"name\" ] if \"prefix\" in kwargs : prefix = kwargs [ \"prefix\" ] if prefix is not None : warnings . warn ( DeprecationWarning , \"prefix is deprecated\" ) print ( \"hello \" + name ) # still working as expected greet ( \"hello\" , \"world\" ) greet ( \"hello\" , name = \"world\" ) greet ( prefix = \"hello\" , name = \"world\" ) Parameter changed kind \u00a4 Parameter kind was changed Changing the kind of a parameter to another (positional-only, keyword-only, positional or keyword, variadic positional, variadic keyword) can immediately break your users' code. before # your code def greet ( name ): print ( \"hello \" + name ) def greet2 ( name ): print ( \"hello \" + name ) # user's code: all working fine greet ( \"tim\" ) greet ( name = \"tim\" ) greet2 ( \"tim\" ) greet2 ( name = \"tim\" ) after # your code def greet ( name , / ): print ( \"hello \" + name ) def greet2 ( * , name ): print ( \"hello \" + name ) # user's code: working as expected greet ( \"tim\" ) greet2 ( name = \"tim\" ) # immediate error greet ( name = \"tim\" ) greet2 ( \"tim\" ) Hint Although it actually is a breaking change, changing your positional or keyword parameters' kind to keyword-only makes your public function more robust to future changes (forward-compatibility). For functions with lots of optional parameters, and a few (one or two) required parameters, it can be a good idea to accept the required parameters as positional or keyword, while accepting the optional parameters as keyword-only parameters: def greet ( name , * , punctuation = False , bold = False , italic = False ): ... # simple cases are easy to write greet ( \"tim\" ) greet ( \"tiff\" ) # complex cases are never ambiguous greet ( \"tim\" , italic = True , bold = True ) greet ( name = \"tiff\" , bold = True , punctuation = True ) Positional-only parameters are useful in some specific cases, such as when a function takes two or more numeric values, and their order does not matter, and naming the parameters would not make sense: def multiply3 ( a , b , c , / ): return a * b * c # all the following are equivalent multiply3 ( 4 , 2 , 3 ) multiply3 ( 4 , 3 , 2 ) multiply3 ( 2 , 3 , 4 ) # etc. Parameter changed default \u00a4 Parameter default was changed Changing the default value of a parameter can silently break your users' code. before # your code def compute_something ( value : int , to_float = True ): value = ... if to_float : return float ( value ) return value # user's code: condition is entered if isinstance ( compute_something ( 7 ), float ): ... after # your code def compute_something ( value : int , to_float = False ): value = ... if to_float : return float ( value ) return value # user's code: condition is not entered anymore if isinstance ( compute_something ( 7 ), float ): ... Note Changing default value of parameters is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like TypeError . Not using the parameter still provides the argument with a default value: the contract is fullfilled. But default values very often have specific meaning, and changing them will silently lead (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes. Hint Allow a deprecation period for the old default value by using a sentinel value to detect when the parameter wasn't used by the user: in the coming release _sentinel = object () def compute_something ( value : int , to_float = _sentinel ): value = ... if to_float is _sentinel : to_float = True warnings . warn ( DeprecationWarning , \"default value of 'to_float' will change from True to False, \" \"please provide 'to_float=True' if you want to retain the current behavior\" ) if to_float : return float ( value ) return value In a later release you can remove the sentinel, the deprecation warning, and set False as default to to_float . in a later release def compute_something ( value : int , to_float = False ): value = ... if to_float : return float ( value ) return value Parameter changed required \u00a4 Parameter is now required Changing an optional parameter to a required one (by removing its default value) can immediately break your users' code. before # your code def greet ( name , prefix = \"hello\" ): print ( prefix + \" \" + name ) # user's code greet ( \"tiff\" ) after # your code def greet ( name , prefix ): print ( prefix + \" \" + name ) # user's code: immediate error greet ( \"tiff\" ) Hint Allow a deprecation period for the default value by using a sentinel value to detect when the parameter wasn't used by the user: in the coming release _sentinel = object () def greet ( name , prefix = _sentinel ): if prefix is _sentinel : prefix = \"hello\" warnings . warn ( DeprecationWarning , \"'prefix' will become required in the next release\" ) print ( prefix + \" \" + name ) In a later release you can remove the sentinel, the deprecation warning, and the default value of prefix . in a later release def greet ( name , prefix ): print ( prefix + \" \" + name ) Parameter added required \u00a4 Parameter was added as required Adding a new, required parameter can immediately break your users' code. before # your code def greet ( name ): print ( \"hello \" + name ) # user's code greet ( \"tiff\" ) after # your code def greet ( name , prefix ): print ( prefix + \" \" + name ) # user's code: immediate error greet ( \"tiff\" ) Hint You can delay (or avoid) and inform your users about the upcoming breakage by temporarily (or permanently) providing a default value for the new parameter: in the coming release def greet ( name , prefix = \"hello\" ): print ( prefix + \" \" + name ) Return changed type \u00a4 Return types are incompatible Not yet supported! Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later. Object removed \u00a4 Public object was removed Removing a public object from a module can immediately break your users' code. before # your/module.py special_thing = \"hey\" # user/module.py from your.module import special_thing # other/user/module.py from your import module print ( module . special_thing ) after # user/module.py: import error from your.module import special_thing # other/user/module.py: attribute error from your import module print ( module . special_thing ) Hint Allow a deprecation period by declaring a module-level __getattr__ function that returns the given object while warning about its deprecation: def __getattr__ ( name ): if name == \"special_thing\" : warnings . warn ( DeprecationWarning , \"'special_thing' is deprecated and will be removed\" ) return \"hey\" Object changed kind \u00a4 Public object points to a different kind of object Changing the kind (attribute, function, class, module) of a public object can silently break your users' code. before # your code class Factory : def __call__ ( self , ... ): ... factory = Factory ( ... ) # user's code: condition is entered if isinstance ( factory , Factory ): ... after # your code class Factory : ... def factory ( ... ): ... # user's code: condition is not entered anymore if isinstance ( factory , Factory ): ... Note Changing the kind of an object is not really an API breakage, depending on our definition of API, since this won't always raise immediate errors like TypeError . The object is still here and accessed: the contract is fullfilled. But developers sometimes rely on the kind of an object, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes. Attribute changed type \u00a4 Attribute types are incompatible Not yet supported! Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later. Attribute changed value \u00a4 Attribute value was changed Changing the value of an attribute can silently break your users' code. before # your code PY_VERSION = os . getenv ( \"PY_VERSION\" ) # user's code: condition is entered if PY_VERSION is None : ... after # your code PY_VERSION = os . getenv ( \"PY_VERSION\" , \"3.8\" ) # user's code: condition is not entered anymore if PY_VERSION is None : ... Note Changing the value of an attribute is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like TypeError . The attribute is still here and accessed: the contract is fullfilled. But developers heavily rely on the value of public attributes, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes. Hint Make sure to document the change of value of the attribute in your changelog, particularly the previous and new range of values it can take. Class removed base \u00a4 Base class was removed Removing a class from another class' bases can silently break your users' code. before # your code class A : ... class B : ... class C ( A , B ): ... # user's code: condition is entered if B in klass . __bases__ : ... after # your code class A : ... class B : ... class C ( A ): ... # user's code: condition is not entered anymore if B in klass . __bases__ : ... Note Unless inherited members are lost in the process, removing a class base is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like TypeError . The class is here, its members as well: the contract is fullfilled. But developers sometimes rely on the actual bases of a class, so changing them will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes. Output style \u00a4 By default, Griffe will print each detected breakage on a single line, on stderr : $ griffe check griffe -ssrc -b0.24.0 -a0.23.0 src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_exported ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_exported ): Parameter default was changed : True -> None src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_known_modules ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_known_modules ): Parameter default was changed : True -> None src/griffe/loader.py :156: GriffeLoader.resolve_aliases( max_iterations ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/loader.py :308: GriffeLoader.resolve_module_aliases( only_exported ): Parameter was removed src/griffe/loader.py :308: GriffeLoader.resolve_module_aliases( only_known_modules ): Parameter was removed src/griffe/git.py :39: tmp_worktree( commit ): Parameter was removed src/griffe/git.py :39: tmp_worktree( repo ): Positional parameter was moved : position: from 2 to 1 (-1) src/griffe/git.py :75: load_git( commit ): Parameter was removed src/griffe/git.py :75: load_git( repo ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( submodules ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( try_relative_path ): Parameter was removed src/griffe/git.py :75: load_git( extensions ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( search_paths ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( docstring_parser ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( docstring_options ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( lines_collection ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( modules_collection ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( allow_inspection ): Parameter kind was changed : positional or keyword -> keyword-only Depending on the detected breakages, the lines might be hard to read (being too compact), so griffe check also accepts a --verbose or -v option to add some space to the output: $ griffe check griffe -ssrc -b0.24.0 -a0.23.0 --verbose src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_exported ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_exported ): Parameter default was changed : Old: True New: None src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_known_modules ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_known_modules ): Parameter default was changed : Old: True New: None src/griffe/loader.py :156: GriffeLoader.resolve_aliases( max_iterations ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/loader.py :308: GriffeLoader.resolve_module_aliases( only_exported ): Parameter was removed src/griffe/loader.py :308: GriffeLoader.resolve_module_aliases( only_known_modules ): Parameter was removed src/griffe/git.py :39: tmp_worktree( commit ): Parameter was removed src/griffe/git.py :39: tmp_worktree( repo ): Positional parameter was moved : Details: position: from 1 to 0 (-1) src/griffe/git.py :75: load_git( commit ): Parameter was removed src/griffe/git.py :75: load_git( repo ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( submodules ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( try_relative_path ): Parameter was removed src/griffe/git.py :75: load_git( extensions ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( search_paths ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( docstring_parser ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( docstring_options ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( lines_collection ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( modules_collection ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( allow_inspection ): Parameter kind was changed : Old: positional or keyword New: keyword-only","title":"Checking for API breakages"},{"location":"checking/#checking-for-api-breakages","text":"Griffe is able to compare two snapshots of your project to detect API breakages between the old and the new snapshot. By snapshot we mean a specific point in your Git history. For example, you can ask Griffe to compare your current code against a specific tag. By default, Griffe will compare the current code to the latest tag: $ griffe check mypackage To specify another Git reference to check against, use the --against or -a option: $ griffe check mypackage -a 0 .2.0 You can specify a Git tag, commit (hash), or even a branch: Griffe will create a worktree at this reference in a temporary directory, and clean it up after finishing. If you want to also specify the base reference to use (instead of the current code), use the --base or -b option. Some examples: $ griffe check mypackage -b HEAD -a 2 .0.0 $ griffe check mypackage -b 2 .0.0 -a 1 .0.0 $ griffe check mypackage -b fix-issue-90 -a 1 .2.3 $ griffe check mypackage -b 8afcfd6e Important: Remember that the base is the most recent reference, and the one we compare it against is the oldest one. The package name you pass to griffe check must be found relatively to the repository root. For Griffe to find packages in subfolders, pass the parent subfolder to the --search or -s option. Example for src -layouts: $ griffe check -s src griffe Example in a monorepo, within a deeper file tree: $ griffe check -s back/services/identity-provider/src identity_provider","title":"Checking for API breakages"},{"location":"checking/#detected-breakages","text":"In this section, we will describe the breakages that Griffe detects, giving some code examples and hints on how to properly communicate breakages with deprecation messages before actually releasing them. Obviously, these explanations and the value of the hints we provide depend on your definition of what is a public Python API. There is no clear and generally agreed upon definition of \"public Python API\". A public Python API might vary from one project to another. In essence, your public API is what you say it is. However, we do have conventions like prefixing objects with an underscore to tell users these objects are part of the private API, or internals, and therefore should not be used. For the rest, Griffe can detect changes that will trigger immedate errors in your users code', and changes that might cause issues in your users' code. Although the latter sound less impactful, they do have a serious impact, because they can silently change the behavior of your users' code, leading to issues that are hard to detect, understand and fix. Knowing that every change is a breaking change , the more we detect and document (potentially) breaking changes in our changelogs, the better.","title":"Detected breakages"},{"location":"checking/#parameter-moved","text":"Positional parameter was moved. Moving the order of positional parameters can silently break your users' code. before # your code def greet ( prefix , name ): print ( prefix + \" \" + name ) # user's code greet ( \"hello\" , \"world\" ) after # your code def greet ( name , prefix ): print ( prefix + \" \" + name ) # user's code: no immediate error, broken behavior greet ( \"hello\" , \"world\" ) Note Moving required parameters around is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like TypeError . The function expects a number of arguments, and the developer pass it this same number of arguments: the contract is fullfilled. But parameters very often have specific meaning, and changing their order will silently lead (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes. Hint If you often add, move or remove parameters, consider making them keyword-only, so that their order doesn't matter. before def greet ( * , prefix , name ): print ( prefix + \" \" + name ) greet ( prefix = \"hello\" , name = \"world\" ) after def greet ( * , name , prefix ): print ( prefix + \" \" + name ) # still working as expected greet ( prefix = \"hello\" , name = \"world\" )","title":"Parameter moved"},{"location":"checking/#parameter-removed","text":"Parameter was removed. Removing a parameter can immediately break your users' code. before # your code def greet ( prefix , name ): print ( prefix + \" \" + name ) # user's code greet ( \"hello\" , \"world\" ) after # your code def greet ( name ): print ( \"hello \" + name ) # user's code: immediate error greet ( \"hello\" , \"world\" ) # even with keyword parameters: immediate error greet ( prefix = \"hello\" , name = \"world\" ) Hint Allow a deprecation period for the removed parameter by swallowing it in a variadic positional parameter, a variadic keyword parameter, or both. positional-only keyword-only positional or keyword before # your parameters are positional-only parameters (difficult deprecation) def greet ( prefix , name , / ): print ( prefix + \" \" + name ) greet ( \"hello\" , \"world\" ) after # swallow prefix using a variadic positional parameter def greet ( * args ): if len ( args ) == 2 : prefix , name = args elif len ( args ) == 1 : prefix = None name = args [ 0 ] else : raise ValueError ( \"missing parameter 'name'\" ) if prefix is not None : warnings . warn ( DeprecationWarning , \"prefix is deprecated\" ) print ( \"hello \" + name ) # still working as expected greet ( \"hello\" , \"world\" ) before # your parameters are keyword-only parameters (easy deprecation) def greet ( * , prefix , name ): print ( prefix + \" \" + name ) greet ( prefix = \"hello\" , name = \"world\" ) after # swallow prefix using a variadic keyword parameter def greet ( name , ** kwargs ): prefix = kwargs . get ( \"prefix\" , None ) if prefix is not None : warnings . warn ( DeprecationWarning , \"prefix is deprecated\" ) print ( \"hello \" + name ) # still working as expected greet ( prefix = \"hello\" , name = \"world\" ) before # your parameters are positional or keyword parameters (very difficult deprecation) def greet ( prefix , name ): print ( prefix + \" \" + name ) greet ( \"hello\" , name = \"world\" ) after # no other choice than swallowing both forms... # ignoring the deprecated parameter becomes quite complex def greet ( * args , ** kwargs ): if len ( args ) == 2 : prefix , name = args elif len ( args ) == 1 : prefix = None name = args [ 0 ] if \"name\" in kwargs : name = kwargs [ \"name\" ] if \"prefix\" in kwargs : prefix = kwargs [ \"prefix\" ] if prefix is not None : warnings . warn ( DeprecationWarning , \"prefix is deprecated\" ) print ( \"hello \" + name ) # still working as expected greet ( \"hello\" , \"world\" ) greet ( \"hello\" , name = \"world\" ) greet ( prefix = \"hello\" , name = \"world\" )","title":"Parameter removed"},{"location":"checking/#parameter-changed-kind","text":"Parameter kind was changed Changing the kind of a parameter to another (positional-only, keyword-only, positional or keyword, variadic positional, variadic keyword) can immediately break your users' code. before # your code def greet ( name ): print ( \"hello \" + name ) def greet2 ( name ): print ( \"hello \" + name ) # user's code: all working fine greet ( \"tim\" ) greet ( name = \"tim\" ) greet2 ( \"tim\" ) greet2 ( name = \"tim\" ) after # your code def greet ( name , / ): print ( \"hello \" + name ) def greet2 ( * , name ): print ( \"hello \" + name ) # user's code: working as expected greet ( \"tim\" ) greet2 ( name = \"tim\" ) # immediate error greet ( name = \"tim\" ) greet2 ( \"tim\" ) Hint Although it actually is a breaking change, changing your positional or keyword parameters' kind to keyword-only makes your public function more robust to future changes (forward-compatibility). For functions with lots of optional parameters, and a few (one or two) required parameters, it can be a good idea to accept the required parameters as positional or keyword, while accepting the optional parameters as keyword-only parameters: def greet ( name , * , punctuation = False , bold = False , italic = False ): ... # simple cases are easy to write greet ( \"tim\" ) greet ( \"tiff\" ) # complex cases are never ambiguous greet ( \"tim\" , italic = True , bold = True ) greet ( name = \"tiff\" , bold = True , punctuation = True ) Positional-only parameters are useful in some specific cases, such as when a function takes two or more numeric values, and their order does not matter, and naming the parameters would not make sense: def multiply3 ( a , b , c , / ): return a * b * c # all the following are equivalent multiply3 ( 4 , 2 , 3 ) multiply3 ( 4 , 3 , 2 ) multiply3 ( 2 , 3 , 4 ) # etc.","title":"Parameter changed kind"},{"location":"checking/#parameter-changed-default","text":"Parameter default was changed Changing the default value of a parameter can silently break your users' code. before # your code def compute_something ( value : int , to_float = True ): value = ... if to_float : return float ( value ) return value # user's code: condition is entered if isinstance ( compute_something ( 7 ), float ): ... after # your code def compute_something ( value : int , to_float = False ): value = ... if to_float : return float ( value ) return value # user's code: condition is not entered anymore if isinstance ( compute_something ( 7 ), float ): ... Note Changing default value of parameters is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like TypeError . Not using the parameter still provides the argument with a default value: the contract is fullfilled. But default values very often have specific meaning, and changing them will silently lead (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes. Hint Allow a deprecation period for the old default value by using a sentinel value to detect when the parameter wasn't used by the user: in the coming release _sentinel = object () def compute_something ( value : int , to_float = _sentinel ): value = ... if to_float is _sentinel : to_float = True warnings . warn ( DeprecationWarning , \"default value of 'to_float' will change from True to False, \" \"please provide 'to_float=True' if you want to retain the current behavior\" ) if to_float : return float ( value ) return value In a later release you can remove the sentinel, the deprecation warning, and set False as default to to_float . in a later release def compute_something ( value : int , to_float = False ): value = ... if to_float : return float ( value ) return value","title":"Parameter changed default"},{"location":"checking/#parameter-changed-required","text":"Parameter is now required Changing an optional parameter to a required one (by removing its default value) can immediately break your users' code. before # your code def greet ( name , prefix = \"hello\" ): print ( prefix + \" \" + name ) # user's code greet ( \"tiff\" ) after # your code def greet ( name , prefix ): print ( prefix + \" \" + name ) # user's code: immediate error greet ( \"tiff\" ) Hint Allow a deprecation period for the default value by using a sentinel value to detect when the parameter wasn't used by the user: in the coming release _sentinel = object () def greet ( name , prefix = _sentinel ): if prefix is _sentinel : prefix = \"hello\" warnings . warn ( DeprecationWarning , \"'prefix' will become required in the next release\" ) print ( prefix + \" \" + name ) In a later release you can remove the sentinel, the deprecation warning, and the default value of prefix . in a later release def greet ( name , prefix ): print ( prefix + \" \" + name )","title":"Parameter changed required"},{"location":"checking/#parameter-added-required","text":"Parameter was added as required Adding a new, required parameter can immediately break your users' code. before # your code def greet ( name ): print ( \"hello \" + name ) # user's code greet ( \"tiff\" ) after # your code def greet ( name , prefix ): print ( prefix + \" \" + name ) # user's code: immediate error greet ( \"tiff\" ) Hint You can delay (or avoid) and inform your users about the upcoming breakage by temporarily (or permanently) providing a default value for the new parameter: in the coming release def greet ( name , prefix = \"hello\" ): print ( prefix + \" \" + name )","title":"Parameter added required"},{"location":"checking/#return-changed-type","text":"Return types are incompatible Not yet supported! Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.","title":"Return changed type"},{"location":"checking/#object-removed","text":"Public object was removed Removing a public object from a module can immediately break your users' code. before # your/module.py special_thing = \"hey\" # user/module.py from your.module import special_thing # other/user/module.py from your import module print ( module . special_thing ) after # user/module.py: import error from your.module import special_thing # other/user/module.py: attribute error from your import module print ( module . special_thing ) Hint Allow a deprecation period by declaring a module-level __getattr__ function that returns the given object while warning about its deprecation: def __getattr__ ( name ): if name == \"special_thing\" : warnings . warn ( DeprecationWarning , \"'special_thing' is deprecated and will be removed\" ) return \"hey\"","title":"Object removed"},{"location":"checking/#object-changed-kind","text":"Public object points to a different kind of object Changing the kind (attribute, function, class, module) of a public object can silently break your users' code. before # your code class Factory : def __call__ ( self , ... ): ... factory = Factory ( ... ) # user's code: condition is entered if isinstance ( factory , Factory ): ... after # your code class Factory : ... def factory ( ... ): ... # user's code: condition is not entered anymore if isinstance ( factory , Factory ): ... Note Changing the kind of an object is not really an API breakage, depending on our definition of API, since this won't always raise immediate errors like TypeError . The object is still here and accessed: the contract is fullfilled. But developers sometimes rely on the kind of an object, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.","title":"Object changed kind"},{"location":"checking/#attribute-changed-type","text":"Attribute types are incompatible Not yet supported! Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.","title":"Attribute changed type"},{"location":"checking/#attribute-changed-value","text":"Attribute value was changed Changing the value of an attribute can silently break your users' code. before # your code PY_VERSION = os . getenv ( \"PY_VERSION\" ) # user's code: condition is entered if PY_VERSION is None : ... after # your code PY_VERSION = os . getenv ( \"PY_VERSION\" , \"3.8\" ) # user's code: condition is not entered anymore if PY_VERSION is None : ... Note Changing the value of an attribute is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like TypeError . The attribute is still here and accessed: the contract is fullfilled. But developers heavily rely on the value of public attributes, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes. Hint Make sure to document the change of value of the attribute in your changelog, particularly the previous and new range of values it can take.","title":"Attribute changed value"},{"location":"checking/#class-removed-base","text":"Base class was removed Removing a class from another class' bases can silently break your users' code. before # your code class A : ... class B : ... class C ( A , B ): ... # user's code: condition is entered if B in klass . __bases__ : ... after # your code class A : ... class B : ... class C ( A ): ... # user's code: condition is not entered anymore if B in klass . __bases__ : ... Note Unless inherited members are lost in the process, removing a class base is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like TypeError . The class is here, its members as well: the contract is fullfilled. But developers sometimes rely on the actual bases of a class, so changing them will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.","title":"Class removed base"},{"location":"checking/#output-style","text":"By default, Griffe will print each detected breakage on a single line, on stderr : $ griffe check griffe -ssrc -b0.24.0 -a0.23.0 src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_exported ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_exported ): Parameter default was changed : True -> None src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_known_modules ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_known_modules ): Parameter default was changed : True -> None src/griffe/loader.py :156: GriffeLoader.resolve_aliases( max_iterations ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/loader.py :308: GriffeLoader.resolve_module_aliases( only_exported ): Parameter was removed src/griffe/loader.py :308: GriffeLoader.resolve_module_aliases( only_known_modules ): Parameter was removed src/griffe/git.py :39: tmp_worktree( commit ): Parameter was removed src/griffe/git.py :39: tmp_worktree( repo ): Positional parameter was moved : position: from 2 to 1 (-1) src/griffe/git.py :75: load_git( commit ): Parameter was removed src/griffe/git.py :75: load_git( repo ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( submodules ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( try_relative_path ): Parameter was removed src/griffe/git.py :75: load_git( extensions ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( search_paths ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( docstring_parser ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( docstring_options ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( lines_collection ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( modules_collection ): Parameter kind was changed : positional or keyword -> keyword-only src/griffe/git.py :75: load_git( allow_inspection ): Parameter kind was changed : positional or keyword -> keyword-only Depending on the detected breakages, the lines might be hard to read (being too compact), so griffe check also accepts a --verbose or -v option to add some space to the output: $ griffe check griffe -ssrc -b0.24.0 -a0.23.0 --verbose src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_exported ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_exported ): Parameter default was changed : Old: True New: None src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_known_modules ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/loader.py :156: GriffeLoader.resolve_aliases( only_known_modules ): Parameter default was changed : Old: True New: None src/griffe/loader.py :156: GriffeLoader.resolve_aliases( max_iterations ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/loader.py :308: GriffeLoader.resolve_module_aliases( only_exported ): Parameter was removed src/griffe/loader.py :308: GriffeLoader.resolve_module_aliases( only_known_modules ): Parameter was removed src/griffe/git.py :39: tmp_worktree( commit ): Parameter was removed src/griffe/git.py :39: tmp_worktree( repo ): Positional parameter was moved : Details: position: from 1 to 0 (-1) src/griffe/git.py :75: load_git( commit ): Parameter was removed src/griffe/git.py :75: load_git( repo ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( submodules ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( try_relative_path ): Parameter was removed src/griffe/git.py :75: load_git( extensions ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( search_paths ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( docstring_parser ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( docstring_options ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( lines_collection ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( modules_collection ): Parameter kind was changed : Old: positional or keyword New: keyword-only src/griffe/git.py :75: load_git( allow_inspection ): Parameter kind was changed : Old: positional or keyword New: keyword-only","title":"Output style"},{"location":"cli_reference/","text":"CLI reference \u00a4 griffe \u00a4 Signatures for entire Python programs. Global Options: -h , --help : Show this help message and exit. Commands also accept the -h/--help option. Commands: dump \u00a4 Load package-signatures and dump them as JSON. Search Options: -s , --search : Paths to search packages into. Loading Options: -e , --extensions : A list of extensions to use. -X , --no-inspection : Disallow inspection of builtin/compiled/not found modules. Default: True . Dump Options: packages PACKAGE : Packages to find, load and dump. -f , --full : Whether to dump full data in JSON. -o , --output : Output file. Supports templating to output each package in its own file, with {package} . Default: sys.stdout . -d , --docstyle : The docstring style to parse. -D , --docopts : The options for the docstring parser. -y , --sys-path : Whether to append sys.path to search paths specified with -s . -r , --resolve-aliases : Whether to resolve aliases. -I , --resolve-implicit : Whether to resolve implicitely exported aliases as well. Aliases are explicitely exported when defined in __all__ . -U , --resolve-external : Whether to resolve aliases pointing to external/unknown modules (not loaded directly). -S , --stats : Show statistics at the end. Debugging Options: -L , --log-level LEVEL : Set the log level: DEBUG , INFO , WARNING , ERROR , CRITICAL . Default: INFO . Common Options: -h , --help : Show this help message and exit. check \u00a4 Check for API breakages or possible improvements. Search Options: -s , --search : Paths to search packages into. Loading Options: -e , --extensions : A list of extensions to use. -X , --no-inspection : Disallow inspection of builtin/compiled/not found modules. Default: True . Debugging Options: -L , --log-level LEVEL : Set the log level: DEBUG , INFO , WARNING , ERROR , CRITICAL . Default: INFO . Common Options: -h , --help : Show this help message and exit. Check Options: package PACKAGE : Package to find, load and check, as path. -a , --against REF : Older Git reference (commit, branch, tag) to check against. Default: load latest tag. -b , --base-ref BASE_REF : Git reference (commit, branch, tag) to check. Default: load current code. -v , --verbose : Verbose output.","title":"CLI reference"},{"location":"cli_reference/#cli-reference","text":"","title":"CLI reference"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"These projects were used to build griffe . Thank you! python | pdm | copier-pdm Runtime dependencies \u00a4 Project Summary Version (accepted) Version (last resolved) License aiofiles File support for asyncio. ~=0.7 0.8.0 Apache-2.0 cached-property A decorator for caching properties in classes. ; python_version < '3.8' 1.5.2 BSD colorama Cross-platform colored terminal text. >=0.4 0.4.6 BSD License Development dependencies \u00a4 Project Summary Version (accepted) Version (last resolved) License ansimarkup Produce colored terminal text with an xml-like markup ~=1.4 1.5.0 Revised BSD License astor Read/rewrite/write Python ASTs >=0.8 0.8.1 BSD-3-Clause attrs Classes Without Boilerplate >=19.2.0 22.1.0 MIT autoflake Removes unused imports and unused variables >=1.4 1.7.8 MIT bandit Security oriented static analyser for python code. >=1.7.3 1.7.4 Apache-2.0 license black The uncompromising code formatter. >=22.3 22.10.0 MIT License cached-property A decorator for caching properties in classes. ~=1.5; python_version < \"3.8\" 1.5.2 BSD certifi Python package for providing Mozilla's CA Bundle. >=2017.4.17 2022.9.24 MPL-2.0 charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <3,>=2 2.1.1 MIT click Composable command line interface toolkit >=8.0.0 8.1.3 BSD-3-Clause colorama Cross-platform colored terminal text. ; platform_system == \"Windows\" 0.4.6 BSD License commonmark Python parser for the CommonMark Markdown spec <0.10.0,>=0.9.0 0.9.1 BSD-3-Clause coverage Code coverage measurement for Python [toml]>=5.2.1 6.5.0 Apache 2.0 darglint A utility for ensuring Google-style docstrings stay up to date with the source code. >=1.8 1.8.1 MIT dparse A parser for Python dependency files >=0.6.2 0.6.2 MIT license duty A simple task runner. >=0.7 0.7.0 ISC exceptiongroup Backport of PEP 654 (exception groups) >=1.0.0rc8; python_version < \"3.11\" 1.0.4 MIT License execnet execnet: rapid multi-Python deployment >=1.1 1.9.0 MIT failprint Run a command, print its output only if it fails. ~=0.8 0.8.0 ISC flake8 the modular source code checker: pep8 pyflakes and co >=4; python_version >= '3.8' 5.0.4 MIT flake8-bandit Automated security testing with bandit and flake8. >=2.1 4.1.1 MIT flake8-black flake8 plugin to call black as a code style validator >=0.2 0.3.5 MIT flake8-bugbear A plugin for flake8 finding likely bugs and design problems in your program. Contains warnings that don't belong in pyflakes and pycodestyle. >=21.9 22.10.27 MIT flake8-builtins Check for python builtins being used as variables or parameters. >=1.5 2.0.1 GPL version 2 flake8-comprehensions A flake8 plugin to help you write better list/set/dict comprehensions. >=3.7 3.10.1 MIT flake8-docstrings Extension for flake8 which uses pydocstyle to check docstrings >=1.6 1.6.0 MIT License flake8-plugin-utils The package provides base classes and utils for flake8 plugin writing <2.0.0,>=1.3.2 1.3.2 MIT flake8-polyfill Polyfill package for Flake8 plugins >=1.0.2 1.0.2 MIT flake8-pytest-style A flake8 plugin checking common style issues or inconsistencies with pytest-based tests. >=1.5 1.6.0 MIT flake8-string-format string format checker, plugin for flake8 >=0.3 0.3.0 MIT License flake8-tidy-imports A flake8 plugin that helps you write tidier imports. >=4.5 4.8.0 MIT flake8-variables-names A flake8 extension that helps to make more readable variables names >=0.0 0.0.5 MIT ghp-import Copy your docs directly to the gh-pages branch. >=1.0 2.1.0 Apache Software License git-changelog Automatic Changelog generator using Jinja2 templates. >=0.4 0.6.0 ISC gitdb Git Object Database <5,>=4.0.1 4.0.10 BSD License gitpython GitPython is a python library used to interact with Git repositories >=1.0.1 3.1.29 BSD griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. >=0.24 0.24.2.dev7+g0ed9c36.d20221130 ISC hypothesis A library for property-based testing [lark]>=6.58.1 6.58.2 MPL-2.0 hypothesmith Hypothesis strategies for generating Python programs, something like CSmith >=0.2.0 0.2.2 MPL 2.0 idna Internationalized Domain Names in Applications (IDNA) <4,>=2.5 3.4 BSD License importlib-metadata Read metadata from Python packages <5; python_version < '3.8' 4.13.0 Apache Software License iniconfig iniconfig: brain-dead simple config-ini parsing 1.1.1 MIT License isort A Python utility / library to sort Python imports. >=5.10 5.10.1 MIT jinja2 A very fast and expressive template engine. <4,>=2.11 3.1.2 BSD-3-Clause lark a modern parsing library >=0.10.1 1.1.4 MIT libcst A concrete syntax tree with AST-like properties for Python 3.5, 3.6, 3.7, 3.8, 3.9, and 3.10 programs. >=0.4.0 0.4.9 MIT markdown Python implementation of Markdown. <4.0.0,>=3.3.3 3.3.7 BSD License markdown-callouts Markdown extension: a classier syntax for admonitions >=0.2 0.3.0 MIT markdown-exec Utilities to execute code blocks in Markdown files. >=0.5 1.0.0 ISC markupsafe Safely add untrusted strings to HTML/XML markup. >=2.0 2.1.1 BSD-3-Clause mccabe McCabe checker, plugin for flake8 <0.8.0,>=0.7.0 0.7.0 Expat license mergedeep A deep merge function for \ud83d\udc0d. >=1.3.4 1.3.4 MIT License mkdocs Project documentation with Markdown. >=1.3 1.4.2 BSD License mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. >=0.2 0.2.6 ISC mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build >=0.3 0.4.0 MIT mkdocs-literate-nav MkDocs plugin to specify the navigation in Markdown instead of YAML >=0.4 0.5.0 MIT mkdocs-material Documentation that simply works >=7.3 8.5.11 MIT License mkdocs-material-extensions Extension pack for Python Markdown and MkDocs Material. >=1.1 1.1.1 MIT License mkdocs-section-index MkDocs plugin to allow clickable sections that lead to an index page >=0.3 0.3.4 MIT mkdocstrings Automatic documentation from sources, for MkDocs. [python]>=0.18 0.19.0 ISC License (ISCL) mkdocstrings-python A Python handler for mkdocstrings. >=0.5.2 0.8.2 ISC mypy Optional static typing for Python >=0.910 0.991 MIT License mypy-extensions Experimental type system extensions for programs checked with the mypy typechecker. >=0.4.3 0.4.3 MIT License packaging Core utilities for Python packages >=20.5 21.3 BSD-2-Clause or Apache-2.0 pathspec Utility library for gitignore style pattern matching of file paths. >=0.9.0 0.10.2 MPL 2.0 pbr Python Build Reasonableness !=2.1.0,>=2.0.0 5.11.0 Apache Software License pep8-naming Check PEP-8 naming conventions, plugin for flake8 >=0.12 0.13.2 Expat license platformdirs A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". >=2 2.5.4 MIT License pluggy plugin and hook calling mechanisms for python <2.0,>=0.12 1.0.0 MIT ptyprocess Run a subprocess in a pseudo terminal ~=0.6; sys_platform != \"win32\" 0.7.0 ISC License (ISCL) pycodestyle Python style guide checker <2.10.0,>=2.9.0 2.9.1 Expat license pydocstyle Python docstring style checker >=2.1 6.1.1 MIT pyflakes passive checker of Python programs <3,>=1.1.0 2.5.0 MIT pygments Pygments is a syntax highlighting package written in Python. >=2.12 2.13.0 BSD License pymdown-extensions Extension pack for Python Markdown. >=9 9.9 MIT License pyparsing pyparsing module - Classes and methods to define and execute parsing grammars !=3.0.5,>=2.0.2 3.0.9 MIT License pytest pytest: simple powerful testing with Python >=6.2 7.2.0 MIT pytest-cov Pytest plugin for measuring coverage. >=3.0 4.0.0 MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. >=3.10 3.12.0 MIT pytest-xdist pytest xdist plugin for distributed testing and loop-on-failing modes >=2.4 3.0.2 MIT python-dateutil Extensions to the standard Python datetime module >=2.8.1 2.8.2 Dual License pyyaml YAML parser and emitter for Python >=5.2 6.0 MIT pyyaml-env-tag A custom YAML tag for referencing environment variables in YAML files. >=0.1 0.1 MIT License requests Python HTTP for Humans. >=2.26 2.28.1 Apache 2.0 rich Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal >=12.6.0 12.6.0 MIT ruamel.yaml ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order >=0.17.21 0.17.21 MIT license ruamel.yaml.clib C version of reader, parser and emitter for ruamel.yaml derived from libyaml >=0.2.6; platform_python_implementation == \"CPython\" and python_version < \"3.11\" 0.2.7 MIT safety Checks installed dependencies for known vulnerabilities and licenses. >=2 2.3.3 MIT license semver Python helper for Semantic Versioning (http://semver.org/) ~=2.13 2.13.0 BSD setuptools Easily download, build, install, upgrade, and uninstall Python packages >=19.3 65.6.3 MIT License six Python 2 and 3 compatibility utilities >=1.5 1.16.0 MIT smmap A pure Python implementation of a sliding window memory map manager <6,>=3.0.1 5.0.0 BSD snowballstemmer This package provides 29 stemmers for 28 languages generated from Snowball algorithms. 2.2.0 BSD-3-Clause stevedore Manage dynamic plugins for Python applications >=1.20.0 3.5.2 Apache Software License toml Python Library for Tom's Obvious, Minimal Language >=0.10 0.10.2 MIT tomli A lil' TOML parser >=2.0.1; python_version < \"3.11\" 2.0.1 MIT License typed-ast a fork of Python 2 and 3 ast modules with type comment support >=1.4.2; python_version < \"3.8\" and implementation_name == \"cpython\" 1.5.4 Apache License 2.0 types-aiofiles Typing stubs for aiofiles ~=0.7 0.8.11 Apache-2.0 license types-markdown Typing stubs for Markdown >=3.3 3.4.2.1 Apache-2.0 license types-toml Typing stubs for toml >=0.10 0.10.8.1 Apache-2.0 license typing-extensions Backported and Experimental Type Hints for Python 3.7+ >=3.10.0.0; python_version < \"3.10\" 4.4.0 Python Software Foundation License typing-inspect Runtime inspection utilities for typing module. >=0.4.0 0.8.0 MIT urllib3 HTTP library with thread-safe connection pooling, file post, and more. <1.27,>=1.21.1 1.26.13 MIT watchdog Filesystem events monitoring >=2.0 2.1.9 Apache License 2.0 wps-light The strictest and most opinionated python linter ever (lighter fork). >=0.15 0.16.1 MIT zipp Backport of pathlib-compatible object wrapper for zip files >=0.5 3.11.0 MIT License More credits from the author","title":"Credits"},{"location":"docstrings/","text":"Docstrings \u00a4 Griffe provides different docstring parsers allowing to extract even more structured data from source code. The available parsers are: google , to parse Google-style docstrings, see Napoleon's documentation numpy , to parse Numpydoc docstrings, see Numpydoc's documentation sphinx , to parse Sphinx-style docstrings, see Sphinx's documentation Syntax \u00a4 Most of the time, the syntax specified in the aforementioned docs is supported. In some cases, the original syntax is not supported, or is supported but with subtle differences. We will try to document these differences in the following sections. No assumption is made on the markup used in docstrings: it's retrieved as regular text. Tooling making use of Griffe can then choose to render the text as if it is Markdown, or AsciiDoc, or reStructuredText, etc.. Google-style \u00a4 Sections are written like this: section identifier: optional section title section contents All sections identifiers are case-insensitive. All sections support multiple lines in descriptions, as well as blank lines. Some sections also support documenting multiple items. When multiple items are supported, each item description can use multiple lines, and continuation lines must be indented once more so that the parser is able to differentiate items. def foo ( a , b ): \"\"\"Foo. Parameters: a: Here's a. Continuation line 1. Continuation line 2. b: Here's b. \"\"\" It's possible to start a description with a newline if you find it less confusing: def foo ( a , b ): \"\"\"Foo. Parameters: a: Here's a. Continuation line 1. Continuation line 2. b: Here's b. \"\"\" Attributes \u00a4 Multiple items allowed Attributes sections allow to document attributes of a module, class, or class instance. They should be used in modules and classes docstrings only. \"\"\"My module. Attributes: foo: Description for `foo`. bar: Description for `bar`. \"\"\" foo : int = 0 bar : bool = True class MyClass : \"\"\"My class. Attributes: foofoo: Description for `foofoo`. barbar: Description for `barbar`. \"\"\" foofoo : int = 0 def __init__ ( self ): self . barbar : bool = True Type annotations are fetched from the related attributes definitions. You can override those by adding types between parentheses before the colon: \"\"\"My module. Attributes: foo (Integer): Description for `foo`. bar (Boolean): Description for `bar`. \"\"\" Types in docstrings are resolved using the docstrings' parent scope. When documenting an attribute with attr_name (attr_type): Attribute description , attr_type will be resolved using the scope of the docstrings' parent object (class or module). For example, a type of list[str] will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example Optional[Union[int, Tuple[float, float]]] . Deprecated \u00a4 Deprecated sections allow to document a deprecation that happened at a particular version. They can be used in every docstring. \"\"\"My module. Deprecated: 1.2: The `foo` attribute is deprecated. \"\"\" foo : int = 0 Examples \u00a4 Examples sections allow to add examples of Python code without the use of markup code blocks. They are a mix of prose and interactive console snippets. They can be used in every docstring. \"\"\"My module. Examples: Some explanation of what is possible. >>> print(\"hello!\") hello! Blank lines delimit prose vs. console blocks. >>> a = 0 >>> a += 1 >>> a 1 \"\"\" Not the same as Example sections. Example (singular) sections are parsed as admonitions. Console code blocks will only be understood in Examples (plural) sections. Parameters \u00a4 Aliases: Args, Arguments, Params Multiple items allowed Parameters sections allow to document parameters of a function. They are typically used in functions docstrings, but can also be used in dataclasses docstrings. def foo ( a : int , b : str ): \"\"\"Foo. Parameters: a: Here's a. b: Here's b. \"\"\" from dataclasses import dataclass @dataclass class Foo : \"\"\"Foo. Parameters: a: Here's a. b: Here's b. \"\"\" foo : int bar : str Type annotations are fetched from the related parameters definitions. You can override those by adding types between parentheses before the colon: \"\"\"My function. Parameters: foo (Integer): Description for `foo`. bar (String): Description for `bar`. \"\"\" Types in docstrings are resolved using the docstrings' parent scope. When documenting a parameter with param_name (param_type): Parameter description , param_type will be resolved using the scope of the function (or class). For example, a type of list[str] will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example Optional[Union[int, Tuple[float, float]]] . Other Parameters \u00a4 Aliases: Keyword Args, Keyword Arguments, Other Params Multiple items allowed Other parameters sections allow to document secondary parameters such as variadic keyword arguments, or parameters that should be of lesser interest to the user. They are used the same way Parameters sections are, but can also be useful in decorators / to document returned callables. def foo ( a , b , ** kwargs ): \"\"\"Foo. Parameters: a: Here's a. b: Here's b. Other parameters: c (int): Here's c. d (bool): Here's d. \"\"\" def foo ( a , b ): \"\"\"Returns a callable. Parameters: a: Here's a. b: Here's b. Other parameters: Parameters of the returned callable: c (int): Here's c. d (bool): Here's d. \"\"\" def inner ( c , d ): ... return inner Types in docstrings are resolved using the docstrings' parent scope. See the same tip for parameters. Raises \u00a4 Aliases: Exceptions Multiple items allowed Raises sections allow to document exceptions that are raised by a function. They are usually only used in functions docstrings. def foo ( a : int ): \"\"\"Foo. Parameters: a: A value. Raises: ValueError: When `a` is less than 0. \"\"\" if a < 0 : raise ValueError ( \"message\" ) Exceptions names are resolved using the function's scope. ValueError and other built-in exceptions are resolved as such. You can document custom exception, using the names available in the current scope, for example my_exceptions.MyCustomException or MyCustomException directly, depending on what you imported/defined in the current module. Receives \u00a4 Multiple items allowed Receives sections allow to document values that can be sent to generators using their send method. They should be used only in generators docstrings. Documented items can be given a name when it makes sense. from typing import Generator def foo () -> Generator [ int , str , None ]: \"\"\"Foo. Receives: reverse: Reverse the generator if `\"reverse\"` is received. Yields: Integers from 0 to 9. Examples: >>> gen = foo() >>> next(gen) 0 >>> next(gen) 1 >>> next(gen) 2 >>> gen.send(\"reverse\") 2 >>> next(gen) 1 >>> next(gen) 0 >>> next(gen) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> StopIteration \"\"\" for i in range ( 10 ): received = yield i if received == \"reverse\" : for j in range ( i , - 1 , - 1 ): yield j break Type annotations are fetched from the function return annotation when the annotation is typing.Generator . If your generator is able to receive tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly: def foo () -> Generator [ int , tuple [ str , bool ], None ]: \"\"\"Foo. Receives: mode: Some mode. flag: Some flag. ... \"\"\" ... Type annotations can as usual be overridden using types in parentheses in the docstring itself: \"\"\"Foo. Receives: mode (ModeEnum): Some mode. flag (int): Some flag. \"\"\" Types in docstrings are resolved using the docstrings' parent scope. See previous tips for types in docstrings. Returns \u00a4 Multiple items allowed Returns sections allow to document values returned by functions. They should be used only in functions docstrings. Documented items can be given a name when it makes sense. import random def foo () -> int : \"\"\"Foo. Returns: A random integer. \"\"\" return random . randint ( 0 , 100 ) Type annotations are fetched from the function return annotation. If your function returns tuples of values, you can document each item of the tuple separately, and the type annotation will be fetched accordingly: def foo () -> tuple [ bool , float ]: \"\"\"Foo. Returns: success: Whether it succeeded. precision: Final precision. ... \"\"\" ... Type annotations can as usual be overridden using types in parentheses in the docstring itself: \"\"\"Foo. Returns: success (int): Whether it succeeded. precision (Decimal): Final precision. \"\"\" Types in docstrings are resolved using the docstrings' function scope. See previous tips for types in docstrings. Continuation lines for a single returned item must still be indented. Even when your function returns a single value, you must indent continuation lines of its description so that the parser does not think you are documenting multiple items. Warns \u00a4 Multiple items allowed Warns sections allow to document warnings emitted by the following code. They are usually only used in functions docstrings. import warnings def foo (): \"\"\"Foo. Warns: UserWarning: To annoy users. \"\"\" warnings . warn ( \"Just messing with you.\" , UserWarning ) Warnings names are resolved using the function's scope. UserWarning and other built-in warnings are resolved as such. You can document custom warnings, using the names available in the current scope, for example my_warnings.MyCustomWarning or MyCustomWarning directly, depending on what you imported/defined in the current module. Yields \u00a4 Multiple items allowed Yields sections allow to document values that generator yield. They should be used only in generators docstrings. Documented items can be given a name when it makes sense. from typing import Iterator def foo () -> Iterator [ int ]: \"\"\"Foo. Yields: Integers from 0 to 9. \"\"\" for i in range ( 10 ): yield i Type annotations are fetched from the function return annotation when the annotation is typing.Generator or typing.Iterator . If your generator yields tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly: from datetime import datetime def foo () -> Iterator [ tuple [ float , float , datetime ]]: \"\"\"Foo. Yields: x: Absissa. y: Ordinate. t: Time. ... \"\"\" ... Type annotations can as usual be overridden using types in parentheses in the docstring itself: \"\"\"Foo. Yields: x (int): Absissa. y (int): Ordinate. t (int): Timestamp. Types in docstrings are resolved using the docstrings' parent scope. See previous tips for types in docstrings. Parsers features \u00a4 Want to contribute? Each red cross is a link to an issue on the bugtracker. You will find some guidance on how to add support for the corresponding item. The sections are easier to deal in that order: Deprecated (single item, version and text) Raises, Warns (multiple items, no names, single type each) Attributes, Other Parameters, Parameters (multiple items, one name and one optional type each) Returns (multiple items, optional name and/or type each, annotation to split when multiple names) Receives, Yields (multiple items, optional name and/or type each, several types of annotations to split when multiple names) \"Examples\" section are a bit different as they require to parse the examples. But you can probably reuse the code in the Google parser. We can probably even factorize the examples parsing into a single function. You can tackle several items at once in a single PR, as long as they relate to a single parser or a single section (a line or a column of the following tables). Sections \u00a4 Section Google Numpy Sphinx Attributes \u2705 \u2705 \u2705 Deprecated \u2705 \u2705 1 \u274c Examples \u2705 \u2705 \u274c Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises \u2705 \u2705 \u2705 Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705 Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c Getting annotations/defaults from parent \u00a4 Section Google Numpy Sphinx Attributes \u2705 \u2705 \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises / / / Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705 Warns / / / Yields \u2705 \u2705 \u274c Cross-references for annotations in docstrings \u00a4 Section Google Numpy Sphinx Attributes \u2705 \u2705 \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u274c Raises \u2705 \u2705 \u274c Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u274c Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c Parsing options \u00a4 Option Google Numpy Sphinx Ignore __init__ summary \u2705 \u2705 \u274c Trim doctest flags \u2705 \u2705 \u274c Warn about unknown params \u2705 \u2705 \u274c Support for a regular section instead of the RST directive specified in the Numpydoc styleguide . \u21a9","title":"Supported styles"},{"location":"docstrings/#docstrings","text":"Griffe provides different docstring parsers allowing to extract even more structured data from source code. The available parsers are: google , to parse Google-style docstrings, see Napoleon's documentation numpy , to parse Numpydoc docstrings, see Numpydoc's documentation sphinx , to parse Sphinx-style docstrings, see Sphinx's documentation","title":"Docstrings"},{"location":"docstrings/#syntax","text":"Most of the time, the syntax specified in the aforementioned docs is supported. In some cases, the original syntax is not supported, or is supported but with subtle differences. We will try to document these differences in the following sections. No assumption is made on the markup used in docstrings: it's retrieved as regular text. Tooling making use of Griffe can then choose to render the text as if it is Markdown, or AsciiDoc, or reStructuredText, etc..","title":"Syntax"},{"location":"docstrings/#google-style","text":"Sections are written like this: section identifier: optional section title section contents All sections identifiers are case-insensitive. All sections support multiple lines in descriptions, as well as blank lines. Some sections also support documenting multiple items. When multiple items are supported, each item description can use multiple lines, and continuation lines must be indented once more so that the parser is able to differentiate items. def foo ( a , b ): \"\"\"Foo. Parameters: a: Here's a. Continuation line 1. Continuation line 2. b: Here's b. \"\"\" It's possible to start a description with a newline if you find it less confusing: def foo ( a , b ): \"\"\"Foo. Parameters: a: Here's a. Continuation line 1. Continuation line 2. b: Here's b. \"\"\"","title":"Google-style"},{"location":"docstrings/#attributes","text":"Multiple items allowed Attributes sections allow to document attributes of a module, class, or class instance. They should be used in modules and classes docstrings only. \"\"\"My module. Attributes: foo: Description for `foo`. bar: Description for `bar`. \"\"\" foo : int = 0 bar : bool = True class MyClass : \"\"\"My class. Attributes: foofoo: Description for `foofoo`. barbar: Description for `barbar`. \"\"\" foofoo : int = 0 def __init__ ( self ): self . barbar : bool = True Type annotations are fetched from the related attributes definitions. You can override those by adding types between parentheses before the colon: \"\"\"My module. Attributes: foo (Integer): Description for `foo`. bar (Boolean): Description for `bar`. \"\"\" Types in docstrings are resolved using the docstrings' parent scope. When documenting an attribute with attr_name (attr_type): Attribute description , attr_type will be resolved using the scope of the docstrings' parent object (class or module). For example, a type of list[str] will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example Optional[Union[int, Tuple[float, float]]] .","title":"Attributes"},{"location":"docstrings/#deprecated","text":"Deprecated sections allow to document a deprecation that happened at a particular version. They can be used in every docstring. \"\"\"My module. Deprecated: 1.2: The `foo` attribute is deprecated. \"\"\" foo : int = 0","title":"Deprecated"},{"location":"docstrings/#examples","text":"Examples sections allow to add examples of Python code without the use of markup code blocks. They are a mix of prose and interactive console snippets. They can be used in every docstring. \"\"\"My module. Examples: Some explanation of what is possible. >>> print(\"hello!\") hello! Blank lines delimit prose vs. console blocks. >>> a = 0 >>> a += 1 >>> a 1 \"\"\" Not the same as Example sections. Example (singular) sections are parsed as admonitions. Console code blocks will only be understood in Examples (plural) sections.","title":"Examples"},{"location":"docstrings/#parameters","text":"Aliases: Args, Arguments, Params Multiple items allowed Parameters sections allow to document parameters of a function. They are typically used in functions docstrings, but can also be used in dataclasses docstrings. def foo ( a : int , b : str ): \"\"\"Foo. Parameters: a: Here's a. b: Here's b. \"\"\" from dataclasses import dataclass @dataclass class Foo : \"\"\"Foo. Parameters: a: Here's a. b: Here's b. \"\"\" foo : int bar : str Type annotations are fetched from the related parameters definitions. You can override those by adding types between parentheses before the colon: \"\"\"My function. Parameters: foo (Integer): Description for `foo`. bar (String): Description for `bar`. \"\"\" Types in docstrings are resolved using the docstrings' parent scope. When documenting a parameter with param_name (param_type): Parameter description , param_type will be resolved using the scope of the function (or class). For example, a type of list[str] will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example Optional[Union[int, Tuple[float, float]]] .","title":"Parameters"},{"location":"docstrings/#other-parameters","text":"Aliases: Keyword Args, Keyword Arguments, Other Params Multiple items allowed Other parameters sections allow to document secondary parameters such as variadic keyword arguments, or parameters that should be of lesser interest to the user. They are used the same way Parameters sections are, but can also be useful in decorators / to document returned callables. def foo ( a , b , ** kwargs ): \"\"\"Foo. Parameters: a: Here's a. b: Here's b. Other parameters: c (int): Here's c. d (bool): Here's d. \"\"\" def foo ( a , b ): \"\"\"Returns a callable. Parameters: a: Here's a. b: Here's b. Other parameters: Parameters of the returned callable: c (int): Here's c. d (bool): Here's d. \"\"\" def inner ( c , d ): ... return inner Types in docstrings are resolved using the docstrings' parent scope. See the same tip for parameters.","title":"Other Parameters"},{"location":"docstrings/#raises","text":"Aliases: Exceptions Multiple items allowed Raises sections allow to document exceptions that are raised by a function. They are usually only used in functions docstrings. def foo ( a : int ): \"\"\"Foo. Parameters: a: A value. Raises: ValueError: When `a` is less than 0. \"\"\" if a < 0 : raise ValueError ( \"message\" ) Exceptions names are resolved using the function's scope. ValueError and other built-in exceptions are resolved as such. You can document custom exception, using the names available in the current scope, for example my_exceptions.MyCustomException or MyCustomException directly, depending on what you imported/defined in the current module.","title":"Raises"},{"location":"docstrings/#receives","text":"Multiple items allowed Receives sections allow to document values that can be sent to generators using their send method. They should be used only in generators docstrings. Documented items can be given a name when it makes sense. from typing import Generator def foo () -> Generator [ int , str , None ]: \"\"\"Foo. Receives: reverse: Reverse the generator if `\"reverse\"` is received. Yields: Integers from 0 to 9. Examples: >>> gen = foo() >>> next(gen) 0 >>> next(gen) 1 >>> next(gen) 2 >>> gen.send(\"reverse\") 2 >>> next(gen) 1 >>> next(gen) 0 >>> next(gen) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> StopIteration \"\"\" for i in range ( 10 ): received = yield i if received == \"reverse\" : for j in range ( i , - 1 , - 1 ): yield j break Type annotations are fetched from the function return annotation when the annotation is typing.Generator . If your generator is able to receive tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly: def foo () -> Generator [ int , tuple [ str , bool ], None ]: \"\"\"Foo. Receives: mode: Some mode. flag: Some flag. ... \"\"\" ... Type annotations can as usual be overridden using types in parentheses in the docstring itself: \"\"\"Foo. Receives: mode (ModeEnum): Some mode. flag (int): Some flag. \"\"\" Types in docstrings are resolved using the docstrings' parent scope. See previous tips for types in docstrings.","title":"Receives"},{"location":"docstrings/#returns","text":"Multiple items allowed Returns sections allow to document values returned by functions. They should be used only in functions docstrings. Documented items can be given a name when it makes sense. import random def foo () -> int : \"\"\"Foo. Returns: A random integer. \"\"\" return random . randint ( 0 , 100 ) Type annotations are fetched from the function return annotation. If your function returns tuples of values, you can document each item of the tuple separately, and the type annotation will be fetched accordingly: def foo () -> tuple [ bool , float ]: \"\"\"Foo. Returns: success: Whether it succeeded. precision: Final precision. ... \"\"\" ... Type annotations can as usual be overridden using types in parentheses in the docstring itself: \"\"\"Foo. Returns: success (int): Whether it succeeded. precision (Decimal): Final precision. \"\"\" Types in docstrings are resolved using the docstrings' function scope. See previous tips for types in docstrings. Continuation lines for a single returned item must still be indented. Even when your function returns a single value, you must indent continuation lines of its description so that the parser does not think you are documenting multiple items.","title":"Returns"},{"location":"docstrings/#warns","text":"Multiple items allowed Warns sections allow to document warnings emitted by the following code. They are usually only used in functions docstrings. import warnings def foo (): \"\"\"Foo. Warns: UserWarning: To annoy users. \"\"\" warnings . warn ( \"Just messing with you.\" , UserWarning ) Warnings names are resolved using the function's scope. UserWarning and other built-in warnings are resolved as such. You can document custom warnings, using the names available in the current scope, for example my_warnings.MyCustomWarning or MyCustomWarning directly, depending on what you imported/defined in the current module.","title":"Warns"},{"location":"docstrings/#yields","text":"Multiple items allowed Yields sections allow to document values that generator yield. They should be used only in generators docstrings. Documented items can be given a name when it makes sense. from typing import Iterator def foo () -> Iterator [ int ]: \"\"\"Foo. Yields: Integers from 0 to 9. \"\"\" for i in range ( 10 ): yield i Type annotations are fetched from the function return annotation when the annotation is typing.Generator or typing.Iterator . If your generator yields tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly: from datetime import datetime def foo () -> Iterator [ tuple [ float , float , datetime ]]: \"\"\"Foo. Yields: x: Absissa. y: Ordinate. t: Time. ... \"\"\" ... Type annotations can as usual be overridden using types in parentheses in the docstring itself: \"\"\"Foo. Yields: x (int): Absissa. y (int): Ordinate. t (int): Timestamp. Types in docstrings are resolved using the docstrings' parent scope. See previous tips for types in docstrings.","title":"Yields"},{"location":"docstrings/#parsers-features","text":"Want to contribute? Each red cross is a link to an issue on the bugtracker. You will find some guidance on how to add support for the corresponding item. The sections are easier to deal in that order: Deprecated (single item, version and text) Raises, Warns (multiple items, no names, single type each) Attributes, Other Parameters, Parameters (multiple items, one name and one optional type each) Returns (multiple items, optional name and/or type each, annotation to split when multiple names) Receives, Yields (multiple items, optional name and/or type each, several types of annotations to split when multiple names) \"Examples\" section are a bit different as they require to parse the examples. But you can probably reuse the code in the Google parser. We can probably even factorize the examples parsing into a single function. You can tackle several items at once in a single PR, as long as they relate to a single parser or a single section (a line or a column of the following tables).","title":"Parsers features"},{"location":"docstrings/#sections","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u2705 Deprecated \u2705 \u2705 1 \u274c Examples \u2705 \u2705 \u274c Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises \u2705 \u2705 \u2705 Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705 Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c","title":"Sections"},{"location":"docstrings/#getting-annotationsdefaults-from-parent","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises / / / Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705 Warns / / / Yields \u2705 \u2705 \u274c","title":"Getting annotations/defaults from parent"},{"location":"docstrings/#cross-references-for-annotations-in-docstrings","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u274c Raises \u2705 \u2705 \u274c Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u274c Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c","title":"Cross-references for annotations in docstrings"},{"location":"docstrings/#parsing-options","text":"Option Google Numpy Sphinx Ignore __init__ summary \u2705 \u2705 \u274c Trim doctest flags \u2705 \u2705 \u274c Warn about unknown params \u2705 \u2705 \u274c Support for a regular section instead of the RST directive specified in the Numpydoc styleguide . \u21a9","title":"Parsing options"},{"location":"dumping/","text":"Dumping packages' signatures as JSON \u00a4 Griffe can be used to load packages' signatures and output them as JSON on the standard output or in writable files. Pass the names of packages to the griffe dump command: $ griffe dump httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages' signatures. Try it out on Griffe itself: $ griffe dump griffe [ { \"name\": \"griffe\", ... } ] To output in a file instead of standard output, use the --output or -o option: $ griffe dump griffe -o griffe.json If you load multiple packages' signatures, you can dump each in its own file with a templated filepath: $ griffe dump griffe -o './dumps/{package}.json' By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError . For an example of what real data looks like, see the full Griffe JSON dump .","title":"Dumping data as JSON"},{"location":"dumping/#dumping-packages-signatures-as-json","text":"Griffe can be used to load packages' signatures and output them as JSON on the standard output or in writable files. Pass the names of packages to the griffe dump command: $ griffe dump httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages' signatures. Try it out on Griffe itself: $ griffe dump griffe [ { \"name\": \"griffe\", ... } ] To output in a file instead of standard output, use the --output or -o option: $ griffe dump griffe -o griffe.json If you load multiple packages' signatures, you can dump each in its own file with a templated filepath: $ griffe dump griffe -o './dumps/{package}.json' By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError . For an example of what real data looks like, see the full Griffe JSON dump .","title":"Dumping packages' signatures as JSON"},{"location":"extensions/","text":"Extensions \u00a4 You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import VisitorExtension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( VisitorExtension ): when = When . after_all def visit_classdef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of a custom version of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE_LOWER> methods to visit nodes of certain types, and act on their properties. See the full list of AST nodes . Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not visit child nodes in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children. You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_functiondef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, attribute See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit/inspection: When.before_all . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is not yet instantiated. before the children visit/inspection: When.before_children . If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is now instantiated. Children have not yet been visited/inspected. after the children visit/inspection: When.after_children . Children have now been visited/inspected. after the visit/inspection: When.after_all See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . after_children By default, it will run the extension after the visit/inspection of the node: that's when the full data for this node and its children is loaded. AST nodes \u00a4 Add alias And AnnAssign arg arguments Assert Assign AsyncFor AsyncFunctionDef AsyncWith Attribute AugAssign Await BinOp BitAnd BitOr BitXor BoolOp Break Bytes 1 Call ClassDef Compare comprehension Constant Continue Del Delete Dict DictComp Div Ellipsis 1 Eq ExceptHandler Expr Expression 1 ExtSlice 2 FloorDiv For FormattedValue FunctionDef GeneratorExp Global Gt GtE If IfExp Import ImportFrom In Index 2 Interactive 3 Invert Is IsNot JoinedStr keyword Lambda List ListComp Load LShift Lt LtE Match MatchAs match_case MatchClass MatchMapping MatchOr MatchSequence MatchSingleton MatchStar MatchValue MatMult Mod Module 3 Mult Name NameConstant 1 NamedExpr Nonlocal Not NotEq NotIn Num 1 Or Pass pattern 3 Pow Print 4 Raise Return RShift Set SetComp Slice Starred Store Str 1 Sub Subscript Try TryExcept 5 TryFinally 6 Tuple UAdd UnaryOp USub While With withitem Yield YieldFrom Deprecated since Python 3.8. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Deprecated since Python 3.9. \u21a9 \u21a9 Not documented. \u21a9 \u21a9 \u21a9 print became a builtin (instead of a keyword) in Python 3. \u21a9 Now ExceptHandler , in the handlers attribute of Try nodes. \u21a9 Now a list of expressions in the finalbody attribute of Try nodes. \u21a9","title":"Using and writing extensions"},{"location":"extensions/#extensions","text":"You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import VisitorExtension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( VisitorExtension ): when = When . after_all def visit_classdef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of a custom version of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE_LOWER> methods to visit nodes of certain types, and act on their properties. See the full list of AST nodes . Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not visit child nodes in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children. You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_functiondef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, attribute See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit/inspection: When.before_all . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is not yet instantiated. before the children visit/inspection: When.before_children . If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is now instantiated. Children have not yet been visited/inspected. after the children visit/inspection: When.after_children . Children have now been visited/inspected. after the visit/inspection: When.after_all See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . after_children By default, it will run the extension after the visit/inspection of the node: that's when the full data for this node and its children is loaded.","title":"Extensions"},{"location":"extensions/#ast-nodes","text":"Add alias And AnnAssign arg arguments Assert Assign AsyncFor AsyncFunctionDef AsyncWith Attribute AugAssign Await BinOp BitAnd BitOr BitXor BoolOp Break Bytes 1 Call ClassDef Compare comprehension Constant Continue Del Delete Dict DictComp Div Ellipsis 1 Eq ExceptHandler Expr Expression 1 ExtSlice 2 FloorDiv For FormattedValue FunctionDef GeneratorExp Global Gt GtE If IfExp Import ImportFrom In Index 2 Interactive 3 Invert Is IsNot JoinedStr keyword Lambda List ListComp Load LShift Lt LtE Match MatchAs match_case MatchClass MatchMapping MatchOr MatchSequence MatchSingleton MatchStar MatchValue MatMult Mod Module 3 Mult Name NameConstant 1 NamedExpr Nonlocal Not NotEq NotIn Num 1 Or Pass pattern 3 Pow Print 4 Raise Return RShift Set SetComp Slice Starred Store Str 1 Sub Subscript Try TryExcept 5 TryFinally 6 Tuple UAdd UnaryOp USub While With withitem Yield YieldFrom Deprecated since Python 3.8. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Deprecated since Python 3.9. \u21a9 \u21a9 Not documented. \u21a9 \u21a9 \u21a9 print became a builtin (instead of a keyword) in Python 3. \u21a9 Now ExceptHandler , in the handlers attribute of Try nodes. \u21a9 Now a list of expressions in the finalbody attribute of Try nodes. \u21a9","title":"AST nodes"},{"location":"license/","text":"ISC License Copyright (c) 2021, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"loading/","text":"Loading data with Python \u00a4 Griffe provides a shorcut function for simple needs: import griffe mkdocs = griffe . load ( \"mkdocs\" ) The load function accepts a number of parameters. For more complex needs, create and use a loader: from griffe.loader import GriffeLoader loader = GriffeLoader () mkdocs = loader . load_module ( \"mkdocs\" ) Similarly, the GriffeLoader accepts a number of parameters to configure how the modules are found and loaded. If you don't want to recurse in the submodules: mkdocs = loader . load_module ( \"mkdocs\" , submodules = False ) Navigating into the loaded objects \u00a4 Both the load function and the GriffeLoader.load_module method return a Module instance. There are several ways to access members of an object: through its members attribute, which is a dictionary, with the usual keys() , values() and items() methods. thanks to its __getitem__ method. For example griffe[\"dataclasses\"] returns the Module instance representing Griffe's dataclasses module. Since this module also has members, you can chain calls: griffe[\"dataclasses\"][\"Module\"] . Conveniently, you can chain the names with dots in a single call: griffe[\"dataclasses.Module\"] . You can even pass a tuple instead of a string: griffe[(\"dataclasses\", \"Module\")] . through the modules , classes , functions and attributes properties, which take care of filtering members based on their kind, and return dictionaries. Most of the time, you will only use classes from the griffe.dataclasses and griffe.docstrings.dataclasses modules.","title":"Loading and navigating data"},{"location":"loading/#loading-data-with-python","text":"Griffe provides a shorcut function for simple needs: import griffe mkdocs = griffe . load ( \"mkdocs\" ) The load function accepts a number of parameters. For more complex needs, create and use a loader: from griffe.loader import GriffeLoader loader = GriffeLoader () mkdocs = loader . load_module ( \"mkdocs\" ) Similarly, the GriffeLoader accepts a number of parameters to configure how the modules are found and loaded. If you don't want to recurse in the submodules: mkdocs = loader . load_module ( \"mkdocs\" , submodules = False )","title":"Loading data with Python"},{"location":"loading/#navigating-into-the-loaded-objects","text":"Both the load function and the GriffeLoader.load_module method return a Module instance. There are several ways to access members of an object: through its members attribute, which is a dictionary, with the usual keys() , values() and items() methods. thanks to its __getitem__ method. For example griffe[\"dataclasses\"] returns the Module instance representing Griffe's dataclasses module. Since this module also has members, you can chain calls: griffe[\"dataclasses\"][\"Module\"] . Conveniently, you can chain the names with dots in a single call: griffe[\"dataclasses.Module\"] . You can even pass a tuple instead of a string: griffe[(\"dataclasses\", \"Module\")] . through the modules , classes , functions and attributes properties, which take care of filtering members based on their kind, and return dictionaries. Most of the time, you will only use classes from the griffe.dataclasses and griffe.docstrings.dataclasses modules.","title":"Navigating into the loaded objects"},{"location":"parsing_docstrings/","text":"Using Griffe as a docstring-parsing library \u00a4 You can use Griffe to parse arbitrary docstrings. You don't have to load anything through the Griffe loader. You need to import the parse function, the Parser enumeration, and the Docstring class. Then you can build a Docstring instance and call parse on it, choosing the parsing-style to use: from griffe.dataclasses import Docstring from griffe.docstrings.parsers import Parser , parse text = \"Hello I'm a docstring!\" docstring = Docstring ( text , lineno = 1 ) parsed = parse ( docstring , Parser . google ) If you want to take advantage of the parsers ability to fetch annotations from the object from which the docstring originates, you can manually create the parent objects and link them to the docstring: from griffe.dataclasses import Docstring , Function , Parameters , Parameter , ParameterKind from griffe.docstrings.parsers import Parser , parse function = Function ( \"func\" , parameters = Parameters ( Parameter ( \"param1\" , annotation = \"str\" , kind = ParameterKind . positional_or_keyword ), Parameter ( \"param2\" , annotation = \"int\" , kind = ParameterKind . keyword_only ), ) ) text = \"\"\" Hello I'm a docstring! Parameters: param1: Description. param2: Description. \"\"\" docstring = Docstring ( text , lineno = 1 , parent = function ) parsed = parse ( docstring , Parser . google ) With this the parser will fetch the str and int annotations from the parent function's parameters.","title":"Parsing docstrings in Python"},{"location":"parsing_docstrings/#using-griffe-as-a-docstring-parsing-library","text":"You can use Griffe to parse arbitrary docstrings. You don't have to load anything through the Griffe loader. You need to import the parse function, the Parser enumeration, and the Docstring class. Then you can build a Docstring instance and call parse on it, choosing the parsing-style to use: from griffe.dataclasses import Docstring from griffe.docstrings.parsers import Parser , parse text = \"Hello I'm a docstring!\" docstring = Docstring ( text , lineno = 1 ) parsed = parse ( docstring , Parser . google ) If you want to take advantage of the parsers ability to fetch annotations from the object from which the docstring originates, you can manually create the parent objects and link them to the docstring: from griffe.dataclasses import Docstring , Function , Parameters , Parameter , ParameterKind from griffe.docstrings.parsers import Parser , parse function = Function ( \"func\" , parameters = Parameters ( Parameter ( \"param1\" , annotation = \"str\" , kind = ParameterKind . positional_or_keyword ), Parameter ( \"param2\" , annotation = \"int\" , kind = ParameterKind . keyword_only ), ) ) text = \"\"\" Hello I'm a docstring! Parameters: param1: Description. param2: Description. \"\"\" docstring = Docstring ( text , lineno = 1 , parent = function ) parsed = parse ( docstring , Parser . google ) With this the parser will fetch the str and int annotations from the parent function's parameters.","title":"Using Griffe as a docstring-parsing library"},{"location":"usage/","text":"window.location.href = \"../cli_reference\"; Redirecting...","title":"Usage"},{"location":"reference/SUMMARY/","text":"griffe agents base extensions hybrid inspector nodes visitor cli collections dataclasses diff docstrings dataclasses google markdown numpy parsers sphinx utils encoders exceptions expressions finder git importer loader logger merger mixins stats","title":"SUMMARY"},{"location":"reference/griffe/","text":"griffe package. Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. load \u00a4 load ( module , submodules = True , try_relative_path = True , extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True , ) Load and return a module. Example: import griffe module = griffe . load ( ... ) This is a shortcut for: from griffe.loader import GriffeLoader loader = GriffeLoader ( ... ) module = loader . load_module ( ... ) See the documentation for the loader: GriffeLoader . Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Returns: Module \u2013 A loaded module. Source code in griffe/loader.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 def load ( module : str | Path , submodules : bool = True , try_relative_path : bool = True , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> Module : \"\"\"Load and return a module. Example: ```python import griffe module = griffe.load(...) ``` This is a shortcut for: ```python from griffe.loader import GriffeLoader loader = GriffeLoader(...) module = loader.load_module(...) ``` See the documentation for the loader: [`GriffeLoader`][griffe.loader.GriffeLoader]. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. try_relative_path: Whether to try finding the module as a relative path. extensions: The extensions to use. search_paths: The paths to search into. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. Returns: A loaded module. \"\"\" return GriffeLoader ( extensions = extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , allow_inspection = allow_inspection , ) . load_module ( module = module , submodules = submodules , try_relative_path = try_relative_path , ) load_git \u00a4 load_git ( module , * , ref = \"HEAD\" , repo = \".\" , submodules = True , extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True ) Load and return a module from a specific Git reference. This function will create a temporary git worktree at the requested reference before loading module with griffe.load . This function requires that the git executable is installed. Parameters: module ( str | Path ) \u2013 The module path, relative to the repository root. ref ( str ) \u2013 A Git reference such as a commit, tag or branch. repo ( str | Path ) \u2013 Path to the repository (i.e. the directory containing the .git directory) submodules ( bool ) \u2013 Whether to recurse on the submodules. extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into (relative to the repository root). docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Returns: Module \u2013 A loaded module. Source code in griffe/git.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def load_git ( module : str | Path , * , ref : str = \"HEAD\" , repo : str | Path = \".\" , submodules : bool = True , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> Module : \"\"\"Load and return a module from a specific Git reference. This function will create a temporary [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference before loading `module` with [`griffe.load`][griffe.loader.load]. This function requires that the `git` executable is installed. Parameters: module: The module path, relative to the repository root. ref: A Git reference such as a commit, tag or branch. repo: Path to the repository (i.e. the directory *containing* the `.git` directory) submodules: Whether to recurse on the submodules. extensions: The extensions to use. search_paths: The paths to search into (relative to the repository root). docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. Returns: A loaded module. \"\"\" with tmp_worktree ( repo , ref ) as worktree : search_paths = [ worktree / path for path in search_paths or [ \".\" ]] if isinstance ( module , Path ): module = worktree / module return loader . load ( module = module , submodules = submodules , try_relative_path = False , extensions = extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , allow_inspection = allow_inspection , )","title":"griffe"},{"location":"reference/griffe/#griffe.load","text":"load ( module , submodules = True , try_relative_path = True , extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True , ) Load and return a module. Example: import griffe module = griffe . load ( ... ) This is a shortcut for: from griffe.loader import GriffeLoader loader = GriffeLoader ( ... ) module = loader . load_module ( ... ) See the documentation for the loader: GriffeLoader . Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Returns: Module \u2013 A loaded module. Source code in griffe/loader.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 def load ( module : str | Path , submodules : bool = True , try_relative_path : bool = True , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> Module : \"\"\"Load and return a module. Example: ```python import griffe module = griffe.load(...) ``` This is a shortcut for: ```python from griffe.loader import GriffeLoader loader = GriffeLoader(...) module = loader.load_module(...) ``` See the documentation for the loader: [`GriffeLoader`][griffe.loader.GriffeLoader]. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. try_relative_path: Whether to try finding the module as a relative path. extensions: The extensions to use. search_paths: The paths to search into. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. Returns: A loaded module. \"\"\" return GriffeLoader ( extensions = extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , allow_inspection = allow_inspection , ) . load_module ( module = module , submodules = submodules , try_relative_path = try_relative_path , )","title":"load()"},{"location":"reference/griffe/#griffe.load_git","text":"load_git ( module , * , ref = \"HEAD\" , repo = \".\" , submodules = True , extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True ) Load and return a module from a specific Git reference. This function will create a temporary git worktree at the requested reference before loading module with griffe.load . This function requires that the git executable is installed. Parameters: module ( str | Path ) \u2013 The module path, relative to the repository root. ref ( str ) \u2013 A Git reference such as a commit, tag or branch. repo ( str | Path ) \u2013 Path to the repository (i.e. the directory containing the .git directory) submodules ( bool ) \u2013 Whether to recurse on the submodules. extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into (relative to the repository root). docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Returns: Module \u2013 A loaded module. Source code in griffe/git.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def load_git ( module : str | Path , * , ref : str = \"HEAD\" , repo : str | Path = \".\" , submodules : bool = True , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> Module : \"\"\"Load and return a module from a specific Git reference. This function will create a temporary [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference before loading `module` with [`griffe.load`][griffe.loader.load]. This function requires that the `git` executable is installed. Parameters: module: The module path, relative to the repository root. ref: A Git reference such as a commit, tag or branch. repo: Path to the repository (i.e. the directory *containing* the `.git` directory) submodules: Whether to recurse on the submodules. extensions: The extensions to use. search_paths: The paths to search into (relative to the repository root). docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. Returns: A loaded module. \"\"\" with tmp_worktree ( repo , ref ) as worktree : search_paths = [ worktree / path for path in search_paths or [ \".\" ]] if isinstance ( module , Path ): module = worktree / module return loader . load ( module = module , submodules = submodules , try_relative_path = False , extensions = extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , allow_inspection = allow_inspection , )","title":"load_git()"},{"location":"reference/griffe/cli/","text":"Module that contains the command line application. check \u00a4 check ( package , against = None , against_path = None , * , base_ref = None , extensions = None , search_paths = None , allow_inspection = True , verbose = False ) Load packages data and dump it as JSON. Parameters: package ( str | Path ) \u2013 The package to load and check. against ( str | None ) \u2013 Older Git reference (commit, branch, tag) to check against. against_path ( str | Path | None ) \u2013 Path when the \"against\" reference is checked out. base_ref ( str | None ) \u2013 Git reference (commit, branch, tag) to check. extensions ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. verbose ( bool ) \u2013 Use a verbose output. Returns: int \u2013 0 for success, 1 for failure. Source code in griffe/cli.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 def check ( package : str | Path , against : str | None = None , against_path : str | Path | None = None , * , base_ref : str | None = None , extensions : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] | None = None , search_paths : Sequence [ str | Path ] | None = None , allow_inspection : bool = True , verbose : bool = False , ) -> int : \"\"\"Load packages data and dump it as JSON. Parameters: package: The package to load and check. against: Older Git reference (commit, branch, tag) to check against. against_path: Path when the \"against\" reference is checked out. base_ref: Git reference (commit, branch, tag) to check. extensions: The extensions to use. search_paths: The paths to search into. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. verbose: Use a verbose output. Returns: `0` for success, `1` for failure. \"\"\" colorama . deinit () colorama . init () search_paths = list ( search_paths ) if search_paths else [] against = against or _get_latest_tag ( package ) against_path = against_path or package repository = _get_repo_root ( against_path ) try : loaded_extensions = load_extensions ( extensions or ()) except ExtensionError as error : logger . error ( error ) return 1 old_package = load_git ( against_path , ref = against , repo = repository , extensions = loaded_extensions , search_paths = search_paths , allow_inspection = allow_inspection , ) if base_ref : new_package = load_git ( package , ref = base_ref , repo = repository , extensions = loaded_extensions , search_paths = search_paths , allow_inspection = allow_inspection , ) else : new_package = load ( package , try_relative_path = True , extensions = loaded_extensions , search_paths = search_paths , allow_inspection = allow_inspection , ) if verbose : style = ExplanationStyle . VERBOSE else : style = ExplanationStyle . ONE_LINE breakages = list ( find_breaking_changes ( old_package , new_package )) for breakage in breakages : print ( breakage . explain ( style = style ), file = sys . stderr ) if breakages : return 1 return 0 dump \u00a4 dump ( packages , * , output = None , full = False , docstring_parser = None , docstring_options = None , extensions = None , resolve_aliases = False , resolve_implicit = False , resolve_external = False , search_paths = None , append_sys_path = False , allow_inspection = True , stats = False ) Load packages data and dump it as JSON. Parameters: packages ( Sequence [ str ] ) \u2013 The packages to load and dump. output ( str | IO | None ) \u2013 Where to output the JSON-serialized data. full ( bool ) \u2013 Whether to output full or minimal data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. resolve_aliases ( bool ) \u2013 Whether to resolve aliases (indirect objects references). resolve_implicit ( bool ) \u2013 Whether to resolve every alias or only the explicitly exported ones. resolve_external ( bool ) \u2013 Whether to load additional, unspecified modules to resolve aliases. extensions ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. append_sys_path ( bool ) \u2013 Whether to append the contents of sys.path to the search paths. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. stats ( bool ) \u2013 Whether to compute and log stats about loading. Returns: int \u2013 0 for success, 1 for failure. Source code in griffe/cli.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 def dump ( packages : Sequence [ str ], * , output : str | IO | None = None , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , extensions : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] | None = None , resolve_aliases : bool = False , resolve_implicit : bool = False , resolve_external : bool = False , search_paths : Sequence [ str | Path ] | None = None , append_sys_path : bool = False , allow_inspection : bool = True , stats : bool = False , ) -> int : \"\"\"Load packages data and dump it as JSON. Parameters: packages: The packages to load and dump. output: Where to output the JSON-serialized data. full: Whether to output full or minimal data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. resolve_aliases: Whether to resolve aliases (indirect objects references). resolve_implicit: Whether to resolve every alias or only the explicitly exported ones. resolve_external: Whether to load additional, unspecified modules to resolve aliases. extensions: The extensions to use. search_paths: The paths to search into. append_sys_path: Whether to append the contents of `sys.path` to the search paths. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. stats: Whether to compute and log stats about loading. Returns: `0` for success, `1` for failure. \"\"\" per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search_paths = list ( search_paths ) if search_paths else [] if append_sys_path : search_paths . extend ( sys . path ) try : loaded_extensions = load_extensions ( extensions or ()) except ExtensionError as error : logger . error ( error ) return 1 loader = _load_packages ( packages , extensions = loaded_extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , resolve_aliases = resolve_aliases , resolve_implicit = resolve_implicit , resolve_external = resolve_external , allow_inspection = allow_inspection , ) data_packages = loader . modules_collection . members started = datetime . now () if per_package_output : for package_name , data in data_packages . items (): serialized = data . as_json ( indent = 2 , full = full ) _print_data ( serialized , output . format ( package = package_name )) # type: ignore[union-attr] else : serialized = json . dumps ( data_packages , cls = JSONEncoder , indent = 2 , full = full ) _print_data ( serialized , output ) elapsed = datetime . now () - started if stats : logger . info ( _stats ({ \"time_spent_serializing\" : elapsed . microseconds , ** loader . stats ()})) return 0 if len ( data_packages ) == len ( packages ) else 1 get_parser \u00a4 get_parser () Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser. Returns: The argument parser for the program. \"\"\" usage = \" %(prog)s [GLOBAL_OPTS...] COMMAND [COMMAND_OPTS...]\" # noqa: WPS323 (%-formatting) description = \"Signatures for entire Python programs. \" \"Extract the structure, the frame, the skeleton of your project, \" \"to generate API documentation or find breaking changes in your API.\" parser = argparse . ArgumentParser ( add_help = False , usage = usage , description = description , prog = \"griffe\" ) main_help = \"Show this help message and exit. Commands also accept the -h/--help option.\" subcommand_help = \"Show this help message and exit.\" global_options = parser . add_argument_group ( title = \"Global options\" ) global_options . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = main_help ) def add_common_options ( subparser ): # noqa: WPS430 common_options = subparser . add_argument_group ( title = \"Common options\" ) common_options . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = subcommand_help ) search_options = subparser . add_argument_group ( title = \"Search options\" ) search_options . add_argument ( \"-s\" , \"--search\" , dest = \"search_paths\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) loading_options = subparser . add_argument_group ( title = \"Loading options\" ) loading_options . add_argument ( \"-e\" , \"--extensions\" , default = {}, type = json . loads , help = \"A list of extensions to use.\" , ) loading_options . add_argument ( \"-X\" , \"--no-inspection\" , dest = \"allow_inspection\" , action = \"store_false\" , default = True , help = \"Disallow inspection of builtin/compiled/not found modules.\" , ) debug_options = subparser . add_argument_group ( title = \"Debugging options\" ) debug_options . add_argument ( \"-L\" , \"--log-level\" , metavar = \"LEVEL\" , default = DEFAULT_LOG_LEVEL , choices = _level_choices , type = str . upper , help = \"Set the log level: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`.\" , ) # ========= SUBPARSERS ========= # subparsers = parser . add_subparsers ( dest = \"subcommand\" , title = \"Commands\" , metavar = \"COMMAND\" , prog = \"griffe\" , required = True ) def add_subparser ( command : str , text : str , ** kwargs ) -> argparse . ArgumentParser : # noqa: WPS430 (nested function) return subparsers . add_parser ( command , add_help = False , help = text , description = text , ** kwargs ) # ========= DUMP PARSER ========= # dump_parser = add_subparser ( \"dump\" , \"Load package-signatures and dump them as JSON.\" ) dump_options = dump_parser . add_argument_group ( title = \"Dump options\" ) dump_options . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find, load and dump.\" ) dump_options . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) dump_options . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with ` {package} `.\" , ) dump_options . add_argument ( \"-d\" , \"--docstyle\" , dest = \"docstring_parser\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) dump_options . add_argument ( \"-D\" , \"--docopts\" , dest = \"docstring_options\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) dump_options . add_argument ( \"-y\" , \"--sys-path\" , dest = \"append_sys_path\" , action = \"store_true\" , help = \"Whether to append `sys.path` to search paths specified with `-s`.\" , ) dump_options . add_argument ( \"-r\" , \"--resolve-aliases\" , action = \"store_true\" , help = \"Whether to resolve aliases.\" , ) dump_options . add_argument ( \"-I\" , \"--resolve-implicit\" , action = \"store_true\" , help = \"Whether to resolve implicitely exported aliases as well. \" \"Aliases are explicitely exported when defined in `__all__`.\" , ) dump_options . add_argument ( \"-U\" , \"--resolve-external\" , action = \"store_true\" , help = \"Whether to resolve aliases pointing to external/unknown modules (not loaded directly).\" , ) dump_options . add_argument ( \"-S\" , \"--stats\" , action = \"store_true\" , help = \"Show statistics at the end.\" , ) add_common_options ( dump_parser ) # ========= CHECK PARSER ========= # check_parser = add_subparser ( \"check\" , \"Check for API breakages or possible improvements.\" ) check_options = check_parser . add_argument_group ( title = \"Check options\" ) check_options . add_argument ( \"package\" , metavar = \"PACKAGE\" , help = \"Package to find, load and check, as path.\" ) check_options . add_argument ( \"-a\" , \"--against\" , metavar = \"REF\" , help = \"Older Git reference (commit, branch, tag) to check against. Default: load latest tag.\" , ) check_options . add_argument ( \"-b\" , \"--base-ref\" , metavar = \"BASE_REF\" , help = \"Git reference (commit, branch, tag) to check. Default: load current code.\" , ) check_options . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , help = \"Verbose output.\" ) add_common_options ( check_parser ) return parser main \u00a4 main ( args = None ) Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\"Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) opts_dict = opts . __dict__ subcommand = opts_dict . pop ( \"subcommand\" ) log_level = opts_dict . pop ( \"log_level\" , DEFAULT_LOG_LEVEL ) try : level = getattr ( logging , log_level ) except AttributeError : choices = \"', '\" . join ( _level_choices ) print ( f \"griffe: error: invalid log level ' { log_level } ' (choose from ' { choices } ')\" , file = sys . stderr , ) return 1 else : logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = level ) # noqa: WPS323 commands : dict [ str , Callable [ ... , int ]] = { \"check\" : check , \"dump\" : dump } return commands [ subcommand ]( ** opts_dict )","title":"cli"},{"location":"reference/griffe/cli/#griffe.cli.check","text":"check ( package , against = None , against_path = None , * , base_ref = None , extensions = None , search_paths = None , allow_inspection = True , verbose = False ) Load packages data and dump it as JSON. Parameters: package ( str | Path ) \u2013 The package to load and check. against ( str | None ) \u2013 Older Git reference (commit, branch, tag) to check against. against_path ( str | Path | None ) \u2013 Path when the \"against\" reference is checked out. base_ref ( str | None ) \u2013 Git reference (commit, branch, tag) to check. extensions ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. verbose ( bool ) \u2013 Use a verbose output. Returns: int \u2013 0 for success, 1 for failure. Source code in griffe/cli.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 def check ( package : str | Path , against : str | None = None , against_path : str | Path | None = None , * , base_ref : str | None = None , extensions : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] | None = None , search_paths : Sequence [ str | Path ] | None = None , allow_inspection : bool = True , verbose : bool = False , ) -> int : \"\"\"Load packages data and dump it as JSON. Parameters: package: The package to load and check. against: Older Git reference (commit, branch, tag) to check against. against_path: Path when the \"against\" reference is checked out. base_ref: Git reference (commit, branch, tag) to check. extensions: The extensions to use. search_paths: The paths to search into. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. verbose: Use a verbose output. Returns: `0` for success, `1` for failure. \"\"\" colorama . deinit () colorama . init () search_paths = list ( search_paths ) if search_paths else [] against = against or _get_latest_tag ( package ) against_path = against_path or package repository = _get_repo_root ( against_path ) try : loaded_extensions = load_extensions ( extensions or ()) except ExtensionError as error : logger . error ( error ) return 1 old_package = load_git ( against_path , ref = against , repo = repository , extensions = loaded_extensions , search_paths = search_paths , allow_inspection = allow_inspection , ) if base_ref : new_package = load_git ( package , ref = base_ref , repo = repository , extensions = loaded_extensions , search_paths = search_paths , allow_inspection = allow_inspection , ) else : new_package = load ( package , try_relative_path = True , extensions = loaded_extensions , search_paths = search_paths , allow_inspection = allow_inspection , ) if verbose : style = ExplanationStyle . VERBOSE else : style = ExplanationStyle . ONE_LINE breakages = list ( find_breaking_changes ( old_package , new_package )) for breakage in breakages : print ( breakage . explain ( style = style ), file = sys . stderr ) if breakages : return 1 return 0","title":"check()"},{"location":"reference/griffe/cli/#griffe.cli.dump","text":"dump ( packages , * , output = None , full = False , docstring_parser = None , docstring_options = None , extensions = None , resolve_aliases = False , resolve_implicit = False , resolve_external = False , search_paths = None , append_sys_path = False , allow_inspection = True , stats = False ) Load packages data and dump it as JSON. Parameters: packages ( Sequence [ str ] ) \u2013 The packages to load and dump. output ( str | IO | None ) \u2013 Where to output the JSON-serialized data. full ( bool ) \u2013 Whether to output full or minimal data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. resolve_aliases ( bool ) \u2013 Whether to resolve aliases (indirect objects references). resolve_implicit ( bool ) \u2013 Whether to resolve every alias or only the explicitly exported ones. resolve_external ( bool ) \u2013 Whether to load additional, unspecified modules to resolve aliases. extensions ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. append_sys_path ( bool ) \u2013 Whether to append the contents of sys.path to the search paths. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. stats ( bool ) \u2013 Whether to compute and log stats about loading. Returns: int \u2013 0 for success, 1 for failure. Source code in griffe/cli.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 def dump ( packages : Sequence [ str ], * , output : str | IO | None = None , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , extensions : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] | None = None , resolve_aliases : bool = False , resolve_implicit : bool = False , resolve_external : bool = False , search_paths : Sequence [ str | Path ] | None = None , append_sys_path : bool = False , allow_inspection : bool = True , stats : bool = False , ) -> int : \"\"\"Load packages data and dump it as JSON. Parameters: packages: The packages to load and dump. output: Where to output the JSON-serialized data. full: Whether to output full or minimal data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. resolve_aliases: Whether to resolve aliases (indirect objects references). resolve_implicit: Whether to resolve every alias or only the explicitly exported ones. resolve_external: Whether to load additional, unspecified modules to resolve aliases. extensions: The extensions to use. search_paths: The paths to search into. append_sys_path: Whether to append the contents of `sys.path` to the search paths. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. stats: Whether to compute and log stats about loading. Returns: `0` for success, `1` for failure. \"\"\" per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search_paths = list ( search_paths ) if search_paths else [] if append_sys_path : search_paths . extend ( sys . path ) try : loaded_extensions = load_extensions ( extensions or ()) except ExtensionError as error : logger . error ( error ) return 1 loader = _load_packages ( packages , extensions = loaded_extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , resolve_aliases = resolve_aliases , resolve_implicit = resolve_implicit , resolve_external = resolve_external , allow_inspection = allow_inspection , ) data_packages = loader . modules_collection . members started = datetime . now () if per_package_output : for package_name , data in data_packages . items (): serialized = data . as_json ( indent = 2 , full = full ) _print_data ( serialized , output . format ( package = package_name )) # type: ignore[union-attr] else : serialized = json . dumps ( data_packages , cls = JSONEncoder , indent = 2 , full = full ) _print_data ( serialized , output ) elapsed = datetime . now () - started if stats : logger . info ( _stats ({ \"time_spent_serializing\" : elapsed . microseconds , ** loader . stats ()})) return 0 if len ( data_packages ) == len ( packages ) else 1","title":"dump()"},{"location":"reference/griffe/cli/#griffe.cli.get_parser","text":"get_parser () Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser. Returns: The argument parser for the program. \"\"\" usage = \" %(prog)s [GLOBAL_OPTS...] COMMAND [COMMAND_OPTS...]\" # noqa: WPS323 (%-formatting) description = \"Signatures for entire Python programs. \" \"Extract the structure, the frame, the skeleton of your project, \" \"to generate API documentation or find breaking changes in your API.\" parser = argparse . ArgumentParser ( add_help = False , usage = usage , description = description , prog = \"griffe\" ) main_help = \"Show this help message and exit. Commands also accept the -h/--help option.\" subcommand_help = \"Show this help message and exit.\" global_options = parser . add_argument_group ( title = \"Global options\" ) global_options . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = main_help ) def add_common_options ( subparser ): # noqa: WPS430 common_options = subparser . add_argument_group ( title = \"Common options\" ) common_options . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = subcommand_help ) search_options = subparser . add_argument_group ( title = \"Search options\" ) search_options . add_argument ( \"-s\" , \"--search\" , dest = \"search_paths\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) loading_options = subparser . add_argument_group ( title = \"Loading options\" ) loading_options . add_argument ( \"-e\" , \"--extensions\" , default = {}, type = json . loads , help = \"A list of extensions to use.\" , ) loading_options . add_argument ( \"-X\" , \"--no-inspection\" , dest = \"allow_inspection\" , action = \"store_false\" , default = True , help = \"Disallow inspection of builtin/compiled/not found modules.\" , ) debug_options = subparser . add_argument_group ( title = \"Debugging options\" ) debug_options . add_argument ( \"-L\" , \"--log-level\" , metavar = \"LEVEL\" , default = DEFAULT_LOG_LEVEL , choices = _level_choices , type = str . upper , help = \"Set the log level: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`.\" , ) # ========= SUBPARSERS ========= # subparsers = parser . add_subparsers ( dest = \"subcommand\" , title = \"Commands\" , metavar = \"COMMAND\" , prog = \"griffe\" , required = True ) def add_subparser ( command : str , text : str , ** kwargs ) -> argparse . ArgumentParser : # noqa: WPS430 (nested function) return subparsers . add_parser ( command , add_help = False , help = text , description = text , ** kwargs ) # ========= DUMP PARSER ========= # dump_parser = add_subparser ( \"dump\" , \"Load package-signatures and dump them as JSON.\" ) dump_options = dump_parser . add_argument_group ( title = \"Dump options\" ) dump_options . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find, load and dump.\" ) dump_options . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) dump_options . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with ` {package} `.\" , ) dump_options . add_argument ( \"-d\" , \"--docstyle\" , dest = \"docstring_parser\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) dump_options . add_argument ( \"-D\" , \"--docopts\" , dest = \"docstring_options\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) dump_options . add_argument ( \"-y\" , \"--sys-path\" , dest = \"append_sys_path\" , action = \"store_true\" , help = \"Whether to append `sys.path` to search paths specified with `-s`.\" , ) dump_options . add_argument ( \"-r\" , \"--resolve-aliases\" , action = \"store_true\" , help = \"Whether to resolve aliases.\" , ) dump_options . add_argument ( \"-I\" , \"--resolve-implicit\" , action = \"store_true\" , help = \"Whether to resolve implicitely exported aliases as well. \" \"Aliases are explicitely exported when defined in `__all__`.\" , ) dump_options . add_argument ( \"-U\" , \"--resolve-external\" , action = \"store_true\" , help = \"Whether to resolve aliases pointing to external/unknown modules (not loaded directly).\" , ) dump_options . add_argument ( \"-S\" , \"--stats\" , action = \"store_true\" , help = \"Show statistics at the end.\" , ) add_common_options ( dump_parser ) # ========= CHECK PARSER ========= # check_parser = add_subparser ( \"check\" , \"Check for API breakages or possible improvements.\" ) check_options = check_parser . add_argument_group ( title = \"Check options\" ) check_options . add_argument ( \"package\" , metavar = \"PACKAGE\" , help = \"Package to find, load and check, as path.\" ) check_options . add_argument ( \"-a\" , \"--against\" , metavar = \"REF\" , help = \"Older Git reference (commit, branch, tag) to check against. Default: load latest tag.\" , ) check_options . add_argument ( \"-b\" , \"--base-ref\" , metavar = \"BASE_REF\" , help = \"Git reference (commit, branch, tag) to check. Default: load current code.\" , ) check_options . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , help = \"Verbose output.\" ) add_common_options ( check_parser ) return parser","title":"get_parser()"},{"location":"reference/griffe/cli/#griffe.cli.main","text":"main ( args = None ) Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\"Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) opts_dict = opts . __dict__ subcommand = opts_dict . pop ( \"subcommand\" ) log_level = opts_dict . pop ( \"log_level\" , DEFAULT_LOG_LEVEL ) try : level = getattr ( logging , log_level ) except AttributeError : choices = \"', '\" . join ( _level_choices ) print ( f \"griffe: error: invalid log level ' { log_level } ' (choose from ' { choices } ')\" , file = sys . stderr , ) return 1 else : logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = level ) # noqa: WPS323 commands : dict [ str , Callable [ ... , int ]] = { \"check\" : check , \"dump\" : dump } return commands [ subcommand ]( ** opts_dict )","title":"main()"},{"location":"reference/griffe/collections/","text":"This module stores collections of data, useful during parsing. LinesCollection \u00a4 LinesCollection () A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 21 22 23 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {} items \u00a4 items () Return the collection items. Returns: ItemsView \u2013 The collection items. Source code in griffe/collections.py 50 51 52 53 54 55 56 def items ( self ) -> ItemsView : \"\"\"Return the collection items. Returns: The collection items. \"\"\" return self . _data . items () keys \u00a4 keys () Return the collection keys. Returns: KeysView \u2013 The collection keys. Source code in griffe/collections.py 34 35 36 37 38 39 40 def keys ( self ) -> KeysView : \"\"\"Return the collection keys. Returns: The collection keys. \"\"\" return self . _data . keys () tokens cached \u00a4 tokens ( path ) Tokenize the code. Parameters: path ( Path ) \u2013 The filepath to get the tokens of. Returns: tuple [ list [ tokenize . TokenInfo ], defaultdict ] \u2013 A token list and a mapping of tokens by line number. Source code in griffe/collections.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @lru_cache ( maxsize = None ) # noqa: B019 def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table values \u00a4 values () Return the collection values. Returns: ValuesView \u2013 The collection values. Source code in griffe/collections.py 42 43 44 45 46 47 48 def values ( self ) -> ValuesView : \"\"\"Return the collection values. Returns: The collection values. \"\"\" return self . _data . values () ModulesCollection \u00a4 ModulesCollection () Bases: GetMembersMixin , SetMembersMixin A collection of modules, allowing easy access to members. Source code in griffe/collections.py 82 83 84 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"collections"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection","text":"LinesCollection () A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 21 22 23 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {}","title":"LinesCollection"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.items","text":"items () Return the collection items. Returns: ItemsView \u2013 The collection items. Source code in griffe/collections.py 50 51 52 53 54 55 56 def items ( self ) -> ItemsView : \"\"\"Return the collection items. Returns: The collection items. \"\"\" return self . _data . items ()","title":"items()"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.keys","text":"keys () Return the collection keys. Returns: KeysView \u2013 The collection keys. Source code in griffe/collections.py 34 35 36 37 38 39 40 def keys ( self ) -> KeysView : \"\"\"Return the collection keys. Returns: The collection keys. \"\"\" return self . _data . keys ()","title":"keys()"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.tokens","text":"tokens ( path ) Tokenize the code. Parameters: path ( Path ) \u2013 The filepath to get the tokens of. Returns: tuple [ list [ tokenize . TokenInfo ], defaultdict ] \u2013 A token list and a mapping of tokens by line number. Source code in griffe/collections.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @lru_cache ( maxsize = None ) # noqa: B019 def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table","title":"tokens()"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.values","text":"values () Return the collection values. Returns: ValuesView \u2013 The collection values. Source code in griffe/collections.py 42 43 44 45 46 47 48 def values ( self ) -> ValuesView : \"\"\"Return the collection values. Returns: The collection values. \"\"\" return self . _data . values ()","title":"values()"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection","text":"ModulesCollection () Bases: GetMembersMixin , SetMembersMixin A collection of modules, allowing easy access to members. Source code in griffe/collections.py 82 83 84 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"ModulesCollection"},{"location":"reference/griffe/dataclasses/","text":"This module contains the data classes that represent Python objects. The different objects are modules, classes, functions, and attribute (variables like module/class/instance attributes). Alias \u00a4 Alias ( name , target , * , lineno = None , endlineno = None , runtime = True , parent = None ) Bases: ObjectAliasMixin This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. target_path ( str ) \u2013 The alias target path. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. runtime ( bool ) \u2013 Whether this alias is present at runtime or not. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , runtime : bool = True , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. runtime: Whether this alias is present at runtime or not. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . target_path : str = target else : self . _target = target self . target_path = target . path if parent is not None : with suppress ( AliasResolutionError ): target . aliases [ self . path ] = self self . alias_lineno : int | None = lineno self . alias_endlineno : int | None = endlineno self . runtime : bool = runtime self . _parent : Module | Class | None = parent self . _passed_through : bool = False endlineno property \u00a4 endlineno : int | None Return the target endlineno or the alias endlineno. Returns: int | None \u2013 The target endlineno or the alias endlineno. has_docstring property \u00a4 has_docstring : bool Tell if this alias' target has a non-empty docstring. has_docstrings property \u00a4 has_docstrings : bool Tell if this alias' target or any of its members has a non-empty docstring. kind property \u00a4 kind : Kind Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind. lineno property \u00a4 lineno : int | None Return the target lineno or the alias lineno. Returns: int | None \u2013 The target lineno or the alias lineno. modules_collection property cached \u00a4 modules_collection : ModulesCollection Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection. parent property writable \u00a4 parent : Module | Class | None Return the parent of this alias. Returns: Module | Class | None \u2013 The parent. path property cached \u00a4 path : str Return the dotted path / import path of this object. Returns: str \u2013 A dotted path. resolved property \u00a4 resolved : bool Tell whether this alias' target is resolved. Returns: bool \u2013 True or False. target property writable \u00a4 target : Object | Alias Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: Object | Alias \u2013 The resolved target. wildcard property cached \u00a4 wildcard : str | None Return the module on which the wildcard import is performed (if any). Returns: str | None \u2013 The wildcard imported module, or None. as_dict \u00a4 as_dict ( full = False , ** kwargs ) Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base resolve_target \u00a4 resolve_target () Resolve the target. Raises: AliasResolutionError \u2013 When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. CyclicAliasError \u2013 When the resolved target is the alias itself. Source code in griffe/dataclasses.py 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. CyclicAliasError: When the resolved target is the alias itself. \"\"\" try : resolved = self . modules_collection [ self . target_path ] except KeyError as error : raise AliasResolutionError ( self . target_path ) from error if resolved is self : raise CyclicAliasError ([ self . target_path ]) self . _target = resolved if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target Attribute \u00a4 Attribute ( * args , value = None , annotation = None , ** kwargs ) Bases: Object The class representing a Python module/class/instance attribute. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation as_dict \u00a4 as_dict ( ** kwargs ) Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base Class \u00a4 Class ( * args , bases = None , decorators = None , ** kwargs ) Bases: Object The class representing a Python class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression | str ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] self . overloads : dict [ str , list [ Function ]] = defaultdict ( list ) parameters property \u00a4 parameters : Parameters Return the parameters of this class' __init__ method, if any. Returns: Parameters \u2013 The parameters containter. as_dict \u00a4 as_dict ( ** kwargs ) Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base Decorator \u00a4 Decorator ( value , * , lineno , endlineno ) This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Parameters: value ( str ) \u2013 The decorator code. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , value : str , * , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: value: The decorator code. lineno: The starting line number. endlineno: The ending line number. \"\"\" self . value : str = value self . lineno : int | None = lineno self . endlineno : int | None = endlineno as_dict \u00a4 as_dict ( ** kwargs ) Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } Docstring \u00a4 Docstring ( value , * , lineno = None , endlineno = None , parent = None , parser = None , parser_options = None ) This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value . rstrip ()) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} lines property cached \u00a4 lines : list [ str ] Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines. parsed property cached \u00a4 parsed : list [ DocstringSection ] Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. as_dict \u00a4 as_dict ( full = False , docstring_parser = None , ** kwargs ) Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base parse \u00a4 parse ( parser = None , ** options ) Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 144 145 146 147 148 149 150 151 152 153 154 155 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) Function \u00a4 Function ( * args , parameters = None , returns = None , decorators = None , ** kwargs ) Bases: Object The class representing a Python function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] self . setter : Function | None = None self . deleter : Function | None = None self . overloads : list [ Function ] | None = None annotation property \u00a4 annotation : str | Name | Expression | None Return the return annotation. Returns: str | Name | Expression | None \u2013 The function return annotation. as_dict \u00a4 as_dict ( ** kwargs ) Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base Kind \u00a4 Bases: enum . Enum Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind. Module \u00a4 Module ( * args , filepath = None , ** kwargs ) Bases: Object The class representing a Python module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path | list [ Path ] | None ) \u2013 The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 def __init__ ( self , * args : Any , filepath : Path | list [ Path ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | list [ Path ] | None = filepath self . overloads : dict [ str , list [ Function ]] = defaultdict ( list ) filepath property \u00a4 filepath : Path | list [ Path ] Get the file path of this module. Raises: BuiltinModuleError \u2013 When the instance filepath is None. Returns: Path | list [ Path ] \u2013 The module's file path. is_init_module property cached \u00a4 is_init_module : bool Tell if this module is an __init__.py module. Returns: bool \u2013 True or False. is_namespace_package property cached \u00a4 is_namespace_package : bool Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False. is_namespace_subpackage property cached \u00a4 is_namespace_subpackage : bool Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False. is_package property cached \u00a4 is_package : bool Tell if this module is a package (top module). Returns: bool \u2013 True or False. is_subpackage property cached \u00a4 is_subpackage : bool Tell if this module is a subpackage. Returns: bool \u2013 True or False. as_dict \u00a4 as_dict ( ** kwargs ) Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base Object \u00a4 Object ( name , * , lineno = None , endlineno = None , runtime = True , docstring = None , parent = None , lines_collection = None , modules_collection = None ) Bases: GetMembersMixin , SetMembersMixin , ObjectAliasMixin , SerializationMixin An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. runtime ( bool ) \u2013 Whether this object is present at runtime or not. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , runtime : bool = True , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. runtime: Whether this object is present at runtime or not. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | list [ str | Name ] | None = None self . aliases : dict [ str , Alias ] = {} self . runtime : bool = runtime self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self attributes property \u00a4 attributes : dict [ str , Attribute ] Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes. canonical_path property cached \u00a4 canonical_path : str Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path. classes property \u00a4 classes : dict [ str , Class ] Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes. filepath property cached \u00a4 filepath : Path | list [ Path ] Return the file path where this object was defined. Returns: Path | list [ Path ] \u2013 A file path or a list of directories. functions property \u00a4 functions : dict [ str , Function ] Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions. has_docstring property \u00a4 has_docstring : bool Tell if this object has a non-empty docstring. has_docstrings property \u00a4 has_docstrings : bool Tell if this object or any of its members has a non-empty docstring. is_attribute property \u00a4 is_attribute : bool Tell if this object is an attribute. is_class property \u00a4 is_class : bool Tell if this object is a class. is_function property \u00a4 is_function : bool Tell if this object is a function. is_module property \u00a4 is_module : bool Tell if this object is a module. lines property cached \u00a4 lines : list [ str ] Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines. lines_collection property cached \u00a4 lines_collection : LinesCollection Return the lines collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: LinesCollection \u2013 A lines collection. module property cached \u00a4 module : Module Return the parent module of this object. Raises: ValueError \u2013 When the object is not a module and does not have a parent. Returns: Module \u2013 The parent module. modules property \u00a4 modules : dict [ str , Module ] Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules. modules_collection property cached \u00a4 modules_collection : ModulesCollection Return the modules collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: ModulesCollection \u2013 A modules collection. package property cached \u00a4 package : Module Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module. path property cached \u00a4 path : str Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path. relative_filepath property cached \u00a4 relative_filepath : Path Return the file path where this object was defined, relative to the top module path. Raises: ValueError \u2013 When the relative path could not be computed. Returns: Path \u2013 A file path. source property cached \u00a4 source : str Return the source code of this object. Returns: str \u2013 The source code. as_dict \u00a4 as_dict ( full = False , ** kwargs ) Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base filter_members \u00a4 filter_members ( * predicates ) Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members has_labels \u00a4 has_labels ( labels ) Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 451 452 453 454 455 456 457 458 459 460 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) is_kind \u00a4 is_kind ( kind ) Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Raises: ValueError \u2013 When an empty set is given as argument. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind member_is_exported \u00a4 member_is_exported ( member , explicitely = True ) Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported, unless it's a module and it was not imported, and unless it's not defined at runtime. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if not member . runtime : return False if self . exports is None : return not explicitely and ( member . is_alias or not member . is_module or member . name in self . imports ) return member . name in self . exports resolve \u00a4 resolve ( name ) Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Raises: NameResolutionError \u2013 When the name could not be resolved. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members : if self . members [ name ] . is_alias : return self . members [ name ] . target_path # type: ignore[union-attr] return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name and not self . parent . is_module : return self . parent . path return self . parent . resolve ( name ) Parameter \u00a4 Parameter ( name , * , annotation = None , kind = None , default = None ) This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default required property \u00a4 required : bool Tell if this parameter is required. Returns: bool \u2013 True or False. as_dict \u00a4 as_dict ( ** kwargs ) Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , } ParameterKind \u00a4 Bases: enum . Enum Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter. Parameters \u00a4 Parameters ( * parameters ) This class is a container for parameters. It allows to get parameters using their position (index) or their name. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 247 248 249 250 251 252 253 254 255 256 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) add \u00a4 add ( parameter ) Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Raises: ValueError \u2013 When a parameter with the same name is already present. Source code in griffe/dataclasses.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"dataclasses"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias","text":"Alias ( name , target , * , lineno = None , endlineno = None , runtime = True , parent = None ) Bases: ObjectAliasMixin This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. target_path ( str ) \u2013 The alias target path. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. runtime ( bool ) \u2013 Whether this alias is present at runtime or not. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , runtime : bool = True , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. runtime: Whether this alias is present at runtime or not. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . target_path : str = target else : self . _target = target self . target_path = target . path if parent is not None : with suppress ( AliasResolutionError ): target . aliases [ self . path ] = self self . alias_lineno : int | None = lineno self . alias_endlineno : int | None = endlineno self . runtime : bool = runtime self . _parent : Module | Class | None = parent self . _passed_through : bool = False","title":"Alias"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.endlineno","text":"endlineno : int | None Return the target endlineno or the alias endlineno. Returns: int | None \u2013 The target endlineno or the alias endlineno.","title":"endlineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.has_docstring","text":"has_docstring : bool Tell if this alias' target has a non-empty docstring.","title":"has_docstring"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.has_docstrings","text":"has_docstrings : bool Tell if this alias' target or any of its members has a non-empty docstring.","title":"has_docstrings"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.kind","text":"kind : Kind Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind.","title":"kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.lineno","text":"lineno : int | None Return the target lineno or the alias lineno. Returns: int | None \u2013 The target lineno or the alias lineno.","title":"lineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.modules_collection","text":"modules_collection : ModulesCollection Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection.","title":"modules_collection"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.parent","text":"parent : Module | Class | None Return the parent of this alias. Returns: Module | Class | None \u2013 The parent.","title":"parent"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.path","text":"path : str Return the dotted path / import path of this object. Returns: str \u2013 A dotted path.","title":"path"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolved","text":"resolved : bool Tell whether this alias' target is resolved. Returns: bool \u2013 True or False.","title":"resolved"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.target","text":"target : Object | Alias Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: Object | Alias \u2013 The resolved target.","title":"target"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.wildcard","text":"wildcard : str | None Return the module on which the wildcard import is performed (if any). Returns: str | None \u2013 The wildcard imported module, or None.","title":"wildcard"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.as_dict","text":"as_dict ( full = False , ** kwargs ) Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolve_target","text":"resolve_target () Resolve the target. Raises: AliasResolutionError \u2013 When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. CyclicAliasError \u2013 When the resolved target is the alias itself. Source code in griffe/dataclasses.py 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. CyclicAliasError: When the resolved target is the alias itself. \"\"\" try : resolved = self . modules_collection [ self . target_path ] except KeyError as error : raise AliasResolutionError ( self . target_path ) from error if resolved is self : raise CyclicAliasError ([ self . target_path ]) self . _target = resolved if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target","title":"resolve_target()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute","text":"Attribute ( * args , value = None , annotation = None , ** kwargs ) Bases: Object The class representing a Python module/class/instance attribute. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation","title":"Attribute"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.as_dict","text":"as_dict ( ** kwargs ) Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class","text":"Class ( * args , bases = None , decorators = None , ** kwargs ) Bases: Object The class representing a Python class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression | str ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] self . overloads : dict [ str , list [ Function ]] = defaultdict ( list )","title":"Class"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.parameters","text":"parameters : Parameters Return the parameters of this class' __init__ method, if any. Returns: Parameters \u2013 The parameters containter.","title":"parameters"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.as_dict","text":"as_dict ( ** kwargs ) Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator","text":"Decorator ( value , * , lineno , endlineno ) This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Parameters: value ( str ) \u2013 The decorator code. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , value : str , * , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: value: The decorator code. lineno: The starting line number. endlineno: The ending line number. \"\"\" self . value : str = value self . lineno : int | None = lineno self . endlineno : int | None = endlineno","title":"Decorator"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.as_dict","text":"as_dict ( ** kwargs ) Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring","text":"Docstring ( value , * , lineno = None , endlineno = None , parent = None , parser = None , parser_options = None ) This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value . rstrip ()) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {}","title":"Docstring"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.lines","text":"lines : list [ str ] Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines.","title":"lines"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parsed","text":"parsed : list [ DocstringSection ] Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections.","title":"parsed"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.as_dict","text":"as_dict ( full = False , docstring_parser = None , ** kwargs ) Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parse","text":"parse ( parser = None , ** options ) Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 144 145 146 147 148 149 150 151 152 153 154 155 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options ))","title":"parse()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function","text":"Function ( * args , parameters = None , returns = None , decorators = None , ** kwargs ) Bases: Object The class representing a Python function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] self . setter : Function | None = None self . deleter : Function | None = None self . overloads : list [ Function ] | None = None","title":"Function"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.annotation","text":"annotation : str | Name | Expression | None Return the return annotation. Returns: str | Name | Expression | None \u2013 The function return annotation.","title":"annotation"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.as_dict","text":"as_dict ( ** kwargs ) Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind","text":"Bases: enum . Enum Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind.","title":"Kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module","text":"Module ( * args , filepath = None , ** kwargs ) Bases: Object The class representing a Python module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path | list [ Path ] | None ) \u2013 The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 def __init__ ( self , * args : Any , filepath : Path | list [ Path ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | list [ Path ] | None = filepath self . overloads : dict [ str , list [ Function ]] = defaultdict ( list )","title":"Module"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.filepath","text":"filepath : Path | list [ Path ] Get the file path of this module. Raises: BuiltinModuleError \u2013 When the instance filepath is None. Returns: Path | list [ Path ] \u2013 The module's file path.","title":"filepath"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_init_module","text":"is_init_module : bool Tell if this module is an __init__.py module. Returns: bool \u2013 True or False.","title":"is_init_module"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_package","text":"is_namespace_package : bool Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False.","title":"is_namespace_package"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_subpackage","text":"is_namespace_subpackage : bool Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False.","title":"is_namespace_subpackage"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_package","text":"is_package : bool Tell if this module is a package (top module). Returns: bool \u2013 True or False.","title":"is_package"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_subpackage","text":"is_subpackage : bool Tell if this module is a subpackage. Returns: bool \u2013 True or False.","title":"is_subpackage"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.as_dict","text":"as_dict ( ** kwargs ) Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object","text":"Object ( name , * , lineno = None , endlineno = None , runtime = True , docstring = None , parent = None , lines_collection = None , modules_collection = None ) Bases: GetMembersMixin , SetMembersMixin , ObjectAliasMixin , SerializationMixin An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. runtime ( bool ) \u2013 Whether this object is present at runtime or not. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , runtime : bool = True , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. runtime: Whether this object is present at runtime or not. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | list [ str | Name ] | None = None self . aliases : dict [ str , Alias ] = {} self . runtime : bool = runtime self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self","title":"Object"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.attributes","text":"attributes : dict [ str , Attribute ] Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes.","title":"attributes"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.canonical_path","text":"canonical_path : str Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path.","title":"canonical_path"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.classes","text":"classes : dict [ str , Class ] Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes.","title":"classes"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filepath","text":"filepath : Path | list [ Path ] Return the file path where this object was defined. Returns: Path | list [ Path ] \u2013 A file path or a list of directories.","title":"filepath"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.functions","text":"functions : dict [ str , Function ] Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions.","title":"functions"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstring","text":"has_docstring : bool Tell if this object has a non-empty docstring.","title":"has_docstring"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstrings","text":"has_docstrings : bool Tell if this object or any of its members has a non-empty docstring.","title":"has_docstrings"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_attribute","text":"is_attribute : bool Tell if this object is an attribute.","title":"is_attribute"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_class","text":"is_class : bool Tell if this object is a class.","title":"is_class"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_function","text":"is_function : bool Tell if this object is a function.","title":"is_function"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_module","text":"is_module : bool Tell if this object is a module.","title":"is_module"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines","text":"lines : list [ str ] Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines.","title":"lines"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines_collection","text":"lines_collection : LinesCollection Return the lines collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: LinesCollection \u2013 A lines collection.","title":"lines_collection"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.module","text":"module : Module Return the parent module of this object. Raises: ValueError \u2013 When the object is not a module and does not have a parent. Returns: Module \u2013 The parent module.","title":"module"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules","text":"modules : dict [ str , Module ] Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules.","title":"modules"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules_collection","text":"modules_collection : ModulesCollection Return the modules collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: ModulesCollection \u2013 A modules collection.","title":"modules_collection"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.package","text":"package : Module Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module.","title":"package"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.path","text":"path : str Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path.","title":"path"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.relative_filepath","text":"relative_filepath : Path Return the file path where this object was defined, relative to the top module path. Raises: ValueError \u2013 When the relative path could not be computed. Returns: Path \u2013 A file path.","title":"relative_filepath"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.source","text":"source : str Return the source code of this object. Returns: str \u2013 The source code.","title":"source"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.as_dict","text":"as_dict ( full = False , ** kwargs ) Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filter_members","text":"filter_members ( * predicates ) Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members","title":"filter_members()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_labels","text":"has_labels ( labels ) Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 451 452 453 454 455 456 457 458 459 460 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels )","title":"has_labels()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_kind","text":"is_kind ( kind ) Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Raises: ValueError \u2013 When an empty set is given as argument. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind","title":"is_kind()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.member_is_exported","text":"member_is_exported ( member , explicitely = True ) Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported, unless it's a module and it was not imported, and unless it's not defined at runtime. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if not member . runtime : return False if self . exports is None : return not explicitely and ( member . is_alias or not member . is_module or member . name in self . imports ) return member . name in self . exports","title":"member_is_exported()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.resolve","text":"resolve ( name ) Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Raises: NameResolutionError \u2013 When the name could not be resolved. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members : if self . members [ name ] . is_alias : return self . members [ name ] . target_path # type: ignore[union-attr] return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name and not self . parent . is_module : return self . parent . path return self . parent . resolve ( name )","title":"resolve()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter","text":"Parameter ( name , * , annotation = None , kind = None , default = None ) This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default","title":"Parameter"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.required","text":"required : bool Tell if this parameter is required. Returns: bool \u2013 True or False.","title":"required"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.as_dict","text":"as_dict ( ** kwargs ) Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind","text":"Bases: enum . Enum Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter.","title":"ParameterKind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters","text":"Parameters ( * parameters ) This class is a container for parameters. It allows to get parameters using their position (index) or their name. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 247 248 249 250 251 252 253 254 255 256 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter )","title":"Parameters"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.add","text":"add ( parameter ) Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Raises: ValueError \u2013 When a parameter with the same name is already present. Source code in griffe/dataclasses.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"add()"},{"location":"reference/griffe/diff/","text":"This module exports \"breaking changes\" related utilities. AttributeChangedTypeBreakage \u00a4 Bases: Breakage Specific breakage class for attributes whose type changed. AttributeChangedValueBreakage \u00a4 Bases: Breakage Specific breakage class for attributes whose value changed. Breakage \u00a4 Breakage ( obj , old_value , new_value , details = '' ) Breakages can explain what broke from a version to another. Parameters: obj ( Object ) \u2013 The object related to the breakage. old_value ( Any ) \u2013 The old value. new_value ( Any ) \u2013 The new, incompatible value. details ( str ) \u2013 Some details about the breakage. Source code in griffe/diff.py 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , obj : Object , old_value : Any , new_value : Any , details : str = \"\" ) -> None : \"\"\"Initialize the breakage. Parameters: obj: The object related to the breakage. old_value: The old value. new_value: The new, incompatible value. details: Some details about the breakage. \"\"\" self . obj = obj self . old_value = old_value self . new_value = new_value self . details = details as_dict \u00a4 as_dict ( full = False , ** kwargs ) Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/diff.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"object_path\" : self . obj . path , \"old_value\" : self . old_value , \"new_value\" : self . new_value , } explain \u00a4 explain ( style = ExplanationStyle . ONE_LINE ) Explain the breakage by showing old and new value. Parameters: style ( ExplanationStyle ) \u2013 The explanation style to use. Returns: str \u2013 An explanation. Source code in griffe/diff.py 87 88 89 90 91 92 93 94 95 96 def explain ( self , style : ExplanationStyle = ExplanationStyle . ONE_LINE ) -> str : \"\"\"Explain the breakage by showing old and new value. Parameters: style: The explanation style to use. Returns: An explanation. \"\"\" return getattr ( self , f \"_explain_ { style . value } \" )() BreakageKind \u00a4 Bases: enum . Enum An enumeration of the possible breakages. ClassRemovedBaseBreakage \u00a4 Bases: Breakage Specific breakage class for removed base classes. ExplanationStyle \u00a4 Bases: enum . Enum An enumeration of the possible styles for explanations. ObjectChangedKindBreakage \u00a4 Bases: Breakage Specific breakage class for objects whose kind changed. ObjectRemovedBreakage \u00a4 Bases: Breakage Specific breakage class for removed objects. ParameterAddedRequiredBreakage \u00a4 Bases: Breakage Specific breakage class for new parameters added as required. ParameterChangedDefaultBreakage \u00a4 Bases: Breakage Specific breakage class for parameters whose default value changed. ParameterChangedKindBreakage \u00a4 Bases: Breakage Specific breakage class for parameters whose kind changed. ParameterChangedRequiredBreakage \u00a4 Bases: Breakage Specific breakage class for parameters which became required. ParameterMovedBreakage \u00a4 Bases: Breakage Specific breakage class for moved parameters. ParameterRemovedBreakage \u00a4 Bases: Breakage Specific breakage class for removed parameters. ReturnChangedTypeBreakage \u00a4 Bases: Breakage Specific breakage class for return values which changed type.","title":"diff"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedTypeBreakage","text":"Bases: Breakage Specific breakage class for attributes whose type changed.","title":"AttributeChangedTypeBreakage"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedValueBreakage","text":"Bases: Breakage Specific breakage class for attributes whose value changed.","title":"AttributeChangedValueBreakage"},{"location":"reference/griffe/diff/#griffe.diff.Breakage","text":"Breakage ( obj , old_value , new_value , details = '' ) Breakages can explain what broke from a version to another. Parameters: obj ( Object ) \u2013 The object related to the breakage. old_value ( Any ) \u2013 The old value. new_value ( Any ) \u2013 The new, incompatible value. details ( str ) \u2013 Some details about the breakage. Source code in griffe/diff.py 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , obj : Object , old_value : Any , new_value : Any , details : str = \"\" ) -> None : \"\"\"Initialize the breakage. Parameters: obj: The object related to the breakage. old_value: The old value. new_value: The new, incompatible value. details: Some details about the breakage. \"\"\" self . obj = obj self . old_value = old_value self . new_value = new_value self . details = details","title":"Breakage"},{"location":"reference/griffe/diff/#griffe.diff.Breakage.as_dict","text":"as_dict ( full = False , ** kwargs ) Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/diff.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"object_path\" : self . obj . path , \"old_value\" : self . old_value , \"new_value\" : self . new_value , }","title":"as_dict()"},{"location":"reference/griffe/diff/#griffe.diff.Breakage.explain","text":"explain ( style = ExplanationStyle . ONE_LINE ) Explain the breakage by showing old and new value. Parameters: style ( ExplanationStyle ) \u2013 The explanation style to use. Returns: str \u2013 An explanation. Source code in griffe/diff.py 87 88 89 90 91 92 93 94 95 96 def explain ( self , style : ExplanationStyle = ExplanationStyle . ONE_LINE ) -> str : \"\"\"Explain the breakage by showing old and new value. Parameters: style: The explanation style to use. Returns: An explanation. \"\"\" return getattr ( self , f \"_explain_ { style . value } \" )()","title":"explain()"},{"location":"reference/griffe/diff/#griffe.diff.BreakageKind","text":"Bases: enum . Enum An enumeration of the possible breakages.","title":"BreakageKind"},{"location":"reference/griffe/diff/#griffe.diff.ClassRemovedBaseBreakage","text":"Bases: Breakage Specific breakage class for removed base classes.","title":"ClassRemovedBaseBreakage"},{"location":"reference/griffe/diff/#griffe.diff.ExplanationStyle","text":"Bases: enum . Enum An enumeration of the possible styles for explanations.","title":"ExplanationStyle"},{"location":"reference/griffe/diff/#griffe.diff.ObjectChangedKindBreakage","text":"Bases: Breakage Specific breakage class for objects whose kind changed.","title":"ObjectChangedKindBreakage"},{"location":"reference/griffe/diff/#griffe.diff.ObjectRemovedBreakage","text":"Bases: Breakage Specific breakage class for removed objects.","title":"ObjectRemovedBreakage"},{"location":"reference/griffe/diff/#griffe.diff.ParameterAddedRequiredBreakage","text":"Bases: Breakage Specific breakage class for new parameters added as required.","title":"ParameterAddedRequiredBreakage"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedDefaultBreakage","text":"Bases: Breakage Specific breakage class for parameters whose default value changed.","title":"ParameterChangedDefaultBreakage"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedKindBreakage","text":"Bases: Breakage Specific breakage class for parameters whose kind changed.","title":"ParameterChangedKindBreakage"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedRequiredBreakage","text":"Bases: Breakage Specific breakage class for parameters which became required.","title":"ParameterChangedRequiredBreakage"},{"location":"reference/griffe/diff/#griffe.diff.ParameterMovedBreakage","text":"Bases: Breakage Specific breakage class for moved parameters.","title":"ParameterMovedBreakage"},{"location":"reference/griffe/diff/#griffe.diff.ParameterRemovedBreakage","text":"Bases: Breakage Specific breakage class for removed parameters.","title":"ParameterRemovedBreakage"},{"location":"reference/griffe/diff/#griffe.diff.ReturnChangedTypeBreakage","text":"Bases: Breakage Specific breakage class for return values which changed type.","title":"ReturnChangedTypeBreakage"},{"location":"reference/griffe/encoders/","text":"This module contains data encoders/serializers and decoders/deserializers. The available formats are: JSON : see the JSONEncoder and json_decoder . JSONEncoder \u00a4 JSONEncoder ( * args , full = False , docstring_parser = None , docstring_options = None , ** kwargs ) Bases: json . JSONEncoder JSON encoder. JSON encoders can be used directly, or through the json.dump or json.dumps methods. Examples: >>> from griffe.encoders import JSONEncoder >>> JSONEncoder ( full = True ) . encode ( ... , ** kwargs ) >>> import json >>> from griffe.encoders import JSONEncoder >>> json . dumps ( ... , cls = JSONEncoder , full = True , ** kwargs ) Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the json_decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [`json_decoder`][griffe.encoders.json_decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} default \u00a4 default ( obj ) Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 90 91 92 93 94 95 96 97 98 99 100 101 102 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _json_encoder_map . get ( type ( obj ), super () . default )( obj ) json_decoder \u00a4 json_decoder ( obj_dict ) Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Examples: >>> import json >>> from griffe.encoders import json_decoder >>> json . loads ( ... , object_hook = json_decoder ) Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Object | Alias | Parameter \u2013 An instance of a data class. Source code in griffe/encoders.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def json_decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Object | Alias | Parameter : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Examples: >>> import json >>> from griffe.encoders import json_decoder >>> json.loads(..., object_hook=json_decoder) Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : try : kind = Kind ( obj_dict [ \"kind\" ]) except ValueError : return _load_parameter ( obj_dict ) return _loader_map [ kind ]( obj_dict ) return obj_dict","title":"encoders"},{"location":"reference/griffe/encoders/#griffe.encoders.JSONEncoder","text":"JSONEncoder ( * args , full = False , docstring_parser = None , docstring_options = None , ** kwargs ) Bases: json . JSONEncoder JSON encoder. JSON encoders can be used directly, or through the json.dump or json.dumps methods. Examples: >>> from griffe.encoders import JSONEncoder >>> JSONEncoder ( full = True ) . encode ( ... , ** kwargs ) >>> import json >>> from griffe.encoders import JSONEncoder >>> json . dumps ( ... , cls = JSONEncoder , full = True , ** kwargs ) Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the json_decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [`json_decoder`][griffe.encoders.json_decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {}","title":"JSONEncoder"},{"location":"reference/griffe/encoders/#griffe.encoders.JSONEncoder.default","text":"default ( obj ) Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 90 91 92 93 94 95 96 97 98 99 100 101 102 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _json_encoder_map . get ( type ( obj ), super () . default )( obj )","title":"default()"},{"location":"reference/griffe/encoders/#griffe.encoders.json_decoder","text":"json_decoder ( obj_dict ) Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Examples: >>> import json >>> from griffe.encoders import json_decoder >>> json . loads ( ... , object_hook = json_decoder ) Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Object | Alias | Parameter \u2013 An instance of a data class. Source code in griffe/encoders.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def json_decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Object | Alias | Parameter : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Examples: >>> import json >>> from griffe.encoders import json_decoder >>> json.loads(..., object_hook=json_decoder) Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : try : kind = Kind ( obj_dict [ \"kind\" ]) except ValueError : return _load_parameter ( obj_dict ) return _loader_map [ kind ]( obj_dict ) return obj_dict","title":"json_decoder()"},{"location":"reference/griffe/exceptions/","text":"This module contains all the exceptions specific to Griffe. AliasResolutionError \u00a4 AliasResolutionError ( target_path ) Bases: GriffeError Exception for alias that cannot be resolved. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 29 30 31 32 33 34 35 36 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"Could not resolve { self . target_path } \" ) BuiltinModuleError \u00a4 Bases: GriffeError Exception raised when trying to access the filepath of a builtin module. CyclicAliasError \u00a4 CyclicAliasError ( chain ) Bases: GriffeError Exception raised when a cycle is detected in aliases. Parameters: chain ( list [ str ] ) \u2013 The cyclic chain of items (such as target path). Source code in griffe/exceptions.py 42 43 44 45 46 47 48 49 def __init__ ( self , chain : list [ str ]) -> None : \"\"\"Initialize the exception. Parameters: chain: The cyclic chain of items (such as target path). \"\"\" self . chain : list [ str ] = chain super () . __init__ ( \"Cyclic aliases detected: \\n \" + \" \\n \" . join ( self . chain )) ExtensionError \u00a4 Bases: GriffeError Base class for errors raised by extensions. ExtensionNotLoadedError \u00a4 Bases: ExtensionError Exception raised when an extension could not be loaded. GriffeError \u00a4 Bases: Exception The base exception for all Griffe errors. LastNodeError \u00a4 Bases: GriffeError Exception raised when trying to access a next or previous node. LoadingError \u00a4 Bases: GriffeError The base exception for all Griffe errors. NameResolutionError \u00a4 Bases: GriffeError Exception for names that cannot be resolved in a object scope. RootNodeError \u00a4 Bases: GriffeError Exception raised when trying to use siblings properties on a root node. UnhandledEditablesModuleError \u00a4 Bases: GriffeError Exception for unhandled editables modules, when searching modules. UnimportableModuleError \u00a4 Bases: GriffeError Exception for modules that cannot be imported.","title":"exceptions"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError","text":"AliasResolutionError ( target_path ) Bases: GriffeError Exception for alias that cannot be resolved. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 29 30 31 32 33 34 35 36 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"Could not resolve { self . target_path } \" )","title":"AliasResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.BuiltinModuleError","text":"Bases: GriffeError Exception raised when trying to access the filepath of a builtin module.","title":"BuiltinModuleError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.CyclicAliasError","text":"CyclicAliasError ( chain ) Bases: GriffeError Exception raised when a cycle is detected in aliases. Parameters: chain ( list [ str ] ) \u2013 The cyclic chain of items (such as target path). Source code in griffe/exceptions.py 42 43 44 45 46 47 48 49 def __init__ ( self , chain : list [ str ]) -> None : \"\"\"Initialize the exception. Parameters: chain: The cyclic chain of items (such as target path). \"\"\" self . chain : list [ str ] = chain super () . __init__ ( \"Cyclic aliases detected: \\n \" + \" \\n \" . join ( self . chain ))","title":"CyclicAliasError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionError","text":"Bases: GriffeError Base class for errors raised by extensions.","title":"ExtensionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionNotLoadedError","text":"Bases: ExtensionError Exception raised when an extension could not be loaded.","title":"ExtensionNotLoadedError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.GriffeError","text":"Bases: Exception The base exception for all Griffe errors.","title":"GriffeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LastNodeError","text":"Bases: GriffeError Exception raised when trying to access a next or previous node.","title":"LastNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LoadingError","text":"Bases: GriffeError The base exception for all Griffe errors.","title":"LoadingError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.NameResolutionError","text":"Bases: GriffeError Exception for names that cannot be resolved in a object scope.","title":"NameResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.RootNodeError","text":"Bases: GriffeError Exception raised when trying to use siblings properties on a root node.","title":"RootNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnhandledEditablesModuleError","text":"Bases: GriffeError Exception for unhandled editables modules, when searching modules.","title":"UnhandledEditablesModuleError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnimportableModuleError","text":"Bases: GriffeError Exception for modules that cannot be imported.","title":"UnimportableModuleError"},{"location":"reference/griffe/expressions/","text":"This module contains the data classes that represent resolvable names and expressions. Expression \u00a4 Expression ( * values ) Bases: list This class represents a Python expression. For example, it can represent complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 104 105 106 107 108 109 110 111 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) full property \u00a4 full : str Return self as a string. This property is only useful to the AST utils. Returns: str \u2013 Self as a string. is_generator property \u00a4 is_generator : bool Tell whether this expression represents a generator. Returns: bool \u2013 True or False. is_iterator property \u00a4 is_iterator : bool Tell whether this expression represents an iterator. Returns: bool \u2013 True or False. is_tuple property \u00a4 is_tuple : bool Tell whether this expression represents a tuple. Returns: bool \u2013 True or False. kind property \u00a4 kind : str Return the main type object as a string. Returns: str \u2013 The main type of this expression. non_optional property cached \u00a4 non_optional : Expression Return the same expression as non-optional. This will return a new expression without the Optional[] or | None parts. Returns: Expression \u2013 A non-optional expression. generator_items \u00a4 generator_items () Return the items of a generator. Returns: Name | Expression \u2013 The yield type. Name | Expression \u2013 The send/receive type. Name | Expression \u2013 The return type. Source code in griffe/expressions.py 224 225 226 227 228 229 230 231 232 233 def generator_items ( self ) -> tuple [ Name | Expression , Name | Expression , Name | Expression ]: \"\"\"Return the items of a generator. Returns: The yield type. The send/receive type. The return type. \"\"\" # Generator[Yield, Send/Receive, Return] return self . non_optional [ 2 ][ 0 ], self [ 2 ][ 2 ], self [ 2 ][ 4 ] iterator_item \u00a4 iterator_item () Return the item of an iterator. Returns: Name | Expression \u2013 The iterator item. Source code in griffe/expressions.py 215 216 217 218 219 220 221 222 def iterator_item ( self ) -> Name | Expression : \"\"\"Return the item of an iterator. Returns: The iterator item. \"\"\" # Iterator[ItemType] return self . non_optional [ 2 ] tuple_item \u00a4 tuple_item ( nth ) Return the n-th item of this tuple expression. Parameters: nth ( int ) \u2013 The item number. Returns: str | Name \u2013 A string or name. Source code in griffe/expressions.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self . non_optional [ 2 ][ 2 * nth ] tuple_items \u00a4 tuple_items () Return a tuple items as a list. Returns: list [ Name | Expression ] \u2013 The tuple items. Source code in griffe/expressions.py 207 208 209 210 211 212 213 def tuple_items ( self ) -> list [ Name | Expression ]: \"\"\"Return a tuple items as a list. Returns: The tuple items. \"\"\" return self . non_optional [ 2 ][:: 2 ] Name \u00a4 Name ( source , full ) This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full brief property \u00a4 brief : str Return the brief source name. Returns: str \u2013 The last part of the source name. full property \u00a4 full : str Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source. as_dict \u00a4 as_dict ( ** kwargs ) Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 80 81 82 83 84 85 86 87 88 89 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full }","title":"expressions"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression","text":"Expression ( * values ) Bases: list This class represents a Python expression. For example, it can represent complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 104 105 106 107 108 109 110 111 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values )","title":"Expression"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.full","text":"full : str Return self as a string. This property is only useful to the AST utils. Returns: str \u2013 Self as a string.","title":"full"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_generator","text":"is_generator : bool Tell whether this expression represents a generator. Returns: bool \u2013 True or False.","title":"is_generator"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_iterator","text":"is_iterator : bool Tell whether this expression represents an iterator. Returns: bool \u2013 True or False.","title":"is_iterator"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_tuple","text":"is_tuple : bool Tell whether this expression represents a tuple. Returns: bool \u2013 True or False.","title":"is_tuple"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.kind","text":"kind : str Return the main type object as a string. Returns: str \u2013 The main type of this expression.","title":"kind"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.non_optional","text":"non_optional : Expression Return the same expression as non-optional. This will return a new expression without the Optional[] or | None parts. Returns: Expression \u2013 A non-optional expression.","title":"non_optional"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.generator_items","text":"generator_items () Return the items of a generator. Returns: Name | Expression \u2013 The yield type. Name | Expression \u2013 The send/receive type. Name | Expression \u2013 The return type. Source code in griffe/expressions.py 224 225 226 227 228 229 230 231 232 233 def generator_items ( self ) -> tuple [ Name | Expression , Name | Expression , Name | Expression ]: \"\"\"Return the items of a generator. Returns: The yield type. The send/receive type. The return type. \"\"\" # Generator[Yield, Send/Receive, Return] return self . non_optional [ 2 ][ 0 ], self [ 2 ][ 2 ], self [ 2 ][ 4 ]","title":"generator_items()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.iterator_item","text":"iterator_item () Return the item of an iterator. Returns: Name | Expression \u2013 The iterator item. Source code in griffe/expressions.py 215 216 217 218 219 220 221 222 def iterator_item ( self ) -> Name | Expression : \"\"\"Return the item of an iterator. Returns: The iterator item. \"\"\" # Iterator[ItemType] return self . non_optional [ 2 ]","title":"iterator_item()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.tuple_item","text":"tuple_item ( nth ) Return the n-th item of this tuple expression. Parameters: nth ( int ) \u2013 The item number. Returns: str | Name \u2013 A string or name. Source code in griffe/expressions.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self . non_optional [ 2 ][ 2 * nth ]","title":"tuple_item()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.tuple_items","text":"tuple_items () Return a tuple items as a list. Returns: list [ Name | Expression ] \u2013 The tuple items. Source code in griffe/expressions.py 207 208 209 210 211 212 213 def tuple_items ( self ) -> list [ Name | Expression ]: \"\"\"Return a tuple items as a list. Returns: The tuple items. \"\"\" return self . non_optional [ 2 ][:: 2 ]","title":"tuple_items()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name","text":"Name ( source , full ) This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full","title":"Name"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.brief","text":"brief : str Return the brief source name. Returns: str \u2013 The last part of the source name.","title":"brief"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.full","text":"full : str Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source.","title":"full"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.as_dict","text":"as_dict ( ** kwargs ) Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 80 81 82 83 84 85 86 87 88 89 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full }","title":"as_dict()"},{"location":"reference/griffe/finder/","text":"This module contains the code allowing to find modules. ModuleFinder \u00a4 ModuleFinder ( search_paths = None ) The Griffe finder, allowing to find modules on the file system. Parameters: search_paths ( Sequence [ str | Path ] | None ) \u2013 Optional paths to search into. Source code in griffe/finder.py 57 58 59 60 61 62 63 64 65 66 67 68 69 def __init__ ( self , search_paths : Sequence [ str | Path ] | None = None ) -> None : \"\"\"Initialize the finder. Parameters: search_paths: Optional paths to search into. \"\"\" self . _paths_contents : dict [ Path , list [ Path ]] = {} # optimization: pre-compute Paths to relieve CPU when joining paths self . search_paths = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] if bool ( search_paths ): # without custom search paths, sys.path is used, and is already extended from .pth files self . _extend_from_pth_files () self . _extend_from_editables_modules () find_package \u00a4 find_package ( module_name ) Find a package or namespace package. Parameters: module_name ( str ) \u2013 The module name. Raises: ModuleNotFoundError \u2013 When the module cannot be found. Returns: Package | NamespacePackage \u2013 A package or namespace package wrapper. Source code in griffe/finder.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def find_package ( self , module_name : str ) -> Package | NamespacePackage : # noqa: WPS231 \"\"\"Find a package or namespace package. Parameters: module_name: The module name. Raises: ModuleNotFoundError: When the module cannot be found. Returns: A package or namespace package wrapper. \"\"\" filepaths = [ Path ( module_name ), # TODO: handle .py[cod] and .so files? Path ( f \" { module_name } .py\" ), ] namespace_dirs = [] for path in self . search_paths : # noqa: WPS440 path_contents = self . _contents ( path ) if path_contents : for choice in filepaths : abs_path = path / choice if abs_path in path_contents : if abs_path . suffix : stubs = abs_path . with_suffix ( \".pyi\" ) return Package ( module_name , abs_path , stubs if stubs . exists () else None ) else : init_module = abs_path / \"__init__.py\" if init_module . exists () and not _is_pkg_style_namespace ( init_module ): stubs = init_module . with_suffix ( \".pyi\" ) return Package ( module_name , init_module , stubs if stubs . exists () else None ) namespace_dirs . append ( abs_path ) if namespace_dirs : return NamespacePackage ( module_name , namespace_dirs ) raise ModuleNotFoundError ( module_name ) find_spec \u00a4 find_spec ( module , try_relative_path = True ) Find the top module of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module ( str | Path ) \u2013 The module name or path. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError \u2013 When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist ModuleNotFoundError \u2013 When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file Returns: tuple [ str , Package | NamespacePackage ] \u2013 The name of the module, and an instance representing its (namespace) package. Source code in griffe/finder.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def find_spec ( self , module : str | Path , try_relative_path : bool = True , ) -> tuple [ str , Package | NamespacePackage ]: \"\"\"Find the top module of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module: The module name or path. try_relative_path: Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError: When a Path was passed and the module could not be found: - the directory has no `__init__.py` file in it - the path does not exist ModuleNotFoundError: When a string was passed and the module could not be found: - no `module/__init__.py` - no `module.py` - no `module.pth` - no `module` directory (namespace packages) - or unsupported .pth file Returns: The name of the module, and an instance representing its (namespace) package. \"\"\" module_path : Path | list [ Path ] if isinstance ( module , Path ): module_name , module_path = self . _module_name_path ( module ) # type: ignore[arg-type] top_module_name = self . _top_module_name ( module_path ) elif try_relative_path : try : module_name , module_path = self . _module_name_path ( Path ( module )) except FileNotFoundError : module_name = module # type: ignore[assignment] top_module_name = module . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] else : top_module_name = self . _top_module_name ( module_path ) else : module_name = module top_module_name = module . split ( \".\" , 1 )[ 0 ] return module_name , self . find_package ( top_module_name ) iter_submodules \u00a4 iter_submodules ( path , seen = None ) Iterate on a module's submodules, if any. Parameters: path ( Path | list [ Path ] ) \u2013 The module path. seen ( set | None ) \u2013 If not none, this set is used to skip some files. The goal is to replicate the behavior of Python by only using the first packages (with __init__ modules) of the same name found in different namespace packages. As soon as we find an __init__ module, we add its parent path to the seen set, which will be reused when scanning the next namespace packages. Yields: name_parts ( tuple [ str , ...] ) \u2013 The parts of a submodule name. filepath ( Path ) \u2013 A submodule filepath. Source code in griffe/finder.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def iter_submodules ( # noqa: WPS231,WPS234 self , path : Path | list [ Path ], seen : set | None = None , ) -> Iterator [ NamePartsAndPathType ]: \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. seen: If not none, this set is used to skip some files. The goal is to replicate the behavior of Python by only using the first packages (with `__init__` modules) of the same name found in different namespace packages. As soon as we find an `__init__` module, we add its parent path to the `seen` set, which will be reused when scanning the next namespace packages. Yields: name_parts (tuple[str, ...]): The parts of a submodule name. filepath (Path): A submodule filepath. \"\"\" if isinstance ( path , list ): seen = set () for path_elem in path : yield from self . iter_submodules ( path_elem , seen ) return if path . stem == \"__init__\" : path = path . parent # optimization: just check if the file name ends with .py[icod]/.so # (to distinguish it from a directory), # not if it's an actual file elif path . suffix in self . extensions_set : return skip = set ( seen ) if seen else set () for subpath in self . _filter_py_modules ( path ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . parent in skip : logger . debug ( f \"Skip { subpath } , another module took precedence\" ) continue py_file = rel_subpath . suffix == \".py\" stem = rel_subpath . stem if not py_file : # .py[cod] and .so files look like `name.cpython-38-x86_64-linux-gnu.ext` stem = stem . split ( \".\" , 1 )[ 0 ] if stem == \"__init__\" : # optimization: since it's a relative path, # if it has only one part and is named __init__, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath if seen is not None : seen . add ( rel_subpath . parent ) elif py_file : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath else : yield rel_subpath . with_name ( stem ) . parts , subpath submodules \u00a4 submodules ( module ) Return the list of a module's submodules. Parameters: module ( Module ) \u2013 The parent module. Returns: list [ NamePartsAndPathType ] \u2013 A list of tuples containing the parts of the submodule name and its path. Source code in griffe/finder.py 222 223 224 225 226 227 228 229 230 231 def submodules ( self , module : Module ) -> list [ NamePartsAndPathType ]: \"\"\"Return the list of a module's submodules. Parameters: module: The parent module. Returns: A list of tuples containing the parts of the submodule name and its path. \"\"\" return sorted ( self . iter_submodules ( module . filepath ), key = _module_depth ) NamespacePackage \u00a4 NamespacePackage ( name , path ) This class is a simple placeholder used during the process of finding packages. Parameters: name ( str ) \u2013 The package name. path ( list [ Path ] ) \u2013 The package paths. Source code in griffe/finder.py 40 41 42 43 44 45 46 47 48 def __init__ ( self , name : str , path : list [ Path ]) -> None : \"\"\"Initialize the namespace package. Parameters: name: The package name. path: The package paths. \"\"\" self . name : str = name self . path : list [ Path ] = path Package \u00a4 Package ( name , path , stubs = None ) This class is a simple placeholder used during the process of finding packages. Parameters: name ( str ) \u2013 The package name. path ( Path ) \u2013 The package path(s). stubs ( Path | None ) \u2013 An optional path to the related stubs file (.pyi). Source code in griffe/finder.py 24 25 26 27 28 29 30 31 32 33 34 def __init__ ( self , name : str , path : Path , stubs : Path | None = None ) -> None : \"\"\"Initialize the package. Parameters: name: The package name. path: The package path(s). stubs: An optional path to the related stubs file (.pyi). \"\"\" self . name : str = name self . path : Path = path self . stubs : Path | None = stubs","title":"finder"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder","text":"ModuleFinder ( search_paths = None ) The Griffe finder, allowing to find modules on the file system. Parameters: search_paths ( Sequence [ str | Path ] | None ) \u2013 Optional paths to search into. Source code in griffe/finder.py 57 58 59 60 61 62 63 64 65 66 67 68 69 def __init__ ( self , search_paths : Sequence [ str | Path ] | None = None ) -> None : \"\"\"Initialize the finder. Parameters: search_paths: Optional paths to search into. \"\"\" self . _paths_contents : dict [ Path , list [ Path ]] = {} # optimization: pre-compute Paths to relieve CPU when joining paths self . search_paths = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] if bool ( search_paths ): # without custom search paths, sys.path is used, and is already extended from .pth files self . _extend_from_pth_files () self . _extend_from_editables_modules ()","title":"ModuleFinder"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.find_package","text":"find_package ( module_name ) Find a package or namespace package. Parameters: module_name ( str ) \u2013 The module name. Raises: ModuleNotFoundError \u2013 When the module cannot be found. Returns: Package | NamespacePackage \u2013 A package or namespace package wrapper. Source code in griffe/finder.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def find_package ( self , module_name : str ) -> Package | NamespacePackage : # noqa: WPS231 \"\"\"Find a package or namespace package. Parameters: module_name: The module name. Raises: ModuleNotFoundError: When the module cannot be found. Returns: A package or namespace package wrapper. \"\"\" filepaths = [ Path ( module_name ), # TODO: handle .py[cod] and .so files? Path ( f \" { module_name } .py\" ), ] namespace_dirs = [] for path in self . search_paths : # noqa: WPS440 path_contents = self . _contents ( path ) if path_contents : for choice in filepaths : abs_path = path / choice if abs_path in path_contents : if abs_path . suffix : stubs = abs_path . with_suffix ( \".pyi\" ) return Package ( module_name , abs_path , stubs if stubs . exists () else None ) else : init_module = abs_path / \"__init__.py\" if init_module . exists () and not _is_pkg_style_namespace ( init_module ): stubs = init_module . with_suffix ( \".pyi\" ) return Package ( module_name , init_module , stubs if stubs . exists () else None ) namespace_dirs . append ( abs_path ) if namespace_dirs : return NamespacePackage ( module_name , namespace_dirs ) raise ModuleNotFoundError ( module_name )","title":"find_package()"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.find_spec","text":"find_spec ( module , try_relative_path = True ) Find the top module of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module ( str | Path ) \u2013 The module name or path. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError \u2013 When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist ModuleNotFoundError \u2013 When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file Returns: tuple [ str , Package | NamespacePackage ] \u2013 The name of the module, and an instance representing its (namespace) package. Source code in griffe/finder.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def find_spec ( self , module : str | Path , try_relative_path : bool = True , ) -> tuple [ str , Package | NamespacePackage ]: \"\"\"Find the top module of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module: The module name or path. try_relative_path: Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError: When a Path was passed and the module could not be found: - the directory has no `__init__.py` file in it - the path does not exist ModuleNotFoundError: When a string was passed and the module could not be found: - no `module/__init__.py` - no `module.py` - no `module.pth` - no `module` directory (namespace packages) - or unsupported .pth file Returns: The name of the module, and an instance representing its (namespace) package. \"\"\" module_path : Path | list [ Path ] if isinstance ( module , Path ): module_name , module_path = self . _module_name_path ( module ) # type: ignore[arg-type] top_module_name = self . _top_module_name ( module_path ) elif try_relative_path : try : module_name , module_path = self . _module_name_path ( Path ( module )) except FileNotFoundError : module_name = module # type: ignore[assignment] top_module_name = module . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] else : top_module_name = self . _top_module_name ( module_path ) else : module_name = module top_module_name = module . split ( \".\" , 1 )[ 0 ] return module_name , self . find_package ( top_module_name )","title":"find_spec()"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.iter_submodules","text":"iter_submodules ( path , seen = None ) Iterate on a module's submodules, if any. Parameters: path ( Path | list [ Path ] ) \u2013 The module path. seen ( set | None ) \u2013 If not none, this set is used to skip some files. The goal is to replicate the behavior of Python by only using the first packages (with __init__ modules) of the same name found in different namespace packages. As soon as we find an __init__ module, we add its parent path to the seen set, which will be reused when scanning the next namespace packages. Yields: name_parts ( tuple [ str , ...] ) \u2013 The parts of a submodule name. filepath ( Path ) \u2013 A submodule filepath. Source code in griffe/finder.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def iter_submodules ( # noqa: WPS231,WPS234 self , path : Path | list [ Path ], seen : set | None = None , ) -> Iterator [ NamePartsAndPathType ]: \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. seen: If not none, this set is used to skip some files. The goal is to replicate the behavior of Python by only using the first packages (with `__init__` modules) of the same name found in different namespace packages. As soon as we find an `__init__` module, we add its parent path to the `seen` set, which will be reused when scanning the next namespace packages. Yields: name_parts (tuple[str, ...]): The parts of a submodule name. filepath (Path): A submodule filepath. \"\"\" if isinstance ( path , list ): seen = set () for path_elem in path : yield from self . iter_submodules ( path_elem , seen ) return if path . stem == \"__init__\" : path = path . parent # optimization: just check if the file name ends with .py[icod]/.so # (to distinguish it from a directory), # not if it's an actual file elif path . suffix in self . extensions_set : return skip = set ( seen ) if seen else set () for subpath in self . _filter_py_modules ( path ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . parent in skip : logger . debug ( f \"Skip { subpath } , another module took precedence\" ) continue py_file = rel_subpath . suffix == \".py\" stem = rel_subpath . stem if not py_file : # .py[cod] and .so files look like `name.cpython-38-x86_64-linux-gnu.ext` stem = stem . split ( \".\" , 1 )[ 0 ] if stem == \"__init__\" : # optimization: since it's a relative path, # if it has only one part and is named __init__, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath if seen is not None : seen . add ( rel_subpath . parent ) elif py_file : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath else : yield rel_subpath . with_name ( stem ) . parts , subpath","title":"iter_submodules()"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.submodules","text":"submodules ( module ) Return the list of a module's submodules. Parameters: module ( Module ) \u2013 The parent module. Returns: list [ NamePartsAndPathType ] \u2013 A list of tuples containing the parts of the submodule name and its path. Source code in griffe/finder.py 222 223 224 225 226 227 228 229 230 231 def submodules ( self , module : Module ) -> list [ NamePartsAndPathType ]: \"\"\"Return the list of a module's submodules. Parameters: module: The parent module. Returns: A list of tuples containing the parts of the submodule name and its path. \"\"\" return sorted ( self . iter_submodules ( module . filepath ), key = _module_depth )","title":"submodules()"},{"location":"reference/griffe/finder/#griffe.finder.NamespacePackage","text":"NamespacePackage ( name , path ) This class is a simple placeholder used during the process of finding packages. Parameters: name ( str ) \u2013 The package name. path ( list [ Path ] ) \u2013 The package paths. Source code in griffe/finder.py 40 41 42 43 44 45 46 47 48 def __init__ ( self , name : str , path : list [ Path ]) -> None : \"\"\"Initialize the namespace package. Parameters: name: The package name. path: The package paths. \"\"\" self . name : str = name self . path : list [ Path ] = path","title":"NamespacePackage"},{"location":"reference/griffe/finder/#griffe.finder.Package","text":"Package ( name , path , stubs = None ) This class is a simple placeholder used during the process of finding packages. Parameters: name ( str ) \u2013 The package name. path ( Path ) \u2013 The package path(s). stubs ( Path | None ) \u2013 An optional path to the related stubs file (.pyi). Source code in griffe/finder.py 24 25 26 27 28 29 30 31 32 33 34 def __init__ ( self , name : str , path : Path , stubs : Path | None = None ) -> None : \"\"\"Initialize the package. Parameters: name: The package name. path: The package path(s). stubs: An optional path to the related stubs file (.pyi). \"\"\" self . name : str = name self . path : Path = path self . stubs : Path | None = stubs","title":"Package"},{"location":"reference/griffe/git/","text":"This module contains the code allowing to load modules from specific git commits. from griffe.git import load_git # where `repo` is the folder *containing* `.git` old_api = load_git ( \"my_module\" , commit = \"v0.1.0\" , repo = \"path/to/repo\" ) load_git \u00a4 load_git ( module , * , ref = \"HEAD\" , repo = \".\" , submodules = True , extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True ) Load and return a module from a specific Git reference. This function will create a temporary git worktree at the requested reference before loading module with griffe.load . This function requires that the git executable is installed. Parameters: module ( str | Path ) \u2013 The module path, relative to the repository root. ref ( str ) \u2013 A Git reference such as a commit, tag or branch. repo ( str | Path ) \u2013 Path to the repository (i.e. the directory containing the .git directory) submodules ( bool ) \u2013 Whether to recurse on the submodules. extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into (relative to the repository root). docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Returns: Module \u2013 A loaded module. Source code in griffe/git.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def load_git ( module : str | Path , * , ref : str = \"HEAD\" , repo : str | Path = \".\" , submodules : bool = True , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> Module : \"\"\"Load and return a module from a specific Git reference. This function will create a temporary [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference before loading `module` with [`griffe.load`][griffe.loader.load]. This function requires that the `git` executable is installed. Parameters: module: The module path, relative to the repository root. ref: A Git reference such as a commit, tag or branch. repo: Path to the repository (i.e. the directory *containing* the `.git` directory) submodules: Whether to recurse on the submodules. extensions: The extensions to use. search_paths: The paths to search into (relative to the repository root). docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. Returns: A loaded module. \"\"\" with tmp_worktree ( repo , ref ) as worktree : search_paths = [ worktree / path for path in search_paths or [ \".\" ]] if isinstance ( module , Path ): module = worktree / module return loader . load ( module = module , submodules = submodules , try_relative_path = False , extensions = extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , allow_inspection = allow_inspection , ) tmp_worktree \u00a4 tmp_worktree ( repo = '.' , ref = 'HEAD' ) Context manager that checks out the given reference in the given repository to a temporary worktree. Parameters: repo ( str | Path ) \u2013 Path to the repository (i.e. the directory containing the .git directory) ref ( str ) \u2013 A Git reference such as a commit, tag or branch. Yields: Iterator [ Path ] \u2013 The path to the temporary worktree. Raises: OSError \u2013 If repo is not a valid .git repository RuntimeError \u2013 If the git executable is unavailable, or if it cannot create a worktree Source code in griffe/git.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 @contextmanager def tmp_worktree ( repo : str | Path = \".\" , ref : str = \"HEAD\" ) -> Iterator [ Path ]: \"\"\"Context manager that checks out the given reference in the given repository to a temporary worktree. Parameters: repo: Path to the repository (i.e. the directory *containing* the `.git` directory) ref: A Git reference such as a commit, tag or branch. Yields: The path to the temporary worktree. Raises: OSError: If `repo` is not a valid `.git` repository RuntimeError: If the `git` executable is unavailable, or if it cannot create a worktree \"\"\" repo = str ( repo ) _assert_git_repo ( repo ) with TemporaryDirectory ( prefix = \"griffe-worktree-\" ) as td : uid = f \"griffe_ { ref } \" target = os . path . join ( td , uid ) retval = run ( # noqa: S603,S607 [ \"git\" , \"-C\" , repo , \"worktree\" , \"add\" , \"-b\" , uid , target , ref ], stderr = PIPE , stdout = PIPE , ) if retval . returncode : raise RuntimeError ( f \"Could not create git worktree: { retval . stderr . decode () } \" ) try : yield Path ( target ) finally : run ([ \"git\" , \"-C\" , repo , \"worktree\" , \"remove\" , uid ], stdout = DEVNULL ) # noqa: S603,S607 run ([ \"git\" , \"-C\" , repo , \"worktree\" , \"prune\" ], stdout = DEVNULL ) # noqa: S603,S607 run ([ \"git\" , \"-C\" , repo , \"branch\" , \"-d\" , uid ], stdout = DEVNULL ) # noqa: S603,S607","title":"git"},{"location":"reference/griffe/git/#griffe.git.load_git","text":"load_git ( module , * , ref = \"HEAD\" , repo = \".\" , submodules = True , extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True ) Load and return a module from a specific Git reference. This function will create a temporary git worktree at the requested reference before loading module with griffe.load . This function requires that the git executable is installed. Parameters: module ( str | Path ) \u2013 The module path, relative to the repository root. ref ( str ) \u2013 A Git reference such as a commit, tag or branch. repo ( str | Path ) \u2013 Path to the repository (i.e. the directory containing the .git directory) submodules ( bool ) \u2013 Whether to recurse on the submodules. extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into (relative to the repository root). docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Returns: Module \u2013 A loaded module. Source code in griffe/git.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def load_git ( module : str | Path , * , ref : str = \"HEAD\" , repo : str | Path = \".\" , submodules : bool = True , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> Module : \"\"\"Load and return a module from a specific Git reference. This function will create a temporary [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference before loading `module` with [`griffe.load`][griffe.loader.load]. This function requires that the `git` executable is installed. Parameters: module: The module path, relative to the repository root. ref: A Git reference such as a commit, tag or branch. repo: Path to the repository (i.e. the directory *containing* the `.git` directory) submodules: Whether to recurse on the submodules. extensions: The extensions to use. search_paths: The paths to search into (relative to the repository root). docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. Returns: A loaded module. \"\"\" with tmp_worktree ( repo , ref ) as worktree : search_paths = [ worktree / path for path in search_paths or [ \".\" ]] if isinstance ( module , Path ): module = worktree / module return loader . load ( module = module , submodules = submodules , try_relative_path = False , extensions = extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , allow_inspection = allow_inspection , )","title":"load_git()"},{"location":"reference/griffe/git/#griffe.git.tmp_worktree","text":"tmp_worktree ( repo = '.' , ref = 'HEAD' ) Context manager that checks out the given reference in the given repository to a temporary worktree. Parameters: repo ( str | Path ) \u2013 Path to the repository (i.e. the directory containing the .git directory) ref ( str ) \u2013 A Git reference such as a commit, tag or branch. Yields: Iterator [ Path ] \u2013 The path to the temporary worktree. Raises: OSError \u2013 If repo is not a valid .git repository RuntimeError \u2013 If the git executable is unavailable, or if it cannot create a worktree Source code in griffe/git.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 @contextmanager def tmp_worktree ( repo : str | Path = \".\" , ref : str = \"HEAD\" ) -> Iterator [ Path ]: \"\"\"Context manager that checks out the given reference in the given repository to a temporary worktree. Parameters: repo: Path to the repository (i.e. the directory *containing* the `.git` directory) ref: A Git reference such as a commit, tag or branch. Yields: The path to the temporary worktree. Raises: OSError: If `repo` is not a valid `.git` repository RuntimeError: If the `git` executable is unavailable, or if it cannot create a worktree \"\"\" repo = str ( repo ) _assert_git_repo ( repo ) with TemporaryDirectory ( prefix = \"griffe-worktree-\" ) as td : uid = f \"griffe_ { ref } \" target = os . path . join ( td , uid ) retval = run ( # noqa: S603,S607 [ \"git\" , \"-C\" , repo , \"worktree\" , \"add\" , \"-b\" , uid , target , ref ], stderr = PIPE , stdout = PIPE , ) if retval . returncode : raise RuntimeError ( f \"Could not create git worktree: { retval . stderr . decode () } \" ) try : yield Path ( target ) finally : run ([ \"git\" , \"-C\" , repo , \"worktree\" , \"remove\" , uid ], stdout = DEVNULL ) # noqa: S603,S607 run ([ \"git\" , \"-C\" , repo , \"worktree\" , \"prune\" ], stdout = DEVNULL ) # noqa: S603,S607 run ([ \"git\" , \"-C\" , repo , \"branch\" , \"-d\" , uid ], stdout = DEVNULL ) # noqa: S603,S607","title":"tmp_worktree()"},{"location":"reference/griffe/importer/","text":"This module contains utilities to dynamically import objects. dynamic_import \u00a4 dynamic_import ( import_path , import_paths = None ) Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path ( str ) \u2013 The path of the object to import. import_paths ( list [ Path ] | None ) \u2013 The paths to import the object from. Raises: ModuleNotFoundError \u2013 When the object's module could not be found. ImportError \u2013 When there was an import error or when couldn't get the attribute. Returns: Any \u2013 The imported object. Source code in griffe/importer.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def dynamic_import ( import_path : str , import_paths : list [ Path ] | None = None ) -> Any : # noqa: WPS231 \"\"\"Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path: The path of the object to import. import_paths: The paths to import the object from. Raises: ModuleNotFoundError: When the object's module could not be found. ImportError: When there was an import error or when couldn't get the attribute. Returns: The imported object. \"\"\" module_parts : list [ str ] = import_path . split ( \".\" ) object_parts : list [ str ] = [] errors = [] with sys_path ( * ( import_paths or ())): while True : module_path = \".\" . join ( module_parts ) try : # noqa: WPS503 (false-positive) module = import_module ( module_path ) except ModuleNotFoundError as error : if len ( module_parts ) == 1 : raise errors . append ( str ( error )) object_parts . insert ( 0 , module_parts . pop ( - 1 )) else : break # Sometimes extra dependencies are not installed, # and therefore we aren't able to import the leaf module, # so we end up with its parent instead, on which we can't # get the attribute either. In that case we re-raise an # ImportError for consistency. # See https://github.com/mkdocstrings/mkdocstrings/issues/380 value = module for part in object_parts : try : value = getattr ( value , part ) except AttributeError as error : # noqa: WPS440 raise ImportError ( \" \\n \" . join ( errors )) from error return value sys_path \u00a4 sys_path ( * paths ) Redefine sys.path temporarily. Parameters: *paths ( str | Path ) \u2013 The paths to use when importing modules. If no paths are given, keep sys.path untouched. Yields: Iterator [None] \u2013 Nothing. Source code in griffe/importer.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @contextmanager def sys_path ( * paths : str | Path ) -> Iterator [ None ]: \"\"\"Redefine `sys.path` temporarily. Parameters: *paths: The paths to use when importing modules. If no paths are given, keep `sys.path` untouched. Yields: Nothing. \"\"\" if not paths : yield return old_path = sys . path sys . path = [ str ( path ) for path in paths ] try : yield finally : sys . path = old_path","title":"importer"},{"location":"reference/griffe/importer/#griffe.importer.dynamic_import","text":"dynamic_import ( import_path , import_paths = None ) Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path ( str ) \u2013 The path of the object to import. import_paths ( list [ Path ] | None ) \u2013 The paths to import the object from. Raises: ModuleNotFoundError \u2013 When the object's module could not be found. ImportError \u2013 When there was an import error or when couldn't get the attribute. Returns: Any \u2013 The imported object. Source code in griffe/importer.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def dynamic_import ( import_path : str , import_paths : list [ Path ] | None = None ) -> Any : # noqa: WPS231 \"\"\"Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path: The path of the object to import. import_paths: The paths to import the object from. Raises: ModuleNotFoundError: When the object's module could not be found. ImportError: When there was an import error or when couldn't get the attribute. Returns: The imported object. \"\"\" module_parts : list [ str ] = import_path . split ( \".\" ) object_parts : list [ str ] = [] errors = [] with sys_path ( * ( import_paths or ())): while True : module_path = \".\" . join ( module_parts ) try : # noqa: WPS503 (false-positive) module = import_module ( module_path ) except ModuleNotFoundError as error : if len ( module_parts ) == 1 : raise errors . append ( str ( error )) object_parts . insert ( 0 , module_parts . pop ( - 1 )) else : break # Sometimes extra dependencies are not installed, # and therefore we aren't able to import the leaf module, # so we end up with its parent instead, on which we can't # get the attribute either. In that case we re-raise an # ImportError for consistency. # See https://github.com/mkdocstrings/mkdocstrings/issues/380 value = module for part in object_parts : try : value = getattr ( value , part ) except AttributeError as error : # noqa: WPS440 raise ImportError ( \" \\n \" . join ( errors )) from error return value","title":"dynamic_import()"},{"location":"reference/griffe/importer/#griffe.importer.sys_path","text":"sys_path ( * paths ) Redefine sys.path temporarily. Parameters: *paths ( str | Path ) \u2013 The paths to use when importing modules. If no paths are given, keep sys.path untouched. Yields: Iterator [None] \u2013 Nothing. Source code in griffe/importer.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @contextmanager def sys_path ( * paths : str | Path ) -> Iterator [ None ]: \"\"\"Redefine `sys.path` temporarily. Parameters: *paths: The paths to use when importing modules. If no paths are given, keep `sys.path` untouched. Yields: Nothing. \"\"\" if not paths : yield return old_path = sys . path sys . path = [ str ( path ) for path in paths ] try : yield finally : sys . path = old_path","title":"sys_path()"},{"location":"reference/griffe/loader/","text":"This module contains the code allowing to load modules data. This is the entrypoint to use griffe programatically: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) GriffeLoader \u00a4 GriffeLoader ( extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True , ) The Griffe loader, allowing to load data from modules. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Source code in griffe/loader.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def __init__ ( self , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. search_paths: The paths to search into. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () self . allow_inspection : bool = allow_inspection self . finder : ModuleFinder = ModuleFinder ( search_paths ) self . _time_stats : dict = { \"time_spent_visiting\" : 0 , \"time_spent_inspecting\" : 0 , } patch_ast () expand_exports \u00a4 expand_exports ( module , seen = None ) Expand exports: try to recursively expand all module exports. Parameters: module ( Module ) \u2013 The module to recurse on. seen ( set | None ) \u2013 Used to avoid infinite recursion. Source code in griffe/loader.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def expand_exports ( self , module : Module , seen : set | None = None ) -> None : # noqa: WPS231 \"\"\"Expand exports: try to recursively expand all module exports. Parameters: module: The module to recurse on. seen: Used to avoid infinite recursion. \"\"\" seen = seen or set () seen . add ( module . path ) if module . exports is None : return expanded = set () for export in module . exports : if isinstance ( export , Name ): module_path = export . full . rsplit ( \".\" , 1 )[ 0 ] # remove trailing .__all__ next_module = self . modules_collection [ module_path ] if next_module . path not in seen : self . expand_exports ( next_module , seen ) try : expanded |= next_module . exports except TypeError : logger . warning ( f \"Unsupported item in { module . path } .__all__: { export } (use strings only)\" ) else : expanded . add ( export ) module . exports = expanded expand_wildcards \u00a4 expand_wildcards ( obj , only_known_modules = True , seen = None ) Expand wildcards: try to recursively expand all found wildcards. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to expand wildcards. seen ( set | None ) \u2013 Used to avoid infinite recursion. Source code in griffe/loader.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def expand_wildcards ( # noqa: WPS231 self , obj : Object , only_known_modules : bool = True , seen : set | None = None , ) -> None : \"\"\"Expand wildcards: try to recursively expand all found wildcards. Parameters: obj: The object and its members to recurse on. only_known_modules: When true, don't try to load unspecified modules to expand wildcards. seen: Used to avoid infinite recursion. \"\"\" expanded = [] to_remove = [] seen = seen or set () seen . add ( obj . path ) for member in obj . members . values (): if member . is_alias and member . wildcard : # type: ignore[union-attr] # we know it's an alias package = member . wildcard . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] not_loaded = obj . package . path != package and package not in self . modules_collection if not_loaded : if only_known_modules : continue try : self . load_module ( package , try_relative_path = False ) except ImportError as error : logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) continue target = self . modules_collection [ member . target_path ] # type: ignore[union-attr] if target . path not in seen : try : self . expand_wildcards ( target , only_known_modules , seen ) # type: ignore[union-attr] except ( AliasResolutionError , CyclicAliasError ) as error : # noqa: WPS440 logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) continue expanded . extend ( self . _expand_wildcard ( member )) # type: ignore[arg-type] to_remove . append ( member . name ) elif not member . is_alias and member . is_module and member . path not in seen : self . expand_wildcards ( member , only_known_modules , seen ) # type: ignore[arg-type] for name in to_remove : del obj [ name ] # noqa: WPS420 for new_member , alias_lineno , alias_endlineno in expanded : overwrite = False already_present = new_member . name in obj . members if already_present : old_member = obj [ new_member . name ] old_lineno = getattr ( old_member , \"alias_lineno\" , old_member . lineno or 0 ) overwrite = alias_lineno > old_lineno # type: ignore[operator] if not already_present or overwrite : obj [ new_member . name ] = Alias ( new_member . name , new_member , lineno = alias_lineno , endlineno = alias_endlineno ) load_module \u00a4 load_module ( module , submodules = True , try_relative_path = True ) Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. Raises: LoadingError \u2013 When loading a module failed for various reasons. ModuleNotFoundError \u2013 When a module was not found and inspection is disallowed. Returns: Module \u2013 A module. Source code in griffe/loader.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def load_module ( # noqa: WPS231 self , module : str | Path , submodules : bool = True , try_relative_path : bool = True , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. try_relative_path: Whether to try finding the module as a relative path. Raises: LoadingError: When loading a module failed for various reasons. ModuleNotFoundError: When a module was not found and inspection is disallowed. Returns: A module. \"\"\" module_name : str if module in _builtin_modules : logger . debug ( f \" { module } is a builtin module\" ) if self . allow_inspection : logger . debug ( f \"Inspecting { module } \" ) module_name = module # type: ignore[assignment] top_module = self . _inspect_module ( module ) # type: ignore[arg-type] self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index] raise LoadingError ( \"Cannot load builtin module without inspection\" ) try : # noqa: WPS503 module_name , package = self . finder . find_spec ( module , try_relative_path ) except ModuleNotFoundError : logger . debug ( f \"Could not find { module } \" ) if self . allow_inspection : logger . debug ( f \"Trying inspection on { module } \" ) module_name = module # type: ignore[assignment] top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : raise else : logger . debug ( f \"Found { module } : loading\" ) try : # noqa: WPS505 top_module = self . _load_package ( package , submodules = submodules ) except LoadingError as error : # noqa: WPS440 logger . error ( str ( error )) raise return self . modules_collection [ module_name ] # type: ignore[index] resolve_aliases \u00a4 resolve_aliases ( * , implicit = None , external = None , max_iterations = None , only_exported = None , only_known_modules = None ) Resolve aliases. Parameters: implicit ( bool | None ) \u2013 When false, only try to resolve an alias if it is explicitely exported. external ( bool | None ) \u2013 When false, don't try to load unspecified modules to resolve aliases. max_iterations ( int | None ) \u2013 Maximum number of iterations on the loader modules collection. only_exported ( bool | None ) \u2013 Deprecated. Use the implicit parameter instead (inverting the value). only_known_modules ( bool | None ) \u2013 Deprecated. Use the external parameter instead (inverting the value). Returns: tuple [ set [ str ], int ] \u2013 The unresolved aliases and the number of iterations done. Source code in griffe/loader.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def resolve_aliases ( # noqa: WPS231 self , * , implicit : bool | None = None , external : bool | None = None , max_iterations : int | None = None , only_exported : bool | None = None , only_known_modules : bool | None = None , ) -> tuple [ set [ str ], int ]: \"\"\"Resolve aliases. Parameters: implicit: When false, only try to resolve an alias if it is explicitely exported. external: When false, don't try to load unspecified modules to resolve aliases. max_iterations: Maximum number of iterations on the loader modules collection. only_exported: Deprecated. Use the `implicit` parameter instead (inverting the value). only_known_modules: Deprecated. Use the `external` parameter instead (inverting the value). Returns: The unresolved aliases and the number of iterations done. \"\"\" # TODO: remove deprecated params at some point if only_exported is not None and implicit is None : warn ( \"Parameter `only_exported` is deprecated, use `implicit` instead.\" , DeprecationWarning , stacklevel = 2 , ) implicit = not only_exported if only_known_modules is not None and external is None : warn ( \"Parameter `only_known_modules` is deprecated, use `external` instead.\" , DeprecationWarning , stacklevel = 2 , ) external = not only_known_modules # TODO: set as param defaults once deprecated params are dropped if implicit is None : implicit = False if external is None : external = False if max_iterations is None : max_iterations = float ( \"inf\" ) # type: ignore[assignment] prev_unresolved : set [ str ] = set () unresolved : set [ str ] = set ( \"0\" ) # init to enter loop iteration = 0 collection = self . modules_collection . members for exports_module in list ( collection . values ()): self . expand_exports ( exports_module ) for wildcards_module in list ( collection . values ()): self . expand_wildcards ( wildcards_module ) while unresolved and unresolved != prev_unresolved and iteration < max_iterations : # type: ignore[operator] prev_unresolved = unresolved - { \"0\" } unresolved = set () resolved : set [ str ] = set () iteration += 1 for module_name in list ( collection . keys ()): module = collection [ module_name ] next_resolved , next_unresolved = self . resolve_module_aliases ( module , implicit , external ) resolved |= next_resolved unresolved |= next_unresolved logger . debug ( f \"Iteration { iteration } finished, { len ( resolved ) } aliases resolved, still { len ( unresolved ) } to go\" ) return unresolved , iteration resolve_module_aliases \u00a4 resolve_module_aliases ( obj , implicit = False , external = False , seen = None ) Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. implicit ( bool ) \u2013 When false, only try to resolve an alias if it is explicitely exported. external ( bool ) \u2013 When false, don't try to load unspecified modules to resolve aliases. seen ( set | None ) \u2013 Used to avoid infinite recursion. Returns: tuple [ set [ str ], set [ str ]] \u2013 Both sets of resolved and unresolved aliases. Source code in griffe/loader.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def resolve_module_aliases ( # noqa: WPS231 self , obj : Object , implicit : bool = False , external : bool = False , seen : set | None = None , ) -> tuple [ set [ str ], set [ str ]]: \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. implicit: When false, only try to resolve an alias if it is explicitely exported. external: When false, don't try to load unspecified modules to resolve aliases. seen: Used to avoid infinite recursion. Returns: Both sets of resolved and unresolved aliases. \"\"\" resolved = set () unresolved = set () seen = seen or set () seen . add ( obj . path ) for member in obj . members . values (): # noqa: WPS440 if member . is_alias : if member . wildcard or member . resolved : # type: ignore[union-attr] continue if not implicit and not member . is_explicitely_exported : continue try : member . resolve_target () # type: ignore[union-attr] except AliasResolutionError as error : # noqa: WPS440 path = member . path target = error . target_path # type: ignore[union-attr] # noqa: WPS437 logger . debug ( f \"Alias resolution error for { path } -> { target } \" ) unresolved . add ( path ) package = target . split ( \".\" , 1 )[ 0 ] load_module = external and obj . package . path != package and package not in self . modules_collection if load_module : try : # noqa: WPS505 self . load_module ( package , try_relative_path = False ) except ImportError as error : # noqa: WPS440 logger . debug ( f \"Could not follow alias { member . path } : { error } \" ) except CyclicAliasError as error : logger . debug ( str ( error )) else : logger . debug ( f \"Alias { member . path } was resolved to { member . target . path } \" ) # type: ignore[union-attr] resolved . add ( member . path ) elif member . kind in { Kind . MODULE , Kind . CLASS } and member . path not in seen : sub_resolved , sub_unresolved = self . resolve_module_aliases ( member , implicit , external , seen # type: ignore[arg-type] ) resolved |= sub_resolved unresolved |= sub_unresolved return resolved , unresolved stats \u00a4 stats () Compute some statistics. Returns: dict \u2013 Some statistics. Source code in griffe/loader.py 366 367 368 369 370 371 372 def stats ( self ) -> dict : \"\"\"Compute some statistics. Returns: Some statistics. \"\"\" return { ** stats ( self ), ** self . _time_stats } load \u00a4 load ( module , submodules = True , try_relative_path = True , extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True , ) Load and return a module. Example: import griffe module = griffe . load ( ... ) This is a shortcut for: from griffe.loader import GriffeLoader loader = GriffeLoader ( ... ) module = loader . load_module ( ... ) See the documentation for the loader: GriffeLoader . Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Returns: Module \u2013 A loaded module. Source code in griffe/loader.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 def load ( module : str | Path , submodules : bool = True , try_relative_path : bool = True , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> Module : \"\"\"Load and return a module. Example: ```python import griffe module = griffe.load(...) ``` This is a shortcut for: ```python from griffe.loader import GriffeLoader loader = GriffeLoader(...) module = loader.load_module(...) ``` See the documentation for the loader: [`GriffeLoader`][griffe.loader.GriffeLoader]. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. try_relative_path: Whether to try finding the module as a relative path. extensions: The extensions to use. search_paths: The paths to search into. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. Returns: A loaded module. \"\"\" return GriffeLoader ( extensions = extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , allow_inspection = allow_inspection , ) . load_module ( module = module , submodules = submodules , try_relative_path = try_relative_path , )","title":"loader"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader","text":"GriffeLoader ( extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True , ) The Griffe loader, allowing to load data from modules. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Source code in griffe/loader.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def __init__ ( self , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. search_paths: The paths to search into. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () self . allow_inspection : bool = allow_inspection self . finder : ModuleFinder = ModuleFinder ( search_paths ) self . _time_stats : dict = { \"time_spent_visiting\" : 0 , \"time_spent_inspecting\" : 0 , } patch_ast ()","title":"GriffeLoader"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.expand_exports","text":"expand_exports ( module , seen = None ) Expand exports: try to recursively expand all module exports. Parameters: module ( Module ) \u2013 The module to recurse on. seen ( set | None ) \u2013 Used to avoid infinite recursion. Source code in griffe/loader.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def expand_exports ( self , module : Module , seen : set | None = None ) -> None : # noqa: WPS231 \"\"\"Expand exports: try to recursively expand all module exports. Parameters: module: The module to recurse on. seen: Used to avoid infinite recursion. \"\"\" seen = seen or set () seen . add ( module . path ) if module . exports is None : return expanded = set () for export in module . exports : if isinstance ( export , Name ): module_path = export . full . rsplit ( \".\" , 1 )[ 0 ] # remove trailing .__all__ next_module = self . modules_collection [ module_path ] if next_module . path not in seen : self . expand_exports ( next_module , seen ) try : expanded |= next_module . exports except TypeError : logger . warning ( f \"Unsupported item in { module . path } .__all__: { export } (use strings only)\" ) else : expanded . add ( export ) module . exports = expanded","title":"expand_exports()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.expand_wildcards","text":"expand_wildcards ( obj , only_known_modules = True , seen = None ) Expand wildcards: try to recursively expand all found wildcards. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to expand wildcards. seen ( set | None ) \u2013 Used to avoid infinite recursion. Source code in griffe/loader.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def expand_wildcards ( # noqa: WPS231 self , obj : Object , only_known_modules : bool = True , seen : set | None = None , ) -> None : \"\"\"Expand wildcards: try to recursively expand all found wildcards. Parameters: obj: The object and its members to recurse on. only_known_modules: When true, don't try to load unspecified modules to expand wildcards. seen: Used to avoid infinite recursion. \"\"\" expanded = [] to_remove = [] seen = seen or set () seen . add ( obj . path ) for member in obj . members . values (): if member . is_alias and member . wildcard : # type: ignore[union-attr] # we know it's an alias package = member . wildcard . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] not_loaded = obj . package . path != package and package not in self . modules_collection if not_loaded : if only_known_modules : continue try : self . load_module ( package , try_relative_path = False ) except ImportError as error : logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) continue target = self . modules_collection [ member . target_path ] # type: ignore[union-attr] if target . path not in seen : try : self . expand_wildcards ( target , only_known_modules , seen ) # type: ignore[union-attr] except ( AliasResolutionError , CyclicAliasError ) as error : # noqa: WPS440 logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) continue expanded . extend ( self . _expand_wildcard ( member )) # type: ignore[arg-type] to_remove . append ( member . name ) elif not member . is_alias and member . is_module and member . path not in seen : self . expand_wildcards ( member , only_known_modules , seen ) # type: ignore[arg-type] for name in to_remove : del obj [ name ] # noqa: WPS420 for new_member , alias_lineno , alias_endlineno in expanded : overwrite = False already_present = new_member . name in obj . members if already_present : old_member = obj [ new_member . name ] old_lineno = getattr ( old_member , \"alias_lineno\" , old_member . lineno or 0 ) overwrite = alias_lineno > old_lineno # type: ignore[operator] if not already_present or overwrite : obj [ new_member . name ] = Alias ( new_member . name , new_member , lineno = alias_lineno , endlineno = alias_endlineno )","title":"expand_wildcards()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.load_module","text":"load_module ( module , submodules = True , try_relative_path = True ) Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. Raises: LoadingError \u2013 When loading a module failed for various reasons. ModuleNotFoundError \u2013 When a module was not found and inspection is disallowed. Returns: Module \u2013 A module. Source code in griffe/loader.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def load_module ( # noqa: WPS231 self , module : str | Path , submodules : bool = True , try_relative_path : bool = True , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. try_relative_path: Whether to try finding the module as a relative path. Raises: LoadingError: When loading a module failed for various reasons. ModuleNotFoundError: When a module was not found and inspection is disallowed. Returns: A module. \"\"\" module_name : str if module in _builtin_modules : logger . debug ( f \" { module } is a builtin module\" ) if self . allow_inspection : logger . debug ( f \"Inspecting { module } \" ) module_name = module # type: ignore[assignment] top_module = self . _inspect_module ( module ) # type: ignore[arg-type] self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index] raise LoadingError ( \"Cannot load builtin module without inspection\" ) try : # noqa: WPS503 module_name , package = self . finder . find_spec ( module , try_relative_path ) except ModuleNotFoundError : logger . debug ( f \"Could not find { module } \" ) if self . allow_inspection : logger . debug ( f \"Trying inspection on { module } \" ) module_name = module # type: ignore[assignment] top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : raise else : logger . debug ( f \"Found { module } : loading\" ) try : # noqa: WPS505 top_module = self . _load_package ( package , submodules = submodules ) except LoadingError as error : # noqa: WPS440 logger . error ( str ( error )) raise return self . modules_collection [ module_name ] # type: ignore[index]","title":"load_module()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_aliases","text":"resolve_aliases ( * , implicit = None , external = None , max_iterations = None , only_exported = None , only_known_modules = None ) Resolve aliases. Parameters: implicit ( bool | None ) \u2013 When false, only try to resolve an alias if it is explicitely exported. external ( bool | None ) \u2013 When false, don't try to load unspecified modules to resolve aliases. max_iterations ( int | None ) \u2013 Maximum number of iterations on the loader modules collection. only_exported ( bool | None ) \u2013 Deprecated. Use the implicit parameter instead (inverting the value). only_known_modules ( bool | None ) \u2013 Deprecated. Use the external parameter instead (inverting the value). Returns: tuple [ set [ str ], int ] \u2013 The unresolved aliases and the number of iterations done. Source code in griffe/loader.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def resolve_aliases ( # noqa: WPS231 self , * , implicit : bool | None = None , external : bool | None = None , max_iterations : int | None = None , only_exported : bool | None = None , only_known_modules : bool | None = None , ) -> tuple [ set [ str ], int ]: \"\"\"Resolve aliases. Parameters: implicit: When false, only try to resolve an alias if it is explicitely exported. external: When false, don't try to load unspecified modules to resolve aliases. max_iterations: Maximum number of iterations on the loader modules collection. only_exported: Deprecated. Use the `implicit` parameter instead (inverting the value). only_known_modules: Deprecated. Use the `external` parameter instead (inverting the value). Returns: The unresolved aliases and the number of iterations done. \"\"\" # TODO: remove deprecated params at some point if only_exported is not None and implicit is None : warn ( \"Parameter `only_exported` is deprecated, use `implicit` instead.\" , DeprecationWarning , stacklevel = 2 , ) implicit = not only_exported if only_known_modules is not None and external is None : warn ( \"Parameter `only_known_modules` is deprecated, use `external` instead.\" , DeprecationWarning , stacklevel = 2 , ) external = not only_known_modules # TODO: set as param defaults once deprecated params are dropped if implicit is None : implicit = False if external is None : external = False if max_iterations is None : max_iterations = float ( \"inf\" ) # type: ignore[assignment] prev_unresolved : set [ str ] = set () unresolved : set [ str ] = set ( \"0\" ) # init to enter loop iteration = 0 collection = self . modules_collection . members for exports_module in list ( collection . values ()): self . expand_exports ( exports_module ) for wildcards_module in list ( collection . values ()): self . expand_wildcards ( wildcards_module ) while unresolved and unresolved != prev_unresolved and iteration < max_iterations : # type: ignore[operator] prev_unresolved = unresolved - { \"0\" } unresolved = set () resolved : set [ str ] = set () iteration += 1 for module_name in list ( collection . keys ()): module = collection [ module_name ] next_resolved , next_unresolved = self . resolve_module_aliases ( module , implicit , external ) resolved |= next_resolved unresolved |= next_unresolved logger . debug ( f \"Iteration { iteration } finished, { len ( resolved ) } aliases resolved, still { len ( unresolved ) } to go\" ) return unresolved , iteration","title":"resolve_aliases()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_module_aliases","text":"resolve_module_aliases ( obj , implicit = False , external = False , seen = None ) Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. implicit ( bool ) \u2013 When false, only try to resolve an alias if it is explicitely exported. external ( bool ) \u2013 When false, don't try to load unspecified modules to resolve aliases. seen ( set | None ) \u2013 Used to avoid infinite recursion. Returns: tuple [ set [ str ], set [ str ]] \u2013 Both sets of resolved and unresolved aliases. Source code in griffe/loader.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def resolve_module_aliases ( # noqa: WPS231 self , obj : Object , implicit : bool = False , external : bool = False , seen : set | None = None , ) -> tuple [ set [ str ], set [ str ]]: \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. implicit: When false, only try to resolve an alias if it is explicitely exported. external: When false, don't try to load unspecified modules to resolve aliases. seen: Used to avoid infinite recursion. Returns: Both sets of resolved and unresolved aliases. \"\"\" resolved = set () unresolved = set () seen = seen or set () seen . add ( obj . path ) for member in obj . members . values (): # noqa: WPS440 if member . is_alias : if member . wildcard or member . resolved : # type: ignore[union-attr] continue if not implicit and not member . is_explicitely_exported : continue try : member . resolve_target () # type: ignore[union-attr] except AliasResolutionError as error : # noqa: WPS440 path = member . path target = error . target_path # type: ignore[union-attr] # noqa: WPS437 logger . debug ( f \"Alias resolution error for { path } -> { target } \" ) unresolved . add ( path ) package = target . split ( \".\" , 1 )[ 0 ] load_module = external and obj . package . path != package and package not in self . modules_collection if load_module : try : # noqa: WPS505 self . load_module ( package , try_relative_path = False ) except ImportError as error : # noqa: WPS440 logger . debug ( f \"Could not follow alias { member . path } : { error } \" ) except CyclicAliasError as error : logger . debug ( str ( error )) else : logger . debug ( f \"Alias { member . path } was resolved to { member . target . path } \" ) # type: ignore[union-attr] resolved . add ( member . path ) elif member . kind in { Kind . MODULE , Kind . CLASS } and member . path not in seen : sub_resolved , sub_unresolved = self . resolve_module_aliases ( member , implicit , external , seen # type: ignore[arg-type] ) resolved |= sub_resolved unresolved |= sub_unresolved return resolved , unresolved","title":"resolve_module_aliases()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.stats","text":"stats () Compute some statistics. Returns: dict \u2013 Some statistics. Source code in griffe/loader.py 366 367 368 369 370 371 372 def stats ( self ) -> dict : \"\"\"Compute some statistics. Returns: Some statistics. \"\"\" return { ** stats ( self ), ** self . _time_stats }","title":"stats()"},{"location":"reference/griffe/loader/#griffe.loader.load","text":"load ( module , submodules = True , try_relative_path = True , extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , allow_inspection = True , ) Load and return a module. Example: import griffe module = griffe . load ( ... ) This is a shortcut for: from griffe.loader import GriffeLoader loader = GriffeLoader ( ... ) module = loader . load_module ( ... ) See the documentation for the loader: GriffeLoader . Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. allow_inspection ( bool ) \u2013 Whether to allow inspecting modules when visiting them is not possible. Returns: Module \u2013 A loaded module. Source code in griffe/loader.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 def load ( module : str | Path , submodules : bool = True , try_relative_path : bool = True , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , allow_inspection : bool = True , ) -> Module : \"\"\"Load and return a module. Example: ```python import griffe module = griffe.load(...) ``` This is a shortcut for: ```python from griffe.loader import GriffeLoader loader = GriffeLoader(...) module = loader.load_module(...) ``` See the documentation for the loader: [`GriffeLoader`][griffe.loader.GriffeLoader]. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. try_relative_path: Whether to try finding the module as a relative path. extensions: The extensions to use. search_paths: The paths to search into. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. allow_inspection: Whether to allow inspecting modules when visiting them is not possible. Returns: A loaded module. \"\"\" return GriffeLoader ( extensions = extensions , search_paths = search_paths , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , allow_inspection = allow_inspection , ) . load_module ( module = module , submodules = submodules , try_relative_path = try_relative_path , )","title":"load()"},{"location":"reference/griffe/logger/","text":"This module contains logging utilities. We provide the patch_loggers function so dependant libraries can patch loggers as they see fit. For example, to fit in the MkDocs logging configuration and prefix each log message with the module name: import logging from griffe.logger import patch_loggers class LoggerAdapter ( logging . LoggerAdapter ): def __init__ ( self , prefix , logger ): super () . __init__ ( logger , {}) self . prefix = prefix def process ( self , msg , kwargs ): return f \" { self . prefix } : { msg } \" , kwargs def get_logger ( name ): logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) return LoggerAdapter ( name , logger ) patch_loggers ( get_logger ) LogLevel \u00a4 Bases: Enum Enumeration of available log levels. get_logger \u00a4 get_logger ( name ) Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: _Logger \u2013 The logger. Source code in griffe/logger.py 74 75 76 77 78 79 80 81 82 83 def get_logger ( name : str ) -> _Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return _Logger ( name ) patch_loggers \u00a4 patch_loggers ( get_logger_func ) Patch loggers. Parameters: get_logger_func ( Callable [[ str ], Any ] ) \u2013 A function accepting a name as parameter and returning a logger. Source code in griffe/logger.py 86 87 88 89 90 91 92 def patch_loggers ( get_logger_func : Callable [[ str ], Any ]) -> None : \"\"\"Patch loggers. Parameters: get_logger_func: A function accepting a name as parameter and returning a logger. \"\"\" _Logger . _patch_loggers ( get_logger_func ) # noqa: WPS437","title":"logger"},{"location":"reference/griffe/logger/#griffe.logger.LogLevel","text":"Bases: Enum Enumeration of available log levels.","title":"LogLevel"},{"location":"reference/griffe/logger/#griffe.logger.get_logger","text":"get_logger ( name ) Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: _Logger \u2013 The logger. Source code in griffe/logger.py 74 75 76 77 78 79 80 81 82 83 def get_logger ( name : str ) -> _Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return _Logger ( name )","title":"get_logger()"},{"location":"reference/griffe/logger/#griffe.logger.patch_loggers","text":"patch_loggers ( get_logger_func ) Patch loggers. Parameters: get_logger_func ( Callable [[ str ], Any ] ) \u2013 A function accepting a name as parameter and returning a logger. Source code in griffe/logger.py 86 87 88 89 90 91 92 def patch_loggers ( get_logger_func : Callable [[ str ], Any ]) -> None : \"\"\"Patch loggers. Parameters: get_logger_func: A function accepting a name as parameter and returning a logger. \"\"\" _Logger . _patch_loggers ( get_logger_func ) # noqa: WPS437","title":"patch_loggers()"},{"location":"reference/griffe/merger/","text":"This module contains utilities to merge data together. merge_stubs \u00a4 merge_stubs ( mod1 , mod2 ) Merge stubs into a module. Parameters: mod1 ( Module ) \u2013 A regular module or stubs module. mod2 ( Module ) \u2013 A regular module or stubs module. Raises: ValueError \u2013 When both modules are regular modules (no stubs is passed). Returns: Module \u2013 The regular module. Source code in griffe/merger.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def merge_stubs ( mod1 : Module , mod2 : Module ) -> Module : \"\"\"Merge stubs into a module. Parameters: mod1: A regular module or stubs module. mod2: A regular module or stubs module. Raises: ValueError: When both modules are regular modules (no stubs is passed). Returns: The regular module. \"\"\" logger . debug ( f \"Trying to merge { mod1 . filepath } and { mod2 . filepath } \" ) if mod1 . filepath . suffix == \".pyi\" : # type: ignore[union-attr] stubs = mod1 module = mod2 elif mod2 . filepath . suffix == \".pyi\" : # type: ignore[union-attr] stubs = mod2 module = mod1 else : raise ValueError ( \"cannot merge regular (non-stubs) modules together\" ) _merge_module_stubs ( module , stubs ) return module","title":"merger"},{"location":"reference/griffe/merger/#griffe.merger.merge_stubs","text":"merge_stubs ( mod1 , mod2 ) Merge stubs into a module. Parameters: mod1 ( Module ) \u2013 A regular module or stubs module. mod2 ( Module ) \u2013 A regular module or stubs module. Raises: ValueError \u2013 When both modules are regular modules (no stubs is passed). Returns: Module \u2013 The regular module. Source code in griffe/merger.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def merge_stubs ( mod1 : Module , mod2 : Module ) -> Module : \"\"\"Merge stubs into a module. Parameters: mod1: A regular module or stubs module. mod2: A regular module or stubs module. Raises: ValueError: When both modules are regular modules (no stubs is passed). Returns: The regular module. \"\"\" logger . debug ( f \"Trying to merge { mod1 . filepath } and { mod2 . filepath } \" ) if mod1 . filepath . suffix == \".pyi\" : # type: ignore[union-attr] stubs = mod1 module = mod2 elif mod2 . filepath . suffix == \".pyi\" : # type: ignore[union-attr] stubs = mod2 module = mod1 else : raise ValueError ( \"cannot merge regular (non-stubs) modules together\" ) _merge_module_stubs ( module , stubs ) return module","title":"merge_stubs()"},{"location":"reference/griffe/mixins/","text":"This module contains some mixins classes about accessing and setting members. DelMembersMixin \u00a4 This mixin adds a __delitem__ method to a class. GetMembersMixin \u00a4 This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance. ObjectAliasMixin \u00a4 A mixin for methods that appear both in objects and aliases, unchanged. is_explicitely_exported property \u00a4 is_explicitely_exported : bool Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False. is_implicitely_exported property \u00a4 is_implicitely_exported : bool Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False. is_exported \u00a4 is_exported ( explicitely = True ) Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 94 95 96 97 98 99 100 101 102 103 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined] SerializationMixin \u00a4 A mixin that adds de/serialization conveniences. as_json \u00a4 as_json ( full = False , ** kwargs ) Return this object's data as a JSON string. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options passed to encoder. Returns: str \u2013 A string. Source code in griffe/mixins.py 127 128 129 130 131 132 133 134 135 136 137 138 139 def as_json ( self , full : bool = False , ** kwargs : Any ) -> str : \"\"\"Return this object's data as a JSON string. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options passed to encoder. Returns: A string. \"\"\" from griffe.encoders import JSONEncoder # avoid circular import return json . dumps ( self , cls = JSONEncoder , full = full , ** kwargs ) from_json classmethod \u00a4 from_json ( json_string , ** kwargs ) Create an instance of this class from a JSON string. Parameters: json_string ( str ) \u2013 JSON to decode into Object. **kwargs ( Any ) \u2013 Additional options passed to decoder. Returns: _ObjType \u2013 An Object instance. Raises: TypeError \u2013 When the json_string does not represent and object of the class from which this classmethod has been called. Source code in griffe/mixins.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @classmethod def from_json ( cls : Type [ _ObjType ], json_string : str , ** kwargs : Any ) -> _ObjType : \"\"\"Create an instance of this class from a JSON string. Parameters: json_string: JSON to decode into Object. **kwargs: Additional options passed to decoder. Returns: An Object instance. Raises: TypeError: When the json_string does not represent and object of the class from which this classmethod has been called. \"\"\" from griffe.encoders import json_decoder # avoid circular import kwargs . setdefault ( \"object_hook\" , json_decoder ) obj = json . loads ( json_string , ** kwargs ) if not isinstance ( obj , cls ): raise TypeError ( f \"provided JSON object is not of type { cls } \" ) return obj SetMembersMixin \u00a4 Bases: DelMembersMixin This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well.","title":"mixins"},{"location":"reference/griffe/mixins/#griffe.mixins.DelMembersMixin","text":"This mixin adds a __delitem__ method to a class.","title":"DelMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin","text":"This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance.","title":"GetMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin","text":"A mixin for methods that appear both in objects and aliases, unchanged.","title":"ObjectAliasMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_explicitely_exported","text":"is_explicitely_exported : bool Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False.","title":"is_explicitely_exported"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_implicitely_exported","text":"is_implicitely_exported : bool Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False.","title":"is_implicitely_exported"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_exported","text":"is_exported ( explicitely = True ) Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 94 95 96 97 98 99 100 101 102 103 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined]","title":"is_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.SerializationMixin","text":"A mixin that adds de/serialization conveniences.","title":"SerializationMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.SerializationMixin.as_json","text":"as_json ( full = False , ** kwargs ) Return this object's data as a JSON string. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options passed to encoder. Returns: str \u2013 A string. Source code in griffe/mixins.py 127 128 129 130 131 132 133 134 135 136 137 138 139 def as_json ( self , full : bool = False , ** kwargs : Any ) -> str : \"\"\"Return this object's data as a JSON string. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options passed to encoder. Returns: A string. \"\"\" from griffe.encoders import JSONEncoder # avoid circular import return json . dumps ( self , cls = JSONEncoder , full = full , ** kwargs )","title":"as_json()"},{"location":"reference/griffe/mixins/#griffe.mixins.SerializationMixin.from_json","text":"from_json ( json_string , ** kwargs ) Create an instance of this class from a JSON string. Parameters: json_string ( str ) \u2013 JSON to decode into Object. **kwargs ( Any ) \u2013 Additional options passed to decoder. Returns: _ObjType \u2013 An Object instance. Raises: TypeError \u2013 When the json_string does not represent and object of the class from which this classmethod has been called. Source code in griffe/mixins.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @classmethod def from_json ( cls : Type [ _ObjType ], json_string : str , ** kwargs : Any ) -> _ObjType : \"\"\"Create an instance of this class from a JSON string. Parameters: json_string: JSON to decode into Object. **kwargs: Additional options passed to decoder. Returns: An Object instance. Raises: TypeError: When the json_string does not represent and object of the class from which this classmethod has been called. \"\"\" from griffe.encoders import json_decoder # avoid circular import kwargs . setdefault ( \"object_hook\" , json_decoder ) obj = json . loads ( json_string , ** kwargs ) if not isinstance ( obj , cls ): raise TypeError ( f \"provided JSON object is not of type { cls } \" ) return obj","title":"from_json()"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin","text":"Bases: DelMembersMixin This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well.","title":"SetMembersMixin"},{"location":"reference/griffe/stats/","text":"This module contains utilities to compute loading statistics. stats \u00a4 stats ( loader ) Return some loading statistics. Parameters: loader ( GriffeLoader ) \u2013 The loader to compute stats from. Returns: dict \u2013 Some statistics. Source code in griffe/stats.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def stats ( loader : GriffeLoader ) -> dict : \"\"\"Return some loading statistics. Parameters: loader: The loader to compute stats from. Returns: Some statistics. \"\"\" modules_by_extension = { \"\" : 0 , \".py\" : 0 , \".pyc\" : 0 , \".pyo\" : 0 , \".pyd\" : 0 , \".so\" : 0 , } top_modules = loader . modules_collection . members . values () for module in top_modules : _sum_extensions ( modules_by_extension , module ) n_lines = sum ( len ( lines ) for lines in loader . lines_collection . values ()) return { \"packages\" : len ( top_modules ), \"modules\" : len ( top_modules ) + sum ( _n_modules ( mod ) for mod in top_modules ), \"classes\" : sum ( _n_classes ( mod ) for mod in top_modules ), \"functions\" : sum ( _n_functions ( mod ) for mod in top_modules ), \"attributes\" : sum ( _n_attributes ( mod ) for mod in top_modules ), \"modules_by_extension\" : modules_by_extension , \"lines\" : n_lines , }","title":"stats"},{"location":"reference/griffe/stats/#griffe.stats.stats","text":"stats ( loader ) Return some loading statistics. Parameters: loader ( GriffeLoader ) \u2013 The loader to compute stats from. Returns: dict \u2013 Some statistics. Source code in griffe/stats.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def stats ( loader : GriffeLoader ) -> dict : \"\"\"Return some loading statistics. Parameters: loader: The loader to compute stats from. Returns: Some statistics. \"\"\" modules_by_extension = { \"\" : 0 , \".py\" : 0 , \".pyc\" : 0 , \".pyo\" : 0 , \".pyd\" : 0 , \".so\" : 0 , } top_modules = loader . modules_collection . members . values () for module in top_modules : _sum_extensions ( modules_by_extension , module ) n_lines = sum ( len ( lines ) for lines in loader . lines_collection . values ()) return { \"packages\" : len ( top_modules ), \"modules\" : len ( top_modules ) + sum ( _n_modules ( mod ) for mod in top_modules ), \"classes\" : sum ( _n_classes ( mod ) for mod in top_modules ), \"functions\" : sum ( _n_functions ( mod ) for mod in top_modules ), \"attributes\" : sum ( _n_attributes ( mod ) for mod in top_modules ), \"modules_by_extension\" : modules_by_extension , \"lines\" : n_lines , }","title":"stats()"},{"location":"reference/griffe/agents/","text":"These modules contain the different agents that are able to extract data.","title":"agents"},{"location":"reference/griffe/agents/base/","text":"This module contains the base classes for dealing with extensions. BaseInspector \u00a4 The base class for inspectors. generic_inspect \u00a4 generic_inspect ( node ) Inspect the children of a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect (its children). Source code in griffe/agents/base.py 40 41 42 43 44 45 def generic_inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\" inspect \u00a4 inspect ( node ) Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/base.py 32 33 34 35 36 37 38 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node ) BaseVisitor \u00a4 The base class for visitors. generic_visit \u00a4 generic_visit ( node ) Visit the children of a node. Parameters: node ( ast . AST ) \u2013 The node to visit (its children). Source code in griffe/agents/base.py 21 22 23 24 25 26 def generic_visit ( self , node : ast . AST ) -> None : \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\" visit \u00a4 visit ( node ) Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/base.py 13 14 15 16 17 18 19 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined]","title":"base"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector","text":"The base class for inspectors.","title":"BaseInspector"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.generic_inspect","text":"generic_inspect ( node ) Inspect the children of a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect (its children). Source code in griffe/agents/base.py 40 41 42 43 44 45 def generic_inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\"","title":"generic_inspect()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.inspect","text":"inspect ( node ) Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/base.py 32 33 34 35 36 37 38 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node )","title":"inspect()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor","text":"The base class for visitors.","title":"BaseVisitor"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.generic_visit","text":"generic_visit ( node ) Visit the children of a node. Parameters: node ( ast . AST ) \u2013 The node to visit (its children). Source code in griffe/agents/base.py 21 22 23 24 25 26 def generic_visit ( self , node : ast . AST ) -> None : \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\"","title":"generic_visit()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.visit","text":"visit ( node ) Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/base.py 13 14 15 16 17 18 19 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined]","title":"visit()"},{"location":"reference/griffe/agents/inspector/","text":"This module defines introspection mechanisms. Sometimes we cannot get the source code of a module or an object, typically built-in modules like itertools . The only way to know what they are made of is to actually import them and inspect their contents. Sometimes, even if the source code is available, loading the object is desired because it was created or modified dynamically, and our node visitor is not powerful enough to infer all these dynamic modifications. In this case, we always try to visit the code first, and only then we load the object to update the data with introspection. This module exposes a public function, inspect() , which inspects the module using inspect.getmembers() , and returns a new Module instance, populating its members recursively, by using a NodeVisitor -like class. The inspection agent works similarly to the regular \"node visitor\" agent, in that it maintains a state with the current object being handled, and recursively handle its members. Inspector \u00a4 Inspector ( module_name , filepath , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , ) Bases: BaseInspector This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path | None ) \u2013 The optional filepath. extensions ( Extensions ) \u2013 Extensions to use when inspecting. parent ( Module | None ) \u2013 The module parent. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Source code in griffe/agents/inspector.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () generic_inspect \u00a4 generic_inspect ( node ) Extend the base generic inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) for child in node . children : child_module_path = _should_create_alias ( node , child , self . current . module . path ) if child_module_path : child_name = getattr ( child . obj , \"__name__\" , child . name ) target_path = f \" { child_module_path } . { child_name } \" self . current [ child . name ] = Alias ( child . name , target_path ) else : self . inspect ( child ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node ) get_module \u00a4 get_module ( import_paths = None ) Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Parameters: import_paths ( list [ Path ] | None ) \u2013 Paths replacing sys.path to import the module. Returns: Module \u2013 A module instance. Source code in griffe/agents/inspector.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def get_module ( self , import_paths : list [ Path ] | None = None ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Parameters: import_paths: Paths replacing `sys.path` to import the module. Returns: A module instance. \"\"\" import_path = self . module_name if self . parent is not None : import_path = f \" { self . parent . path } . { import_path } \" value = dynamic_import ( import_path , import_paths ) top_node = ObjectNode ( value , self . module_name ) self . inspect ( top_node ) return self . current . module handle_attribute \u00a4 handle_attribute ( node , annotation = None ) Handle an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. annotation ( str | Name | Expression | None ) \u2013 A potentiel annotation. Source code in griffe/agents/inspector.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO: to improve parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) try : value = repr ( node . obj ) except Exception : # could trigger anything value = None docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj ) handle_function \u00a4 handle_function ( node , labels = None ) Handle a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/inspector.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ( AttributeError , ValueError , TokenError , TypeError ): parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter , parent = self . current ) for parameter in signature . parameters . values ()] ) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = _convert_object_to_annotation ( return_annotation , parent = self . current ) obj : Attribute | Function labels = labels or set () if \"property\" in labels : obj = Attribute ( name = node . name , value = None , annotation = returns , docstring = self . _get_docstring ( node ), ) else : obj = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) obj . labels |= labels self . current [ node . name ] = obj inspect \u00a4 inspect ( node ) Extend the base inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 220 221 222 223 224 225 226 227 228 229 230 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node ) inspect_attribute \u00a4 inspect_attribute ( node ) Inspect an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 408 409 410 411 412 413 414 def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node ) inspect_builtin_function \u00a4 inspect_builtin_function ( node ) Inspect a builtin function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 334 335 336 337 338 339 340 def inspect_builtin_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) inspect_builtin_method \u00a4 inspect_builtin_method ( node ) Inspect a builtin method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 310 311 312 313 314 315 316 def inspect_builtin_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) inspect_cached_property \u00a4 inspect_cached_property ( node ) Inspect a cached property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 350 351 352 353 354 355 356 357 def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" node . obj = node . obj . func self . handle_function ( node , { \"cached\" , \"property\" }) inspect_class \u00a4 inspect_class ( node ) Inspect a class. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment] inspect_classmethod \u00a4 inspect_classmethod ( node ) Inspect a class method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 294 295 296 297 298 299 300 def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" }) inspect_coroutine \u00a4 inspect_coroutine ( node ) Inspect a coroutine. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 326 327 328 329 330 331 332 def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" }) inspect_function \u00a4 inspect_function ( node ) Inspect a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 342 343 344 345 346 347 348 def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) inspect_method \u00a4 inspect_method ( node ) Inspect a method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 318 319 320 321 322 323 324 def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) inspect_method_descriptor \u00a4 inspect_method_descriptor ( node ) Inspect a method descriptor. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 302 303 304 305 306 307 308 def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" }) inspect_module \u00a4 inspect_module ( node ) Inspect a module. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node ) inspect_property \u00a4 inspect_property ( node ) Inspect a property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 359 360 361 362 363 364 365 def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" }) inspect_staticmethod \u00a4 inspect_staticmethod ( node ) Inspect a static method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 286 287 288 289 290 291 292 def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" }) inspect \u00a4 inspect ( module_name , * , filepath = None , import_paths = None , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None ) Inspect a module. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path | None ) \u2013 The module file path. import_paths ( list [ Path ] | None ) \u2013 Paths to import the module from. extensions ( Extensions | None ) \u2013 The extensions to use when inspecting the module. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/inspector.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def inspect ( module_name : str , * , filepath : Path | None = None , import_paths : list [ Path ] | None = None , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Inspect a module. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. import_paths: Paths to import the module from. extensions: The extensions to use when inspecting the module. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" if not import_paths and filepath : import_paths = [ filepath . parent ] return Inspector ( module_name , filepath , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ( import_paths )","title":"inspector"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector","text":"Inspector ( module_name , filepath , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , ) Bases: BaseInspector This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path | None ) \u2013 The optional filepath. extensions ( Extensions ) \u2013 Extensions to use when inspecting. parent ( Module | None ) \u2013 The module parent. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Source code in griffe/agents/inspector.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection ()","title":"Inspector"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.generic_inspect","text":"generic_inspect ( node ) Extend the base generic inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) for child in node . children : child_module_path = _should_create_alias ( node , child , self . current . module . path ) if child_module_path : child_name = getattr ( child . obj , \"__name__\" , child . name ) target_path = f \" { child_module_path } . { child_name } \" self . current [ child . name ] = Alias ( child . name , target_path ) else : self . inspect ( child ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node )","title":"generic_inspect()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.get_module","text":"get_module ( import_paths = None ) Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Parameters: import_paths ( list [ Path ] | None ) \u2013 Paths replacing sys.path to import the module. Returns: Module \u2013 A module instance. Source code in griffe/agents/inspector.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def get_module ( self , import_paths : list [ Path ] | None = None ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Parameters: import_paths: Paths replacing `sys.path` to import the module. Returns: A module instance. \"\"\" import_path = self . module_name if self . parent is not None : import_path = f \" { self . parent . path } . { import_path } \" value = dynamic_import ( import_path , import_paths ) top_node = ObjectNode ( value , self . module_name ) self . inspect ( top_node ) return self . current . module","title":"get_module()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_attribute","text":"handle_attribute ( node , annotation = None ) Handle an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. annotation ( str | Name | Expression | None ) \u2013 A potentiel annotation. Source code in griffe/agents/inspector.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO: to improve parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) try : value = repr ( node . obj ) except Exception : # could trigger anything value = None docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj )","title":"handle_attribute()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_function","text":"handle_function ( node , labels = None ) Handle a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/inspector.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ( AttributeError , ValueError , TokenError , TypeError ): parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter , parent = self . current ) for parameter in signature . parameters . values ()] ) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = _convert_object_to_annotation ( return_annotation , parent = self . current ) obj : Attribute | Function labels = labels or set () if \"property\" in labels : obj = Attribute ( name = node . name , value = None , annotation = returns , docstring = self . _get_docstring ( node ), ) else : obj = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) obj . labels |= labels self . current [ node . name ] = obj","title":"handle_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect","text":"inspect ( node ) Extend the base inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 220 221 222 223 224 225 226 227 228 229 230 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node )","title":"inspect()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_attribute","text":"inspect_attribute ( node ) Inspect an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 408 409 410 411 412 413 414 def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node )","title":"inspect_attribute()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_function","text":"inspect_builtin_function ( node ) Inspect a builtin function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 334 335 336 337 338 339 340 def inspect_builtin_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" })","title":"inspect_builtin_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_method","text":"inspect_builtin_method ( node ) Inspect a builtin method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 310 311 312 313 314 315 316 def inspect_builtin_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" })","title":"inspect_builtin_method()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_cached_property","text":"inspect_cached_property ( node ) Inspect a cached property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 350 351 352 353 354 355 356 357 def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" node . obj = node . obj . func self . handle_function ( node , { \"cached\" , \"property\" })","title":"inspect_cached_property()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_class","text":"inspect_class ( node ) Inspect a class. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"inspect_class()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_classmethod","text":"inspect_classmethod ( node ) Inspect a class method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 294 295 296 297 298 299 300 def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" })","title":"inspect_classmethod()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_coroutine","text":"inspect_coroutine ( node ) Inspect a coroutine. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 326 327 328 329 330 331 332 def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" })","title":"inspect_coroutine()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_function","text":"inspect_function ( node ) Inspect a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 342 343 344 345 346 347 348 def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node )","title":"inspect_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method","text":"inspect_method ( node ) Inspect a method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 318 319 320 321 322 323 324 def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node )","title":"inspect_method()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method_descriptor","text":"inspect_method_descriptor ( node ) Inspect a method descriptor. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 302 303 304 305 306 307 308 def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" })","title":"inspect_method_descriptor()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_module","text":"inspect_module ( node ) Inspect a module. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node )","title":"inspect_module()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_property","text":"inspect_property ( node ) Inspect a property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 359 360 361 362 363 364 365 def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" })","title":"inspect_property()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_staticmethod","text":"inspect_staticmethod ( node ) Inspect a static method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 286 287 288 289 290 291 292 def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" })","title":"inspect_staticmethod()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.inspect","text":"inspect ( module_name , * , filepath = None , import_paths = None , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None ) Inspect a module. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path | None ) \u2013 The module file path. import_paths ( list [ Path ] | None ) \u2013 Paths to import the module from. extensions ( Extensions | None ) \u2013 The extensions to use when inspecting the module. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/inspector.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def inspect ( module_name : str , * , filepath : Path | None = None , import_paths : list [ Path ] | None = None , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Inspect a module. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. import_paths: Paths to import the module from. extensions: The extensions to use when inspecting the module. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" if not import_paths and filepath : import_paths = [ filepath . parent ] return Inspector ( module_name , filepath , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ( import_paths )","title":"inspect()"},{"location":"reference/griffe/agents/nodes/","text":"This module contains utilities for extracting information from nodes. ASTNode \u00a4 This class is dynamically added to the bases of each AST node class. children property cached \u00a4 children : Sequence [ ASTNode ] Build and return the children of this node. Returns: Sequence [ ASTNode ] \u2013 A list of children. first_child property cached \u00a4 first_child : ASTNode Return the first child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. kind property cached \u00a4 kind : str Return the kind of this node. Returns: str \u2013 The node kind. last_child property cached \u00a4 last_child : ASTNode Return the lasts child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. next property cached \u00a4 next : ASTNode Return the next sibling of this node. Raises: LastNodeError \u2013 When the node does not have next siblings. Returns: ASTNode \u2013 The sibling. next_siblings property cached \u00a4 next_siblings : Sequence [ ASTNode ] Return the next siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The next siblings. position property cached \u00a4 position : int Tell the position of this node amongst its siblings. Raises: RootNodeError \u2013 When the node doesn't have a parent. Returns: int \u2013 The node position amongst its siblings. previous property cached \u00a4 previous : ASTNode Return the previous sibling of this node. Raises: LastNodeError \u2013 When the node does not have previous siblings. Returns: ASTNode \u2013 The sibling. previous_siblings property cached \u00a4 previous_siblings : Sequence [ ASTNode ] Return the previous siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The previous siblings. siblings property cached \u00a4 siblings : Sequence [ ASTNode ] Return the siblings of this node. Returns: Sequence [ ASTNode ] \u2013 The siblings. ObjectKind \u00a4 Bases: enum . Enum Enumeration for the different kinds of objects. ObjectNode \u00a4 ObjectNode ( obj , name , parent = None ) Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj ( Any ) \u2013 The actual Python object. name ( str ) \u2013 The Python object's name. parent ( ObjectNode | None ) \u2013 The parent node. Parameters: obj ( Any ) \u2013 A Python object. name ( str ) \u2013 The object's name. parent ( ObjectNode | None ) \u2013 The object's parent node. Source code in griffe/agents/nodes.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent children property cached \u00a4 children : Sequence [ ObjectNode ] Build and return the children of this node. Returns: Sequence [ ObjectNode ] \u2013 A list of children. is_builtin_function property cached \u00a4 is_builtin_function : bool Tell if this node's object is a builtin function. Returns: bool \u2013 If this node's object is a builtin function. is_builtin_method property cached \u00a4 is_builtin_method : bool Tell if this node's object is a builtin method. Returns: bool \u2013 If this node's object is a builtin method. is_cached_property property cached \u00a4 is_cached_property : bool Tell if this node's object is a cached property. Returns: bool \u2013 If this node's object is a cached property. is_class property cached \u00a4 is_class : bool Tell if this node's object is a class. Returns: bool \u2013 If this node's object is a class. is_classmethod property cached \u00a4 is_classmethod : bool Tell if this node's object is a classmethod. Returns: bool \u2013 If this node's object is a classmethod. is_coroutine property cached \u00a4 is_coroutine : bool Tell if this node's object is a coroutine. Returns: bool \u2013 If this node's object is a coroutine. is_function property cached \u00a4 is_function : bool Tell if this node's object is a function. Returns: bool \u2013 If this node's object is a function. is_method property cached \u00a4 is_method : bool Tell if this node's object is a method. Returns: bool \u2013 If this node's object is a method. is_method_descriptor property cached \u00a4 is_method_descriptor : bool Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: bool \u2013 If this node's object is a method descriptor. is_module property cached \u00a4 is_module : bool Tell if this node's object is a module. Returns: bool \u2013 The root of the tree. is_property property cached \u00a4 is_property : bool Tell if this node's object is a property. Returns: bool \u2013 If this node's object is a property. is_staticmethod property cached \u00a4 is_staticmethod : bool Tell if this node's object is a staticmethod. Returns: bool \u2013 If this node's object is a staticmethod. kind property cached \u00a4 kind : ObjectKind Return the kind of this node. Returns: ObjectKind \u2013 The node kind. parent_is_class property cached \u00a4 parent_is_class : bool Tell if the object of this node's parent is a class. Returns: bool \u2013 If the object of this node's parent is a class. get_annotation \u00a4 get_annotation ( node , parent ) Extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 766 767 768 769 770 771 772 773 774 775 776 777 778 def get_annotation ( node : AST | None , parent : Module | Class ) -> str | Name | Expression | None : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" if node is None : return None return _get_annotation ( node , parent ) get_docstring \u00a4 get_docstring ( node , strict = False ) Extract a docstring. Parameters: node ( AST ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/agents/nodes.py 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 def get_docstring ( node : AST , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore[attr-defined] doc = node . body [ 0 ] . value # type: ignore[attr-defined] else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno # type: ignore[attr-defined] if isinstance ( doc , NodeStr ): # TODO: remove once Python 3.7 support is dropped # on Python 3.7, lineno seems to be the ending line of the string # rather than the starting one, so we substract the number of newlines lineno = doc . lineno if sys . version_info < ( 3 , 8 ): lineno -= doc . s . count ( \" \\n \" ) return doc . s , lineno , doc . end_lineno # type: ignore[attr-defined] return None , None , None get_instance_names \u00a4 get_instance_names ( node ) Extract names from an assignment node, only for instance attributes. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 def get_instance_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )] get_name \u00a4 get_name ( node ) Extract name from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: str \u2013 A list of names. Source code in griffe/agents/nodes.py 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 def get_name ( node : AST ) -> str : \"\"\"Extract name from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_name_map [ type ( node )]( node ) get_names \u00a4 get_names ( node ) Extract names from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 def get_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map [ type ( node )]( node ) get_parameter_default \u00a4 get_parameter_default ( node , filepath , lines_collection ) Extract the default value of a function parameter. Parameters: node ( AST | None ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/agents/nodes.py 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 def get_parameter_default ( node : AST | None , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None with suppress ( KeyError ): return _get_value ( node ) if node . lineno == node . end_lineno : # type: ignore[attr-defined] return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # type: ignore[attr-defined] # TODO: handle multiple line defaults return None get_value \u00a4 get_value ( node ) Unparse a node to its string representation. Parameters: node ( AST | None ) \u2013 The node to unparse. Returns: str | None \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 def get_value ( node : AST | None ) -> str | None : \"\"\"Unparse a node to its string representation. Parameters: node: The node to unparse. Returns: The unparsed code of the node. \"\"\" if node is None : return None return _node_value_map [ type ( node )]( node ) parse__all__ \u00a4 parse__all__ ( node , parent ) Get the values declared in __all__ . Parameters: node ( NodeAssign | NodeAugAssign ) \u2013 The assignment node. parent ( Module ) \u2013 The parent module. Returns: list [ str | Name ] \u2013 A set of names. Source code in griffe/agents/nodes.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 def parse__all__ ( node : NodeAssign | NodeAugAssign , parent : Module ) -> list [ str | Name ]: # noqa: WPS120,WPS440 \"\"\"Get the values declared in `__all__`. Parameters: node: The assignment node. parent: The parent module. Returns: A set of names. \"\"\" try : return _parse__all__ ( node . value , parent ) except KeyError as error : logger . debug ( f \"Cannot parse __all__ assignment: { get_value ( node . value ) } ( { error } )\" ) return [] relative_to_absolute \u00a4 relative_to_absolute ( node , name , current_module ) Convert a relative import path to an absolute one. Parameters: node ( NodeImportFrom ) \u2013 The \"from ... import ...\" AST node. name ( NodeAlias ) \u2013 The imported name. current_module ( Module ) \u2013 The module in which the import happens. Returns: str \u2013 The absolute import path. Source code in griffe/agents/nodes.py 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 def relative_to_absolute ( node : NodeImportFrom , name : NodeAlias , current_module : Module ) -> str : \"\"\"Convert a relative import path to an absolute one. Parameters: node: The \"from ... import ...\" AST node. name: The imported name. current_module: The module in which the import happens. Returns: The absolute import path. \"\"\" level = node . level if level > 0 and current_module . is_package or current_module . is_subpackage : level -= 1 while level > 0 and current_module . parent is not None : current_module = current_module . parent # type: ignore[assignment] level -= 1 base = current_module . path + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" return base + node_module + name . name safe_get_annotation \u00a4 safe_get_annotation ( node , parent , log_level = LogLevel . error ) Safely (no exception) extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. log_level ( LogLevel ) \u2013 Log level to use to log a message. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 def safe_get_annotation ( node : AST | None , parent : Module | Class , log_level : LogLevel = LogLevel . error , ) -> str | Name | Expression | None : \"\"\"Safely (no exception) extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. log_level: Log level to use to log a message. Returns: A string or resovable name or expression. \"\"\" try : return get_annotation ( node , parent ) except Exception as error : message = f \"Failed to parse annotation from ' { node . __class__ . __name__ } ' node\" with suppress ( Exception ): message += f \" at { parent . relative_filepath } : { node . lineno } \" # type: ignore[union-attr] if not isinstance ( error , KeyError ): message += f \": { error } \" getattr ( logger , log_level . value )( message ) return None safe_get_value \u00a4 safe_get_value ( node , filepath = None ) Safely (no exception) unparse a node to its string representation. Parameters: node ( AST | None ) \u2013 The node to unparse. filepath ( str | Path | None ) \u2013 An optional filepath from where the node comes. Returns: str | None \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 def safe_get_value ( node : AST | None , filepath : str | Path | None = None ) -> str | None : \"\"\"Safely (no exception) unparse a node to its string representation. Parameters: node: The node to unparse. filepath: An optional filepath from where the node comes. Returns: The unparsed code of the node. \"\"\" try : return get_value ( node ) except Exception as error : message = f \"Failed to unparse node { node } \" if filepath : message += f \" at { filepath } : { node . lineno } \" # type: ignore[union-attr] message += f \": { error } \" logger . error ( message ) return None","title":"nodes"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode","text":"This class is dynamically added to the bases of each AST node class.","title":"ASTNode"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.children","text":"children : Sequence [ ASTNode ] Build and return the children of this node. Returns: Sequence [ ASTNode ] \u2013 A list of children.","title":"children"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.first_child","text":"first_child : ASTNode Return the first child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child.","title":"first_child"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.kind","text":"kind : str Return the kind of this node. Returns: str \u2013 The node kind.","title":"kind"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.last_child","text":"last_child : ASTNode Return the lasts child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child.","title":"last_child"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next","text":"next : ASTNode Return the next sibling of this node. Raises: LastNodeError \u2013 When the node does not have next siblings. Returns: ASTNode \u2013 The sibling.","title":"next"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next_siblings","text":"next_siblings : Sequence [ ASTNode ] Return the next siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The next siblings.","title":"next_siblings"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.position","text":"position : int Tell the position of this node amongst its siblings. Raises: RootNodeError \u2013 When the node doesn't have a parent. Returns: int \u2013 The node position amongst its siblings.","title":"position"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous","text":"previous : ASTNode Return the previous sibling of this node. Raises: LastNodeError \u2013 When the node does not have previous siblings. Returns: ASTNode \u2013 The sibling.","title":"previous"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous_siblings","text":"previous_siblings : Sequence [ ASTNode ] Return the previous siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The previous siblings.","title":"previous_siblings"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.siblings","text":"siblings : Sequence [ ASTNode ] Return the siblings of this node. Returns: Sequence [ ASTNode ] \u2013 The siblings.","title":"siblings"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind","text":"Bases: enum . Enum Enumeration for the different kinds of objects.","title":"ObjectKind"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode","text":"ObjectNode ( obj , name , parent = None ) Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj ( Any ) \u2013 The actual Python object. name ( str ) \u2013 The Python object's name. parent ( ObjectNode | None ) \u2013 The parent node. Parameters: obj ( Any ) \u2013 A Python object. name ( str ) \u2013 The object's name. parent ( ObjectNode | None ) \u2013 The object's parent node. Source code in griffe/agents/nodes.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent","title":"ObjectNode"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.children","text":"children : Sequence [ ObjectNode ] Build and return the children of this node. Returns: Sequence [ ObjectNode ] \u2013 A list of children.","title":"children"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_function","text":"is_builtin_function : bool Tell if this node's object is a builtin function. Returns: bool \u2013 If this node's object is a builtin function.","title":"is_builtin_function"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_method","text":"is_builtin_method : bool Tell if this node's object is a builtin method. Returns: bool \u2013 If this node's object is a builtin method.","title":"is_builtin_method"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_cached_property","text":"is_cached_property : bool Tell if this node's object is a cached property. Returns: bool \u2013 If this node's object is a cached property.","title":"is_cached_property"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_class","text":"is_class : bool Tell if this node's object is a class. Returns: bool \u2013 If this node's object is a class.","title":"is_class"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_classmethod","text":"is_classmethod : bool Tell if this node's object is a classmethod. Returns: bool \u2013 If this node's object is a classmethod.","title":"is_classmethod"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_coroutine","text":"is_coroutine : bool Tell if this node's object is a coroutine. Returns: bool \u2013 If this node's object is a coroutine.","title":"is_coroutine"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_function","text":"is_function : bool Tell if this node's object is a function. Returns: bool \u2013 If this node's object is a function.","title":"is_function"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method","text":"is_method : bool Tell if this node's object is a method. Returns: bool \u2013 If this node's object is a method.","title":"is_method"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method_descriptor","text":"is_method_descriptor : bool Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: bool \u2013 If this node's object is a method descriptor.","title":"is_method_descriptor"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_module","text":"is_module : bool Tell if this node's object is a module. Returns: bool \u2013 The root of the tree.","title":"is_module"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_property","text":"is_property : bool Tell if this node's object is a property. Returns: bool \u2013 If this node's object is a property.","title":"is_property"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_staticmethod","text":"is_staticmethod : bool Tell if this node's object is a staticmethod. Returns: bool \u2013 If this node's object is a staticmethod.","title":"is_staticmethod"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.kind","text":"kind : ObjectKind Return the kind of this node. Returns: ObjectKind \u2013 The node kind.","title":"kind"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.parent_is_class","text":"parent_is_class : bool Tell if the object of this node's parent is a class. Returns: bool \u2013 If the object of this node's parent is a class.","title":"parent_is_class"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_annotation","text":"get_annotation ( node , parent ) Extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 766 767 768 769 770 771 772 773 774 775 776 777 778 def get_annotation ( node : AST | None , parent : Module | Class ) -> str | Name | Expression | None : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" if node is None : return None return _get_annotation ( node , parent )","title":"get_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_docstring","text":"get_docstring ( node , strict = False ) Extract a docstring. Parameters: node ( AST ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/agents/nodes.py 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 def get_docstring ( node : AST , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore[attr-defined] doc = node . body [ 0 ] . value # type: ignore[attr-defined] else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno # type: ignore[attr-defined] if isinstance ( doc , NodeStr ): # TODO: remove once Python 3.7 support is dropped # on Python 3.7, lineno seems to be the ending line of the string # rather than the starting one, so we substract the number of newlines lineno = doc . lineno if sys . version_info < ( 3 , 8 ): lineno -= doc . s . count ( \" \\n \" ) return doc . s , lineno , doc . end_lineno # type: ignore[attr-defined] return None , None , None","title":"get_docstring()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_instance_names","text":"get_instance_names ( node ) Extract names from an assignment node, only for instance attributes. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 def get_instance_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )]","title":"get_instance_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_name","text":"get_name ( node ) Extract name from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: str \u2013 A list of names. Source code in griffe/agents/nodes.py 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 def get_name ( node : AST ) -> str : \"\"\"Extract name from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_name_map [ type ( node )]( node )","title":"get_name()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_names","text":"get_names ( node ) Extract names from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 def get_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map [ type ( node )]( node )","title":"get_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_parameter_default","text":"get_parameter_default ( node , filepath , lines_collection ) Extract the default value of a function parameter. Parameters: node ( AST | None ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/agents/nodes.py 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 def get_parameter_default ( node : AST | None , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None with suppress ( KeyError ): return _get_value ( node ) if node . lineno == node . end_lineno : # type: ignore[attr-defined] return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # type: ignore[attr-defined] # TODO: handle multiple line defaults return None","title":"get_parameter_default()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_value","text":"get_value ( node ) Unparse a node to its string representation. Parameters: node ( AST | None ) \u2013 The node to unparse. Returns: str | None \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 def get_value ( node : AST | None ) -> str | None : \"\"\"Unparse a node to its string representation. Parameters: node: The node to unparse. Returns: The unparsed code of the node. \"\"\" if node is None : return None return _node_value_map [ type ( node )]( node )","title":"get_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.parse__all__","text":"parse__all__ ( node , parent ) Get the values declared in __all__ . Parameters: node ( NodeAssign | NodeAugAssign ) \u2013 The assignment node. parent ( Module ) \u2013 The parent module. Returns: list [ str | Name ] \u2013 A set of names. Source code in griffe/agents/nodes.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 def parse__all__ ( node : NodeAssign | NodeAugAssign , parent : Module ) -> list [ str | Name ]: # noqa: WPS120,WPS440 \"\"\"Get the values declared in `__all__`. Parameters: node: The assignment node. parent: The parent module. Returns: A set of names. \"\"\" try : return _parse__all__ ( node . value , parent ) except KeyError as error : logger . debug ( f \"Cannot parse __all__ assignment: { get_value ( node . value ) } ( { error } )\" ) return []","title":"parse__all__()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.relative_to_absolute","text":"relative_to_absolute ( node , name , current_module ) Convert a relative import path to an absolute one. Parameters: node ( NodeImportFrom ) \u2013 The \"from ... import ...\" AST node. name ( NodeAlias ) \u2013 The imported name. current_module ( Module ) \u2013 The module in which the import happens. Returns: str \u2013 The absolute import path. Source code in griffe/agents/nodes.py 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 def relative_to_absolute ( node : NodeImportFrom , name : NodeAlias , current_module : Module ) -> str : \"\"\"Convert a relative import path to an absolute one. Parameters: node: The \"from ... import ...\" AST node. name: The imported name. current_module: The module in which the import happens. Returns: The absolute import path. \"\"\" level = node . level if level > 0 and current_module . is_package or current_module . is_subpackage : level -= 1 while level > 0 and current_module . parent is not None : current_module = current_module . parent # type: ignore[assignment] level -= 1 base = current_module . path + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" return base + node_module + name . name","title":"relative_to_absolute()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.safe_get_annotation","text":"safe_get_annotation ( node , parent , log_level = LogLevel . error ) Safely (no exception) extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. log_level ( LogLevel ) \u2013 Log level to use to log a message. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 def safe_get_annotation ( node : AST | None , parent : Module | Class , log_level : LogLevel = LogLevel . error , ) -> str | Name | Expression | None : \"\"\"Safely (no exception) extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. log_level: Log level to use to log a message. Returns: A string or resovable name or expression. \"\"\" try : return get_annotation ( node , parent ) except Exception as error : message = f \"Failed to parse annotation from ' { node . __class__ . __name__ } ' node\" with suppress ( Exception ): message += f \" at { parent . relative_filepath } : { node . lineno } \" # type: ignore[union-attr] if not isinstance ( error , KeyError ): message += f \": { error } \" getattr ( logger , log_level . value )( message ) return None","title":"safe_get_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.safe_get_value","text":"safe_get_value ( node , filepath = None ) Safely (no exception) unparse a node to its string representation. Parameters: node ( AST | None ) \u2013 The node to unparse. filepath ( str | Path | None ) \u2013 An optional filepath from where the node comes. Returns: str | None \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 def safe_get_value ( node : AST | None , filepath : str | Path | None = None ) -> str | None : \"\"\"Safely (no exception) unparse a node to its string representation. Parameters: node: The node to unparse. filepath: An optional filepath from where the node comes. Returns: The unparsed code of the node. \"\"\" try : return get_value ( node ) except Exception as error : message = f \"Failed to unparse node { node } \" if filepath : message += f \" at { filepath } : { node . lineno } \" # type: ignore[union-attr] message += f \": { error } \" logger . error ( message ) return None","title":"safe_get_value()"},{"location":"reference/griffe/agents/visitor/","text":"Code parsing and data extraction utilies. This module exposes a public function, visit() , which parses the module code using parse() , and returns a new Module instance, populating its members recursively, by using a NodeVisitor -like class. Visitor \u00a4 Visitor ( module_name , filepath , code , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , ) Bases: BaseVisitor This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path ) \u2013 The module filepath. code ( str ) \u2013 The module source code. extensions ( Extensions ) \u2013 The extensions to use when visiting. parent ( Module | None ) \u2013 An optional parent for the final module object. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/agents/visitor.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () self . type_guarded : bool = False decorators_to_labels \u00a4 decorators_to_labels ( decorators ) Build and return a set of labels based on decorators. Parameters: decorators ( list [ Decorator ] ) \u2013 The decorators to check. Returns: set [ str ] \u2013 A set of labels. Source code in griffe/agents/visitor.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def decorators_to_labels ( self , decorators : list [ Decorator ]) -> set [ str ]: # noqa: WPS231 \"\"\"Build and return a set of labels based on decorators. Parameters: decorators: The decorators to check. Returns: A set of labels. \"\"\" labels = set () for decorator in decorators : decorator_value = decorator . value . split ( \"(\" , 1 )[ 0 ] if decorator_value in builtin_decorators : labels . add ( builtin_decorators [ decorator_value ]) else : names = decorator_value . split ( \".\" ) with suppress ( NameResolutionError ): resolved_first = self . current . resolve ( names [ 0 ]) resolved_name = \".\" . join ([ resolved_first , * names [ 1 :]]) if resolved_name in stdlib_decorators : labels |= stdlib_decorators [ resolved_name ] return labels generic_visit \u00a4 generic_visit ( node ) Extend the base generic visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 190 191 192 193 194 195 196 197 198 199 200 201 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node ) get_base_property \u00a4 get_base_property ( decorators ) Check decorators to return the base property in case of setters and deleters. Parameters: decorators ( list [ Decorator ] ) \u2013 The decorators to check. Returns: base_property ( Function | None ) \u2013 The property for which the setter/deleted is set. property_function ( str | None ) \u2013 Either \"setter\" or \"deleter\" . Source code in griffe/agents/visitor.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 def get_base_property ( self , decorators : list [ Decorator ]) -> tuple [ Function | None , str | None ]: \"\"\"Check decorators to return the base property in case of setters and deleters. Parameters: decorators: The decorators to check. Returns: base_property: The property for which the setter/deleted is set. property_function: Either `\"setter\"` or `\"deleter\"`. \"\"\" for decorator in decorators : names = decorator . value . split ( \".\" ) with suppress ( ValueError ): base_name , base_function = names property_setter_or_deleter = ( base_function in { \"setter\" , \"deleter\" } and base_name in self . current . members and self . current [ base_name ] . has_labels ({ \"property\" }) ) if property_setter_or_deleter : return self . current [ base_name ], base_function return None , None get_module \u00a4 get_module () Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: Module \u2013 A module instance. Source code in griffe/agents/visitor.py 164 165 166 167 168 169 170 171 172 173 174 175 176 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module handle_attribute \u00a4 handle_attribute ( node , annotation = None ) Handle an attribute (assignment) node. Parameters: node ( ast . Assign | ast . AnnAssign ) \u2013 The node to visit. annotation ( str | Name | Expression | None ) \u2013 A potential annotation. Source code in griffe/agents/visitor.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module-attribute\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class-attribute\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance-attribute\" ) if not names : return value = safe_get_value ( node . value , self . filepath ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times # TODO: might be better to inspect if isinstance ( node . parent , ( ast . If , ast . ExceptHandler )): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , runtime = not self . type_guarded , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = parse__all__ ( node , self . current ) # type: ignore[assignment,arg-type] handle_function \u00a4 handle_function ( node , labels = None ) Handle a function definition node. Parameters: node ( ast . AsyncFunctionDef | ast . FunctionDef ) \u2013 The node to visit. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/visitor.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] overload = False if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno for decorator_node in node . decorator_list : decorator_value = safe_get_value ( decorator_node , self . filepath ) overload = ( decorator_value in typing_overload or decorator_value == \"overload\" and self . current . resolve ( \"overload\" ) in typing_overload ) decorators . append ( Decorator ( decorator_value , # type: ignore[arg-type] lineno = decorator_node . lineno , endlineno = decorator_node . end_lineno , # type: ignore[attr-defined] ) ) else : lineno = node . lineno labels |= self . decorators_to_labels ( decorators ) if \"property\" in labels : attribute = Attribute ( name = node . name , value = None , annotation = safe_get_annotation ( node . returns , parent = self . current ), lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = self . _get_docstring ( node ), runtime = not self . type_guarded , ) attribute . labels |= labels self . current [ node . name ] = attribute return base_property , property_function = self . get_base_property ( decorators ) # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults : Iterable = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) arg : ast . arg kind : ParameterKind arg_default : ast . AST | None for ( arg , kind ), arg_default in args_kinds_defaults : annotation = safe_get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( arg_default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = safe_get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( node . args . vararg . arg , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults : Iterable = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) kwarg : ast . arg kwarg_default : ast . AST | None for kwarg , kwarg_default in kwargs_defaults : # noqa: WPS440 annotation = safe_get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( kwarg_default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = safe_get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( node . args . kwarg . arg , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = safe_get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), runtime = not self . type_guarded , parent = self . current , ) if overload : self . current . overloads [ function . name ] . append ( function ) elif base_property is not None : if property_function == \"setter\" : base_property . setter = function base_property . labels . add ( \"writable\" ) elif property_function == \"deleter\" : base_property . deleter = function base_property . labels . add ( \"deletable\" ) else : self . current [ node . name ] = function if self . current . kind in { Kind . MODULE , Kind . CLASS } and self . current . overloads [ function . name ]: function . overloads = self . current . overloads [ function . name ] del self . current . overloads [ function . name ] # noqa: WPS420 function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] visit \u00a4 visit ( node ) Extend the base visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 178 179 180 181 182 183 184 185 186 187 188 def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node ) visit_annassign \u00a4 visit_annassign ( node ) Visit an annotated assignment node. Parameters: node ( ast . AnnAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 614 615 616 617 618 619 620 def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , safe_get_annotation ( node . annotation , parent = self . current )) visit_assign \u00a4 visit_assign ( node ) Visit an assignment node. Parameters: node ( ast . Assign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 606 607 608 609 610 611 612 def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node ) visit_asyncfunctiondef \u00a4 visit_asyncfunctiondef ( node ) Visit an async function definition node. Parameters: node ( ast . AsyncFunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 476 477 478 479 480 481 482 def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" }) visit_augassign \u00a4 visit_augassign ( node ) Visit an augmented assignment node. Parameters: node ( ast . AugAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 def visit_augassign ( self , node : ast . AugAssign ) -> None : \"\"\"Visit an augmented assignment node. Parameters: node: The node to visit. \"\"\" with suppress ( AttributeError ): all_augment = ( node . target . id == \"__all__\" # type: ignore[attr-defined] and self . current . is_module and isinstance ( node . op , ast . Add ) ) if all_augment : # we assume exports is not None at this point self . current . exports . extend ( parse__all__ ( node , self . current )) # type: ignore[arg-type,union-attr] visit_classdef \u00a4 visit_classdef ( node ) Visit a class definition node. Parameters: node ( ast . ClassDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno for decorator_node in node . decorator_list : decorators . append ( Decorator ( safe_get_value ( decorator_node , self . current . relative_filepath ), # type: ignore[arg-type] lineno = decorator_node . lineno , endlineno = decorator_node . end_lineno , # type: ignore[attr-defined] ) ) else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( safe_get_annotation ( base , parent = self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] runtime = not self . type_guarded , ) class_ . labels |= self . decorators_to_labels ( decorators ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] visit_functiondef \u00a4 visit_functiondef ( node ) Visit a function definition node. Parameters: node ( ast . FunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 468 469 470 471 472 473 474 def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node ) visit_if \u00a4 visit_if ( node ) Visit an \"if\" node. Parameters: node ( ast . If ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 638 639 640 641 642 643 644 645 646 647 648 649 650 def visit_if ( self , node : ast . If ) -> None : \"\"\"Visit an \"if\" node. Parameters: node: The node to visit. \"\"\" if isinstance ( node . parent , ( ast . Module , ast . ClassDef )): # type: ignore[attr-defined] with suppress ( KeyError ): # unhandled AST nodes condition = get_annotation ( node . test , parent = self . current ) if str ( condition ) in { \"typing.TYPE_CHECKING\" , \"TYPE_CHECKING\" }: self . type_guarded = True self . generic_visit ( node ) self . type_guarded = False visit_import \u00a4 visit_import ( node ) Visit an import node. Parameters: node ( ast . Import ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name alias_name = name . asname or alias_path . split ( \".\" , 1 )[ 0 ] self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] runtime = not self . type_guarded , ) visit_importfrom \u00a4 visit_importfrom ( node ) Visit an \"import from\" node. Parameters: node ( ast . ImportFrom ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 def visit_importfrom ( self , node : ast . ImportFrom ) -> None : # noqa: WPS231 \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : if not node . module and node . level == 1 : if not name . asname : # special case: when being in `a` and doing `from . import b`, # we are effectively creating a member `b` in `a` that is pointing to `a.b` # -> cyclic alias! in that case, we just skip it, as both the member and module # have the same name and can be accessed the same way continue alias_path = relative_to_absolute ( node , name , self . current . module ) if name . name == \"*\" : alias_name = alias_path . replace ( \".\" , \"/\" ) # type: ignore[union-attr] alias_path = alias_path . replace ( \".*\" , \"\" ) else : alias_name = name . asname or name . name self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , # type: ignore[arg-type] lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] runtime = not self . type_guarded , ) visit_module \u00a4 visit_module ( node ) Visit a module node. Parameters: node ( ast . Module ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node ) patch_ast \u00a4 patch_ast () Extend the base ast.AST class to provide more functionality. Source code in griffe/agents/visitor.py 656 657 658 659 660 661 662 663 664 665 def patch_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if ast . AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , ASTNode ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442 visit \u00a4 visit ( module_name , filepath , code , * , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/visitor.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def visit ( module_name : str , filepath : Path , code : str , * , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. Returns: The module, with its members populated. \"\"\" return Visitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , ) . get_module ()","title":"visitor"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor","text":"Visitor ( module_name , filepath , code , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None , ) Bases: BaseVisitor This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path ) \u2013 The module filepath. code ( str ) \u2013 The module source code. extensions ( Extensions ) \u2013 The extensions to use when visiting. parent ( Module | None ) \u2013 An optional parent for the final module object. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/agents/visitor.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () self . type_guarded : bool = False","title":"Visitor"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.decorators_to_labels","text":"decorators_to_labels ( decorators ) Build and return a set of labels based on decorators. Parameters: decorators ( list [ Decorator ] ) \u2013 The decorators to check. Returns: set [ str ] \u2013 A set of labels. Source code in griffe/agents/visitor.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def decorators_to_labels ( self , decorators : list [ Decorator ]) -> set [ str ]: # noqa: WPS231 \"\"\"Build and return a set of labels based on decorators. Parameters: decorators: The decorators to check. Returns: A set of labels. \"\"\" labels = set () for decorator in decorators : decorator_value = decorator . value . split ( \"(\" , 1 )[ 0 ] if decorator_value in builtin_decorators : labels . add ( builtin_decorators [ decorator_value ]) else : names = decorator_value . split ( \".\" ) with suppress ( NameResolutionError ): resolved_first = self . current . resolve ( names [ 0 ]) resolved_name = \".\" . join ([ resolved_first , * names [ 1 :]]) if resolved_name in stdlib_decorators : labels |= stdlib_decorators [ resolved_name ] return labels","title":"decorators_to_labels()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.generic_visit","text":"generic_visit ( node ) Extend the base generic visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 190 191 192 193 194 195 196 197 198 199 200 201 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node )","title":"generic_visit()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.get_base_property","text":"get_base_property ( decorators ) Check decorators to return the base property in case of setters and deleters. Parameters: decorators ( list [ Decorator ] ) \u2013 The decorators to check. Returns: base_property ( Function | None ) \u2013 The property for which the setter/deleted is set. property_function ( str | None ) \u2013 Either \"setter\" or \"deleter\" . Source code in griffe/agents/visitor.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 def get_base_property ( self , decorators : list [ Decorator ]) -> tuple [ Function | None , str | None ]: \"\"\"Check decorators to return the base property in case of setters and deleters. Parameters: decorators: The decorators to check. Returns: base_property: The property for which the setter/deleted is set. property_function: Either `\"setter\"` or `\"deleter\"`. \"\"\" for decorator in decorators : names = decorator . value . split ( \".\" ) with suppress ( ValueError ): base_name , base_function = names property_setter_or_deleter = ( base_function in { \"setter\" , \"deleter\" } and base_name in self . current . members and self . current [ base_name ] . has_labels ({ \"property\" }) ) if property_setter_or_deleter : return self . current [ base_name ], base_function return None , None","title":"get_base_property()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.get_module","text":"get_module () Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: Module \u2013 A module instance. Source code in griffe/agents/visitor.py 164 165 166 167 168 169 170 171 172 173 174 175 176 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module","title":"get_module()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_attribute","text":"handle_attribute ( node , annotation = None ) Handle an attribute (assignment) node. Parameters: node ( ast . Assign | ast . AnnAssign ) \u2013 The node to visit. annotation ( str | Name | Expression | None ) \u2013 A potential annotation. Source code in griffe/agents/visitor.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module-attribute\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class-attribute\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance-attribute\" ) if not names : return value = safe_get_value ( node . value , self . filepath ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times # TODO: might be better to inspect if isinstance ( node . parent , ( ast . If , ast . ExceptHandler )): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , runtime = not self . type_guarded , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = parse__all__ ( node , self . current ) # type: ignore[assignment,arg-type]","title":"handle_attribute()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_function","text":"handle_function ( node , labels = None ) Handle a function definition node. Parameters: node ( ast . AsyncFunctionDef | ast . FunctionDef ) \u2013 The node to visit. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/visitor.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] overload = False if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno for decorator_node in node . decorator_list : decorator_value = safe_get_value ( decorator_node , self . filepath ) overload = ( decorator_value in typing_overload or decorator_value == \"overload\" and self . current . resolve ( \"overload\" ) in typing_overload ) decorators . append ( Decorator ( decorator_value , # type: ignore[arg-type] lineno = decorator_node . lineno , endlineno = decorator_node . end_lineno , # type: ignore[attr-defined] ) ) else : lineno = node . lineno labels |= self . decorators_to_labels ( decorators ) if \"property\" in labels : attribute = Attribute ( name = node . name , value = None , annotation = safe_get_annotation ( node . returns , parent = self . current ), lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = self . _get_docstring ( node ), runtime = not self . type_guarded , ) attribute . labels |= labels self . current [ node . name ] = attribute return base_property , property_function = self . get_base_property ( decorators ) # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults : Iterable = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) arg : ast . arg kind : ParameterKind arg_default : ast . AST | None for ( arg , kind ), arg_default in args_kinds_defaults : annotation = safe_get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( arg_default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = safe_get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( node . args . vararg . arg , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults : Iterable = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) kwarg : ast . arg kwarg_default : ast . AST | None for kwarg , kwarg_default in kwargs_defaults : # noqa: WPS440 annotation = safe_get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( kwarg_default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = safe_get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( node . args . kwarg . arg , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = safe_get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), runtime = not self . type_guarded , parent = self . current , ) if overload : self . current . overloads [ function . name ] . append ( function ) elif base_property is not None : if property_function == \"setter\" : base_property . setter = function base_property . labels . add ( \"writable\" ) elif property_function == \"deleter\" : base_property . deleter = function base_property . labels . add ( \"deletable\" ) else : self . current [ node . name ] = function if self . current . kind in { Kind . MODULE , Kind . CLASS } and self . current . overloads [ function . name ]: function . overloads = self . current . overloads [ function . name ] del self . current . overloads [ function . name ] # noqa: WPS420 function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"handle_function()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit","text":"visit ( node ) Extend the base visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 178 179 180 181 182 183 184 185 186 187 188 def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node )","title":"visit()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_annassign","text":"visit_annassign ( node ) Visit an annotated assignment node. Parameters: node ( ast . AnnAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 614 615 616 617 618 619 620 def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , safe_get_annotation ( node . annotation , parent = self . current ))","title":"visit_annassign()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_assign","text":"visit_assign ( node ) Visit an assignment node. Parameters: node ( ast . Assign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 606 607 608 609 610 611 612 def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node )","title":"visit_assign()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_asyncfunctiondef","text":"visit_asyncfunctiondef ( node ) Visit an async function definition node. Parameters: node ( ast . AsyncFunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 476 477 478 479 480 481 482 def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" })","title":"visit_asyncfunctiondef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_augassign","text":"visit_augassign ( node ) Visit an augmented assignment node. Parameters: node ( ast . AugAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 def visit_augassign ( self , node : ast . AugAssign ) -> None : \"\"\"Visit an augmented assignment node. Parameters: node: The node to visit. \"\"\" with suppress ( AttributeError ): all_augment = ( node . target . id == \"__all__\" # type: ignore[attr-defined] and self . current . is_module and isinstance ( node . op , ast . Add ) ) if all_augment : # we assume exports is not None at this point self . current . exports . extend ( parse__all__ ( node , self . current )) # type: ignore[arg-type,union-attr]","title":"visit_augassign()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_classdef","text":"visit_classdef ( node ) Visit a class definition node. Parameters: node ( ast . ClassDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno for decorator_node in node . decorator_list : decorators . append ( Decorator ( safe_get_value ( decorator_node , self . current . relative_filepath ), # type: ignore[arg-type] lineno = decorator_node . lineno , endlineno = decorator_node . end_lineno , # type: ignore[attr-defined] ) ) else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( safe_get_annotation ( base , parent = self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] runtime = not self . type_guarded , ) class_ . labels |= self . decorators_to_labels ( decorators ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"visit_classdef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_functiondef","text":"visit_functiondef ( node ) Visit a function definition node. Parameters: node ( ast . FunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 468 469 470 471 472 473 474 def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node )","title":"visit_functiondef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_if","text":"visit_if ( node ) Visit an \"if\" node. Parameters: node ( ast . If ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 638 639 640 641 642 643 644 645 646 647 648 649 650 def visit_if ( self , node : ast . If ) -> None : \"\"\"Visit an \"if\" node. Parameters: node: The node to visit. \"\"\" if isinstance ( node . parent , ( ast . Module , ast . ClassDef )): # type: ignore[attr-defined] with suppress ( KeyError ): # unhandled AST nodes condition = get_annotation ( node . test , parent = self . current ) if str ( condition ) in { \"typing.TYPE_CHECKING\" , \"TYPE_CHECKING\" }: self . type_guarded = True self . generic_visit ( node ) self . type_guarded = False","title":"visit_if()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_import","text":"visit_import ( node ) Visit an import node. Parameters: node ( ast . Import ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name alias_name = name . asname or alias_path . split ( \".\" , 1 )[ 0 ] self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] runtime = not self . type_guarded , )","title":"visit_import()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_importfrom","text":"visit_importfrom ( node ) Visit an \"import from\" node. Parameters: node ( ast . ImportFrom ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 def visit_importfrom ( self , node : ast . ImportFrom ) -> None : # noqa: WPS231 \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : if not node . module and node . level == 1 : if not name . asname : # special case: when being in `a` and doing `from . import b`, # we are effectively creating a member `b` in `a` that is pointing to `a.b` # -> cyclic alias! in that case, we just skip it, as both the member and module # have the same name and can be accessed the same way continue alias_path = relative_to_absolute ( node , name , self . current . module ) if name . name == \"*\" : alias_name = alias_path . replace ( \".\" , \"/\" ) # type: ignore[union-attr] alias_path = alias_path . replace ( \".*\" , \"\" ) else : alias_name = name . asname or name . name self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , # type: ignore[arg-type] lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] runtime = not self . type_guarded , )","title":"visit_importfrom()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_module","text":"visit_module ( node ) Visit a module node. Parameters: node ( ast . Module ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node )","title":"visit_module()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.patch_ast","text":"patch_ast () Extend the base ast.AST class to provide more functionality. Source code in griffe/agents/visitor.py 656 657 658 659 660 661 662 663 664 665 def patch_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if ast . AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , ASTNode ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442","title":"patch_ast()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.visit","text":"visit ( module_name , filepath , code , * , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/visitor.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def visit ( module_name : str , filepath : Path , code : str , * , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. Returns: The module, with its members populated. \"\"\" return Visitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , ) . get_module ()","title":"visit()"},{"location":"reference/griffe/agents/extensions/","text":"This module is the public interface to import elements from the base. Extensions \u00a4 Extensions ( * extensions ) This class helps iterating on extensions that should run at different times. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 97 98 99 100 101 102 103 104 105 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) after_children_inspection property \u00a4 after_children_inspection : list [ InspectorExtension ] Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. after_children_visit property \u00a4 after_children_visit : list [ VisitorExtension ] Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. after_inspection property \u00a4 after_inspection : list [ InspectorExtension ] Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. after_visit property \u00a4 after_visit : list [ VisitorExtension ] Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. before_children_inspection property \u00a4 before_children_inspection : list [ InspectorExtension ] Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. before_children_visit property \u00a4 before_children_visit : list [ VisitorExtension ] Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. before_inspection property \u00a4 before_inspection : list [ InspectorExtension ] Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. before_visit property \u00a4 before_visit : list [ VisitorExtension ] Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. add \u00a4 add ( * extensions ) Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 107 108 109 110 111 112 113 114 115 116 117 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) attach_inspector \u00a4 attach_inspector ( parent_inspector ) Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 133 134 135 136 137 138 139 140 141 142 143 144 145 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self attach_visitor \u00a4 attach_visitor ( parent_visitor ) Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 119 120 121 122 123 124 125 126 127 128 129 130 131 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self InspectorExtension \u00a4 InspectorExtension () Bases: BaseInspector The object inspector extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 69 70 71 72 def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment] attach \u00a4 attach ( inspector ) Attach the parent inspector to this extension. Parameters: inspector ( Inspector ) \u2013 The parent inspector. Source code in griffe/agents/extensions/base.py 74 75 76 77 78 79 80 def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector inspect \u00a4 inspect ( node ) Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/extensions/base.py 82 83 84 85 86 87 88 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node ) VisitorExtension \u00a4 VisitorExtension () Bases: BaseVisitor The node visitor extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 42 43 44 45 def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment] attach \u00a4 attach ( visitor ) Attach the parent visitor to this extension. Parameters: visitor ( Visitor ) \u2013 The parent visitor. Source code in griffe/agents/extensions/base.py 47 48 49 50 51 52 53 def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor visit \u00a4 visit ( node ) Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/extensions/base.py 55 56 57 58 59 60 61 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined] When \u00a4 Bases: enum . Enum This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection. load_extension \u00a4 load_extension ( extension ) Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Raises: ExtensionNotLoadedError \u2013 When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Raises: ExtensionNotLoadedError: When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" try : ext_module = dynamic_import ( import_path ) except ModuleNotFoundError as error : raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' could not be found\" ) from error except ImportError as error : raise ExtensionNotLoadedError ( f \"Error while importing extension module ' { import_path } ': { error } \" ) from error try : return ext_module . Extension ( ** options ) except AttributeError as error : # noqa: WPS440 raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' has no 'Extension' attribute\" ) from error load_extensions \u00a4 load_extensions ( exts ) Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 269 270 271 272 273 274 275 276 277 278 279 280 281 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"extensions"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.Extensions","text":"Extensions ( * extensions ) This class helps iterating on extensions that should run at different times. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 97 98 99 100 101 102 103 104 105 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions )","title":"Extensions"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_children_inspection","text":"after_children_inspection : list [ InspectorExtension ] Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors.","title":"after_children_inspection"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_children_visit","text":"after_children_visit : list [ VisitorExtension ] Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors.","title":"after_children_visit"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_inspection","text":"after_inspection : list [ InspectorExtension ] Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors.","title":"after_inspection"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_visit","text":"after_visit : list [ VisitorExtension ] Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors.","title":"after_visit"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_children_inspection","text":"before_children_inspection : list [ InspectorExtension ] Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors.","title":"before_children_inspection"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_children_visit","text":"before_children_visit : list [ VisitorExtension ] Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors.","title":"before_children_visit"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_inspection","text":"before_inspection : list [ InspectorExtension ] Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors.","title":"before_inspection"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_visit","text":"before_visit : list [ VisitorExtension ] Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors.","title":"before_visit"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.add","text":"add ( * extensions ) Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 107 108 109 110 111 112 113 114 115 116 117 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension )","title":"add()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.attach_inspector","text":"attach_inspector ( parent_inspector ) Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 133 134 135 136 137 138 139 140 141 142 143 144 145 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self","title":"attach_inspector()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.attach_visitor","text":"attach_visitor ( parent_visitor ) Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 119 120 121 122 123 124 125 126 127 128 129 130 131 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self","title":"attach_visitor()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.InspectorExtension","text":"InspectorExtension () Bases: BaseInspector The object inspector extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 69 70 71 72 def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment]","title":"InspectorExtension"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.InspectorExtension.attach","text":"attach ( inspector ) Attach the parent inspector to this extension. Parameters: inspector ( Inspector ) \u2013 The parent inspector. Source code in griffe/agents/extensions/base.py 74 75 76 77 78 79 80 def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector","title":"attach()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.InspectorExtension.inspect","text":"inspect ( node ) Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/extensions/base.py 82 83 84 85 86 87 88 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node )","title":"inspect()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.VisitorExtension","text":"VisitorExtension () Bases: BaseVisitor The node visitor extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 42 43 44 45 def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment]","title":"VisitorExtension"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.VisitorExtension.attach","text":"attach ( visitor ) Attach the parent visitor to this extension. Parameters: visitor ( Visitor ) \u2013 The parent visitor. Source code in griffe/agents/extensions/base.py 47 48 49 50 51 52 53 def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor","title":"attach()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.VisitorExtension.visit","text":"visit ( node ) Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/extensions/base.py 55 56 57 58 59 60 61 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined]","title":"visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.When","text":"Bases: enum . Enum This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection.","title":"When"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.load_extension","text":"load_extension ( extension ) Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Raises: ExtensionNotLoadedError \u2013 When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Raises: ExtensionNotLoadedError: When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" try : ext_module = dynamic_import ( import_path ) except ModuleNotFoundError as error : raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' could not be found\" ) from error except ImportError as error : raise ExtensionNotLoadedError ( f \"Error while importing extension module ' { import_path } ': { error } \" ) from error try : return ext_module . Extension ( ** options ) except AttributeError as error : # noqa: WPS440 raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' has no 'Extension' attribute\" ) from error","title":"load_extension()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.load_extensions","text":"load_extensions ( exts ) Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 269 270 271 272 273 274 275 276 277 278 279 280 281 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"load_extensions()"},{"location":"reference/griffe/agents/extensions/hybrid/","text":"This extension provides an hybrid behavior while loading data. HybridExtension \u00a4 HybridExtension ( extension ) Bases: VisitorExtension Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. Parameters: extension ( str | dict [ str , Any ] ) \u2013 The name or configuration of another extension. Raises: ExtensionError \u2013 When the passed extension is not an inspector extension. Source code in griffe/agents/extensions/hybrid.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ ()","title":"hybrid"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension","text":"HybridExtension ( extension ) Bases: VisitorExtension Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. Parameters: extension ( str | dict [ str , Any ] ) \u2013 The name or configuration of another extension. Raises: ExtensionError \u2013 When the passed extension is not an inspector extension. Source code in griffe/agents/extensions/hybrid.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ ()","title":"HybridExtension"},{"location":"reference/griffe/docstrings/","text":"This module exposes objects related to docstrings. Parser \u00a4 Bases: enum . Enum Enumeration for the different docstring parsers. parse \u00a4 parse ( docstring , parser , ** options ) Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) # type: ignore[operator] return [ DocstringSectionText ( docstring . value )]","title":"docstrings"},{"location":"reference/griffe/docstrings/#griffe.docstrings.Parser","text":"Bases: enum . Enum Enumeration for the different docstring parsers.","title":"Parser"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parse","text":"parse ( docstring , parser , ** options ) Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) # type: ignore[operator] return [ DocstringSectionText ( docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/dataclasses/","text":"This module contains the dataclasses related to docstrings. DocstringAdmonition \u00a4 Bases: DocstringElement This class represents an admonition. contents property writable \u00a4 contents : str Return the contents of this admonition. Returns: str \u2013 The admonition's contents. kind property writable \u00a4 kind : str | Name | Expression | None Return the kind of this admonition. Returns: str | Name | Expression | None \u2013 The admonition's kind. DocstringAttribute \u00a4 Bases: DocstringNamedElement This class represents a documented module/class attribute. DocstringDeprecated \u00a4 Bases: DocstringElement This class represents a documented deprecated item. version property writable \u00a4 version : str Return the version of this deprecation. Returns: str \u2013 The deprecation version. DocstringElement \u00a4 DocstringElement ( * , description , annotation = None ) This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 23 24 25 26 27 28 29 30 31 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation as_dict \u00a4 as_dict ( ** kwargs ) Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 33 34 35 36 37 38 39 40 41 42 43 44 45 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , } DocstringNamedElement \u00a4 DocstringNamedElement ( name , * , description , annotation = None , value = None ) Bases: DocstringElement This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None , ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value as_dict \u00a4 as_dict ( ** kwargs ) Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 76 77 78 79 80 81 82 83 84 85 86 87 88 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base DocstringParameter \u00a4 Bases: DocstringNamedElement This class represent a documented function parameter. default property writable \u00a4 default : str | None Return the default value of this parameter. Returns: str | None \u2013 The parameter's default. DocstringRaise \u00a4 Bases: DocstringElement This class represents a documented raise value. DocstringReceive \u00a4 Bases: DocstringNamedElement This class represents a documented receive value. DocstringReturn \u00a4 Bases: DocstringNamedElement This class represents a documented return value. DocstringSection \u00a4 DocstringSection ( title = None ) This class represents a docstring section. Parameters: title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 202 203 204 205 206 207 208 def __init__ ( self , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: title: An optional title. \"\"\" self . title : str | None = title as_dict \u00a4 as_dict ( ** kwargs ) Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): # type: ignore[attr-defined] serialized_value = self . value . as_dict ( ** kwargs ) # type: ignore[attr-defined] else : serialized_value = self . value # type: ignore[attr-defined] base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base DocstringSectionAdmonition \u00a4 DocstringSectionAdmonition ( kind , text , title = None ) Bases: DocstringSection This class represents an admonition section. Parameters: kind ( str ) \u2013 The admonition kind. text ( str ) \u2013 The admonition text. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 407 408 409 410 411 412 413 414 415 416 def __init__ ( self , kind : str , text : str , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The admonition kind. text: The admonition text. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : DocstringAdmonition = DocstringAdmonition ( annotation = kind , description = text ) DocstringSectionAttributes \u00a4 DocstringSectionAttributes ( value , title = None ) Bases: DocstringSection This class represents an attributes section. Parameters: value ( list [ DocstringAttribute ] ) \u2013 The section attributes. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 374 375 376 377 378 379 380 381 382 def __init__ ( self , value : list [ DocstringAttribute ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section attributes. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringAttribute ] = value DocstringSectionDeprecated \u00a4 DocstringSectionDeprecated ( version , text , title = None ) Bases: DocstringSection This class represents a deprecated section. Parameters: version ( str ) \u2013 The deprecation version. text ( str ) \u2013 The deprecation text. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 390 391 392 393 394 395 396 397 398 399 def __init__ ( self , version : str , text : str , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: version: The deprecation version. text: The deprecation text. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : DocstringDeprecated = DocstringDeprecated ( annotation = version , description = text ) DocstringSectionExamples \u00a4 DocstringSectionExamples ( value , title = None ) Bases: DocstringSection This class represents an examples section. Parameters: value ( list [ tuple [ Literal [ DocstringSectionKind . text ] | Literal [ DocstringSectionKind . examples ], str ]] ) \u2013 The section examples. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def __init__ ( self , value : list [ tuple [ Literal [ DocstringSectionKind . text ] | Literal [ DocstringSectionKind . examples ], str ]], title : str | None = None , ) -> None : \"\"\"Initialize the section. Parameters: value: The section examples. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ tuple [ Literal [ DocstringSectionKind . text ] | Literal [ DocstringSectionKind . examples ], str ] ] = value DocstringSectionKind \u00a4 Bases: enum . Enum The possible section kinds. DocstringSectionOtherParameters \u00a4 Bases: DocstringSectionParameters This class represents an other parameters section. DocstringSectionParameters \u00a4 DocstringSectionParameters ( value , title = None ) Bases: DocstringSection This class represents a parameters section. Parameters: value ( list [ DocstringParameter ] ) \u2013 The section parameters. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 250 251 252 253 254 255 256 257 258 def __init__ ( self , value : list [ DocstringParameter ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section parameters. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringParameter ] = value DocstringSectionRaises \u00a4 DocstringSectionRaises ( value , title = None ) Bases: DocstringSection This class represents a raises section. Parameters: value ( list [ DocstringRaise ] ) \u2013 The section exceptions. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 272 273 274 275 276 277 278 279 280 def __init__ ( self , value : list [ DocstringRaise ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section exceptions. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringRaise ] = value DocstringSectionReceives \u00a4 DocstringSectionReceives ( value , title = None ) Bases: DocstringSection This class represents a receives section. Parameters: value ( list [ DocstringReceive ] ) \u2013 The section received items. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 336 337 338 339 340 341 342 343 344 def __init__ ( self , value : list [ DocstringReceive ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section received items. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringReceive ] = value DocstringSectionReturns \u00a4 DocstringSectionReturns ( value , title = None ) Bases: DocstringSection This class represents a returns section. Parameters: value ( list [ DocstringReturn ] ) \u2013 The section returned items. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 304 305 306 307 308 309 310 311 312 def __init__ ( self , value : list [ DocstringReturn ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section returned items. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringReturn ] = value DocstringSectionText \u00a4 DocstringSectionText ( value , title = None ) Bases: DocstringSection This class represents a text section. Parameters: value ( str ) \u2013 The section text. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 234 235 236 237 238 239 240 241 242 def __init__ ( self , value : str , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section text. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : str = value DocstringSectionWarns \u00a4 DocstringSectionWarns ( value , title = None ) Bases: DocstringSection This class represents a warns section. Parameters: value ( list [ DocstringWarn ] ) \u2013 The section warnings. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 288 289 290 291 292 293 294 295 296 def __init__ ( self , value : list [ DocstringWarn ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section warnings. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringWarn ] = value DocstringSectionYields \u00a4 DocstringSectionYields ( value , title = None ) Bases: DocstringSection This class represents a yields section. Parameters: value ( list [ DocstringYield ] ) \u2013 The section yielded items. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 320 321 322 323 324 325 326 327 328 def __init__ ( self , value : list [ DocstringYield ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section yielded items. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringYield ] = value DocstringWarn \u00a4 Bases: DocstringElement This class represents a documented warn value. DocstringYield \u00a4 Bases: DocstringNamedElement This class represents a documented yield value.","title":"dataclasses"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition","text":"Bases: DocstringElement This class represents an admonition.","title":"DocstringAdmonition"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.contents","text":"contents : str Return the contents of this admonition. Returns: str \u2013 The admonition's contents.","title":"contents"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.kind","text":"kind : str | Name | Expression | None Return the kind of this admonition. Returns: str | Name | Expression | None \u2013 The admonition's kind.","title":"kind"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAttribute","text":"Bases: DocstringNamedElement This class represents a documented module/class attribute.","title":"DocstringAttribute"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringDeprecated","text":"Bases: DocstringElement This class represents a documented deprecated item.","title":"DocstringDeprecated"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringDeprecated.version","text":"version : str Return the version of this deprecation. Returns: str \u2013 The deprecation version.","title":"version"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement","text":"DocstringElement ( * , description , annotation = None ) This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 23 24 25 26 27 28 29 30 31 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation","title":"DocstringElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.as_dict","text":"as_dict ( ** kwargs ) Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 33 34 35 36 37 38 39 40 41 42 43 44 45 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , }","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement","text":"DocstringNamedElement ( name , * , description , annotation = None , value = None ) Bases: DocstringElement This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None , ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value","title":"DocstringNamedElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.as_dict","text":"as_dict ( ** kwargs ) Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 76 77 78 79 80 81 82 83 84 85 86 87 88 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter","text":"Bases: DocstringNamedElement This class represent a documented function parameter.","title":"DocstringParameter"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter.default","text":"default : str | None Return the default value of this parameter. Returns: str | None \u2013 The parameter's default.","title":"default"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringRaise","text":"Bases: DocstringElement This class represents a documented raise value.","title":"DocstringRaise"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReceive","text":"Bases: DocstringNamedElement This class represents a documented receive value.","title":"DocstringReceive"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReturn","text":"Bases: DocstringNamedElement This class represents a documented return value.","title":"DocstringReturn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection","text":"DocstringSection ( title = None ) This class represents a docstring section. Parameters: title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 202 203 204 205 206 207 208 def __init__ ( self , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: title: An optional title. \"\"\" self . title : str | None = title","title":"DocstringSection"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.as_dict","text":"as_dict ( ** kwargs ) Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): # type: ignore[attr-defined] serialized_value = self . value . as_dict ( ** kwargs ) # type: ignore[attr-defined] else : serialized_value = self . value # type: ignore[attr-defined] base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionAdmonition","text":"DocstringSectionAdmonition ( kind , text , title = None ) Bases: DocstringSection This class represents an admonition section. Parameters: kind ( str ) \u2013 The admonition kind. text ( str ) \u2013 The admonition text. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 407 408 409 410 411 412 413 414 415 416 def __init__ ( self , kind : str , text : str , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The admonition kind. text: The admonition text. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : DocstringAdmonition = DocstringAdmonition ( annotation = kind , description = text )","title":"DocstringSectionAdmonition"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionAttributes","text":"DocstringSectionAttributes ( value , title = None ) Bases: DocstringSection This class represents an attributes section. Parameters: value ( list [ DocstringAttribute ] ) \u2013 The section attributes. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 374 375 376 377 378 379 380 381 382 def __init__ ( self , value : list [ DocstringAttribute ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section attributes. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringAttribute ] = value","title":"DocstringSectionAttributes"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionDeprecated","text":"DocstringSectionDeprecated ( version , text , title = None ) Bases: DocstringSection This class represents a deprecated section. Parameters: version ( str ) \u2013 The deprecation version. text ( str ) \u2013 The deprecation text. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 390 391 392 393 394 395 396 397 398 399 def __init__ ( self , version : str , text : str , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: version: The deprecation version. text: The deprecation text. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : DocstringDeprecated = DocstringDeprecated ( annotation = version , description = text )","title":"DocstringSectionDeprecated"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionExamples","text":"DocstringSectionExamples ( value , title = None ) Bases: DocstringSection This class represents an examples section. Parameters: value ( list [ tuple [ Literal [ DocstringSectionKind . text ] | Literal [ DocstringSectionKind . examples ], str ]] ) \u2013 The section examples. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def __init__ ( self , value : list [ tuple [ Literal [ DocstringSectionKind . text ] | Literal [ DocstringSectionKind . examples ], str ]], title : str | None = None , ) -> None : \"\"\"Initialize the section. Parameters: value: The section examples. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ tuple [ Literal [ DocstringSectionKind . text ] | Literal [ DocstringSectionKind . examples ], str ] ] = value","title":"DocstringSectionExamples"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind","text":"Bases: enum . Enum The possible section kinds.","title":"DocstringSectionKind"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionOtherParameters","text":"Bases: DocstringSectionParameters This class represents an other parameters section.","title":"DocstringSectionOtherParameters"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionParameters","text":"DocstringSectionParameters ( value , title = None ) Bases: DocstringSection This class represents a parameters section. Parameters: value ( list [ DocstringParameter ] ) \u2013 The section parameters. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 250 251 252 253 254 255 256 257 258 def __init__ ( self , value : list [ DocstringParameter ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section parameters. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringParameter ] = value","title":"DocstringSectionParameters"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionRaises","text":"DocstringSectionRaises ( value , title = None ) Bases: DocstringSection This class represents a raises section. Parameters: value ( list [ DocstringRaise ] ) \u2013 The section exceptions. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 272 273 274 275 276 277 278 279 280 def __init__ ( self , value : list [ DocstringRaise ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section exceptions. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringRaise ] = value","title":"DocstringSectionRaises"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionReceives","text":"DocstringSectionReceives ( value , title = None ) Bases: DocstringSection This class represents a receives section. Parameters: value ( list [ DocstringReceive ] ) \u2013 The section received items. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 336 337 338 339 340 341 342 343 344 def __init__ ( self , value : list [ DocstringReceive ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section received items. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringReceive ] = value","title":"DocstringSectionReceives"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionReturns","text":"DocstringSectionReturns ( value , title = None ) Bases: DocstringSection This class represents a returns section. Parameters: value ( list [ DocstringReturn ] ) \u2013 The section returned items. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 304 305 306 307 308 309 310 311 312 def __init__ ( self , value : list [ DocstringReturn ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section returned items. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringReturn ] = value","title":"DocstringSectionReturns"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionText","text":"DocstringSectionText ( value , title = None ) Bases: DocstringSection This class represents a text section. Parameters: value ( str ) \u2013 The section text. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 234 235 236 237 238 239 240 241 242 def __init__ ( self , value : str , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section text. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : str = value","title":"DocstringSectionText"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionWarns","text":"DocstringSectionWarns ( value , title = None ) Bases: DocstringSection This class represents a warns section. Parameters: value ( list [ DocstringWarn ] ) \u2013 The section warnings. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 288 289 290 291 292 293 294 295 296 def __init__ ( self , value : list [ DocstringWarn ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section warnings. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringWarn ] = value","title":"DocstringSectionWarns"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionYields","text":"DocstringSectionYields ( value , title = None ) Bases: DocstringSection This class represents a yields section. Parameters: value ( list [ DocstringYield ] ) \u2013 The section yielded items. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 320 321 322 323 324 325 326 327 328 def __init__ ( self , value : list [ DocstringYield ], title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: value: The section yielded items. title: An optional title. \"\"\" super () . __init__ ( title ) self . value : list [ DocstringYield ] = value","title":"DocstringSectionYields"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringWarn","text":"Bases: DocstringElement This class represents a documented warn value.","title":"DocstringWarn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringYield","text":"Bases: DocstringNamedElement This class represents a documented yield value.","title":"DocstringYield"},{"location":"reference/griffe/docstrings/google/","text":"This module defines functions to parse Google-style docstrings into structured data. parse \u00a4 parse ( docstring , ignore_init_summary = False , trim_doctest_flags = True , ** options ) Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. ignore_init_summary ( bool ) \u2013 Whether to ignore the summary in __init__ methods' docstrings. trim_doctest_flags ( bool ) \u2013 Whether to remove doctest flags from Python example blocks. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 def parse ( # noqa: WPS231 docstring : Docstring , ignore_init_summary : bool = False , trim_doctest_flags : bool = True , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings. trim_doctest_flags: Whether to remove doctest flags from Python example blocks. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections : list [ DocstringSection ] = [] current_section = [] in_code_block = False lines = docstring . lines options = { \"ignore_init_summary\" : ignore_init_summary , \"trim_doctest_flags\" : trim_doctest_flags , ** options , } ignore_summary = ( options [ \"ignore_init_summary\" ] # noqa: WPS222 and docstring . parent is not None and docstring . parent . name == \"__init__\" and docstring . parent . is_function and docstring . parent . parent is not None and docstring . parent . parent . is_class ) if ignore_summary : offset = 2 else : offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : # TODO: once Python 3.7 is dropped, use walrus operator match = _RE_ADMONITION . match ( lines [ offset ]) if match : groups = match . groupdict () title = groups [ \"title\" ] admonition_type = groups [ \"type\" ] if admonition_type . lower () in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) current_section = [] reader = _section_reader [ _section_kind [ admonition_type . lower ()]] section , offset = reader ( docstring , offset + 1 , ** options ) # type: ignore[operator] if section : section . title = title sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : if current_section : if any ( current_section ): sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) current_section = [] if title is None : title = admonition_type admonition_type = admonition_type . lower () . replace ( \" \" , \"-\" ) sections . append ( DocstringSectionAdmonition ( kind = admonition_type , text = contents , title = title )) else : with suppress ( IndexError ): current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"google"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.parse","text":"parse ( docstring , ignore_init_summary = False , trim_doctest_flags = True , ** options ) Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. ignore_init_summary ( bool ) \u2013 Whether to ignore the summary in __init__ methods' docstrings. trim_doctest_flags ( bool ) \u2013 Whether to remove doctest flags from Python example blocks. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 def parse ( # noqa: WPS231 docstring : Docstring , ignore_init_summary : bool = False , trim_doctest_flags : bool = True , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings. trim_doctest_flags: Whether to remove doctest flags from Python example blocks. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections : list [ DocstringSection ] = [] current_section = [] in_code_block = False lines = docstring . lines options = { \"ignore_init_summary\" : ignore_init_summary , \"trim_doctest_flags\" : trim_doctest_flags , ** options , } ignore_summary = ( options [ \"ignore_init_summary\" ] # noqa: WPS222 and docstring . parent is not None and docstring . parent . name == \"__init__\" and docstring . parent . is_function and docstring . parent . parent is not None and docstring . parent . parent . is_class ) if ignore_summary : offset = 2 else : offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : # TODO: once Python 3.7 is dropped, use walrus operator match = _RE_ADMONITION . match ( lines [ offset ]) if match : groups = match . groupdict () title = groups [ \"title\" ] admonition_type = groups [ \"type\" ] if admonition_type . lower () in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) current_section = [] reader = _section_reader [ _section_kind [ admonition_type . lower ()]] section , offset = reader ( docstring , offset + 1 , ** options ) # type: ignore[operator] if section : section . title = title sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : if current_section : if any ( current_section ): sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) current_section = [] if title is None : title = admonition_type admonition_type = admonition_type . lower () . replace ( \" \" , \"-\" ) sections . append ( DocstringSectionAdmonition ( kind = admonition_type , text = contents , title = title )) else : with suppress ( IndexError ): current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/markdown/","text":"This module defines functions and classes to parse Markdown docstrings into structured data.","title":"markdown"},{"location":"reference/griffe/docstrings/numpy/","text":"This module defines functions to parse Numpy-style docstrings into structured data. Based on https://numpydoc.readthedocs.io/en/latest/format.html , it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification. Rejected as non particularly Pythonic or useful as sections: See also: this section feels too subjective (specially crafted as a standard for Numpy itself), and there are may ways to reference related items in a docstring, depending on the chosen markup. Methods: with a good documentation renderer, methods are easily made accessible or hidden. Griffe also has a goal of making the merging of inherited methods configurable (on/off). Rejected as naturally handled by the user-chosen markup: Warnings: this is just markup. Notes: again, just markup. References: again, just markup. The following sections are supported: Deprecated (revisited): we expect a title instead of an RST directive. Python has support for deprecating things, so it feels natural to structure deprecations. Parameters: obviously. Returns: obviously. Yields: obviously. Receives: less used than Yields, but very natural/Pythonic as well. Other parameters: used here as documentation for keyword parameters. Raises: obviously. Warns: less used than Raises, but very natural/Pythonic as well. Examples: obviously. Special handling for non-code-blocks >>> . Attributes: obviously. parse \u00a4 parse ( docstring , ignore_init_summary = False , trim_doctest_flags = True , ** options ) Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. ignore_init_summary ( bool ) \u2013 Whether to ignore the summary in __init__ methods' docstrings. trim_doctest_flags ( bool ) \u2013 Whether to remove doctest flags from Python example blocks. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 def parse ( # noqa: WPS231 docstring : Docstring , ignore_init_summary : bool = False , trim_doctest_flags : bool = True , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings. trim_doctest_flags: Whether to remove doctest flags from Python example blocks. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections : list [ DocstringSection ] = [] current_section = [] in_code_block = False lines = docstring . lines options = { \"trim_doctest_flags\" : trim_doctest_flags , \"ignore_init_summary\" : ignore_init_summary , ** options , } ignore_summary = ( options [ \"ignore_init_summary\" ] # noqa: WPS222 and docstring . parent is not None and docstring . parent . name == \"__init__\" and docstring . parent . is_function and docstring . parent . parent is not None and docstring . parent . parent . is_class ) if ignore_summary : offset = 2 else : offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower in _section_kind and _is_dash_line ( lines [ offset + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , offset = reader ( docstring , offset + 2 , ** options ) # type: ignore[operator] if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"numpy"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy.parse","text":"parse ( docstring , ignore_init_summary = False , trim_doctest_flags = True , ** options ) Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. ignore_init_summary ( bool ) \u2013 Whether to ignore the summary in __init__ methods' docstrings. trim_doctest_flags ( bool ) \u2013 Whether to remove doctest flags from Python example blocks. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 def parse ( # noqa: WPS231 docstring : Docstring , ignore_init_summary : bool = False , trim_doctest_flags : bool = True , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings. trim_doctest_flags: Whether to remove doctest flags from Python example blocks. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections : list [ DocstringSection ] = [] current_section = [] in_code_block = False lines = docstring . lines options = { \"trim_doctest_flags\" : trim_doctest_flags , \"ignore_init_summary\" : ignore_init_summary , ** options , } ignore_summary = ( options [ \"ignore_init_summary\" ] # noqa: WPS222 and docstring . parent is not None and docstring . parent . name == \"__init__\" and docstring . parent . is_function and docstring . parent . parent is not None and docstring . parent . parent . is_class ) if ignore_summary : offset = 2 else : offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower in _section_kind and _is_dash_line ( lines [ offset + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , offset = reader ( docstring , offset + 2 , ** options ) # type: ignore[operator] if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSectionText ( \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/parsers/","text":"This module imports all the defined parsers. Parser \u00a4 Bases: enum . Enum Enumeration for the different docstring parsers. parse \u00a4 parse ( docstring , parser , ** options ) Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) # type: ignore[operator] return [ DocstringSectionText ( docstring . value )]","title":"parsers"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser","text":"Bases: enum . Enum Enumeration for the different docstring parsers.","title":"Parser"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.parse","text":"parse ( docstring , parser , ** options ) Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) # type: ignore[operator] return [ DocstringSectionText ( docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/sphinx/","text":"This module defines functions to parse Sphinx docstrings into structured data. Credits to Patrick Lannigan ( @plannigan ) who originally added the parser in the pytkdocs project . See https://github.com/mkdocstrings/pytkdocs/pull/71 . FieldType dataclass \u00a4 Maps directive names to parser functions. matches \u00a4 matches ( line ) Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/sphinx.py 51 52 53 54 55 56 57 58 59 60 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names ) ParsedDirective dataclass \u00a4 Directive information that has been parsed from a docstring. ParsedValues dataclass \u00a4 Values parsed from the docstring to be used to produce sections. parse \u00a4 parse ( docstring , ** options ) Parse a Sphinx-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/sphinx.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse a Sphinx-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore[misc,operator] break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"sphinx"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.FieldType","text":"Maps directive names to parser functions.","title":"FieldType"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.FieldType.matches","text":"matches ( line ) Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/sphinx.py 51 52 53 54 55 56 57 58 59 60 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names )","title":"matches()"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.ParsedDirective","text":"Directive information that has been parsed from a docstring.","title":"ParsedDirective"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.ParsedValues","text":"Values parsed from the docstring to be used to produce sections.","title":"ParsedValues"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.parse","text":"parse ( docstring , ** options ) Parse a Sphinx-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/sphinx.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse a Sphinx-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore[misc,operator] break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"parse()"},{"location":"reference/griffe/docstrings/utils/","text":"This module contains utilities for docstrings parsers. parse_annotation \u00a4 parse_annotation ( annotation , docstring , log_level = LogLevel . error ) Parse a string into a true name or expression that can be resolved later. Parameters: annotation ( str ) \u2013 The annotation to parse. docstring ( Docstring ) \u2013 The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression. log_level ( LogLevel ) \u2013 Log level to use to log a message. Returns: str | Name | Expression \u2013 The string unchanged, or a new name or expression. Source code in griffe/docstrings/utils.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def parse_annotation ( annotation : str , docstring : Docstring , log_level : LogLevel = LogLevel . error , ) -> str | Name | Expression : \"\"\"Parse a string into a true name or expression that can be resolved later. Parameters: annotation: The annotation to parse. docstring: The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression. log_level: Log level to use to log a message. Returns: The string unchanged, or a new name or expression. \"\"\" with suppress ( AttributeError , # docstring has no parent that can be used to resolve names SyntaxError , # annotation contains syntax errors ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) if code . body : name_or_expr = safe_get_annotation ( code . body , parent = docstring . parent , # type: ignore[arg-type] log_level = log_level , ) return name_or_expr or annotation return annotation warning \u00a4 warning ( name ) Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore[union-attr] except ( AttributeError , ValueError ): prefix = \"<module>\" logger . warning ( f \" { prefix } : { ( docstring . lineno or 0 ) + offset } : { message } \" ) return warn","title":"utils"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.parse_annotation","text":"parse_annotation ( annotation , docstring , log_level = LogLevel . error ) Parse a string into a true name or expression that can be resolved later. Parameters: annotation ( str ) \u2013 The annotation to parse. docstring ( Docstring ) \u2013 The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression. log_level ( LogLevel ) \u2013 Log level to use to log a message. Returns: str | Name | Expression \u2013 The string unchanged, or a new name or expression. Source code in griffe/docstrings/utils.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def parse_annotation ( annotation : str , docstring : Docstring , log_level : LogLevel = LogLevel . error , ) -> str | Name | Expression : \"\"\"Parse a string into a true name or expression that can be resolved later. Parameters: annotation: The annotation to parse. docstring: The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression. log_level: Log level to use to log a message. Returns: The string unchanged, or a new name or expression. \"\"\" with suppress ( AttributeError , # docstring has no parent that can be used to resolve names SyntaxError , # annotation contains syntax errors ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) if code . body : name_or_expr = safe_get_annotation ( code . body , parent = docstring . parent , # type: ignore[arg-type] log_level = log_level , ) return name_or_expr or annotation return annotation","title":"parse_annotation()"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.warning","text":"warning ( name ) Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore[union-attr] except ( AttributeError , ValueError ): prefix = \"<module>\" logger . warning ( f \" { prefix } : { ( docstring . lineno or 0 ) + offset } : { message } \" ) return warn","title":"warning()"},{"location":"coverage/","text":"article h1, article > a, .md-sidebar--secondary { display: none !important; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}