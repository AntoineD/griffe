{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"griffe \u00a4 Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Work in progress! Requirements \u00a4 Griffe requires Python 3.8 or above. To install Python 3.8, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - bash ) \" # install Python 3.8 pyenv install 3 .8.12 # make it available globally pyenv global system 3 .8.12 Installation \u00a4 With pip : python3.8 -m pip install griffe With pipx : python3.8 -m pip install --user pipx pipx install --python python3.8 griffe Usage \u00a4 On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples. Todo \u00a4 Design: Navigable trees (nodes and data) Extension system Performance Loader/Visitor: Docstrings Line numbers Parsing: see below Labels Attribute: ? Function: ? Class: ? Module: ? Modules Classes Bases (parent classes) Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring Decorators Functions Parameters Return annotation (names, constants, attributes) Decorators Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Attributes (variables/constants) Docstrings Value Name resolution Per-object scope Load external packages resursively (indirections/aliases) Resolve everything that is an ast.Name Resolve names inside more complex expressions? Calls, exprs, etc. Lines collection (lines for each module) Extension system Node-visiting extensions Post-processing extensions Docstrings parsers Structured format Styles Google RST Numpy epydoc New Markdown-based format? For graceful degradation Serializer: JSON Nested Flat API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Overview"},{"location":"#griffe","text":"Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Work in progress!","title":"griffe"},{"location":"#requirements","text":"Griffe requires Python 3.8 or above. To install Python 3.8, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - bash ) \" # install Python 3.8 pyenv install 3 .8.12 # make it available globally pyenv global system 3 .8.12","title":"Requirements"},{"location":"#installation","text":"With pip : python3.8 -m pip install griffe With pipx : python3.8 -m pip install --user pipx pipx install --python python3.8 griffe","title":"Installation"},{"location":"#usage","text":"On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples.","title":"Usage"},{"location":"#todo","text":"Design: Navigable trees (nodes and data) Extension system Performance Loader/Visitor: Docstrings Line numbers Parsing: see below Labels Attribute: ? Function: ? Class: ? Module: ? Modules Classes Bases (parent classes) Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring Decorators Functions Parameters Return annotation (names, constants, attributes) Decorators Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Attributes (variables/constants) Docstrings Value Name resolution Per-object scope Load external packages resursively (indirections/aliases) Resolve everything that is an ast.Name Resolve names inside more complex expressions? Calls, exprs, etc. Lines collection (lines for each module) Extension system Node-visiting extensions Post-processing extensions Docstrings parsers Structured format Styles Google RST Numpy epydoc New Markdown-based format? For graceful degradation Serializer: JSON Nested Flat API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Todo"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.2.0 - 2021-09-25 \u00a4 Compare with 0.1.0 Features \u00a4 Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli). 0.1.0 - 2021-09-09 \u00a4 Compare with first commit Features \u00a4 Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#020-2021-09-25","text":"Compare with 0.1.0","title":"0.2.0 - 2021-09-25"},{"location":"changelog/#features","text":"Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements","text":"Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#010-2021-09-09","text":"Compare with first commit","title":"0.1.0 - 2021-09-09"},{"location":"changelog/#features_1","text":"Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build griffe . Thank you! python | pdm | copier-pdm Direct dependencies \u00a4 aiofiles | autoflake | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | toml | wps-light Indirect dependencies \u00a4 ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | click | colorama | coverage | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | regex | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typing-extensions | watchdog | wheel | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build griffe . Thank you! python | pdm | copier-pdm","title":"Credits"},{"location":"credits/#direct-dependencies","text":"aiofiles | autoflake | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | toml | wps-light","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | click | colorama | coverage | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | regex | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typing-extensions | watchdog | wheel | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2021, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"usage/","text":"Usage \u00a4 On the command line \u00a4 Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError . With Python \u00a4 Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) If you don't want to recurse in the submodules: fastapi = griffe . load_module ( \"fastapi\" , recursive = False ) Extensions \u00a4 You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import Extension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( Extension ): when = When . visit_stops def visit_ClassDef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE> methods to visit nodes of certain types, and act on their properties. Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not call the .generic_visit(node) method in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children (what the generic_visit does). You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_FunctionDef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, data See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit starts: When.visit_starts . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current ) is not yet instantiated. before the children visit starts: When.children_visit_starts . If this node represents a data object, the object ( self.visitor.current ) is now instantiated. Children have not yet been visited. after the children visit stops: When.children_visit_stops . Children have now been visited. after the visit stops: When.visit_stops See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . children_visit_stops By default, it will run it when the visit for the node stops: that's when all the data for this node and its children is loaded. ??? Nodes - `Constant` - `Num` - `Str` - `FormattedValue` - `JoinedStr` - `Bytes` - `List` - `Tuple` - `Set` - `Dict` - `Ellipsis` - `NameConstant` - `Name` - `Load` - `Store` - `Del` - `Starred` - `Expr` - `NamedExpr` - `UnaryOp` - `UAdd` - `USub` - `Not` - `Invert` - `BinOp` - `Add` - `Sub` - `Mult` - `Div` - `FloorDiv` - `Mod` - `Pow` - `LShift` - `RShift` - `BitOr` - `BitXor` - `BitAnd` - `MatMult` - `BoolOp` - `And` - `Or` - `Compare` - `Eq` - `NotEq` - `Lt` - `LtE` - `Gt` - `GtE` - `Is` - `IsNot` - `In` - `NotIn` - `Call` - `keyword` - `IfExp` - `Attribute` - `Subscript` - `Index` - `Slice` - `ExtSlice` - `ListComp` - `SetComp` - `GeneratorExp` - `DictComp` - `comprehension` - `Assign` - `AnnAssign` - `AugAssign` - `Print` - `Raise` - `Assert` - `Delete` - `Pass` - `Import` - `ImportFrom` - `alias` - `If` - `For` - `While` - `Break` - `Continue` - `Try` - `TryFinally` - `TryExcept` - `ExceptHandler` - `With` - `withitem` - `Lambda` - `arguments` - `arg` - `Return` - `Yield` - `YieldFrom` - `Global` - `NonLocal` - `AsyncFunctionDef` - `Await` - `AsyncFor` - `AsyncWith` - `Module` - `Interactive` - `Expression` - `ClassDef` - `FunctionDef` - `MatchOr` - `MatchAs` - `MatchClass` - `MatchMapping` - `MatchStar` - `MatchSequence` - `MatchSingleton` - `MatchValue` - `match_case` - `pattern` - `Match`","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#on-the-command-line","text":"Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError .","title":"On the command line"},{"location":"usage/#with-python","text":"Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) If you don't want to recurse in the submodules: fastapi = griffe . load_module ( \"fastapi\" , recursive = False )","title":"With Python"},{"location":"usage/#extensions","text":"You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import Extension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( Extension ): when = When . visit_stops def visit_ClassDef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE> methods to visit nodes of certain types, and act on their properties. Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not call the .generic_visit(node) method in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children (what the generic_visit does). You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_FunctionDef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, data See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit starts: When.visit_starts . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current ) is not yet instantiated. before the children visit starts: When.children_visit_starts . If this node represents a data object, the object ( self.visitor.current ) is now instantiated. Children have not yet been visited. after the children visit stops: When.children_visit_stops . Children have now been visited. after the visit stops: When.visit_stops See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . children_visit_stops By default, it will run it when the visit for the node stops: that's when all the data for this node and its children is loaded. ??? Nodes - `Constant` - `Num` - `Str` - `FormattedValue` - `JoinedStr` - `Bytes` - `List` - `Tuple` - `Set` - `Dict` - `Ellipsis` - `NameConstant` - `Name` - `Load` - `Store` - `Del` - `Starred` - `Expr` - `NamedExpr` - `UnaryOp` - `UAdd` - `USub` - `Not` - `Invert` - `BinOp` - `Add` - `Sub` - `Mult` - `Div` - `FloorDiv` - `Mod` - `Pow` - `LShift` - `RShift` - `BitOr` - `BitXor` - `BitAnd` - `MatMult` - `BoolOp` - `And` - `Or` - `Compare` - `Eq` - `NotEq` - `Lt` - `LtE` - `Gt` - `GtE` - `Is` - `IsNot` - `In` - `NotIn` - `Call` - `keyword` - `IfExp` - `Attribute` - `Subscript` - `Index` - `Slice` - `ExtSlice` - `ListComp` - `SetComp` - `GeneratorExp` - `DictComp` - `comprehension` - `Assign` - `AnnAssign` - `AugAssign` - `Print` - `Raise` - `Assert` - `Delete` - `Pass` - `Import` - `ImportFrom` - `alias` - `If` - `For` - `While` - `Break` - `Continue` - `Try` - `TryFinally` - `TryExcept` - `ExceptHandler` - `With` - `withitem` - `Lambda` - `arguments` - `arg` - `Return` - `Yield` - `YieldFrom` - `Global` - `NonLocal` - `AsyncFunctionDef` - `Await` - `AsyncFor` - `AsyncWith` - `Module` - `Interactive` - `Expression` - `ClassDef` - `FunctionDef` - `MatchOr` - `MatchAs` - `MatchClass` - `MatchMapping` - `MatchStar` - `MatchSequence` - `MatchSingleton` - `MatchValue` - `match_case` - `pattern` - `Match`","title":"Extensions"},{"location":"reference/SUMMARY/","text":"griffe cli collections dataclasses docstrings dataclasses google markdown numpy parsers rst utils encoders exceptions expressions extended_ast extensions loader logger mixins node_utils visitor","title":"SUMMARY"},{"location":"reference/griffe/","text":"griffe package. Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.","title":"griffe"},{"location":"reference/griffe/cli/","text":"Module that contains the command line application. get_parser () \u00a4 Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async-loader\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-a\" , \"--append-sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {{package}}.\" , ) parser . add_argument ( \"-d\" , \"--docstyle\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) parser . add_argument ( \"-D\" , \"--docopts\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser main ( args = None ) \u00a4 Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\" Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) # type: ignore logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = logging . WARNING ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . append_sys_path : search . extend ( sys . path ) extensions = Extensions () if opts . async_loader : loop = asyncio . get_event_loop () coroutine = _load_packages_async ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) packages = loop . run_until_complete ( coroutine ) else : packages = _load_packages ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output ) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"cli"},{"location":"reference/griffe/cli/#griffe.cli.get_parser","text":"Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async-loader\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-a\" , \"--append-sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {{package}}.\" , ) parser . add_argument ( \"-d\" , \"--docstyle\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) parser . add_argument ( \"-D\" , \"--docopts\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser","title":"get_parser()"},{"location":"reference/griffe/cli/#griffe.cli.main","text":"Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\" Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) # type: ignore logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = logging . WARNING ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . append_sys_path : search . extend ( sys . path ) extensions = Extensions () if opts . async_loader : loop = asyncio . get_event_loop () coroutine = _load_packages_async ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) packages = loop . run_until_complete ( coroutine ) else : packages = _load_packages ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output ) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"main()"},{"location":"reference/griffe/collections/","text":"This module stores collections of data, useful during parsing. LinesCollection ( dict ) \u00a4 A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 13 14 15 16 17 class LinesCollection ( dict ): # noqa: WPS600 \"\"\"A simple dictionary containing the modules source code lines.\"\"\" def __bool__ ( self ): return True ModulesCollection ( GetMembersMixin , SetCollectionMembersMixin ) \u00a4 A collection of modules, allowing easy access to members. Source code in griffe/collections.py 20 21 22 23 24 25 26 27 28 29 30 31 class ModulesCollection ( GetMembersMixin , SetCollectionMembersMixin ): \"\"\"A collection of modules, allowing easy access to members.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {} def __bool__ ( self ): return True def __contains__ ( self , item : Any ) -> bool : return item in self . members __init__ ( self ) \u00a4 Initialize the collection. Source code in griffe/collections.py 23 24 25 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"collections"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection","text":"A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 13 14 15 16 17 class LinesCollection ( dict ): # noqa: WPS600 \"\"\"A simple dictionary containing the modules source code lines.\"\"\" def __bool__ ( self ): return True","title":"LinesCollection"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection","text":"A collection of modules, allowing easy access to members. Source code in griffe/collections.py 20 21 22 23 24 25 26 27 28 29 30 31 class ModulesCollection ( GetMembersMixin , SetCollectionMembersMixin ): \"\"\"A collection of modules, allowing easy access to members.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {} def __bool__ ( self ): return True def __contains__ ( self , item : Any ) -> bool : return item in self . members","title":"ModulesCollection"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.__init__","text":"Initialize the collection. Source code in griffe/collections.py 23 24 25 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"__init__()"},{"location":"reference/griffe/dataclasses/","text":"This module contains the data classes that represent Python objects. The different objects are modules, classes, functions, and attribute (variables like module/class/instance attributes). Alias ( ObjectAliasMixin ) \u00a4 This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 class Alias ( ObjectAliasMixin ): \"\"\"This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: - line numbers are those of the alias, not the target - the path is the alias path, not the canonical one - the name can be different from the target's - if the target can be resolved, the kind is the target's kind - if the target cannot be resolved, the kind becomes [Kind.ALIAS][griffe.dataclasses.Kind] Attributes: name: The alias name. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" is_alias : bool = True def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | None = parent def __getattr__ ( self , name : str ) -> Any : # forward everything to the target return getattr ( self . target , name ) def __getitem__ ( self , key ): # not handled by __getattr__ return self . target [ key ] def __setitem__ ( self , key , value ): # not handled by __getattr__ self . target [ key ] = value @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore # we assume there's always a parent @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore # we assume there's always a parent @property def target ( self ) -> Object | Alias : \"\"\"Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: The resolved target. \"\"\" if not self . resolved : self . resolve_target () return self . _target # type: ignore # cannot return None, exception is raised def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base __init__ ( self , name , target , * , lineno = None , endlineno = None , parent = None ) \u00a4 Initialize the alias. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | None = parent as_dict ( self , full = False , ** kwargs ) \u00a4 Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base kind ( self ) \u00a4 Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind. Source code in griffe/dataclasses.py 693 694 695 696 697 698 699 700 701 702 703 704 @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS modules_collection ( self ) \u00a4 Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 715 716 717 718 719 720 721 722 723 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore # we assume there's always a parent path ( self ) \u00a4 Return the dotted path / import path of this object. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 706 707 708 709 710 711 712 713 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore # we assume there's always a parent resolve_target ( self ) \u00a4 Resolve the target. Source code in griffe/dataclasses.py 739 740 741 742 743 744 745 746 747 748 749 750 751 752 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error resolved ( self ) \u00a4 Tell whether this alias' target is resolved. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 754 755 756 757 758 759 760 761 @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None target ( self ) \u00a4 Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: Object | Alias \u2013 The resolved target. Source code in griffe/dataclasses.py 725 726 727 728 729 730 731 732 733 734 735 736 737 @property def target ( self ) -> Object | Alias : \"\"\"Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: The resolved target. \"\"\" if not self . resolved : self . resolve_target () return self . _target # type: ignore # cannot return None, exception is raised Attribute ( Object ) \u00a4 The class representing a Python module/class/instance attribute. Source code in griffe/dataclasses.py 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 class Attribute ( Object ): \"\"\"The class representing a Python module/class/instance attribute.\"\"\" kind = Kind . ATTRIBUTE def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base __init__ ( self , * args , value = None , annotation = None , ** kwargs ) \u00a4 Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base Class ( Object ) \u00a4 The class representing a Python class. Source code in griffe/dataclasses.py 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 class Class ( Object ): \"\"\"The class representing a Python class.\"\"\" kind = Kind . CLASS def __init__ ( self , * args : Any , bases : list [ Name | Expression ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base __init__ ( self , * args , bases = None , decorators = None , ** kwargs ) \u00a4 Initialize the class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 def __init__ ( self , * args : Any , bases : list [ Name | Expression ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] as_dict ( self , ** kwargs ) \u00a4 Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 906 907 908 909 910 911 912 913 914 915 916 917 918 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base Decorator \u00a4 This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Decorator : \"\"\"This class represents decorators. Attributes: lineno: The starting line number. endlineno: The ending line number. \"\"\" def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } __init__ ( self , lineno , endlineno ) \u00a4 Initialize the decorator. Parameters: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 50 51 52 53 54 55 56 57 58 def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno as_dict ( self , ** kwargs ) \u00a4 Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 60 61 62 63 64 65 66 67 68 69 70 71 72 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } Docstring \u00a4 This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Module | Class | Function | Attribute | None ) \u2013 The parent object on which this docstring is attached. Source code in griffe/dataclasses.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class Docstring : \"\"\"This class represents docstrings. Attributes: value: The actual documentation string, cleaned up. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. \"\"\" def __init__ ( self , value : str , * , lineno : int | None , endlineno : int | None , parent : Module | Class | Function | Attribute | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | Function | Attribute | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} def __bool__ ( self ): return bool ( self . value ) @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base __init__ ( self , value , * , lineno , endlineno , parent = None , parser = None , parser_options = None ) \u00a4 Initialize the docstring. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Module | Class | Function | Attribute | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def __init__ ( self , value : str , * , lineno : int | None , endlineno : int | None , parent : Module | Class | Function | Attribute | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | Function | Attribute | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} as_dict ( self , full = False , docstring_parser = None , ** kwargs ) \u00a4 Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base lines ( self ) \u00a4 Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines. Source code in griffe/dataclasses.py 115 116 117 118 119 120 121 122 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) parse ( self , parser = None , ** options ) \u00a4 Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 133 134 135 136 137 138 139 140 141 142 143 144 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) parsed ( self ) \u00a4 Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 124 125 126 127 128 129 130 131 @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () Function ( Object ) \u00a4 The class representing a Python function. Source code in griffe/dataclasses.py 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 class Function ( Object ): \"\"\"The class representing a Python function.\"\"\" kind = Kind . FUNCTION def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base __init__ ( self , * args , parameters = None , returns = None , decorators = None , ** kwargs ) \u00a4 Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 948 949 950 951 952 953 954 955 956 957 958 959 960 961 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base Kind ( enum . Enum ) \u00a4 Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind. Source code in griffe/dataclasses.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 class Kind ( enum . Enum ): \"\"\"Enumeration of the different objects kinds. Attributes: MODULE: The module kind. CLASS: The class kind. FUNCTION: The function kind. ATTRIBUTE: The attribute kind. \"\"\" MODULE : str = \"module\" CLASS : str = \"class\" FUNCTION : str = \"function\" ATTRIBUTE : str = \"attribute\" ALIAS : str = \"alias\" Module ( Object ) \u00a4 The class representing a Python module. Source code in griffe/dataclasses.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 class Module ( Object ): \"\"\"The class representing a Python module.\"\"\" kind = Kind . MODULE def __init__ ( self , * args : Any , filepath : Path , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path. It can be null for namespace packages. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path = filepath def __repr__ ( self ) -> str : return f \"<Module( { self . _filepath !r} )>\" @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Returns: The module's file path. \"\"\" return self . _filepath @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" return self . filepath . name == \"__init__.py\" # type: ignore @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" return not self . parent and self . filepath . is_dir () @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" return ( self . parent and self . filepath . is_dir () and self . parent . is_namespace_package # type: ignore # modules parents are always modules or self . parent . is_namespace_subpackage # type: ignore # modules parents are always modules ) def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . filepath ) if self . filepath else None return base __init__ ( self , * args , filepath , ** kwargs ) \u00a4 Initialize the module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path ) \u2013 The module file path. It can be null for namespace packages. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 795 796 797 798 799 800 801 802 803 804 def __init__ ( self , * args : Any , filepath : Path , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path. It can be null for namespace packages. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path = filepath as_dict ( self , ** kwargs ) \u00a4 Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 868 869 870 871 872 873 874 875 876 877 878 879 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . filepath ) if self . filepath else None return base filepath ( self ) \u00a4 Get the file path of this module. Returns: Path \u2013 The module's file path. Source code in griffe/dataclasses.py 809 810 811 812 813 814 815 816 @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Returns: The module's file path. \"\"\" return self . _filepath is_init_module ( self ) \u00a4 Tell if this module is an __init__.py module. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 818 819 820 821 822 823 824 825 @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" return self . filepath . name == \"__init__.py\" # type: ignore is_namespace_package ( self ) \u00a4 Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 845 846 847 848 849 850 851 852 @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" return not self . parent and self . filepath . is_dir () is_namespace_subpackage ( self ) \u00a4 Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 854 855 856 857 858 859 860 861 862 863 864 865 866 @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" return ( self . parent and self . filepath . is_dir () and self . parent . is_namespace_package # type: ignore # modules parents are always modules or self . parent . is_namespace_subpackage # type: ignore # modules parents are always modules ) is_package ( self ) \u00a4 Tell if this module is a package (top module). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 827 828 829 830 831 832 833 834 @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module is_subpackage ( self ) \u00a4 Tell if this module is a subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 836 837 838 839 840 841 842 843 @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module Object ( GetMembersMixin , SetMembersMixin , ObjectAliasMixin ) \u00a4 An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Source code in griffe/dataclasses.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 class Object ( GetMembersMixin , SetMembersMixin , ObjectAliasMixin ): \"\"\"An abstract class representing a Python object. Attributes: kind: The object kind. name: The object name. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent, or None if it is the top module. members: The object members. labels: The object labels. \"\"\" kind : Kind is_alias : bool = False def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self # type: ignore def __repr__ ( self ) -> str : return f \"< { self . __class__ . __name__ } ( { self . name !r} , { self . lineno !r} , { self . endlineno !r} )>\" def __bool__ ( self ): return bool ( self . docstring ) or any ( self . members . values ()) def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError # TODO: rename to top_module (for packages collection and package property) @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore return module @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) # type: ignore @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if not self . parent : return self . name return \".\" . join (( self . parent . path , self . name )) @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" if self . lineno is None or self . endlineno is None : return self . lines_collection [ self . filepath ] return self . lines_collection [ self . filepath ][ self . lineno - 1 : self . endlineno ] @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base __init__ ( self , name , * , lineno = None , endlineno = None , docstring = None , parent = None , lines_collection = None , modules_collection = None ) \u00a4 Initialize the object. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self # type: ignore as_dict ( self , full = False , ** kwargs ) \u00a4 Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base attributes ( self ) \u00a4 Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes. Source code in griffe/dataclasses.py 430 431 432 433 434 435 436 437 @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore canonical_path ( self ) \u00a4 Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 502 503 504 505 506 507 508 509 510 511 512 513 @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if not self . parent : return self . name return \".\" . join (( self . parent . path , self . name )) classes ( self ) \u00a4 Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes. Source code in griffe/dataclasses.py 412 413 414 415 416 417 418 419 @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore filepath ( self ) \u00a4 Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 468 469 470 471 472 473 474 475 476 477 478 479 480 @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath filter_members ( self , * predicates ) \u00a4 Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members functions ( self ) \u00a4 Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions. Source code in griffe/dataclasses.py 421 422 423 424 425 426 427 428 @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore has_labels ( self , labels ) \u00a4 Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 375 376 377 378 379 380 381 382 383 384 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) is_kind ( self , kind ) \u00a4 Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind lines ( self ) \u00a4 Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines. Source code in griffe/dataclasses.py 547 548 549 550 551 552 553 554 555 556 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" if self . lineno is None or self . endlineno is None : return self . lines_collection [ self . filepath ] return self . lines_collection [ self . filepath ][ self . lineno - 1 : self . endlineno ] lines_collection ( self ) \u00a4 Return the lines collection attached to this object or its parents. Returns: LinesCollection \u2013 A lines collection. Source code in griffe/dataclasses.py 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection member_is_exported ( self , member , explicitely = True ) \u00a4 Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports module ( self ) \u00a4 Return the parent module of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError modules ( self ) \u00a4 Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules. Source code in griffe/dataclasses.py 403 404 405 406 407 408 409 410 @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore modules_collection ( self ) \u00a4 Return the modules collection attached to this object or its parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection package ( self ) \u00a4 Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 456 457 458 459 460 461 462 463 464 465 466 @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore return module path ( self ) \u00a4 Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 491 492 493 494 495 496 497 498 499 500 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path relative_filepath ( self ) \u00a4 Return the file path where this object was defined, relative to the top module path. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 482 483 484 485 486 487 488 489 @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) # type: ignore resolve ( self , name ) \u00a4 Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) source ( self ) \u00a4 Return the source code of this object. Returns: str \u2013 The source code. Source code in griffe/dataclasses.py 558 559 560 561 562 563 564 565 @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) Parameter \u00a4 This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class Parameter : \"\"\"This class represent a function parameter. Attributes: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , } __init__ ( self , name , * , annotation = None , kind = None , default = None ) \u00a4 Initialize the parameter. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default as_dict ( self , ** kwargs ) \u00a4 Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , } ParameterKind ( enum . Enum ) \u00a4 Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter. Source code in griffe/dataclasses.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class ParameterKind ( enum . Enum ): \"\"\"Enumeration of the different parameter kinds. Attributes: positional_only: Positional-only parameter. positional_or_keyword: Positional or keyword parameter. var_positional: Variadic positional parameter. keyword_only: Keyword-only parameter. var_keyword: Variadic keyword parameter. \"\"\" positional_only : str = \"positional-only\" positional_or_keyword : str = \"positional or keyword\" var_positional : str = \"variadic positional\" keyword_only : str = \"keyword-only\" var_keyword : str = \"variadic keyword\" Parameters \u00a4 This class is a container for parameters. It allows to get parameters using their position (index) or their name. Source code in griffe/dataclasses.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 class Parameters : \"\"\"This class is a container for parameters. It allows to get parameters using their position (index) or their name. \"\"\" def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) def __getitem__ ( self , name_or_index : int | str ) -> Parameter : if isinstance ( name_or_index , int ): return self . _parameters_list [ name_or_index ] return self . _parameters_dict [ name_or_index ] def __len__ ( self ): return len ( self . _parameters_list ) def __iter__ ( self ): return iter ( self . _parameters_list ) def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" ) __init__ ( self , * parameters ) \u00a4 Initialize the parameters container. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 221 222 223 224 225 226 227 228 229 230 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) add ( self , parameter ) \u00a4 Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Source code in griffe/dataclasses.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"dataclasses"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias","text":"This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 class Alias ( ObjectAliasMixin ): \"\"\"This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: - line numbers are those of the alias, not the target - the path is the alias path, not the canonical one - the name can be different from the target's - if the target can be resolved, the kind is the target's kind - if the target cannot be resolved, the kind becomes [Kind.ALIAS][griffe.dataclasses.Kind] Attributes: name: The alias name. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" is_alias : bool = True def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | None = parent def __getattr__ ( self , name : str ) -> Any : # forward everything to the target return getattr ( self . target , name ) def __getitem__ ( self , key ): # not handled by __getattr__ return self . target [ key ] def __setitem__ ( self , key , value ): # not handled by __getattr__ self . target [ key ] = value @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore # we assume there's always a parent @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore # we assume there's always a parent @property def target ( self ) -> Object | Alias : \"\"\"Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: The resolved target. \"\"\" if not self . resolved : self . resolve_target () return self . _target # type: ignore # cannot return None, exception is raised def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base","title":"Alias"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.__init__","text":"Initialize the alias. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | None = parent","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.as_dict","text":"Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.kind","text":"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind. Source code in griffe/dataclasses.py 693 694 695 696 697 698 699 700 701 702 703 704 @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS","title":"kind()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.modules_collection","text":"Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 715 716 717 718 719 720 721 722 723 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore # we assume there's always a parent","title":"modules_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.path","text":"Return the dotted path / import path of this object. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 706 707 708 709 710 711 712 713 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore # we assume there's always a parent","title":"path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolve_target","text":"Resolve the target. Source code in griffe/dataclasses.py 739 740 741 742 743 744 745 746 747 748 749 750 751 752 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error","title":"resolve_target()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolved","text":"Tell whether this alias' target is resolved. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 754 755 756 757 758 759 760 761 @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None","title":"resolved()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.target","text":"Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: Object | Alias \u2013 The resolved target. Source code in griffe/dataclasses.py 725 726 727 728 729 730 731 732 733 734 735 736 737 @property def target ( self ) -> Object | Alias : \"\"\"Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: The resolved target. \"\"\" if not self . resolved : self . resolve_target () return self . _target # type: ignore # cannot return None, exception is raised","title":"target()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute","text":"The class representing a Python module/class/instance attribute. Source code in griffe/dataclasses.py 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 class Attribute ( Object ): \"\"\"The class representing a Python module/class/instance attribute.\"\"\" kind = Kind . ATTRIBUTE def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base","title":"Attribute"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.__init__","text":"Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.as_dict","text":"Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class","text":"The class representing a Python class. Source code in griffe/dataclasses.py 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 class Class ( Object ): \"\"\"The class representing a Python class.\"\"\" kind = Kind . CLASS def __init__ ( self , * args : Any , bases : list [ Name | Expression ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base","title":"Class"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.__init__","text":"Initialize the class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 def __init__ ( self , * args : Any , bases : list [ Name | Expression ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression ] = bases or [] self . decorators : list [ Decorator ] = decorators or []","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.as_dict","text":"Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 906 907 908 909 910 911 912 913 914 915 916 917 918 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator","text":"This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Decorator : \"\"\"This class represents decorators. Attributes: lineno: The starting line number. endlineno: The ending line number. \"\"\" def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , }","title":"Decorator"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.__init__","text":"Initialize the decorator. Parameters: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 50 51 52 53 54 55 56 57 58 def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.as_dict","text":"Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 60 61 62 63 64 65 66 67 68 69 70 71 72 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring","text":"This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Module | Class | Function | Attribute | None ) \u2013 The parent object on which this docstring is attached. Source code in griffe/dataclasses.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class Docstring : \"\"\"This class represents docstrings. Attributes: value: The actual documentation string, cleaned up. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. \"\"\" def __init__ ( self , value : str , * , lineno : int | None , endlineno : int | None , parent : Module | Class | Function | Attribute | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | Function | Attribute | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} def __bool__ ( self ): return bool ( self . value ) @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base","title":"Docstring"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.__init__","text":"Initialize the docstring. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Module | Class | Function | Attribute | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def __init__ ( self , value : str , * , lineno : int | None , endlineno : int | None , parent : Module | Class | Function | Attribute | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | Function | Attribute | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {}","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.as_dict","text":"Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.lines","text":"Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines. Source code in griffe/dataclasses.py 115 116 117 118 119 120 121 122 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" )","title":"lines()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parse","text":"Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 133 134 135 136 137 138 139 140 141 142 143 144 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options ))","title":"parse()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parsed","text":"Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 124 125 126 127 128 129 130 131 @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse ()","title":"parsed()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function","text":"The class representing a Python function. Source code in griffe/dataclasses.py 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 class Function ( Object ): \"\"\"The class representing a Python function.\"\"\" kind = Kind . FUNCTION def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base","title":"Function"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.__init__","text":"Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or []","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.as_dict","text":"Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 948 949 950 951 952 953 954 955 956 957 958 959 960 961 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind","text":"Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind. Source code in griffe/dataclasses.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 class Kind ( enum . Enum ): \"\"\"Enumeration of the different objects kinds. Attributes: MODULE: The module kind. CLASS: The class kind. FUNCTION: The function kind. ATTRIBUTE: The attribute kind. \"\"\" MODULE : str = \"module\" CLASS : str = \"class\" FUNCTION : str = \"function\" ATTRIBUTE : str = \"attribute\" ALIAS : str = \"alias\"","title":"Kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module","text":"The class representing a Python module. Source code in griffe/dataclasses.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 class Module ( Object ): \"\"\"The class representing a Python module.\"\"\" kind = Kind . MODULE def __init__ ( self , * args : Any , filepath : Path , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path. It can be null for namespace packages. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path = filepath def __repr__ ( self ) -> str : return f \"<Module( { self . _filepath !r} )>\" @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Returns: The module's file path. \"\"\" return self . _filepath @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" return self . filepath . name == \"__init__.py\" # type: ignore @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" return not self . parent and self . filepath . is_dir () @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" return ( self . parent and self . filepath . is_dir () and self . parent . is_namespace_package # type: ignore # modules parents are always modules or self . parent . is_namespace_subpackage # type: ignore # modules parents are always modules ) def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . filepath ) if self . filepath else None return base","title":"Module"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.__init__","text":"Initialize the module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path ) \u2013 The module file path. It can be null for namespace packages. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 795 796 797 798 799 800 801 802 803 804 def __init__ ( self , * args : Any , filepath : Path , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path. It can be null for namespace packages. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path = filepath","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.as_dict","text":"Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 868 869 870 871 872 873 874 875 876 877 878 879 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . filepath ) if self . filepath else None return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.filepath","text":"Get the file path of this module. Returns: Path \u2013 The module's file path. Source code in griffe/dataclasses.py 809 810 811 812 813 814 815 816 @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Returns: The module's file path. \"\"\" return self . _filepath","title":"filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_init_module","text":"Tell if this module is an __init__.py module. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 818 819 820 821 822 823 824 825 @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" return self . filepath . name == \"__init__.py\" # type: ignore","title":"is_init_module()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_package","text":"Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 845 846 847 848 849 850 851 852 @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" return not self . parent and self . filepath . is_dir ()","title":"is_namespace_package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_subpackage","text":"Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 854 855 856 857 858 859 860 861 862 863 864 865 866 @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" return ( self . parent and self . filepath . is_dir () and self . parent . is_namespace_package # type: ignore # modules parents are always modules or self . parent . is_namespace_subpackage # type: ignore # modules parents are always modules )","title":"is_namespace_subpackage()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_package","text":"Tell if this module is a package (top module). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 827 828 829 830 831 832 833 834 @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module","title":"is_package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_subpackage","text":"Tell if this module is a subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 836 837 838 839 840 841 842 843 @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module","title":"is_subpackage()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object","text":"An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Source code in griffe/dataclasses.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 class Object ( GetMembersMixin , SetMembersMixin , ObjectAliasMixin ): \"\"\"An abstract class representing a Python object. Attributes: kind: The object kind. name: The object name. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent, or None if it is the top module. members: The object members. labels: The object labels. \"\"\" kind : Kind is_alias : bool = False def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self # type: ignore def __repr__ ( self ) -> str : return f \"< { self . __class__ . __name__ } ( { self . name !r} , { self . lineno !r} , { self . endlineno !r} )>\" def __bool__ ( self ): return bool ( self . docstring ) or any ( self . members . values ()) def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError # TODO: rename to top_module (for packages collection and package property) @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore return module @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) # type: ignore @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if not self . parent : return self . name return \".\" . join (( self . parent . path , self . name )) @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" if self . lineno is None or self . endlineno is None : return self . lines_collection [ self . filepath ] return self . lines_collection [ self . filepath ][ self . lineno - 1 : self . endlineno ] @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base","title":"Object"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.__init__","text":"Initialize the object. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self # type: ignore","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.as_dict","text":"Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.attributes","text":"Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes. Source code in griffe/dataclasses.py 430 431 432 433 434 435 436 437 @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore","title":"attributes()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.canonical_path","text":"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 502 503 504 505 506 507 508 509 510 511 512 513 @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if not self . parent : return self . name return \".\" . join (( self . parent . path , self . name ))","title":"canonical_path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.classes","text":"Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes. Source code in griffe/dataclasses.py 412 413 414 415 416 417 418 419 @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore","title":"classes()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filepath","text":"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 468 469 470 471 472 473 474 475 476 477 478 479 480 @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath","title":"filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filter_members","text":"Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members","title":"filter_members()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.functions","text":"Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions. Source code in griffe/dataclasses.py 421 422 423 424 425 426 427 428 @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore","title":"functions()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_labels","text":"Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 375 376 377 378 379 380 381 382 383 384 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels )","title":"has_labels()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_kind","text":"Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind","title":"is_kind()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines","text":"Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines. Source code in griffe/dataclasses.py 547 548 549 550 551 552 553 554 555 556 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" if self . lineno is None or self . endlineno is None : return self . lines_collection [ self . filepath ] return self . lines_collection [ self . filepath ][ self . lineno - 1 : self . endlineno ]","title":"lines()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines_collection","text":"Return the lines collection attached to this object or its parents. Returns: LinesCollection \u2013 A lines collection. Source code in griffe/dataclasses.py 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection","title":"lines_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.member_is_exported","text":"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports","title":"member_is_exported()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.module","text":"Return the parent module of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError","title":"module()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules","text":"Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules. Source code in griffe/dataclasses.py 403 404 405 406 407 408 409 410 @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore","title":"modules()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules_collection","text":"Return the modules collection attached to this object or its parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection","title":"modules_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.package","text":"Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 456 457 458 459 460 461 462 463 464 465 466 @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore return module","title":"package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.path","text":"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 491 492 493 494 495 496 497 498 499 500 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path","title":"path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.relative_filepath","text":"Return the file path where this object was defined, relative to the top module path. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 482 483 484 485 486 487 488 489 @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) # type: ignore","title":"relative_filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.resolve","text":"Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name )","title":"resolve()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.source","text":"Return the source code of this object. Returns: str \u2013 The source code. Source code in griffe/dataclasses.py 558 559 560 561 562 563 564 565 @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines ))","title":"source()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter","text":"This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class Parameter : \"\"\"This class represent a function parameter. Attributes: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , }","title":"Parameter"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.__init__","text":"Initialize the parameter. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.as_dict","text":"Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind","text":"Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter. Source code in griffe/dataclasses.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class ParameterKind ( enum . Enum ): \"\"\"Enumeration of the different parameter kinds. Attributes: positional_only: Positional-only parameter. positional_or_keyword: Positional or keyword parameter. var_positional: Variadic positional parameter. keyword_only: Keyword-only parameter. var_keyword: Variadic keyword parameter. \"\"\" positional_only : str = \"positional-only\" positional_or_keyword : str = \"positional or keyword\" var_positional : str = \"variadic positional\" keyword_only : str = \"keyword-only\" var_keyword : str = \"variadic keyword\"","title":"ParameterKind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters","text":"This class is a container for parameters. It allows to get parameters using their position (index) or their name. Source code in griffe/dataclasses.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 class Parameters : \"\"\"This class is a container for parameters. It allows to get parameters using their position (index) or their name. \"\"\" def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) def __getitem__ ( self , name_or_index : int | str ) -> Parameter : if isinstance ( name_or_index , int ): return self . _parameters_list [ name_or_index ] return self . _parameters_dict [ name_or_index ] def __len__ ( self ): return len ( self . _parameters_list ) def __iter__ ( self ): return iter ( self . _parameters_list ) def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"Parameters"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.__init__","text":"Initialize the parameters container. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 221 222 223 224 225 226 227 228 229 230 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter )","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.add","text":"Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Source code in griffe/dataclasses.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"add()"},{"location":"reference/griffe/encoders/","text":"This module contains data encoders/serializers and decoders/deserializers. The available formats are: JSON: see the encoder and decoder . Encoder ( json . JSONEncoder ) \u00a4 JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: Source code in griffe/encoders.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class Encoder ( json . JSONEncoder ): \"\"\"JSON encoder. JSON encoders are not used directly, but through the [`json.dump`][] or [`json.dumps`][] methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json.dumps(..., cls=Encoder, full=True, **kwargs) \"\"\" def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj ) __init__ ( self , * args , full = False , docstring_parser = None , docstring_options = None , ** kwargs ) \u00a4 Initialize the encoder. Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} default ( self , obj ) \u00a4 Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 70 71 72 73 74 75 76 77 78 79 80 81 82 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj ) decoder ( obj_dict ) \u00a4 Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Module | Class | Function | Attribute \u2013 An instance of a data class. Source code in griffe/encoders.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Module | Class | Function | Attribute : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( name = obj_dict [ \"name\" ], filepath = Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) elif kind == Kind . ATTRIBUTE : return Attribute ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) return obj_dict","title":"encoders"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder","text":"JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: Source code in griffe/encoders.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class Encoder ( json . JSONEncoder ): \"\"\"JSON encoder. JSON encoders are not used directly, but through the [`json.dump`][] or [`json.dumps`][] methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json.dumps(..., cls=Encoder, full=True, **kwargs) \"\"\" def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj )","title":"Encoder"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder.__init__","text":"Initialize the encoder. Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {}","title":"__init__()"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder.default","text":"Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 70 71 72 73 74 75 76 77 78 79 80 81 82 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj )","title":"default()"},{"location":"reference/griffe/encoders/#griffe.encoders.decoder","text":"Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Module | Class | Function | Attribute \u2013 An instance of a data class. Source code in griffe/encoders.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Module | Class | Function | Attribute : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( name = obj_dict [ \"name\" ], filepath = Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) elif kind == Kind . ATTRIBUTE : return Attribute ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) return obj_dict","title":"decoder()"},{"location":"reference/griffe/exceptions/","text":"This module contains all the exceptions specific to Griffe. AliasResolutionError ( GriffeError ) \u00a4 Exception for alias that cannot be resolved. Source code in griffe/exceptions.py 16 17 18 19 20 21 22 23 24 25 26 class AliasResolutionError ( GriffeError ): \"\"\"Exception for alias that cannot be resolved.\"\"\" def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"could not resolve { self . target_path } \" ) __init__ ( self , target_path ) \u00a4 Initialize the exception. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 19 20 21 22 23 24 25 26 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"could not resolve { self . target_path } \" ) GriffeError ( Exception ) \u00a4 The base exception for all Griffe errors. Source code in griffe/exceptions.py 4 5 class GriffeError ( Exception ): \"\"\"The base exception for all Griffe errors.\"\"\" LastNodeError ( GriffeError ) \u00a4 Exception raised when trying to access a next or previous node. Source code in griffe/exceptions.py 29 30 class LastNodeError ( GriffeError ): \"\"\"Exception raised when trying to access a next or previous node.\"\"\" NameResolutionError ( GriffeError ) \u00a4 Exception for names that cannot be resolved in a object scope. Source code in griffe/exceptions.py 8 9 class NameResolutionError ( GriffeError ): \"\"\"Exception for names that cannot be resolved in a object scope.\"\"\" RootNodeError ( GriffeError ) \u00a4 Exception raised when trying to use siblings properties on a root node. Source code in griffe/exceptions.py 33 34 class RootNodeError ( GriffeError ): \"\"\"Exception raised when trying to use siblings properties on a root node.\"\"\" UnhandledPthFileError ( GriffeError ) \u00a4 Exception for unhandled .path files, when searching modules. Source code in griffe/exceptions.py 12 13 class UnhandledPthFileError ( GriffeError ): \"\"\"Exception for unhandled .path files, when searching modules.\"\"\"","title":"exceptions"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError","text":"Exception for alias that cannot be resolved. Source code in griffe/exceptions.py 16 17 18 19 20 21 22 23 24 25 26 class AliasResolutionError ( GriffeError ): \"\"\"Exception for alias that cannot be resolved.\"\"\" def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"could not resolve { self . target_path } \" )","title":"AliasResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError.__init__","text":"Initialize the exception. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 19 20 21 22 23 24 25 26 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"could not resolve { self . target_path } \" )","title":"__init__()"},{"location":"reference/griffe/exceptions/#griffe.exceptions.GriffeError","text":"The base exception for all Griffe errors. Source code in griffe/exceptions.py 4 5 class GriffeError ( Exception ): \"\"\"The base exception for all Griffe errors.\"\"\"","title":"GriffeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LastNodeError","text":"Exception raised when trying to access a next or previous node. Source code in griffe/exceptions.py 29 30 class LastNodeError ( GriffeError ): \"\"\"Exception raised when trying to access a next or previous node.\"\"\"","title":"LastNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.NameResolutionError","text":"Exception for names that cannot be resolved in a object scope. Source code in griffe/exceptions.py 8 9 class NameResolutionError ( GriffeError ): \"\"\"Exception for names that cannot be resolved in a object scope.\"\"\"","title":"NameResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.RootNodeError","text":"Exception raised when trying to use siblings properties on a root node. Source code in griffe/exceptions.py 33 34 class RootNodeError ( GriffeError ): \"\"\"Exception raised when trying to use siblings properties on a root node.\"\"\"","title":"RootNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnhandledPthFileError","text":"Exception for unhandled .path files, when searching modules. Source code in griffe/exceptions.py 12 13 class UnhandledPthFileError ( GriffeError ): \"\"\"Exception for unhandled .path files, when searching modules.\"\"\"","title":"UnhandledPthFileError"},{"location":"reference/griffe/expressions/","text":"This module contains the data classes that represent resolvable names and expressions. Expression ( list ) \u00a4 This class represents a Python expression. For example, it can represents complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Source code in griffe/expressions.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class Expression ( list ): # noqa: WPS600 \"\"\"This class represents a Python expression. For example, it can represents complex annotations such as: - `Optional[Dict[str, Tuple[int, bool]]]` - `str | Callable | list[int]` Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. \"\"\" def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) def __str__ ( self ): return \"\" . join ( str ( element ) for element in self ) __init__ ( self , * values ) \u00a4 Initialize the expression. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 81 82 83 84 85 86 87 88 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) Name \u00a4 This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Source code in griffe/expressions.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Name : \"\"\"This class represents a Python object identified by a name in a given scope. Attributes: source: The name as written in the source code. \"\"\" def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full def __repr__ ( self ) -> str : return f \"AnnotationName(source= { self . source !r} , full= { self . full !r} )\" def __str__ ( self ) -> str : return self . source @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full } __init__ ( self , source , full ) \u00a4 Initialize the name. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full as_dict ( self , ** kwargs ) \u00a4 Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 57 58 59 60 61 62 63 64 65 66 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full } full ( self ) \u00a4 Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source. Source code in griffe/expressions.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full","title":"expressions"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression","text":"This class represents a Python expression. For example, it can represents complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Source code in griffe/expressions.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class Expression ( list ): # noqa: WPS600 \"\"\"This class represents a Python expression. For example, it can represents complex annotations such as: - `Optional[Dict[str, Tuple[int, bool]]]` - `str | Callable | list[int]` Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. \"\"\" def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) def __str__ ( self ): return \"\" . join ( str ( element ) for element in self )","title":"Expression"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.__init__","text":"Initialize the expression. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 81 82 83 84 85 86 87 88 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values )","title":"__init__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name","text":"This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Source code in griffe/expressions.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Name : \"\"\"This class represents a Python object identified by a name in a given scope. Attributes: source: The name as written in the source code. \"\"\" def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full def __repr__ ( self ) -> str : return f \"AnnotationName(source= { self . source !r} , full= { self . full !r} )\" def __str__ ( self ) -> str : return self . source @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full }","title":"Name"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.__init__","text":"Initialize the name. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full","title":"__init__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.as_dict","text":"Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 57 58 59 60 61 62 63 64 65 66 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full }","title":"as_dict()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.full","text":"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source. Source code in griffe/expressions.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full","title":"full()"},{"location":"reference/griffe/extended_ast/","text":"This module, when imported, will patch the ast.AST class. It will add the following attributes and properties to it: node.parent (attribute): The parent node, or None node.children (attribute): A list of children nodes. node.siblings (cached property): A list of siblings nodes. node.position (cached property): The position of the node within its siblings. node.previous_siblings (cached property): The siblings appearing before this node, starting from the closest. node.next_siblings (cached property): The siblings appearing after this node, starting from the closest. node.previous (cached property): The immediate previous node. node.next (cached property): The immediate next node. All these properties will raise a RootNodeError if they are accessed from the root node. The next and previous properties will raise a LastNodeError if there is no next or previous node. extend_ast () \u00a4 Extend the base ast.AST class to provide more functionality. Source code in griffe/extended_ast.py 102 103 104 105 106 107 108 109 110 111 def extend_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , _ExtendedAST ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442","title":"extended_ast"},{"location":"reference/griffe/extended_ast/#griffe.extended_ast.extend_ast","text":"Extend the base ast.AST class to provide more functionality. Source code in griffe/extended_ast.py 102 103 104 105 106 107 108 109 110 111 def extend_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , _ExtendedAST ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442","title":"extend_ast()"},{"location":"reference/griffe/loader/","text":"This module contains the code allowing to find module and load their data. This is the entrypoint to use griffe programatically: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) AsyncGriffeLoader ( _BaseGriffeLoader ) \u00a4 The asynchronous Griffe loader, allowing to load data from modules. Attributes: extensions \u2013 The extensions to use. Source code in griffe/loader.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 class AsyncGriffeLoader ( _BaseGriffeLoader ): \"\"\"The asynchronous Griffe loader, allowing to load data from modules. Attributes: extensions: The extensions to use. \"\"\" async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) module_object = await self . _load_module_path ( module_name , module_path , submodules = submodules ) self . modules_collection [ module_object . path ] = module_object return module_object async def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): await self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore # we know it's an object return success async def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) code = await read_async ( module_path ) self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) module = visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) if submodules : await self . _load_submodules ( module ) return module async def _load_submodules ( self , module : Module ) -> None : await asyncio . gather ( * [ self . _load_submodule ( module , subparts , subpath ) for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ) ] ) async def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : parent_parts = subparts [: - 1 ] try : member_parent = module [ parent_parts ] except KeyError : logger . debug ( f \"Skipping (not importable) { subpath } \" ) else : member_parent [ subparts [ - 1 ]] = await self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent ) follow_aliases ( self , obj , only_exported = True ) \u00a4 Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 Only try to resolve an alias if it is explicitely exported. Returns: bool \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 async def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): await self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore # we know it's an object return success load_module ( self , module , submodules = True , search_paths = None ) \u00a4 Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Module \u2013 A module. Source code in griffe/loader.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) module_object = await self . _load_module_path ( module_name , module_path , submodules = submodules ) self . modules_collection [ module_object . path ] = module_object return module_object GriffeLoader ( _BaseGriffeLoader ) \u00a4 The Griffe loader, allowing to load data from modules. Attributes: extensions \u2013 The extensions to use. Source code in griffe/loader.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class GriffeLoader ( _BaseGriffeLoader ): \"\"\"The Griffe loader, allowing to load data from modules. Attributes: extensions: The extensions to use. \"\"\" def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) module_object = self . _load_module_path ( module_name , module_path , submodules = submodules ) self . modules_collection [ module_object . path ] = module_object return module_object def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore # we know it's an object return success def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) code = module_path . read_text () self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) module = visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) if submodules : self . _load_submodules ( module ) return module def _load_submodules ( self , module : Module ) -> None : for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ): self . _load_submodule ( module , subparts , subpath ) def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : parent_parts = subparts [: - 1 ] try : member_parent = module [ parent_parts ] except KeyError : logger . debug ( f \"Skipping (not importable) { subpath } \" ) else : member_parent [ subparts [ - 1 ]] = self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent ) follow_aliases ( self , obj , only_exported = True ) \u00a4 Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 Only try to resolve an alias if it is explicitely exported. Returns: bool \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore # we know it's an object return success load_module ( self , module , submodules = True , search_paths = None ) \u00a4 Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Module \u2013 A module. Source code in griffe/loader.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) module_object = self . _load_module_path ( module_name , module_path , submodules = submodules ) self . modules_collection [ module_object . path ] = module_object return module_object _BaseGriffeLoader \u00a4 Source code in griffe/loader.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class _BaseGriffeLoader : def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () extend_ast () def _module_name_and_path ( self , module : str | Path , search_paths : Sequence [ str | Path ] | None = None , ) -> tuple [ str , Path ]: if isinstance ( module , Path ): # programatically passed a Path, try only that module_name , module_path = module_name_path ( module ) else : # passed a string (from CLI or Python code), try both try : module_name , module_path = module_name_path ( Path ( module )) except FileNotFoundError : module_name = module module_path = find_module ( module_name , search_paths = search_paths ) return module_name , module_path __init__ ( self , extensions = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 Initialize the loader. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/loader.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () extend_ast () find_module ( module_name , search_paths = None ) \u00a4 Find a module in a given list of paths or in sys.path . Parameters: module_name ( str ) \u2013 The module name. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Path \u2013 The module file path. Source code in griffe/loader.py 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 def find_module ( module_name : str , search_paths : Sequence [ str | Path ] | None = None ) -> Path : # noqa: WPS231 \"\"\"Find a module in a given list of paths or in `sys.path`. Parameters: module_name: The module name. search_paths: The paths to search into. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" # optimization: pre-compute Paths to relieve CPU when joining paths search = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] parts = module_name . split ( \".\" ) filenames = [ Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .pth\" ), ] for path in search : for choice in filenames : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): if abs_path . name . endswith ( \".pth\" ): try : return _handle_pth_file ( abs_path ) except UnhandledPthFileError as error : raise ModuleNotFoundError ( module_name ) from error return abs_path raise ModuleNotFoundError ( module_name ) iter_submodules ( path ) \u00a4 Iterate on a module's submodules, if any. Parameters: path ( Path ) \u2013 The module path. Yields: Iterator [ NamePartsAndPathType ] \u2013 This generator yields tuples containing the parts of the submodule name as well as its filepath. Source code in griffe/loader.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def iter_submodules ( path : Path ) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS234 \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. Yields: This generator yields tuples containing the parts of the submodule name as well as its filepath. \"\"\" if path . name == \"__init__.py\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix == \".py\" : return for subpath in path . rglob ( \"*.py\" ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . name == \"__init__.py\" : # optimization: since it's a relative path, # if it has only one part and is named __init__.py, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath else : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath module_name_path ( path ) \u00a4 Get the module name and path from a path. Parameters: path ( Path ) \u2013 A directory or file path. Paths to __init__.py files will be resolved to their parent directory. Returns: tuple [ str , Path ] \u2013 The name of the module (or package) and its path. Source code in griffe/loader.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def module_name_path ( path : Path ) -> tuple [ str , Path ]: \"\"\"Get the module name and path from a path. Parameters: path: A directory or file path. Paths to `__init__.py` files will be resolved to their parent directory. Raises: FileNotFoundError: When: - the directory has no `__init__.py` file in it - the path does not exist Returns: The name of the module (or package) and its path. \"\"\" if path . is_dir (): module_path = path / \"__init__.py\" if module_path . exists (): return path . name , module_path raise FileNotFoundError if path . exists (): if path . stem == \"__init__\" : if path . parent . is_absolute (): return path . parent . name , path return path . parent . resolve () . name , path return path . stem , path raise FileNotFoundError","title":"loader"},{"location":"reference/griffe/loader/#griffe.loader.AsyncGriffeLoader","text":"The asynchronous Griffe loader, allowing to load data from modules. Attributes: extensions \u2013 The extensions to use. Source code in griffe/loader.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 class AsyncGriffeLoader ( _BaseGriffeLoader ): \"\"\"The asynchronous Griffe loader, allowing to load data from modules. Attributes: extensions: The extensions to use. \"\"\" async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) module_object = await self . _load_module_path ( module_name , module_path , submodules = submodules ) self . modules_collection [ module_object . path ] = module_object return module_object async def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): await self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore # we know it's an object return success async def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) code = await read_async ( module_path ) self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) module = visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) if submodules : await self . _load_submodules ( module ) return module async def _load_submodules ( self , module : Module ) -> None : await asyncio . gather ( * [ self . _load_submodule ( module , subparts , subpath ) for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ) ] ) async def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : parent_parts = subparts [: - 1 ] try : member_parent = module [ parent_parts ] except KeyError : logger . debug ( f \"Skipping (not importable) { subpath } \" ) else : member_parent [ subparts [ - 1 ]] = await self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent )","title":"AsyncGriffeLoader"},{"location":"reference/griffe/loader/#griffe.loader.AsyncGriffeLoader.follow_aliases","text":"Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 Only try to resolve an alias if it is explicitely exported. Returns: bool \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 async def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): await self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore # we know it's an object return success","title":"follow_aliases()"},{"location":"reference/griffe/loader/#griffe.loader.AsyncGriffeLoader.load_module","text":"Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Module \u2013 A module. Source code in griffe/loader.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) module_object = await self . _load_module_path ( module_name , module_path , submodules = submodules ) self . modules_collection [ module_object . path ] = module_object return module_object","title":"load_module()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader","text":"The Griffe loader, allowing to load data from modules. Attributes: extensions \u2013 The extensions to use. Source code in griffe/loader.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class GriffeLoader ( _BaseGriffeLoader ): \"\"\"The Griffe loader, allowing to load data from modules. Attributes: extensions: The extensions to use. \"\"\" def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) module_object = self . _load_module_path ( module_name , module_path , submodules = submodules ) self . modules_collection [ module_object . path ] = module_object return module_object def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore # we know it's an object return success def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) code = module_path . read_text () self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) module = visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) if submodules : self . _load_submodules ( module ) return module def _load_submodules ( self , module : Module ) -> None : for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ): self . _load_submodule ( module , subparts , subpath ) def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : parent_parts = subparts [: - 1 ] try : member_parent = module [ parent_parts ] except KeyError : logger . debug ( f \"Skipping (not importable) { subpath } \" ) else : member_parent [ subparts [ - 1 ]] = self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent )","title":"GriffeLoader"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.follow_aliases","text":"Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 Only try to resolve an alias if it is explicitely exported. Returns: bool \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def follow_aliases ( self , obj : Object , only_exported : bool = True ) -> bool : # noqa: WPS231 \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: Only try to resolve an alias if it is explicitely exported. Returns: True if everything was resolved, False otherwise. \"\"\" success = True for member in obj . members . values (): if member . is_alias : if only_exported and not obj . member_is_exported ( member , explicitely = True ): continue try : member . resolve_target () # type: ignore # we know it's an alias except AliasResolutionError as error : success = False package = error . target_path . split ( \".\" , 1 )[ 0 ] if obj . package . path != package and package not in self . modules_collection : with suppress ( ModuleNotFoundError ): self . load_module ( package ) else : success &= self . follow_aliases ( member ) # type: ignore # we know it's an object return success","title":"follow_aliases()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.load_module","text":"Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Module \u2013 A module. Source code in griffe/loader.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) module_object = self . _load_module_path ( module_name , module_path , submodules = submodules ) self . modules_collection [ module_object . path ] = module_object return module_object","title":"load_module()"},{"location":"reference/griffe/loader/#griffe.loader._BaseGriffeLoader","text":"Source code in griffe/loader.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class _BaseGriffeLoader : def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () extend_ast () def _module_name_and_path ( self , module : str | Path , search_paths : Sequence [ str | Path ] | None = None , ) -> tuple [ str , Path ]: if isinstance ( module , Path ): # programatically passed a Path, try only that module_name , module_path = module_name_path ( module ) else : # passed a string (from CLI or Python code), try both try : module_name , module_path = module_name_path ( Path ( module )) except FileNotFoundError : module_name = module module_path = find_module ( module_name , search_paths = search_paths ) return module_name , module_path","title":"_BaseGriffeLoader"},{"location":"reference/griffe/loader/#griffe.loader._BaseGriffeLoader.__init__","text":"Initialize the loader. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/loader.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () extend_ast ()","title":"__init__()"},{"location":"reference/griffe/loader/#griffe.loader.find_module","text":"Find a module in a given list of paths or in sys.path . Parameters: module_name ( str ) \u2013 The module name. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Returns: Path \u2013 The module file path. Source code in griffe/loader.py 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 def find_module ( module_name : str , search_paths : Sequence [ str | Path ] | None = None ) -> Path : # noqa: WPS231 \"\"\"Find a module in a given list of paths or in `sys.path`. Parameters: module_name: The module name. search_paths: The paths to search into. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" # optimization: pre-compute Paths to relieve CPU when joining paths search = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] parts = module_name . split ( \".\" ) filenames = [ Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .pth\" ), ] for path in search : for choice in filenames : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): if abs_path . name . endswith ( \".pth\" ): try : return _handle_pth_file ( abs_path ) except UnhandledPthFileError as error : raise ModuleNotFoundError ( module_name ) from error return abs_path raise ModuleNotFoundError ( module_name )","title":"find_module()"},{"location":"reference/griffe/loader/#griffe.loader.iter_submodules","text":"Iterate on a module's submodules, if any. Parameters: path ( Path ) \u2013 The module path. Yields: Iterator [ NamePartsAndPathType ] \u2013 This generator yields tuples containing the parts of the submodule name as well as its filepath. Source code in griffe/loader.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def iter_submodules ( path : Path ) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS234 \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. Yields: This generator yields tuples containing the parts of the submodule name as well as its filepath. \"\"\" if path . name == \"__init__.py\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix == \".py\" : return for subpath in path . rglob ( \"*.py\" ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . name == \"__init__.py\" : # optimization: since it's a relative path, # if it has only one part and is named __init__.py, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath else : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath","title":"iter_submodules()"},{"location":"reference/griffe/loader/#griffe.loader.module_name_path","text":"Get the module name and path from a path. Parameters: path ( Path ) \u2013 A directory or file path. Paths to __init__.py files will be resolved to their parent directory. Returns: tuple [ str , Path ] \u2013 The name of the module (or package) and its path. Source code in griffe/loader.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def module_name_path ( path : Path ) -> tuple [ str , Path ]: \"\"\"Get the module name and path from a path. Parameters: path: A directory or file path. Paths to `__init__.py` files will be resolved to their parent directory. Raises: FileNotFoundError: When: - the directory has no `__init__.py` file in it - the path does not exist Returns: The name of the module (or package) and its path. \"\"\" if path . is_dir (): module_path = path / \"__init__.py\" if module_path . exists (): return path . name , module_path raise FileNotFoundError if path . exists (): if path . stem == \"__init__\" : if path . parent . is_absolute (): return path . parent . name , path return path . parent . resolve () . name , path return path . stem , path raise FileNotFoundError","title":"module_name_path()"},{"location":"reference/griffe/logger/","text":"This module contains logging utilities. We provide the get_logger function so dependant libraries can patch it as they see fit. For example, to fit in the MkDocs logging configuration and prefix each log message with the module name: import logging from griffe import logger as griffe_logger class LoggerAdapter ( logging . LoggerAdapter ): def __init__ ( self , prefix , logger ): super () . __init__ ( logger , {}) self . prefix = prefix def process ( self , msg , kwargs ): return f \" { self . prefix } : { msg } \" , kwargs def get_logger ( name ): logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) return LoggerAdapter ( name , logger ) griffe_logger . get_logger = get_logger get_logger ( name ) \u00a4 Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: logging . Logger \u2013 The logger. Source code in griffe/logger.py 33 34 35 36 37 38 39 40 41 42 def get_logger ( name : str ) -> logging . Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return logging . getLogger ( name )","title":"logger"},{"location":"reference/griffe/logger/#griffe.logger.get_logger","text":"Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: logging . Logger \u2013 The logger. Source code in griffe/logger.py 33 34 35 36 37 38 39 40 41 42 def get_logger ( name : str ) -> logging . Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return logging . getLogger ( name )","title":"get_logger()"},{"location":"reference/griffe/mixins/","text":"This module contains some mixins classes about accessing and setting members. GetMembersMixin \u00a4 This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance. Source code in griffe/mixins.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class GetMembersMixin : \"\"\"This mixin adds a `__getitem__` method to a class. It makes it easier to access members of an object. The method expects a `members` attribute/property to be available on the instance. \"\"\" def __getitem__ ( self , key : str | Sequence [ str ]) -> Any : if isinstance ( key , str ): if not key : return self parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : return self if len ( parts ) == 1 : return self . members [ parts [ 0 ]] # type: ignore return self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore ObjectAliasMixin \u00a4 A mixin for methods that appear both in objects and aliases, unchanged. Source code in griffe/mixins.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class ObjectAliasMixin : \"\"\"A mixin for methods that appear both in objects and aliases, unchanged.\"\"\" def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore is_explicitely_exported ( self ) \u00a4 Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 91 92 93 94 95 96 97 98 @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) is_exported ( self , explicitely = True ) \u00a4 Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 80 81 82 83 84 85 86 87 88 89 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore is_implicitely_exported ( self ) \u00a4 Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 100 101 102 103 104 105 106 107 @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore SetCollectionMembersMixin \u00a4 This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its _modules_collection attribute is set as well. Source code in griffe/mixins.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class SetCollectionMembersMixin : \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `_modules_collection` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): if isinstance ( key , str ): if not key : raise ValueError ( \"cannot set self (empty key)\" ) parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : raise ValueError ( \"cannot set self (empty parts)\" ) if len ( parts ) == 1 : self . members [ parts [ 0 ]] = value # type: ignore value . _modules_collection = self # noqa: WPS437 else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore SetMembersMixin \u00a4 This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well. Source code in griffe/mixins.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SetMembersMixin : \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `parent` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): if isinstance ( key , str ): if not key : raise ValueError ( \"cannot set self (empty key)\" ) parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : raise ValueError ( \"cannot set self (empty parts)\" ) if len ( parts ) == 1 : self . members [ parts [ 0 ]] = value # type: ignore value . parent = self else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore","title":"mixins"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin","text":"This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance. Source code in griffe/mixins.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class GetMembersMixin : \"\"\"This mixin adds a `__getitem__` method to a class. It makes it easier to access members of an object. The method expects a `members` attribute/property to be available on the instance. \"\"\" def __getitem__ ( self , key : str | Sequence [ str ]) -> Any : if isinstance ( key , str ): if not key : return self parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : return self if len ( parts ) == 1 : return self . members [ parts [ 0 ]] # type: ignore return self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore","title":"GetMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin","text":"A mixin for methods that appear both in objects and aliases, unchanged. Source code in griffe/mixins.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class ObjectAliasMixin : \"\"\"A mixin for methods that appear both in objects and aliases, unchanged.\"\"\" def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore","title":"ObjectAliasMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_explicitely_exported","text":"Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 91 92 93 94 95 96 97 98 @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True )","title":"is_explicitely_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_exported","text":"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 80 81 82 83 84 85 86 87 88 89 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore","title":"is_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_implicitely_exported","text":"Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 100 101 102 103 104 105 106 107 @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore","title":"is_implicitely_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.SetCollectionMembersMixin","text":"This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its _modules_collection attribute is set as well. Source code in griffe/mixins.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class SetCollectionMembersMixin : \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `_modules_collection` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): if isinstance ( key , str ): if not key : raise ValueError ( \"cannot set self (empty key)\" ) parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : raise ValueError ( \"cannot set self (empty parts)\" ) if len ( parts ) == 1 : self . members [ parts [ 0 ]] = value # type: ignore value . _modules_collection = self # noqa: WPS437 else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore","title":"SetCollectionMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin","text":"This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well. Source code in griffe/mixins.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SetMembersMixin : \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `parent` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): if isinstance ( key , str ): if not key : raise ValueError ( \"cannot set self (empty key)\" ) parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : raise ValueError ( \"cannot set self (empty parts)\" ) if len ( parts ) == 1 : self . members [ parts [ 0 ]] = value # type: ignore value . parent = self else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore","title":"SetMembersMixin"},{"location":"reference/griffe/node_utils/","text":"This module contains utilities for extracting information from AST nodes. get_annotation ( node , parent ) \u00a4 Extract a resolvable annotation. Parameters: node ( Node ) \u2013 The annotation node. parent ( Class | Module ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression \u2013 A string or resovable name or expression. Source code in griffe/node_utils.py 173 174 175 176 177 178 179 180 181 182 183 def get_annotation ( node : Node , parent : Class | Module ) -> str | Name | Expression : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" return _node_annotation_map . get ( type ( node ), lambda node , parent : None )( node , parent ) # type: ignore get_baseclass ( node , parent ) \u00a4 Extract a resolvable name for a given base class. Parameters: node ( Node ) \u2013 The base class node. parent ( Class | Module ) \u2013 The parent used to resolve the name. Returns: Name | Expression \u2013 A resovable name or expression. Source code in griffe/node_utils.py 94 95 96 97 98 99 100 101 102 103 104 def get_baseclass ( node : Node , parent : Class | Module ) -> Name | Expression : \"\"\"Extract a resolvable name for a given base class. Parameters: node: The base class node. parent: The parent used to resolve the name. Returns: A resovable name or expression. \"\"\" return _node_baseclass_map . get ( type ( node ), lambda node , parent : None )( node , parent ) # type: ignore get_docstring ( node , strict = False ) \u00a4 Extract a docstring. Parameters: node ( Node ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/node_utils.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def get_docstring ( node : Node , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore doc = node . body [ 0 ] . value # type: ignore else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno if isinstance ( doc , NodeStr ): return doc . s , doc . lineno , doc . end_lineno return None , None , None get_instance_names ( node ) \u00a4 Extract names from an assignment node, only for instance attributes. Parameters: node ( Node ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/node_utils.py 459 460 461 462 463 464 465 466 467 468 def get_instance_names ( node : Node ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )] get_names ( node ) \u00a4 Extract names from an assignment node. Parameters: node ( Node ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/node_utils.py 447 448 449 450 451 452 453 454 455 456 def get_names ( node : Node ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map . get ( type ( node ), lambda _ : None )( node ) # type: ignore get_parameter_default ( node , filepath , lines_collection ) \u00a4 Extract the default value of a function parameter. Parameters: node ( Node ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/node_utils.py 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def get_parameter_default ( node : Node , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None if isinstance ( node , NodeConstant ): return repr ( node . value ) if isinstance ( node , NodeName ): return node . id if node . lineno == node . end_lineno : return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # TODO: handle multiple line defaults return None get_value ( node ) \u00a4 Extract a complex value as a string. Parameters: node ( Node ) \u2013 The node to extract the value from. Returns: str \u2013 The unparsed code of the node. Source code in griffe/node_utils.py 407 408 409 410 411 412 413 414 415 416 def get_value ( node : Node ) -> str : \"\"\"Extract a complex value as a string. Parameters: node: The node to extract the value from. Returns: The unparsed code of the node. \"\"\" return _node_value_map . get ( type ( node ), lambda _ : None )( node ) # type: ignore","title":"node_utils"},{"location":"reference/griffe/node_utils/#griffe.node_utils.get_annotation","text":"Extract a resolvable annotation. Parameters: node ( Node ) \u2013 The annotation node. parent ( Class | Module ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression \u2013 A string or resovable name or expression. Source code in griffe/node_utils.py 173 174 175 176 177 178 179 180 181 182 183 def get_annotation ( node : Node , parent : Class | Module ) -> str | Name | Expression : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" return _node_annotation_map . get ( type ( node ), lambda node , parent : None )( node , parent ) # type: ignore","title":"get_annotation()"},{"location":"reference/griffe/node_utils/#griffe.node_utils.get_baseclass","text":"Extract a resolvable name for a given base class. Parameters: node ( Node ) \u2013 The base class node. parent ( Class | Module ) \u2013 The parent used to resolve the name. Returns: Name | Expression \u2013 A resovable name or expression. Source code in griffe/node_utils.py 94 95 96 97 98 99 100 101 102 103 104 def get_baseclass ( node : Node , parent : Class | Module ) -> Name | Expression : \"\"\"Extract a resolvable name for a given base class. Parameters: node: The base class node. parent: The parent used to resolve the name. Returns: A resovable name or expression. \"\"\" return _node_baseclass_map . get ( type ( node ), lambda node , parent : None )( node , parent ) # type: ignore","title":"get_baseclass()"},{"location":"reference/griffe/node_utils/#griffe.node_utils.get_docstring","text":"Extract a docstring. Parameters: node ( Node ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/node_utils.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def get_docstring ( node : Node , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore doc = node . body [ 0 ] . value # type: ignore else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno if isinstance ( doc , NodeStr ): return doc . s , doc . lineno , doc . end_lineno return None , None , None","title":"get_docstring()"},{"location":"reference/griffe/node_utils/#griffe.node_utils.get_instance_names","text":"Extract names from an assignment node, only for instance attributes. Parameters: node ( Node ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/node_utils.py 459 460 461 462 463 464 465 466 467 468 def get_instance_names ( node : Node ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )]","title":"get_instance_names()"},{"location":"reference/griffe/node_utils/#griffe.node_utils.get_names","text":"Extract names from an assignment node. Parameters: node ( Node ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/node_utils.py 447 448 449 450 451 452 453 454 455 456 def get_names ( node : Node ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map . get ( type ( node ), lambda _ : None )( node ) # type: ignore","title":"get_names()"},{"location":"reference/griffe/node_utils/#griffe.node_utils.get_parameter_default","text":"Extract the default value of a function parameter. Parameters: node ( Node ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/node_utils.py 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def get_parameter_default ( node : Node , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None if isinstance ( node , NodeConstant ): return repr ( node . value ) if isinstance ( node , NodeName ): return node . id if node . lineno == node . end_lineno : return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # TODO: handle multiple line defaults return None","title":"get_parameter_default()"},{"location":"reference/griffe/node_utils/#griffe.node_utils.get_value","text":"Extract a complex value as a string. Parameters: node ( Node ) \u2013 The node to extract the value from. Returns: str \u2013 The unparsed code of the node. Source code in griffe/node_utils.py 407 408 409 410 411 412 413 414 415 416 def get_value ( node : Node ) -> str : \"\"\"Extract a complex value as a string. Parameters: node: The node to extract the value from. Returns: The unparsed code of the node. \"\"\" return _node_value_map . get ( type ( node ), lambda _ : None )( node ) # type: ignore","title":"get_value()"},{"location":"reference/griffe/visitor/","text":"Code parsing and data extraction utilies. This module exposes a public function, visit() , which parses the module code using parse() , and returns a new Module instance, populating its members recursively, by using a custom NodeVisitor class. visit ( module_name , filepath , code , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None ) \u00a4 Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/visitor.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def visit ( module_name : str , filepath : Path , code : str , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" return _MainVisitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ()","title":"visitor"},{"location":"reference/griffe/visitor/#griffe.visitor.visit","text":"Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/visitor.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def visit ( module_name : str , filepath : Path , code : str , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" return _MainVisitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ()","title":"visit()"},{"location":"reference/griffe/docstrings/","text":"This module exposes objects related to docstrings. Parser ( enum . Enum ) \u00a4 Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\" parse ( docstring , parser , ** options ) \u00a4 Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"docstrings"},{"location":"reference/griffe/docstrings/#griffe.docstrings.Parser","text":"Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\"","title":"Parser"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parse","text":"Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/dataclasses/","text":"This module contains the dataclasses related to docstrings. DocstringAdmonition \u00a4 This base class represents admonitions. Attributes: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class DocstringAdmonition : \"\"\"This base class represents admonitions. Attributes: kind: The admonition kind. contents: The admonition contents. \"\"\" def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , } __init__ ( self , * , kind , contents ) \u00a4 Initialize the admonition. Parameters: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 71 72 73 74 75 76 77 78 79 def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents as_dict ( self , ** kwargs ) \u00a4 Return this admonition's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , } DocstringAttribute ( DocstringNamedElement ) \u00a4 This class represents a documented module/class attribute. Source code in griffe/docstrings/dataclasses.py 213 214 class DocstringAttribute ( DocstringNamedElement ): \"\"\"This class represents a documented module/class attribute.\"\"\" DocstringElement \u00a4 This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class DocstringElement : \"\"\"This base class represents annotated, nameless elements. Attributes: annotation: The element annotation, if any. description: The element description. \"\"\" def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , } __init__ ( self , * , description , annotation = None ) \u00a4 Initialize the element. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 104 105 106 107 108 109 110 111 112 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , } DocstringException ( DocstringElement ) \u00a4 This class represents a documented exception. Source code in griffe/docstrings/dataclasses.py 129 130 class DocstringException ( DocstringElement ): \"\"\"This class represents a documented exception.\"\"\" DocstringNamedElement ( DocstringElement ) \u00a4 This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Source code in griffe/docstrings/dataclasses.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class DocstringNamedElement ( DocstringElement ): \"\"\"This base class represents annotated, named elements. Attributes: name: The element name. value: The element value, as a string, if any. \"\"\" def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base __init__ ( self , name , * , description , annotation = None , value = None ) \u00a4 Initialize the element. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 181 182 183 184 185 186 187 188 189 190 191 192 193 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base DocstringParameter ( DocstringNamedElement ) \u00a4 This class represent a documented function parameter. Source code in griffe/docstrings/dataclasses.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class DocstringParameter ( DocstringNamedElement ): \"\"\"This class represent a documented function parameter.\"\"\" @property def default ( self ): \"\"\"Return the default value of this parameter. Returns: The parameter's default. \"\"\" return self . value @default . setter def default ( self , value ): self . value = value DocstringRaise ( DocstringElement ) \u00a4 This class represents a documented raise value. Source code in griffe/docstrings/dataclasses.py 145 146 class DocstringRaise ( DocstringElement ): \"\"\"This class represents a documented raise value.\"\"\" DocstringReceive ( DocstringElement ) \u00a4 This class represents a documented receive value. Source code in griffe/docstrings/dataclasses.py 141 142 class DocstringReceive ( DocstringElement ): \"\"\"This class represents a documented receive value.\"\"\" DocstringReturn ( DocstringElement ) \u00a4 This class represents a documented return value. Source code in griffe/docstrings/dataclasses.py 133 134 class DocstringReturn ( DocstringElement ): \"\"\"This class represents a documented return value.\"\"\" DocstringSection \u00a4 Placeholder. Source code in griffe/docstrings/dataclasses.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class DocstringSection : \"\"\"Placeholder.\"\"\" def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base __init__ ( self , kind , value , title = None ) \u00a4 Initialize the section. Parameters: kind ( DocstringSectionKind ) \u2013 The section kind. value ( Any ) \u2013 The section value. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title as_dict ( self , ** kwargs ) \u00a4 Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base DocstringSectionKind ( enum . Enum ) \u00a4 The possible section kinds. Source code in griffe/docstrings/dataclasses.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DocstringSectionKind ( enum . Enum ): \"\"\"The possible section kinds.\"\"\" text = \"text\" parameters = \"parameters\" other_parameters = \"other parameters\" raises = \"raises\" warns = \"warns\" returns = \"returns\" yields = \"yields\" receives = \"receives\" examples = \"examples\" attributes = \"attributes\" deprecated = \"deprecated\" admonition = \"admonition\" DocstringWarn ( DocstringElement ) \u00a4 This class represents a documented warn value. Source code in griffe/docstrings/dataclasses.py 149 150 class DocstringWarn ( DocstringElement ): \"\"\"This class represents a documented warn value.\"\"\" DocstringYield ( DocstringElement ) \u00a4 This class represents a documented yield value. Source code in griffe/docstrings/dataclasses.py 137 138 class DocstringYield ( DocstringElement ): \"\"\"This class represents a documented yield value.\"\"\"","title":"dataclasses"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition","text":"This base class represents admonitions. Attributes: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class DocstringAdmonition : \"\"\"This base class represents admonitions. Attributes: kind: The admonition kind. contents: The admonition contents. \"\"\" def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , }","title":"DocstringAdmonition"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.__init__","text":"Initialize the admonition. Parameters: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 71 72 73 74 75 76 77 78 79 def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.as_dict","text":"Return this admonition's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , }","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAttribute","text":"This class represents a documented module/class attribute. Source code in griffe/docstrings/dataclasses.py 213 214 class DocstringAttribute ( DocstringNamedElement ): \"\"\"This class represents a documented module/class attribute.\"\"\"","title":"DocstringAttribute"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement","text":"This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class DocstringElement : \"\"\"This base class represents annotated, nameless elements. Attributes: annotation: The element annotation, if any. description: The element description. \"\"\" def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , }","title":"DocstringElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.__init__","text":"Initialize the element. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 104 105 106 107 108 109 110 111 112 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.as_dict","text":"Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , }","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringException","text":"This class represents a documented exception. Source code in griffe/docstrings/dataclasses.py 129 130 class DocstringException ( DocstringElement ): \"\"\"This class represents a documented exception.\"\"\"","title":"DocstringException"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement","text":"This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Source code in griffe/docstrings/dataclasses.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class DocstringNamedElement ( DocstringElement ): \"\"\"This base class represents annotated, named elements. Attributes: name: The element name. value: The element value, as a string, if any. \"\"\" def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base","title":"DocstringNamedElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.__init__","text":"Initialize the element. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.as_dict","text":"Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 181 182 183 184 185 186 187 188 189 190 191 192 193 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter","text":"This class represent a documented function parameter. Source code in griffe/docstrings/dataclasses.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class DocstringParameter ( DocstringNamedElement ): \"\"\"This class represent a documented function parameter.\"\"\" @property def default ( self ): \"\"\"Return the default value of this parameter. Returns: The parameter's default. \"\"\" return self . value @default . setter def default ( self , value ): self . value = value","title":"DocstringParameter"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringRaise","text":"This class represents a documented raise value. Source code in griffe/docstrings/dataclasses.py 145 146 class DocstringRaise ( DocstringElement ): \"\"\"This class represents a documented raise value.\"\"\"","title":"DocstringRaise"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReceive","text":"This class represents a documented receive value. Source code in griffe/docstrings/dataclasses.py 141 142 class DocstringReceive ( DocstringElement ): \"\"\"This class represents a documented receive value.\"\"\"","title":"DocstringReceive"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReturn","text":"This class represents a documented return value. Source code in griffe/docstrings/dataclasses.py 133 134 class DocstringReturn ( DocstringElement ): \"\"\"This class represents a documented return value.\"\"\"","title":"DocstringReturn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection","text":"Placeholder. Source code in griffe/docstrings/dataclasses.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class DocstringSection : \"\"\"Placeholder.\"\"\" def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base","title":"DocstringSection"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.__init__","text":"Initialize the section. Parameters: kind ( DocstringSectionKind ) \u2013 The section kind. value ( Any ) \u2013 The section value. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.as_dict","text":"Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind","text":"The possible section kinds. Source code in griffe/docstrings/dataclasses.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DocstringSectionKind ( enum . Enum ): \"\"\"The possible section kinds.\"\"\" text = \"text\" parameters = \"parameters\" other_parameters = \"other parameters\" raises = \"raises\" warns = \"warns\" returns = \"returns\" yields = \"yields\" receives = \"receives\" examples = \"examples\" attributes = \"attributes\" deprecated = \"deprecated\" admonition = \"admonition\"","title":"DocstringSectionKind"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringWarn","text":"This class represents a documented warn value. Source code in griffe/docstrings/dataclasses.py 149 150 class DocstringWarn ( DocstringElement ): \"\"\"This class represents a documented warn value.\"\"\"","title":"DocstringWarn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringYield","text":"This class represents a documented yield value. Source code in griffe/docstrings/dataclasses.py 137 138 class DocstringYield ( DocstringElement ): \"\"\"This class represents a documented yield value.\"\"\"","title":"DocstringYield"},{"location":"reference/griffe/docstrings/google/","text":"This module defines functions to parse Google-style docstrings into structured data. _RE_ADMONITION : Pattern = re . compile ( '^(?P<type>[ \\\\ w][ \\\\ s \\\\ w-]*):( \\\\ s+(?P<title>.+))?$' , re . I ) \u00a4 Regular expression to match admonitions, of the form TYPE: [TITLE] . parse ( docstring , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) elif match := _RE_ADMONITION . match ( lines [ offset ]): # noqa: WPS332 groups = match . groupdict () admonition_type = groups [ \"type\" ] . lower () if admonition_type in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type ]] section , offset = reader ( docstring , offset + 1 ) if section : section . title = groups [ \"title\" ] sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type , contents = contents ), title = groups [ \"title\" ], ) ) else : offset -= 1 current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"google"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._RE_ADMONITION","text":"Regular expression to match admonitions, of the form TYPE: [TITLE] .","title":"_RE_ADMONITION"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) elif match := _RE_ADMONITION . match ( lines [ offset ]): # noqa: WPS332 groups = match . groupdict () admonition_type = groups [ \"type\" ] . lower () if admonition_type in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type ]] section , offset = reader ( docstring , offset + 1 ) if section : section . title = groups [ \"title\" ] sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type , contents = contents ), title = groups [ \"title\" ], ) ) else : offset -= 1 current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/markdown/","text":"This module defines functions and classes to parse Markdown docstrings into structured data.","title":"markdown"},{"location":"reference/griffe/docstrings/numpy/","text":"This module defines functions to parse Numpy-style docstrings into structured data. Based on https://numpydoc.readthedocs.io/en/latest/format.html , it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification. Rejected as non particularly Pythonic or useful as sections: See also: this section feels too subjective (specially crafted as a standard for Numpy itself), and there are may ways to reference related items in a docstring, depending on the chosen markup. Methods: with a good documentation renderer, methods are easily made accessible or hidden. Griffe also has a goal of making the merging of inherited methods configurable (on/off). Rejected as naturally handled by the user-chosen markup: Warnings: this is just markup. Notes: again, just markup. References: again, just markup. The following sections are supported: Deprecated (revisited): we expect a title instead of an RST directive. Python has support for deprecating things, so it feels natural to structure deprecations. Parameters: obviously. Returns: obviously. Yields: obviously. Receives: less used than Yields, but very natural/Pythonic as well. Other parameters: used here as documentation for keyword parameters. Raises: obviously. Warns: less used than Raises, but very natural/Pythonic as well. Examples: obviously. Special handling for non-code-blocks >>> . Attributes: obviously. parse ( docstring , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"numpy"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/parsers/","text":"This module imports all the defined parsers. Parser ( enum . Enum ) \u00a4 Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 17 18 19 20 21 22 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\" parse ( docstring , parser , ** options ) \u00a4 Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parsers"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser","text":"Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 17 18 19 20 21 22 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\"","title":"Parser"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.parse","text":"Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/rst/","text":"This module defines functions to parse RST-style docstrings into structured data. Credits to Patrick Lannigan ( @plannigan ) who originally added the parser in the pytkdocs project . See https://github.com/mkdocstrings/pytkdocs/pull/71 . FieldType \u00a4 Maps directive names to parser functions. Source code in griffe/docstrings/rst.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @dataclass ( frozen = True ) class FieldType : \"\"\"Maps directive names to parser functions.\"\"\" names : FrozenSet [ str ] reader : Callable [[ list [ str ], int ], int ] def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names ) matches ( self , line ) \u00a4 Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/rst.py 45 46 47 48 49 50 51 52 53 54 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names ) ParsedDirective \u00a4 Directive information that has been parsed from a docstring. Source code in griffe/docstrings/rst.py 57 58 59 60 61 62 63 64 65 @dataclass class ParsedDirective : \"\"\"Directive information that has been parsed from a docstring.\"\"\" line : str next_index : int directive_parts : list [ str ] value : str invalid : bool = False ParsedValues \u00a4 Values parsed from the docstring to be used to produce sections. Source code in griffe/docstrings/rst.py 68 69 70 71 72 73 74 75 76 77 78 79 @dataclass class ParsedValues : \"\"\"Values parsed from the docstring to be used to produce sections.\"\"\" description : list [ str ] = field ( default_factory = list ) parameters : dict [ str , DocstringParameter ] = field ( default_factory = dict ) param_types : dict [ str , str ] = field ( default_factory = dict ) attributes : dict [ str , DocstringAttribute ] = field ( default_factory = dict ) attribute_types : dict [ str , str ] = field ( default_factory = dict ) exceptions : list [ DocstringException ] = field ( default_factory = list ) return_value : DocstringReturn | None = None return_type : str | None = None _consolidate_continuation_lines ( lines , offset ) \u00a4 Convert a docstring field into a single line if a line continuation exists. Parameters: lines ( list [ str ] ) \u2013 The docstring lines. offset ( int ) \u2013 The line number to start at. Returns: tuple [ str , int ] \u2013 A tuple containing the continued lines as a single string and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 def _consolidate_continuation_lines ( lines : list [ str ], offset : int ) -> tuple [ str , int ]: \"\"\" Convert a docstring field into a single line if a line continuation exists. Parameters: lines: The docstring lines. offset: The line number to start at. Returns: A tuple containing the continued lines as a single string and the index at which to continue parsing. \"\"\" curr_line_index = offset block = [ lines [ curr_line_index ] . lstrip ()] # start processing after first item curr_line_index += 1 while curr_line_index < len ( lines ) and not lines [ curr_line_index ] . startswith ( \":\" ): block . append ( lines [ curr_line_index ] . lstrip ()) curr_line_index += 1 return \" \" . join ( block ) . rstrip ( \" \\n \" ), curr_line_index - 1 _consolidate_descriptive_type ( descriptive_type ) \u00a4 Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type ( str ) \u2013 Descriptions of an item's type. Returns: str \u2013 Type signature for descriptive type. Source code in griffe/docstrings/rst.py 431 432 433 434 435 436 437 438 439 440 441 442 def _consolidate_descriptive_type ( descriptive_type : str ) -> str : \"\"\"Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type: Descriptions of an item's type. Returns: Type signature for descriptive type. \"\"\" return descriptive_type . replace ( \" or \" , \" | \" ) _read_attribute ( docstring , offset , parsed_values ) \u00a4 Parse an attribute value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def _read_attribute ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an attribute value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index annotation = None # Annotation precedence: # - \"vartype\" directive type # - none parsed_attribute_type = parsed_values . attribute_types . get ( name ) if parsed_attribute_type is not None : annotation = parsed_attribute_type if name in parsed_values . attributes : _warn ( docstring , 0 , f \"Duplicate attribute entry for ' { name } '\" ) else : parsed_values . attributes [ name ] = DocstringAttribute ( name = name , annotation = annotation , description = parsed_directive . value , ) return parsed_directive . next_index _read_attribute_type ( docstring , offset , parsed_values ) \u00a4 Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def _read_attribute_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index attribute_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : attribute_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get attribute name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . attribute_types [ attribute_name ] = attribute_type attribute = parsed_values . attributes . get ( attribute_name ) if attribute is not None : if attribute . annotation is None : attribute . annotation = attribute_type else : _warn ( docstring , 0 , f \"Duplicate attribute information for ' { attribute_name } '\" ) return parsed_directive . next_index _read_exception ( docstring , offset , parsed_values ) \u00a4 Parse an exceptions value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 A tuple containing a DocstringSection (or None ) and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def _read_exception ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an exceptions value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: A tuple containing a `DocstringSection` (or `None`) and the index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : ex_type = parsed_directive . directive_parts [ 1 ] parsed_values . exceptions . append ( DocstringException ( annotation = ex_type , description = parsed_directive . value )) else : _warn ( docstring , 0 , f \"Failed to parse exception directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index _read_parameter ( docstring , offset , parsed_values ) \u00a4 Parse a parameter value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def _read_parameter ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index directive_type = None if len ( parsed_directive . directive_parts ) == 2 : # no type info name = parsed_directive . directive_parts [ 1 ] elif len ( parsed_directive . directive_parts ) == 3 : directive_type = parsed_directive . directive_parts [ 1 ] name = parsed_directive . directive_parts [ 2 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index if name in parsed_values . parameters : _warn ( docstring , 0 , f \"Duplicate parameter entry for ' { name } '\" ) return parsed_directive . next_index annotation = _determine_param_annotation ( docstring , name , directive_type , parsed_values ) default = _determine_param_default ( docstring , name ) parsed_values . parameters [ name ] = DocstringParameter ( name = name , annotation = annotation , description = parsed_directive . value , value = default , ) return parsed_directive . next_index _read_parameter_type ( docstring , offset , parsed_values ) \u00a4 Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def _read_parameter_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index param_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : param_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get parameter name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . param_types [ param_name ] = param_type param = parsed_values . parameters . get ( param_name ) if param is not None : if param . annotation is None : param . annotation = param_type else : _warn ( docstring , 0 , f \"Duplicate parameter information for ' { param_name } '\" ) return parsed_directive . next_index _read_return ( docstring , offset , parsed_values ) \u00a4 Parse an return value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def _read_return ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index # Annotation precedence: # - \"rtype\" directive type # - signature annotation # - None annotation : str | None if parsed_values . return_type is not None : annotation = parsed_values . return_type else : try : annotation = docstring . parent . returns # type: ignore except AttributeError : _warn ( docstring , 0 , f \"No return type or annotation at ' { parsed_directive . line } '\" ) annotation = None parsed_values . return_value = DocstringReturn ( annotation = annotation , description = parsed_directive . value ) return parsed_directive . next_index _read_return_type ( docstring , offset , parsed_values ) \u00a4 Parse an return type value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def _read_return_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return type value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index return_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) parsed_values . return_type = return_type return_value = parsed_values . return_value if return_value is not None : return_value . annotation = return_type return parsed_directive . next_index _strip_blank_lines ( lines ) \u00a4 Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines ( list [ str ] ) \u2013 Lines to be stripped. Returns: list [ str ] \u2013 A list with the same contents, with any blank lines at the start or end removed. Source code in griffe/docstrings/rst.py 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 def _strip_blank_lines ( lines : list [ str ]) -> list [ str ]: \"\"\"Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines: Lines to be stripped. Returns: A list with the same contents, with any blank lines at the start or end removed. \"\"\" if not lines : return lines # remove blank lines from the start and end content_found = False initial_content = 0 final_content = 0 for index , line in enumerate ( lines ): if line == \"\" or line . isspace (): if not content_found : initial_content += 1 else : content_found = True final_content = index return lines [ initial_content : final_content + 1 ] parse ( docstring , ** options ) \u00a4 Parse an RST-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/rst.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse an RST-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"rst"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.FieldType","text":"Maps directive names to parser functions. Source code in griffe/docstrings/rst.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @dataclass ( frozen = True ) class FieldType : \"\"\"Maps directive names to parser functions.\"\"\" names : FrozenSet [ str ] reader : Callable [[ list [ str ], int ], int ] def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names )","title":"FieldType"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.FieldType.matches","text":"Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/rst.py 45 46 47 48 49 50 51 52 53 54 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names )","title":"matches()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedDirective","text":"Directive information that has been parsed from a docstring. Source code in griffe/docstrings/rst.py 57 58 59 60 61 62 63 64 65 @dataclass class ParsedDirective : \"\"\"Directive information that has been parsed from a docstring.\"\"\" line : str next_index : int directive_parts : list [ str ] value : str invalid : bool = False","title":"ParsedDirective"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues","text":"Values parsed from the docstring to be used to produce sections. Source code in griffe/docstrings/rst.py 68 69 70 71 72 73 74 75 76 77 78 79 @dataclass class ParsedValues : \"\"\"Values parsed from the docstring to be used to produce sections.\"\"\" description : list [ str ] = field ( default_factory = list ) parameters : dict [ str , DocstringParameter ] = field ( default_factory = dict ) param_types : dict [ str , str ] = field ( default_factory = dict ) attributes : dict [ str , DocstringAttribute ] = field ( default_factory = dict ) attribute_types : dict [ str , str ] = field ( default_factory = dict ) exceptions : list [ DocstringException ] = field ( default_factory = list ) return_value : DocstringReturn | None = None return_type : str | None = None","title":"ParsedValues"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._consolidate_continuation_lines","text":"Convert a docstring field into a single line if a line continuation exists. Parameters: lines ( list [ str ] ) \u2013 The docstring lines. offset ( int ) \u2013 The line number to start at. Returns: tuple [ str , int ] \u2013 A tuple containing the continued lines as a single string and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 def _consolidate_continuation_lines ( lines : list [ str ], offset : int ) -> tuple [ str , int ]: \"\"\" Convert a docstring field into a single line if a line continuation exists. Parameters: lines: The docstring lines. offset: The line number to start at. Returns: A tuple containing the continued lines as a single string and the index at which to continue parsing. \"\"\" curr_line_index = offset block = [ lines [ curr_line_index ] . lstrip ()] # start processing after first item curr_line_index += 1 while curr_line_index < len ( lines ) and not lines [ curr_line_index ] . startswith ( \":\" ): block . append ( lines [ curr_line_index ] . lstrip ()) curr_line_index += 1 return \" \" . join ( block ) . rstrip ( \" \\n \" ), curr_line_index - 1","title":"_consolidate_continuation_lines()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._consolidate_descriptive_type","text":"Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type ( str ) \u2013 Descriptions of an item's type. Returns: str \u2013 Type signature for descriptive type. Source code in griffe/docstrings/rst.py 431 432 433 434 435 436 437 438 439 440 441 442 def _consolidate_descriptive_type ( descriptive_type : str ) -> str : \"\"\"Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type: Descriptions of an item's type. Returns: Type signature for descriptive type. \"\"\" return descriptive_type . replace ( \" or \" , \" | \" )","title":"_consolidate_descriptive_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_attribute","text":"Parse an attribute value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def _read_attribute ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an attribute value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index annotation = None # Annotation precedence: # - \"vartype\" directive type # - none parsed_attribute_type = parsed_values . attribute_types . get ( name ) if parsed_attribute_type is not None : annotation = parsed_attribute_type if name in parsed_values . attributes : _warn ( docstring , 0 , f \"Duplicate attribute entry for ' { name } '\" ) else : parsed_values . attributes [ name ] = DocstringAttribute ( name = name , annotation = annotation , description = parsed_directive . value , ) return parsed_directive . next_index","title":"_read_attribute()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_attribute_type","text":"Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def _read_attribute_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index attribute_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : attribute_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get attribute name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . attribute_types [ attribute_name ] = attribute_type attribute = parsed_values . attributes . get ( attribute_name ) if attribute is not None : if attribute . annotation is None : attribute . annotation = attribute_type else : _warn ( docstring , 0 , f \"Duplicate attribute information for ' { attribute_name } '\" ) return parsed_directive . next_index","title":"_read_attribute_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_exception","text":"Parse an exceptions value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 A tuple containing a DocstringSection (or None ) and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def _read_exception ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an exceptions value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: A tuple containing a `DocstringSection` (or `None`) and the index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : ex_type = parsed_directive . directive_parts [ 1 ] parsed_values . exceptions . append ( DocstringException ( annotation = ex_type , description = parsed_directive . value )) else : _warn ( docstring , 0 , f \"Failed to parse exception directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index","title":"_read_exception()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_parameter","text":"Parse a parameter value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def _read_parameter ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index directive_type = None if len ( parsed_directive . directive_parts ) == 2 : # no type info name = parsed_directive . directive_parts [ 1 ] elif len ( parsed_directive . directive_parts ) == 3 : directive_type = parsed_directive . directive_parts [ 1 ] name = parsed_directive . directive_parts [ 2 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index if name in parsed_values . parameters : _warn ( docstring , 0 , f \"Duplicate parameter entry for ' { name } '\" ) return parsed_directive . next_index annotation = _determine_param_annotation ( docstring , name , directive_type , parsed_values ) default = _determine_param_default ( docstring , name ) parsed_values . parameters [ name ] = DocstringParameter ( name = name , annotation = annotation , description = parsed_directive . value , value = default , ) return parsed_directive . next_index","title":"_read_parameter()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_parameter_type","text":"Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def _read_parameter_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index param_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : param_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get parameter name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . param_types [ param_name ] = param_type param = parsed_values . parameters . get ( param_name ) if param is not None : if param . annotation is None : param . annotation = param_type else : _warn ( docstring , 0 , f \"Duplicate parameter information for ' { param_name } '\" ) return parsed_directive . next_index","title":"_read_parameter_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_return","text":"Parse an return value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def _read_return ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index # Annotation precedence: # - \"rtype\" directive type # - signature annotation # - None annotation : str | None if parsed_values . return_type is not None : annotation = parsed_values . return_type else : try : annotation = docstring . parent . returns # type: ignore except AttributeError : _warn ( docstring , 0 , f \"No return type or annotation at ' { parsed_directive . line } '\" ) annotation = None parsed_values . return_value = DocstringReturn ( annotation = annotation , description = parsed_directive . value ) return parsed_directive . next_index","title":"_read_return()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_return_type","text":"Parse an return type value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def _read_return_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return type value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index return_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) parsed_values . return_type = return_type return_value = parsed_values . return_value if return_value is not None : return_value . annotation = return_type return parsed_directive . next_index","title":"_read_return_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._strip_blank_lines","text":"Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines ( list [ str ] ) \u2013 Lines to be stripped. Returns: list [ str ] \u2013 A list with the same contents, with any blank lines at the start or end removed. Source code in griffe/docstrings/rst.py 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 def _strip_blank_lines ( lines : list [ str ]) -> list [ str ]: \"\"\"Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines: Lines to be stripped. Returns: A list with the same contents, with any blank lines at the start or end removed. \"\"\" if not lines : return lines # remove blank lines from the start and end content_found = False initial_content = 0 final_content = 0 for index , line in enumerate ( lines ): if line == \"\" or line . isspace (): if not content_found : initial_content += 1 else : content_found = True final_content = index return lines [ initial_content : final_content + 1 ]","title":"_strip_blank_lines()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.parse","text":"Parse an RST-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/rst.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse an RST-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"parse()"},{"location":"reference/griffe/docstrings/utils/","text":"This module contains utilities for docstrings parsers. warning ( name ) \u00a4 Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { docstring . lineno + offset } : { message } \" ) # type: ignore return warn","title":"utils"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.warning","text":"Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { docstring . lineno + offset } : { message } \" ) # type: ignore return warn","title":"warning()"},{"location":"reference/griffe/extensions/","text":"This module is the public interface to import elements from the base. Extension ( _BaseVisitor ) \u00a4 The node visitor extension base class, to inherit from. Source code in griffe/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 class Extension ( _BaseVisitor ): \"\"\"The node visitor extension base class, to inherit from.\"\"\" when : When def __init__ ( self , main_visitor : MainVisitor ) -> None : \"\"\"Initialize the visitor extension. Parameters: main_visitor: The main visitor. \"\"\" super () . __init__ () self . visitor = main_visitor __init__ ( self , main_visitor ) \u00a4 Initialize the visitor extension. Parameters: main_visitor ( MainVisitor ) \u2013 The main visitor. Source code in griffe/extensions/base.py 61 62 63 64 65 66 67 68 def __init__ ( self , main_visitor : MainVisitor ) -> None : \"\"\"Initialize the visitor extension. Parameters: main_visitor: The main visitor. \"\"\" super () . __init__ () self . visitor = main_visitor Extensions \u00a4 This class helps iterating on extensions that should run at different times. Source code in griffe/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class Extensions : \"\"\"This class helps iterating on extensions that should run at different times.\"\"\" def __init__ ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions_classes: The extensions to add. \"\"\" self . _classes : list [ Type [ Extension ]] = list ( extensions_classes ) self . _instances : dict [ When , list [ Extension ]] = {} @property def when_visit_starts ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the visit starts. Returns: Visitors. \"\"\" return self . _instances [ When . visit_starts ] @property def when_children_visit_starts ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the children visit starts. Returns: Visitors. \"\"\" return self . _instances [ When . children_visit_starts ] @property def when_children_visit_stops ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the children visit stops. Returns: Visitors. \"\"\" return self . _instances [ When . children_visit_stops ] @property def when_visit_stops ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the visit stops. Returns: Visitors. \"\"\" return self . _instances [ When . visit_stops ] def when ( self , when : When ) -> list [ Extension ]: \"\"\"Return the visitors that run at the given time. Parameters: when: The selected time. Returns: Visitors. \"\"\" return self . _instances [ when ] def add ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Add visitor extensions to this container. Parameters: *extensions_classes: The extensions to add. \"\"\" self . _classes . extend ( extensions_classes ) def instantiate ( self , main_visitor : MainVisitor ) -> Extensions : \"\"\"Clear and instantiate the visitor classes. Parameters: main_visitor: The main visitor, leading the visit. Returns: Self, conveniently. \"\"\" # clear instances for when in When : self . _instances [ when ] = [] # create instances for visitor_class in self . _classes : self . _instances [ visitor_class . when ] . append ( visitor_class ( main_visitor )) return self __init__ ( self , * extensions_classes ) \u00a4 Initialize the extensions container. Parameters: *extensions_classes ( Type [ Extension ] ) \u2013 The extensions to add. Source code in griffe/extensions/base.py 74 75 76 77 78 79 80 81 def __init__ ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions_classes: The extensions to add. \"\"\" self . _classes : list [ Type [ Extension ]] = list ( extensions_classes ) self . _instances : dict [ When , list [ Extension ]] = {} add ( self , * extensions_classes ) \u00a4 Add visitor extensions to this container. Parameters: *extensions_classes ( Type [ Extension ] ) \u2013 The extensions to add. Source code in griffe/extensions/base.py 130 131 132 133 134 135 136 def add ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Add visitor extensions to this container. Parameters: *extensions_classes: The extensions to add. \"\"\" self . _classes . extend ( extensions_classes ) instantiate ( self , main_visitor ) \u00a4 Clear and instantiate the visitor classes. Parameters: main_visitor ( MainVisitor ) \u2013 The main visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/extensions/base.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def instantiate ( self , main_visitor : MainVisitor ) -> Extensions : \"\"\"Clear and instantiate the visitor classes. Parameters: main_visitor: The main visitor, leading the visit. Returns: Self, conveniently. \"\"\" # clear instances for when in When : self . _instances [ when ] = [] # create instances for visitor_class in self . _classes : self . _instances [ visitor_class . when ] . append ( visitor_class ( main_visitor )) return self when ( self , when ) \u00a4 Return the visitors that run at the given time. Parameters: when ( When ) \u2013 The selected time. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 119 120 121 122 123 124 125 126 127 128 def when ( self , when : When ) -> list [ Extension ]: \"\"\"Return the visitors that run at the given time. Parameters: when: The selected time. Returns: Visitors. \"\"\" return self . _instances [ when ] when_children_visit_starts ( self ) \u00a4 Return the visitors that run when the children visit starts. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 92 93 94 95 96 97 98 99 @property def when_children_visit_starts ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the children visit starts. Returns: Visitors. \"\"\" return self . _instances [ When . children_visit_starts ] when_children_visit_stops ( self ) \u00a4 Return the visitors that run when the children visit stops. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 101 102 103 104 105 106 107 108 @property def when_children_visit_stops ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the children visit stops. Returns: Visitors. \"\"\" return self . _instances [ When . children_visit_stops ] when_visit_starts ( self ) \u00a4 Return the visitors that run when the visit starts. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 83 84 85 86 87 88 89 90 @property def when_visit_starts ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the visit starts. Returns: Visitors. \"\"\" return self . _instances [ When . visit_starts ] when_visit_stops ( self ) \u00a4 Return the visitors that run when the visit stops. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 110 111 112 113 114 115 116 117 @property def when_visit_stops ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the visit stops. Returns: Visitors. \"\"\" return self . _instances [ When . visit_stops ] When ( enum . Enum ) \u00a4 This enumeration contains the different times at which an extension is used. Attributes: visit_starts ( int ) \u2013 For each node, before starting the visit. children_visit_starts ( int ) \u2013 For each node, after the visit has started, and before starting to visit children. children_visit_stops ( int ) \u2013 For each node, after the children have been visited, and before finishing the visit. visit_stops ( int ) \u2013 For each node, after finishing the visit. Source code in griffe/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class When ( enum . Enum ): \"\"\"This enumeration contains the different times at which an extension is used. Attributes: visit_starts: For each node, before starting the visit. children_visit_starts: For each node, after the visit has started, and before starting to visit children. children_visit_stops: For each node, after the children have been visited, and before finishing the visit. visit_stops: For each node, after finishing the visit. \"\"\" visit_starts : int = 1 children_visit_starts : int = 2 children_visit_stops : int = 3 visit_stops : int = 4 load_extensions ( exts ) \u00a4 Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension_item in exts : if issubclass ( extension_item , Extension ): # type: ignore extensions . add ( extension_item ) # type: ignore continue if isinstance ( extension_item , str ): if extension_item in builtin_extensions : ext_module = builtin_extensions [ extension_item ] else : ext_module = __import__ ( extension_item ) options = {} elif isinstance ( extension_item , dict ): import_path = next ( extension_item . keys ()) # type: ignore if import_path in builtin_extensions : ext_module = builtin_extensions [ import_path ] else : ext_module = __import__ ( import_path ) options = next ( extension_item . values ()) # type: ignore # TODO: handle AttributeError extension = ext_module . get_extension ( ** options ) # type: ignore extensions . add ( extension ) return extensions","title":"extensions"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension","text":"The node visitor extension base class, to inherit from. Source code in griffe/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 class Extension ( _BaseVisitor ): \"\"\"The node visitor extension base class, to inherit from.\"\"\" when : When def __init__ ( self , main_visitor : MainVisitor ) -> None : \"\"\"Initialize the visitor extension. Parameters: main_visitor: The main visitor. \"\"\" super () . __init__ () self . visitor = main_visitor","title":"Extension"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extension.__init__","text":"Initialize the visitor extension. Parameters: main_visitor ( MainVisitor ) \u2013 The main visitor. Source code in griffe/extensions/base.py 61 62 63 64 65 66 67 68 def __init__ ( self , main_visitor : MainVisitor ) -> None : \"\"\"Initialize the visitor extension. Parameters: main_visitor: The main visitor. \"\"\" super () . __init__ () self . visitor = main_visitor","title":"__init__()"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions","text":"This class helps iterating on extensions that should run at different times. Source code in griffe/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class Extensions : \"\"\"This class helps iterating on extensions that should run at different times.\"\"\" def __init__ ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions_classes: The extensions to add. \"\"\" self . _classes : list [ Type [ Extension ]] = list ( extensions_classes ) self . _instances : dict [ When , list [ Extension ]] = {} @property def when_visit_starts ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the visit starts. Returns: Visitors. \"\"\" return self . _instances [ When . visit_starts ] @property def when_children_visit_starts ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the children visit starts. Returns: Visitors. \"\"\" return self . _instances [ When . children_visit_starts ] @property def when_children_visit_stops ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the children visit stops. Returns: Visitors. \"\"\" return self . _instances [ When . children_visit_stops ] @property def when_visit_stops ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the visit stops. Returns: Visitors. \"\"\" return self . _instances [ When . visit_stops ] def when ( self , when : When ) -> list [ Extension ]: \"\"\"Return the visitors that run at the given time. Parameters: when: The selected time. Returns: Visitors. \"\"\" return self . _instances [ when ] def add ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Add visitor extensions to this container. Parameters: *extensions_classes: The extensions to add. \"\"\" self . _classes . extend ( extensions_classes ) def instantiate ( self , main_visitor : MainVisitor ) -> Extensions : \"\"\"Clear and instantiate the visitor classes. Parameters: main_visitor: The main visitor, leading the visit. Returns: Self, conveniently. \"\"\" # clear instances for when in When : self . _instances [ when ] = [] # create instances for visitor_class in self . _classes : self . _instances [ visitor_class . when ] . append ( visitor_class ( main_visitor )) return self","title":"Extensions"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.__init__","text":"Initialize the extensions container. Parameters: *extensions_classes ( Type [ Extension ] ) \u2013 The extensions to add. Source code in griffe/extensions/base.py 74 75 76 77 78 79 80 81 def __init__ ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions_classes: The extensions to add. \"\"\" self . _classes : list [ Type [ Extension ]] = list ( extensions_classes ) self . _instances : dict [ When , list [ Extension ]] = {}","title":"__init__()"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.add","text":"Add visitor extensions to this container. Parameters: *extensions_classes ( Type [ Extension ] ) \u2013 The extensions to add. Source code in griffe/extensions/base.py 130 131 132 133 134 135 136 def add ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Add visitor extensions to this container. Parameters: *extensions_classes: The extensions to add. \"\"\" self . _classes . extend ( extensions_classes )","title":"add()"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.instantiate","text":"Clear and instantiate the visitor classes. Parameters: main_visitor ( MainVisitor ) \u2013 The main visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/extensions/base.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def instantiate ( self , main_visitor : MainVisitor ) -> Extensions : \"\"\"Clear and instantiate the visitor classes. Parameters: main_visitor: The main visitor, leading the visit. Returns: Self, conveniently. \"\"\" # clear instances for when in When : self . _instances [ when ] = [] # create instances for visitor_class in self . _classes : self . _instances [ visitor_class . when ] . append ( visitor_class ( main_visitor )) return self","title":"instantiate()"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.when","text":"Return the visitors that run at the given time. Parameters: when ( When ) \u2013 The selected time. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 119 120 121 122 123 124 125 126 127 128 def when ( self , when : When ) -> list [ Extension ]: \"\"\"Return the visitors that run at the given time. Parameters: when: The selected time. Returns: Visitors. \"\"\" return self . _instances [ when ]","title":"when()"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.when_children_visit_starts","text":"Return the visitors that run when the children visit starts. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 92 93 94 95 96 97 98 99 @property def when_children_visit_starts ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the children visit starts. Returns: Visitors. \"\"\" return self . _instances [ When . children_visit_starts ]","title":"when_children_visit_starts()"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.when_children_visit_stops","text":"Return the visitors that run when the children visit stops. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 101 102 103 104 105 106 107 108 @property def when_children_visit_stops ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the children visit stops. Returns: Visitors. \"\"\" return self . _instances [ When . children_visit_stops ]","title":"when_children_visit_stops()"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.when_visit_starts","text":"Return the visitors that run when the visit starts. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 83 84 85 86 87 88 89 90 @property def when_visit_starts ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the visit starts. Returns: Visitors. \"\"\" return self . _instances [ When . visit_starts ]","title":"when_visit_starts()"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.when_visit_stops","text":"Return the visitors that run when the visit stops. Returns: list [ Extension ] \u2013 Visitors. Source code in griffe/extensions/base.py 110 111 112 113 114 115 116 117 @property def when_visit_stops ( self ) -> list [ Extension ]: \"\"\"Return the visitors that run when the visit stops. Returns: Visitors. \"\"\" return self . _instances [ When . visit_stops ]","title":"when_visit_stops()"},{"location":"reference/griffe/extensions/#griffe.extensions.When","text":"This enumeration contains the different times at which an extension is used. Attributes: visit_starts ( int ) \u2013 For each node, before starting the visit. children_visit_starts ( int ) \u2013 For each node, after the visit has started, and before starting to visit children. children_visit_stops ( int ) \u2013 For each node, after the children have been visited, and before finishing the visit. visit_stops ( int ) \u2013 For each node, after finishing the visit. Source code in griffe/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class When ( enum . Enum ): \"\"\"This enumeration contains the different times at which an extension is used. Attributes: visit_starts: For each node, before starting the visit. children_visit_starts: For each node, after the visit has started, and before starting to visit children. children_visit_stops: For each node, after the children have been visited, and before finishing the visit. visit_stops: For each node, after finishing the visit. \"\"\" visit_starts : int = 1 children_visit_starts : int = 2 children_visit_stops : int = 3 visit_stops : int = 4","title":"When"},{"location":"reference/griffe/extensions/#griffe.extensions.load_extensions","text":"Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension_item in exts : if issubclass ( extension_item , Extension ): # type: ignore extensions . add ( extension_item ) # type: ignore continue if isinstance ( extension_item , str ): if extension_item in builtin_extensions : ext_module = builtin_extensions [ extension_item ] else : ext_module = __import__ ( extension_item ) options = {} elif isinstance ( extension_item , dict ): import_path = next ( extension_item . keys ()) # type: ignore if import_path in builtin_extensions : ext_module = builtin_extensions [ import_path ] else : ext_module = __import__ ( import_path ) options = next ( extension_item . values ()) # type: ignore # TODO: handle AttributeError extension = ext_module . get_extension ( ** options ) # type: ignore extensions . add ( extension ) return extensions","title":"load_extensions()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}