{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"griffe \u00a4 Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Griffe, pronounced \"grif\" ( /\u0261\u0281if/ ), is a french word that means \"claw\", but also \"signature\" in a familiar way. \"On reconna\u00eet bien l\u00e0 sa griffe.\" Requirements \u00a4 griffe requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7.12 # make it available globally pyenv global system 3 .7.12 Installation \u00a4 With pip : pip install griffe With pipx : python3.7 -m pip install --user pipx pipx install griffe Usage \u00a4 On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples. Todo \u00a4 Visitor/Inspector: Labels Attribute: ? Function: ? Class: ? Module: ? Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring (could be an extension) Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Extensions Post-processing extensions Third-party libraries we could provide support for: Django support Marshmallow support Pydantic support Docstrings parsers epydoc New Markdown-based format? For graceful degradation Serializer: Flat JSON JSON schema API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Overview"},{"location":"#griffe","text":"Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Griffe, pronounced \"grif\" ( /\u0261\u0281if/ ), is a french word that means \"claw\", but also \"signature\" in a familiar way. \"On reconna\u00eet bien l\u00e0 sa griffe.\"","title":"griffe"},{"location":"#requirements","text":"griffe requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7.12 # make it available globally pyenv global system 3 .7.12","title":"Requirements"},{"location":"#installation","text":"With pip : pip install griffe With pipx : python3.7 -m pip install --user pipx pipx install griffe","title":"Installation"},{"location":"#usage","text":"On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples.","title":"Usage"},{"location":"#todo","text":"Visitor/Inspector: Labels Attribute: ? Function: ? Class: ? Module: ? Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring (could be an extension) Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Extensions Post-processing extensions Third-party libraries we could provide support for: Django support Marshmallow support Pydantic support Docstrings parsers epydoc New Markdown-based format? For graceful degradation Serializer: Flat JSON JSON schema API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Todo"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.12.4 - 2022-02-16 \u00a4 Compare with 0.12.3 Bug Fixes \u00a4 Update target path when changing alias target ( 5eda646 by Timoth\u00e9e Mazzucotelli). Fix relative imports to absolute with wildcards ( 69500dd by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 Fix accessing members using tuples ( 87ff1df by Timoth\u00e9e Mazzucotelli). Fix recursive wildcard expansion ( 60e6edf by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 Only export submodules if they were imported ( 98c72db by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 0.12.3 - 2022-02-15 \u00a4 Compare with 0.12.2 Bug Fixes \u00a4 Always decode source as UTF8 ( 563469b by Timoth\u00e9e Mazzucotelli). Fix JSON encoder and decoder ( 3e768d6 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Improve error handling ( 7b15a51 by Timoth\u00e9e Mazzucotelli). 0.12.2 - 2022-02-13 \u00a4 Compare with 0.12.1 Bug Fixes \u00a4 Fix JSON unable to serialize docstring kind values ( 91e6719 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Make attribute labels more explicit ( 19eac2e by Timoth\u00e9e Mazzucotelli). 0.12.1 - 2022-02-12 \u00a4 Compare with 0.11.7 Features \u00a4 Add ignore_init_summary option to the Google parser ( 81f0333 by Timoth\u00e9e Mazzucotelli). Add is_KIND properties on objects ( 17a08cd by Timoth\u00e9e Mazzucotelli). 0.11.7 - 2022-02-12 \u00a4 Compare with 0.11.6 Bug Fixes \u00a4 Keep only first assignment in conditions ( 0104440 by Timoth\u00e9e Mazzucotelli). Support invert unary op in annotations ( 734ef55 by Timoth\u00e9e Mazzucotelli). Fix handling of missing modules during dynamic imports ( 7a3b383 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#380 Fix getting lines of compiled modules ( 899461b by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Get annotation with the same property on functions ( ecc7bba by Timoth\u00e9e Mazzucotelli). 0.11.6 - 2022-02-10 \u00a4 Compare with 0.11.5 Bug Fixes \u00a4 Fix infinite loop in Google parser ( 8b7b97b by Timoth\u00e9e Mazzucotelli). Issue #38 0.11.5 - 2022-02-08 \u00a4 Compare with 0.11.4 Bug Fixes \u00a4 Fix building title and kind of Google admonitions ( 87ab56c by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings#379 0.11.4 - 2022-02-07 \u00a4 Compare with 0.11.3 Bug Fixes \u00a4 Don't trigger alias resolution while checking docstrings presence ( dda72ea by Timoth\u00e9e Mazzucotelli). Issue #37 0.11.3 - 2022-02-05 \u00a4 Compare with 0.11.2 Bug Fixes \u00a4 Fix getting params defaults on Python 3.7 ( 0afd867 by Timoth\u00e9e Mazzucotelli). 0.11.2 - 2022-02-03 \u00a4 Compare with 0.11.1 Code Refactoring \u00a4 Factorize docstring annotation parser ( 19609be by Timoth\u00e9e Mazzucotelli). 0.11.1 - 2022-02-01 \u00a4 Compare with 0.11.0 Code Refactoring \u00a4 Rename RST parser to Sphinx ( a612cb1 by Timoth\u00e9e Mazzucotelli). 0.11.0 - 2022-01-31 \u00a4 Compare with 0.10.0 Features \u00a4 Support matrix multiplication operator in visitor ( 6129e17 by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Fix name resolution for inspected data ( ed3e7e5 by Timoth\u00e9e Mazzucotelli). Make importer actually able to import any nested object ( d007219 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Always use search paths to import modules ( a9a378f by Timoth\u00e9e Mazzucotelli). Split out module finder ( 7290642 by Timoth\u00e9e Mazzucotelli). 0.10.0 - 2022-01-14 \u00a4 Compare with 0.9.0 Bug Fixes \u00a4 Fix infinite recursion errors in alias resolver ( 133b4e4 by Timoth\u00e9e Mazzucotelli). Fix inspection of nodes children (aliases or not) ( bb354f2 by Timoth\u00e9e Mazzucotelli). Fix relative to absolute import conversion ( 464c39e by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Rename some CLI options ( 1323268 by Timoth\u00e9e Mazzucotelli). Return the loader the to main function ( 9c6317e by Timoth\u00e9e Mazzucotelli). Improve logging messages ( b8eb16e by Timoth\u00e9e Mazzucotelli). Skip inspection of some debug packages ( 4ee8968 by Timoth\u00e9e Mazzucotelli). Return ... instead of Ellipsis ( f9ae31d by Timoth\u00e9e Mazzucotelli). Catch attribute errors when cross-referencing docstring annotations ( 288803a by Timoth\u00e9e Mazzucotelli). Support dict methods in lines collection ( 1b0cb94 by Timoth\u00e9e Mazzucotelli). Features \u00a4 Compute and show some stats ( 1b8d0a1 by Timoth\u00e9e Mazzucotelli). Add CLI options for alias resolution ( 87a59cb by Timoth\u00e9e Mazzucotelli). Support Google raises annotations cross-refs ( 8006ae1 by Timoth\u00e9e Mazzucotelli). 0.9.0 - 2022-01-04 \u00a4 Compare with 0.8.0 Features \u00a4 Loader option to only follow aliases in known modules ( 879d91b by Timoth\u00e9e Mazzucotelli). Use aliases when inspecting too ( 60439ee by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Handle more errors when loading modules ( 1aa571a by Timoth\u00e9e Mazzucotelli). Handle more errors when getting signature ( 2db85e7 by Timoth\u00e9e Mazzucotelli). Fix checking parent truthfulness ( 6129e50 by Timoth\u00e9e Mazzucotelli). Fix getting subscript value ( 1699f12 by Timoth\u00e9e Mazzucotelli). Support yield nodes ( 7d536d5 by Timoth\u00e9e Mazzucotelli). Exclude some special low-level members that cause cyclic issues ( b54ab34 by Timoth\u00e9e Mazzucotelli). Fix transforming elements of signatures to annotations ( e278c11 by Timoth\u00e9e Mazzucotelli). Detect cyclic aliases and prevent resolution errors ( de5dd12 by Timoth\u00e9e Mazzucotelli). Don't crash while trying to get the representation of an attribute value ( 77ac55d by Timoth\u00e9e Mazzucotelli). Fix building value for joined strings ( 6154b69 by Timoth\u00e9e Mazzucotelli). Fix prevention of cycles while building objects nodes ( 48062ac by Timoth\u00e9e Mazzucotelli). Better handle relative imports ( 91b42de by Timoth\u00e9e Mazzucotelli). Fix Google parser missing lines ending with colon ( 2f7969c by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Improve alias resolution robustness ( e708139 by Timoth\u00e9e Mazzucotelli). Remove async loader for now ( acc5ecf by Timoth\u00e9e Mazzucotelli). Improve handling of Google admonitions ( 8aa5ed0 by Timoth\u00e9e Mazzucotelli). Better handling of import errors and system exits while inspecting modules ( 7ba1589 by Timoth\u00e9e Mazzucotelli). Empty generic visit/inspect methods in base classes ( 338760e by Timoth\u00e9e Mazzucotelli). 0.8.0 - 2022-01-02 \u00a4 Compare with 0.7.1 Features \u00a4 Support getting attribute annotation from parent in RST docstring parser ( 25db61a by Timoth\u00e9e Mazzucotelli). Handle relative imports ( 62b0927 by Timoth\u00e9e Mazzucotelli). Support wildcard imports ( 77a3cb7 by Timoth\u00e9e Mazzucotelli). Support configuring log level (CLI/env var) ( 839d78e by Timoth\u00e9e Mazzucotelli). Support loading *.py[cod] and *.so modules ( cd98a6f by Timoth\u00e9e Mazzucotelli). Support inspecting builtin functions/methods ( aa1fce3 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Handle extensions errors ( 11278ca by Timoth\u00e9e Mazzucotelli). Don't always try to find a module as a relative path ( e6df277 by Timoth\u00e9e Mazzucotelli). Improve loggers patching ( f4b262a by Timoth\u00e9e Mazzucotelli). Improve dynamic imports ( 2998195 by Timoth\u00e9e Mazzucotelli). 0.7.1 - 2021-12-28 \u00a4 Compare with 0.7.0 Code Refactoring \u00a4 Only log warning if async mode is used ( 356e848 by Timoth\u00e9e Mazzucotelli). 0.7.0 - 2021-12-28 \u00a4 Compare with 0.6.0 Features \u00a4 Support more nodes on Python 3.7 ( 7f2c4ec by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Don't crash on syntax errors and log an error ( 10bb6b1 by Timoth\u00e9e Mazzucotelli). 0.6.0 - 2021-12-27 \u00a4 Compare with 0.5.0 Features \u00a4 Support more AST nodes ( cd1b305 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Use annotation getter for base classes ( 8b1a7ed by Timoth\u00e9e Mazzucotelli). 0.5.0 - 2021-12-20 \u00a4 Compare with 0.4.0 Features \u00a4 Add support for Python 3.7 ( 4535adc by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Don't propagate aliases of an alias ( 8af48f8 by Timoth\u00e9e Mazzucotelli). Don't reassign members defined in except clauses ( d918b4e by Timoth\u00e9e Mazzucotelli). 0.4.0 - 2021-11-28 \u00a4 Compare with 0.3.0 Features \u00a4 Add a prototype 'hybrid' extension ( 8cb3c16 by Timoth\u00e9e Mazzucotelli). Allow passing extensions config as JSON on the CLI ( 9a7fa8b by Timoth\u00e9e Mazzucotelli). Support names for returns, yields and receives sections items ( 1c5a4c9 by Timoth\u00e9e Mazzucotelli). Store aliases on each object ( 91ba643 by Timoth\u00e9e Mazzucotelli). Support in[tro]spection ( 3a0587d by Timoth\u00e9e Mazzucotelli). Support multiple return, yield and receive items ( 0fc70cb by Timoth\u00e9e Mazzucotelli). Support namespace packages ( 2414c8e by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Fix extensions loader ( 78fb70b by Timoth\u00e9e Mazzucotelli). Avoid visiting/inspecting multiple times ( 75a8a8b by Timoth\u00e9e Mazzucotelli). Set modules collection attribute earlier ( 592c0bd by Timoth\u00e9e Mazzucotelli). Support inequality nodes ( b0ed247 by Timoth\u00e9e Mazzucotelli). Handle Div nodes for values ( 272e4d6 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Set log level to INFO ( 718e73e by Timoth\u00e9e Mazzucotelli). Add target setter ( 7f0064c by Timoth\u00e9e Mazzucotelli). Reorganize conditions ( 15ab876 by Timoth\u00e9e Mazzucotelli). Avoid recursion loops ( ea6acec by Timoth\u00e9e Mazzucotelli). Update aliases when replacing a member ( 99a0f8b by Timoth\u00e9e Mazzucotelli). Reorganize code ( 31fcdb1 by Timoth\u00e9e Mazzucotelli). Replace DocstringException with DocstringRaise ( d5ed87a by Timoth\u00e9e Mazzucotelli). Refactor loaders ( d9b94bb by Timoth\u00e9e Mazzucotelli). Improve typing ( e08bcfa by Timoth\u00e9e Mazzucotelli). 0.3.0 - 2021-11-21 \u00a4 Compare with 0.2.0 Features \u00a4 Handle aliases and their resolution ( 67ae903 by Timoth\u00e9e Mazzucotelli). Resolve annotations in docstrings ( 847384a by Timoth\u00e9e Mazzucotelli). Resolve annotations ( 6451eff by Timoth\u00e9e Mazzucotelli). Add lines property to objects ( 7daf7db by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each object ( 07a1d2e by Timoth\u00e9e Mazzucotelli). Get attributes annotations from parent ( 003b990 by Timoth\u00e9e Mazzucotelli). Draft extensions loader ( 17ccd03 by Timoth\u00e9e Mazzucotelli). Add properties to objects ( 0ec301a by Timoth\u00e9e Mazzucotelli). Handle .pth files when searching modules ( 2a2e182 by Timoth\u00e9e Mazzucotelli). Add default property to docstring parameters ( 6298ba3 by Timoth\u00e9e Mazzucotelli). Accept RST and Numpy parsers ( 1cf147d by Timoth\u00e9e Mazzucotelli). Support data (attributes/variables) ( dce84d1 by Timoth\u00e9e Mazzucotelli). Add Numpy-style parser ( ad5b72d by Timoth\u00e9e Mazzucotelli). Support more section kinds in Google-style ( 9d3d047 by Timoth\u00e9e Mazzucotelli). Add docstring section kinds ( b270483 by Timoth\u00e9e Mazzucotelli). Accept initial arguments when creating container ( 90c5956 by Timoth\u00e9e Mazzucotelli). Add an RST-style docstring parser ( 742e7b2 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Improve JSON encoder perfs ( 6a78eb0 by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Handle serialization of Posix paths ( 3a66b95 by Timoth\u00e9e Mazzucotelli). Fix list annotation getter ( 5ae800a by Timoth\u00e9e Mazzucotelli). Show accurate line number in Google warnings ( 2953590 by Timoth\u00e9e Mazzucotelli). Fix assignment names getters ( 6990846 by Timoth\u00e9e Mazzucotelli). Fix async loader (passing parent) ( 57e866e by Timoth\u00e9e Mazzucotelli). Fix exception name ( 4b8b85d by Timoth\u00e9e Mazzucotelli). Fix Google sections titles logic ( 87dd329 by Timoth\u00e9e Mazzucotelli). Prepend current module to base classes (still needs resolution) ( a4b1dee by Timoth\u00e9e Mazzucotelli). Fix Google admonition regex ( 3902e74 by Timoth\u00e9e Mazzucotelli). Fix docstring getter ( 1442eba by Timoth\u00e9e Mazzucotelli). Fix getting arguments defaults in the Google-style parser ( 67adbaf by Timoth\u00e9e Mazzucotelli). Fix getting arguments annotations in the Google-style parser ( 8bcbfba by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Export parsers and main function in docstrings module ( 96469da by Timoth\u00e9e Mazzucotelli). Remove top exports ( cd76694 by Timoth\u00e9e Mazzucotelli). Reorganize exceptions ( 7f9b805 by Timoth\u00e9e Mazzucotelli). Avoid circular import ( ef27dcd by Timoth\u00e9e Mazzucotelli). Rename index to [new] offset ( c07cc7d by Timoth\u00e9e Mazzucotelli). Reorganize code ( 5f4fff2 by Timoth\u00e9e Mazzucotelli). Use keyword only parameters ( d34edd6 by Timoth\u00e9e Mazzucotelli). Default to no parsing for serialization ( 8fecd9e by Timoth\u00e9e Mazzucotelli). Always extend AST ( c227ae6 by Timoth\u00e9e Mazzucotelli). Set default for kwargs parameters ( 7a0b85e by Timoth\u00e9e Mazzucotelli). Rename visitor method ( 3e0c43c by Timoth\u00e9e Mazzucotelli). Improve typing ( ac86f17 by Timoth\u00e9e Mazzucotelli). Fix typo ( a9ed6e9 by Timoth\u00e9e Mazzucotelli). Rewrite ParameterKind ( 90249df by Timoth\u00e9e Mazzucotelli). Add bool methods to docstrings and objects ( 548f72e by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each docstring ( 752e084 by Timoth\u00e9e Mazzucotelli). Skip attribute assignments ( e9cc2cd by Timoth\u00e9e Mazzucotelli). Improve visitor getters ( 2ea88c0 by Timoth\u00e9e Mazzucotelli). Use relative filepath in docstring warnings ( e894df7 by Timoth\u00e9e Mazzucotelli). Set submodules parent earlier ( 53767c0 by Timoth\u00e9e Mazzucotelli). Rename Data to Attribute ( febc12e by Timoth\u00e9e Mazzucotelli). Rename arguments to parameters ( 957856c by Timoth\u00e9e Mazzucotelli). Improve annotation support ( 5b2262f by Timoth\u00e9e Mazzucotelli). Always set parent ( cae85de by Timoth\u00e9e Mazzucotelli). Factorize function handling ( dfece1c by Timoth\u00e9e Mazzucotelli). Privatize stuff, fix loggers ( 5513ed5 by Timoth\u00e9e Mazzucotelli). Use keyword only arguments ( e853fe9 by Timoth\u00e9e Mazzucotelli). Set default values for Argument arguments ( d5cccaa by Timoth\u00e9e Mazzucotelli). Swallow extra parsing options ( 3d9ebe7 by Timoth\u00e9e Mazzucotelli). Rename start_index argument to offset ( dd88358 by Timoth\u00e9e Mazzucotelli). Reuse parsers warn function ( 03dfdd3 by Timoth\u00e9e Mazzucotelli). 0.2.0 - 2021-09-25 \u00a4 Compare with 0.1.0 Features \u00a4 Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli). 0.1.0 - 2021-09-09 \u00a4 Compare with first commit Features \u00a4 Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#0124-2022-02-16","text":"Compare with 0.12.3","title":"0.12.4 - 2022-02-16"},{"location":"changelog/#bug-fixes","text":"Update target path when changing alias target ( 5eda646 by Timoth\u00e9e Mazzucotelli). Fix relative imports to absolute with wildcards ( 69500dd by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 Fix accessing members using tuples ( 87ff1df by Timoth\u00e9e Mazzucotelli). Fix recursive wildcard expansion ( 60e6edf by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382 Only export submodules if they were imported ( 98c72db by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382","title":"Bug Fixes"},{"location":"changelog/#0123-2022-02-15","text":"Compare with 0.12.2","title":"0.12.3 - 2022-02-15"},{"location":"changelog/#bug-fixes_1","text":"Always decode source as UTF8 ( 563469b by Timoth\u00e9e Mazzucotelli). Fix JSON encoder and decoder ( 3e768d6 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Improve error handling ( 7b15a51 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0122-2022-02-13","text":"Compare with 0.12.1","title":"0.12.2 - 2022-02-13"},{"location":"changelog/#bug-fixes_2","text":"Fix JSON unable to serialize docstring kind values ( 91e6719 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_1","text":"Make attribute labels more explicit ( 19eac2e by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0121-2022-02-12","text":"Compare with 0.11.7","title":"0.12.1 - 2022-02-12"},{"location":"changelog/#features","text":"Add ignore_init_summary option to the Google parser ( 81f0333 by Timoth\u00e9e Mazzucotelli). Add is_KIND properties on objects ( 17a08cd by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#0117-2022-02-12","text":"Compare with 0.11.6","title":"0.11.7 - 2022-02-12"},{"location":"changelog/#bug-fixes_3","text":"Keep only first assignment in conditions ( 0104440 by Timoth\u00e9e Mazzucotelli). Support invert unary op in annotations ( 734ef55 by Timoth\u00e9e Mazzucotelli). Fix handling of missing modules during dynamic imports ( 7a3b383 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#380 Fix getting lines of compiled modules ( 899461b by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_2","text":"Get annotation with the same property on functions ( ecc7bba by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0116-2022-02-10","text":"Compare with 0.11.5","title":"0.11.6 - 2022-02-10"},{"location":"changelog/#bug-fixes_4","text":"Fix infinite loop in Google parser ( 8b7b97b by Timoth\u00e9e Mazzucotelli). Issue #38","title":"Bug Fixes"},{"location":"changelog/#0115-2022-02-08","text":"Compare with 0.11.4","title":"0.11.5 - 2022-02-08"},{"location":"changelog/#bug-fixes_5","text":"Fix building title and kind of Google admonitions ( 87ab56c by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings#379","title":"Bug Fixes"},{"location":"changelog/#0114-2022-02-07","text":"Compare with 0.11.3","title":"0.11.4 - 2022-02-07"},{"location":"changelog/#bug-fixes_6","text":"Don't trigger alias resolution while checking docstrings presence ( dda72ea by Timoth\u00e9e Mazzucotelli). Issue #37","title":"Bug Fixes"},{"location":"changelog/#0113-2022-02-05","text":"Compare with 0.11.2","title":"0.11.3 - 2022-02-05"},{"location":"changelog/#bug-fixes_7","text":"Fix getting params defaults on Python 3.7 ( 0afd867 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#0112-2022-02-03","text":"Compare with 0.11.1","title":"0.11.2 - 2022-02-03"},{"location":"changelog/#code-refactoring_3","text":"Factorize docstring annotation parser ( 19609be by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0111-2022-02-01","text":"Compare with 0.11.0","title":"0.11.1 - 2022-02-01"},{"location":"changelog/#code-refactoring_4","text":"Rename RST parser to Sphinx ( a612cb1 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0110-2022-01-31","text":"Compare with 0.10.0","title":"0.11.0 - 2022-01-31"},{"location":"changelog/#features_1","text":"Support matrix multiplication operator in visitor ( 6129e17 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_8","text":"Fix name resolution for inspected data ( ed3e7e5 by Timoth\u00e9e Mazzucotelli). Make importer actually able to import any nested object ( d007219 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_5","text":"Always use search paths to import modules ( a9a378f by Timoth\u00e9e Mazzucotelli). Split out module finder ( 7290642 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#0100-2022-01-14","text":"Compare with 0.9.0","title":"0.10.0 - 2022-01-14"},{"location":"changelog/#bug-fixes_9","text":"Fix infinite recursion errors in alias resolver ( 133b4e4 by Timoth\u00e9e Mazzucotelli). Fix inspection of nodes children (aliases or not) ( bb354f2 by Timoth\u00e9e Mazzucotelli). Fix relative to absolute import conversion ( 464c39e by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_6","text":"Rename some CLI options ( 1323268 by Timoth\u00e9e Mazzucotelli). Return the loader the to main function ( 9c6317e by Timoth\u00e9e Mazzucotelli). Improve logging messages ( b8eb16e by Timoth\u00e9e Mazzucotelli). Skip inspection of some debug packages ( 4ee8968 by Timoth\u00e9e Mazzucotelli). Return ... instead of Ellipsis ( f9ae31d by Timoth\u00e9e Mazzucotelli). Catch attribute errors when cross-referencing docstring annotations ( 288803a by Timoth\u00e9e Mazzucotelli). Support dict methods in lines collection ( 1b0cb94 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features_2","text":"Compute and show some stats ( 1b8d0a1 by Timoth\u00e9e Mazzucotelli). Add CLI options for alias resolution ( 87a59cb by Timoth\u00e9e Mazzucotelli). Support Google raises annotations cross-refs ( 8006ae1 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#090-2022-01-04","text":"Compare with 0.8.0","title":"0.9.0 - 2022-01-04"},{"location":"changelog/#features_3","text":"Loader option to only follow aliases in known modules ( 879d91b by Timoth\u00e9e Mazzucotelli). Use aliases when inspecting too ( 60439ee by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_10","text":"Handle more errors when loading modules ( 1aa571a by Timoth\u00e9e Mazzucotelli). Handle more errors when getting signature ( 2db85e7 by Timoth\u00e9e Mazzucotelli). Fix checking parent truthfulness ( 6129e50 by Timoth\u00e9e Mazzucotelli). Fix getting subscript value ( 1699f12 by Timoth\u00e9e Mazzucotelli). Support yield nodes ( 7d536d5 by Timoth\u00e9e Mazzucotelli). Exclude some special low-level members that cause cyclic issues ( b54ab34 by Timoth\u00e9e Mazzucotelli). Fix transforming elements of signatures to annotations ( e278c11 by Timoth\u00e9e Mazzucotelli). Detect cyclic aliases and prevent resolution errors ( de5dd12 by Timoth\u00e9e Mazzucotelli). Don't crash while trying to get the representation of an attribute value ( 77ac55d by Timoth\u00e9e Mazzucotelli). Fix building value for joined strings ( 6154b69 by Timoth\u00e9e Mazzucotelli). Fix prevention of cycles while building objects nodes ( 48062ac by Timoth\u00e9e Mazzucotelli). Better handle relative imports ( 91b42de by Timoth\u00e9e Mazzucotelli). Fix Google parser missing lines ending with colon ( 2f7969c by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_7","text":"Improve alias resolution robustness ( e708139 by Timoth\u00e9e Mazzucotelli). Remove async loader for now ( acc5ecf by Timoth\u00e9e Mazzucotelli). Improve handling of Google admonitions ( 8aa5ed0 by Timoth\u00e9e Mazzucotelli). Better handling of import errors and system exits while inspecting modules ( 7ba1589 by Timoth\u00e9e Mazzucotelli). Empty generic visit/inspect methods in base classes ( 338760e by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#080-2022-01-02","text":"Compare with 0.7.1","title":"0.8.0 - 2022-01-02"},{"location":"changelog/#features_4","text":"Support getting attribute annotation from parent in RST docstring parser ( 25db61a by Timoth\u00e9e Mazzucotelli). Handle relative imports ( 62b0927 by Timoth\u00e9e Mazzucotelli). Support wildcard imports ( 77a3cb7 by Timoth\u00e9e Mazzucotelli). Support configuring log level (CLI/env var) ( 839d78e by Timoth\u00e9e Mazzucotelli). Support loading *.py[cod] and *.so modules ( cd98a6f by Timoth\u00e9e Mazzucotelli). Support inspecting builtin functions/methods ( aa1fce3 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_8","text":"Handle extensions errors ( 11278ca by Timoth\u00e9e Mazzucotelli). Don't always try to find a module as a relative path ( e6df277 by Timoth\u00e9e Mazzucotelli). Improve loggers patching ( f4b262a by Timoth\u00e9e Mazzucotelli). Improve dynamic imports ( 2998195 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#071-2021-12-28","text":"Compare with 0.7.0","title":"0.7.1 - 2021-12-28"},{"location":"changelog/#code-refactoring_9","text":"Only log warning if async mode is used ( 356e848 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#070-2021-12-28","text":"Compare with 0.6.0","title":"0.7.0 - 2021-12-28"},{"location":"changelog/#features_5","text":"Support more nodes on Python 3.7 ( 7f2c4ec by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_10","text":"Don't crash on syntax errors and log an error ( 10bb6b1 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#060-2021-12-27","text":"Compare with 0.5.0","title":"0.6.0 - 2021-12-27"},{"location":"changelog/#features_6","text":"Support more AST nodes ( cd1b305 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_11","text":"Use annotation getter for base classes ( 8b1a7ed by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#050-2021-12-20","text":"Compare with 0.4.0","title":"0.5.0 - 2021-12-20"},{"location":"changelog/#features_7","text":"Add support for Python 3.7 ( 4535adc by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_11","text":"Don't propagate aliases of an alias ( 8af48f8 by Timoth\u00e9e Mazzucotelli). Don't reassign members defined in except clauses ( d918b4e by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#040-2021-11-28","text":"Compare with 0.3.0","title":"0.4.0 - 2021-11-28"},{"location":"changelog/#features_8","text":"Add a prototype 'hybrid' extension ( 8cb3c16 by Timoth\u00e9e Mazzucotelli). Allow passing extensions config as JSON on the CLI ( 9a7fa8b by Timoth\u00e9e Mazzucotelli). Support names for returns, yields and receives sections items ( 1c5a4c9 by Timoth\u00e9e Mazzucotelli). Store aliases on each object ( 91ba643 by Timoth\u00e9e Mazzucotelli). Support in[tro]spection ( 3a0587d by Timoth\u00e9e Mazzucotelli). Support multiple return, yield and receive items ( 0fc70cb by Timoth\u00e9e Mazzucotelli). Support namespace packages ( 2414c8e by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_12","text":"Fix extensions loader ( 78fb70b by Timoth\u00e9e Mazzucotelli). Avoid visiting/inspecting multiple times ( 75a8a8b by Timoth\u00e9e Mazzucotelli). Set modules collection attribute earlier ( 592c0bd by Timoth\u00e9e Mazzucotelli). Support inequality nodes ( b0ed247 by Timoth\u00e9e Mazzucotelli). Handle Div nodes for values ( 272e4d6 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_12","text":"Set log level to INFO ( 718e73e by Timoth\u00e9e Mazzucotelli). Add target setter ( 7f0064c by Timoth\u00e9e Mazzucotelli). Reorganize conditions ( 15ab876 by Timoth\u00e9e Mazzucotelli). Avoid recursion loops ( ea6acec by Timoth\u00e9e Mazzucotelli). Update aliases when replacing a member ( 99a0f8b by Timoth\u00e9e Mazzucotelli). Reorganize code ( 31fcdb1 by Timoth\u00e9e Mazzucotelli). Replace DocstringException with DocstringRaise ( d5ed87a by Timoth\u00e9e Mazzucotelli). Refactor loaders ( d9b94bb by Timoth\u00e9e Mazzucotelli). Improve typing ( e08bcfa by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#030-2021-11-21","text":"Compare with 0.2.0","title":"0.3.0 - 2021-11-21"},{"location":"changelog/#features_9","text":"Handle aliases and their resolution ( 67ae903 by Timoth\u00e9e Mazzucotelli). Resolve annotations in docstrings ( 847384a by Timoth\u00e9e Mazzucotelli). Resolve annotations ( 6451eff by Timoth\u00e9e Mazzucotelli). Add lines property to objects ( 7daf7db by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each object ( 07a1d2e by Timoth\u00e9e Mazzucotelli). Get attributes annotations from parent ( 003b990 by Timoth\u00e9e Mazzucotelli). Draft extensions loader ( 17ccd03 by Timoth\u00e9e Mazzucotelli). Add properties to objects ( 0ec301a by Timoth\u00e9e Mazzucotelli). Handle .pth files when searching modules ( 2a2e182 by Timoth\u00e9e Mazzucotelli). Add default property to docstring parameters ( 6298ba3 by Timoth\u00e9e Mazzucotelli). Accept RST and Numpy parsers ( 1cf147d by Timoth\u00e9e Mazzucotelli). Support data (attributes/variables) ( dce84d1 by Timoth\u00e9e Mazzucotelli). Add Numpy-style parser ( ad5b72d by Timoth\u00e9e Mazzucotelli). Support more section kinds in Google-style ( 9d3d047 by Timoth\u00e9e Mazzucotelli). Add docstring section kinds ( b270483 by Timoth\u00e9e Mazzucotelli). Accept initial arguments when creating container ( 90c5956 by Timoth\u00e9e Mazzucotelli). Add an RST-style docstring parser ( 742e7b2 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements","text":"Improve JSON encoder perfs ( 6a78eb0 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#bug-fixes_13","text":"Handle serialization of Posix paths ( 3a66b95 by Timoth\u00e9e Mazzucotelli). Fix list annotation getter ( 5ae800a by Timoth\u00e9e Mazzucotelli). Show accurate line number in Google warnings ( 2953590 by Timoth\u00e9e Mazzucotelli). Fix assignment names getters ( 6990846 by Timoth\u00e9e Mazzucotelli). Fix async loader (passing parent) ( 57e866e by Timoth\u00e9e Mazzucotelli). Fix exception name ( 4b8b85d by Timoth\u00e9e Mazzucotelli). Fix Google sections titles logic ( 87dd329 by Timoth\u00e9e Mazzucotelli). Prepend current module to base classes (still needs resolution) ( a4b1dee by Timoth\u00e9e Mazzucotelli). Fix Google admonition regex ( 3902e74 by Timoth\u00e9e Mazzucotelli). Fix docstring getter ( 1442eba by Timoth\u00e9e Mazzucotelli). Fix getting arguments defaults in the Google-style parser ( 67adbaf by Timoth\u00e9e Mazzucotelli). Fix getting arguments annotations in the Google-style parser ( 8bcbfba by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_13","text":"Export parsers and main function in docstrings module ( 96469da by Timoth\u00e9e Mazzucotelli). Remove top exports ( cd76694 by Timoth\u00e9e Mazzucotelli). Reorganize exceptions ( 7f9b805 by Timoth\u00e9e Mazzucotelli). Avoid circular import ( ef27dcd by Timoth\u00e9e Mazzucotelli). Rename index to [new] offset ( c07cc7d by Timoth\u00e9e Mazzucotelli). Reorganize code ( 5f4fff2 by Timoth\u00e9e Mazzucotelli). Use keyword only parameters ( d34edd6 by Timoth\u00e9e Mazzucotelli). Default to no parsing for serialization ( 8fecd9e by Timoth\u00e9e Mazzucotelli). Always extend AST ( c227ae6 by Timoth\u00e9e Mazzucotelli). Set default for kwargs parameters ( 7a0b85e by Timoth\u00e9e Mazzucotelli). Rename visitor method ( 3e0c43c by Timoth\u00e9e Mazzucotelli). Improve typing ( ac86f17 by Timoth\u00e9e Mazzucotelli). Fix typo ( a9ed6e9 by Timoth\u00e9e Mazzucotelli). Rewrite ParameterKind ( 90249df by Timoth\u00e9e Mazzucotelli). Add bool methods to docstrings and objects ( 548f72e by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each docstring ( 752e084 by Timoth\u00e9e Mazzucotelli). Skip attribute assignments ( e9cc2cd by Timoth\u00e9e Mazzucotelli). Improve visitor getters ( 2ea88c0 by Timoth\u00e9e Mazzucotelli). Use relative filepath in docstring warnings ( e894df7 by Timoth\u00e9e Mazzucotelli). Set submodules parent earlier ( 53767c0 by Timoth\u00e9e Mazzucotelli). Rename Data to Attribute ( febc12e by Timoth\u00e9e Mazzucotelli). Rename arguments to parameters ( 957856c by Timoth\u00e9e Mazzucotelli). Improve annotation support ( 5b2262f by Timoth\u00e9e Mazzucotelli). Always set parent ( cae85de by Timoth\u00e9e Mazzucotelli). Factorize function handling ( dfece1c by Timoth\u00e9e Mazzucotelli). Privatize stuff, fix loggers ( 5513ed5 by Timoth\u00e9e Mazzucotelli). Use keyword only arguments ( e853fe9 by Timoth\u00e9e Mazzucotelli). Set default values for Argument arguments ( d5cccaa by Timoth\u00e9e Mazzucotelli). Swallow extra parsing options ( 3d9ebe7 by Timoth\u00e9e Mazzucotelli). Rename start_index argument to offset ( dd88358 by Timoth\u00e9e Mazzucotelli). Reuse parsers warn function ( 03dfdd3 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#020-2021-09-25","text":"Compare with 0.1.0","title":"0.2.0 - 2021-09-25"},{"location":"changelog/#features_10","text":"Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements_1","text":"Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#010-2021-09-09","text":"Compare with first commit","title":"0.1.0 - 2021-09-09"},{"location":"changelog/#features_11","text":"Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build griffe . Thank you! python | pdm | copier-pdm Direct dependencies \u00a4 aiofiles | autoflake | black | cached_property | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | hypothesmith | isort | markdown-callouts | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-xdist | safety | toml | types-aiofiles | types-markdown | types-toml | wps-light Indirect dependencies \u00a4 ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | griffe | hypothesis | idna | importlib-metadata | iniconfig | jinja2 | lark-parser | libcst | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mkdocstrings-python | mkdocstrings-python-legacy | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | sortedcontainers | stevedore | tomli | typed-ast | typing-extensions | typing-inspect | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build griffe . Thank you! python | pdm | copier-pdm","title":"Credits"},{"location":"credits/#direct-dependencies","text":"aiofiles | autoflake | black | cached_property | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | hypothesmith | isort | markdown-callouts | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-xdist | safety | toml | types-aiofiles | types-markdown | types-toml | wps-light","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | griffe | hypothesis | idna | importlib-metadata | iniconfig | jinja2 | lark-parser | libcst | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mkdocstrings-python | mkdocstrings-python-legacy | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | sortedcontainers | stevedore | tomli | typed-ast | typing-extensions | typing-inspect | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Indirect dependencies"},{"location":"docstrings/","text":"Docstrings \u00a4 Want to contribute? Each red cross is a link to an issue on the bugtracker. You will find some guidance on how to add support for the corresponding item. The sections are easier to deal in that order: Deprecated (single item, version and text) Raises, Warns (multiple items, no names, single type each) Attributes, Other Parameters, Parameters (multiple items, one name and one optional type each) Returns (multiple items, optional name and/or type each, annotation to split when multiple names) Receives, Yields (multiple items, optional name and/or type each, several types of annotations to split when multiple names) \"Examples\" section are a bit different as they require to parse the examples. But you can probably reuse the code in the Google parser. We can probably even factorize the examples parsing into a single function. You can tackle several items at once in a single PR, as long as they relate to a single parser or a single section (a line or a column of the following tables). Section support \u00a4 Section Google Numpy Sphinx Attributes \u2705 \u2705 \u2705 Deprecated \u2705 \u2705 1 \u274c Examples \u2705 \u2705 \u274c Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises \u2705 \u2705 \u2705 Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705 Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c Getting annotations/defaults from parent \u00a4 Section Google Numpy Sphinx Attributes \u2705 \u274c \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises / / / Receives \u274c \u274c \u274c Returns \u2705 \u274c \u2705 Warns / / / Yields \u2705 \u274c \u274c Cross-references for annotations in docstrings \u00a4 Section Google Numpy Sphinx Attributes \u2705 \u274c \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u274c \u274c Parameters \u2705 \u274c \u274c Raises \u2705 \u274c \u274c Receives \u2705 \u274c \u274c Returns \u2705 \u274c \u274c Warns \u2705 \u274c \u274c Yields \u2705 \u274c \u274c Support for a regular section instead of the RST directive specified in the Numpydoc styleguide . \u21a9","title":"Docstrings"},{"location":"docstrings/#docstrings","text":"Want to contribute? Each red cross is a link to an issue on the bugtracker. You will find some guidance on how to add support for the corresponding item. The sections are easier to deal in that order: Deprecated (single item, version and text) Raises, Warns (multiple items, no names, single type each) Attributes, Other Parameters, Parameters (multiple items, one name and one optional type each) Returns (multiple items, optional name and/or type each, annotation to split when multiple names) Receives, Yields (multiple items, optional name and/or type each, several types of annotations to split when multiple names) \"Examples\" section are a bit different as they require to parse the examples. But you can probably reuse the code in the Google parser. We can probably even factorize the examples parsing into a single function. You can tackle several items at once in a single PR, as long as they relate to a single parser or a single section (a line or a column of the following tables).","title":"Docstrings"},{"location":"docstrings/#section-support","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u2705 Deprecated \u2705 \u2705 1 \u274c Examples \u2705 \u2705 \u274c Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises \u2705 \u2705 \u2705 Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705 Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c","title":"Section support"},{"location":"docstrings/#getting-annotationsdefaults-from-parent","text":"Section Google Numpy Sphinx Attributes \u2705 \u274c \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises / / / Receives \u274c \u274c \u274c Returns \u2705 \u274c \u2705 Warns / / / Yields \u2705 \u274c \u274c","title":"Getting annotations/defaults from parent"},{"location":"docstrings/#cross-references-for-annotations-in-docstrings","text":"Section Google Numpy Sphinx Attributes \u2705 \u274c \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u274c \u274c Parameters \u2705 \u274c \u274c Raises \u2705 \u274c \u274c Receives \u2705 \u274c \u274c Returns \u2705 \u274c \u274c Warns \u2705 \u274c \u274c Yields \u2705 \u274c \u274c Support for a regular section instead of the RST directive specified in the Numpydoc styleguide . \u21a9","title":"Cross-references for annotations in docstrings"},{"location":"license/","text":"ISC License Copyright (c) 2021, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"usage/","text":"Usage \u00a4 On the command line \u00a4 Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] See the full Griffe JSON dump . By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError . With Python \u00a4 Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader loader = GriffeLoader () griffe = loader . load_module ( \"griffe\" ) If you don't want to recurse in the submodules: griffe = loader . load_module ( \"griffe\" , submodules = False ) The load_module method returns a Module instance. There are several ways to access members of an object: through its members attribute, which is a dictionary, with the usual keys() , values() and items() methods. thanks to its __getitem__ method. For example griffe[\"dataclasses\"] returns the Module instance representing Griffe's dataclasses module. Since this module also has members, you can chain calls: griffe[\"dataclasses\"][\"Module\"] . Conveniently, you can chain the names with dots in a single call: griffe[\"dataclasses.Module\"] . You can even pass a tuple instead of a string: griffe[(\"dataclasses\", \"Module\")] . through the modules , classes , functions and attributes properties, which take care of filtering members based on their kind, and return dictionaries. Most of the time, you will only use classes from the griffe.dataclasses and griffe.docstrings.dataclasses modules. Extensions \u00a4 You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import VisitorExtension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( VisitorExtension ): when = When . after_all def visit_classdef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of a custom version of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE_LOWER> methods to visit nodes of certain types, and act on their properties. See the full list of AST nodes . Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not visit child nodes in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children. You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_functiondef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, attribute See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit/inspection: When.before_all . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is not yet instantiated. before the children visit/inspection: When.before_children . If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is now instantiated. Children have not yet been visited/inspected. after the children visit/inspection: When.after_children . Children have now been visited/inspected. after the visit/inspection: When.after_all See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . after_children By default, it will run the extension after the visit/inspection of the node: that's when the full data for this node and its children is loaded. Using Griffe as a docstring-parsing library \u00a4 You can use Griffe to parse arbitrary docstrings. You don't have to load anything through the Griffe loader. You need to import the parse function, the Parser enumeration, and the Docstring class. Then you can build a Docstring instance and call parse on it, choosing the parsing-style to use: from griffe.dataclasses import Docstring from griffe.docstrings.parsers import Parser , parse text = \"Hello I'm a docstring!\" docstring = Docstring ( text , lineno = 1 ) parsed = parse ( docstring , Parser . google ) If you want to take advantage of the parsers ability to fetch annotations from the object from which the docstring originates, you can manually create the parent objects and link them to the docstring: from griffe.dataclasses import Docstring , Function , Parameters , Parameter , ParameterKind from griffe.docstrings.parsers import Parser , parse function = Function ( \"func\" , parameters = Parameters ( Parameter ( \"param1\" , annotation = \"str\" , kind = ParameterKind . positional_or_keyword ), Parameter ( \"param2\" , annotation = \"int\" , kind = ParameterKind . keyword_only ), ) ) text = \"\"\" Hello I'm a docstring! Parameters: param1: Description. param2: Description. \"\"\" docstring = Docstring ( text , lineno = 1 , parent = function ) parsed = parse ( docstring , Parser . google ) With this the parser will fetch the str and int annotations from the parent function's parameters. AST nodes \u00a4 Add alias And AnnAssign arg arguments Assert Assign AsyncFor AsyncFunctionDef AsyncWith Attribute AugAssign Await BinOp BitAnd BitOr BitXor BoolOp Break Bytes 1 Call ClassDef Compare comprehension Constant Continue Del Delete Dict DictComp Div Ellipsis 1 Eq ExceptHandler Expr Expression 1 ExtSlice 2 FloorDiv For FormattedValue FunctionDef GeneratorExp Global Gt GtE If IfExp Import ImportFrom In Index 2 Interactive 3 Invert Is IsNot JoinedStr keyword Lambda List ListComp Load LShift Lt LtE Match MatchAs match_case MatchClass MatchMapping MatchOr MatchSequence MatchSingleton MatchStar MatchValue MatMult Mod Module 3 Mult Name NameConstant 1 NamedExpr Nonlocal Not NotEq NotIn Num 1 Or Pass pattern 3 Pow Print 4 Raise Return RShift Set SetComp Slice Starred Store Str 1 Sub Subscript Try TryExcept 5 TryFinally 6 Tuple UAdd UnaryOp USub While With withitem Yield YieldFrom Deprecated since Python 3.8. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Deprecated since Python 3.9. \u21a9 \u21a9 Not documented. \u21a9 \u21a9 \u21a9 print became a builtin (instead of a keyword) in Python 3. \u21a9 Now ExceptHandler , in the handlers attribute of Try nodes. \u21a9 Now a list of expressions in the finalbody attribute of Try nodes. \u21a9","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#on-the-command-line","text":"Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] See the full Griffe JSON dump . By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError .","title":"On the command line"},{"location":"usage/#with-python","text":"Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader loader = GriffeLoader () griffe = loader . load_module ( \"griffe\" ) If you don't want to recurse in the submodules: griffe = loader . load_module ( \"griffe\" , submodules = False ) The load_module method returns a Module instance. There are several ways to access members of an object: through its members attribute, which is a dictionary, with the usual keys() , values() and items() methods. thanks to its __getitem__ method. For example griffe[\"dataclasses\"] returns the Module instance representing Griffe's dataclasses module. Since this module also has members, you can chain calls: griffe[\"dataclasses\"][\"Module\"] . Conveniently, you can chain the names with dots in a single call: griffe[\"dataclasses.Module\"] . You can even pass a tuple instead of a string: griffe[(\"dataclasses\", \"Module\")] . through the modules , classes , functions and attributes properties, which take care of filtering members based on their kind, and return dictionaries. Most of the time, you will only use classes from the griffe.dataclasses and griffe.docstrings.dataclasses modules.","title":"With Python"},{"location":"usage/#extensions","text":"You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import VisitorExtension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( VisitorExtension ): when = When . after_all def visit_classdef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of a custom version of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE_LOWER> methods to visit nodes of certain types, and act on their properties. See the full list of AST nodes . Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not visit child nodes in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children. You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_functiondef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, attribute See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit/inspection: When.before_all . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is not yet instantiated. before the children visit/inspection: When.before_children . If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is now instantiated. Children have not yet been visited/inspected. after the children visit/inspection: When.after_children . Children have now been visited/inspected. after the visit/inspection: When.after_all See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . after_children By default, it will run the extension after the visit/inspection of the node: that's when the full data for this node and its children is loaded.","title":"Extensions"},{"location":"usage/#using-griffe-as-a-docstring-parsing-library","text":"You can use Griffe to parse arbitrary docstrings. You don't have to load anything through the Griffe loader. You need to import the parse function, the Parser enumeration, and the Docstring class. Then you can build a Docstring instance and call parse on it, choosing the parsing-style to use: from griffe.dataclasses import Docstring from griffe.docstrings.parsers import Parser , parse text = \"Hello I'm a docstring!\" docstring = Docstring ( text , lineno = 1 ) parsed = parse ( docstring , Parser . google ) If you want to take advantage of the parsers ability to fetch annotations from the object from which the docstring originates, you can manually create the parent objects and link them to the docstring: from griffe.dataclasses import Docstring , Function , Parameters , Parameter , ParameterKind from griffe.docstrings.parsers import Parser , parse function = Function ( \"func\" , parameters = Parameters ( Parameter ( \"param1\" , annotation = \"str\" , kind = ParameterKind . positional_or_keyword ), Parameter ( \"param2\" , annotation = \"int\" , kind = ParameterKind . keyword_only ), ) ) text = \"\"\" Hello I'm a docstring! Parameters: param1: Description. param2: Description. \"\"\" docstring = Docstring ( text , lineno = 1 , parent = function ) parsed = parse ( docstring , Parser . google ) With this the parser will fetch the str and int annotations from the parent function's parameters.","title":"Using Griffe as a docstring-parsing library"},{"location":"usage/#ast-nodes","text":"Add alias And AnnAssign arg arguments Assert Assign AsyncFor AsyncFunctionDef AsyncWith Attribute AugAssign Await BinOp BitAnd BitOr BitXor BoolOp Break Bytes 1 Call ClassDef Compare comprehension Constant Continue Del Delete Dict DictComp Div Ellipsis 1 Eq ExceptHandler Expr Expression 1 ExtSlice 2 FloorDiv For FormattedValue FunctionDef GeneratorExp Global Gt GtE If IfExp Import ImportFrom In Index 2 Interactive 3 Invert Is IsNot JoinedStr keyword Lambda List ListComp Load LShift Lt LtE Match MatchAs match_case MatchClass MatchMapping MatchOr MatchSequence MatchSingleton MatchStar MatchValue MatMult Mod Module 3 Mult Name NameConstant 1 NamedExpr Nonlocal Not NotEq NotIn Num 1 Or Pass pattern 3 Pow Print 4 Raise Return RShift Set SetComp Slice Starred Store Str 1 Sub Subscript Try TryExcept 5 TryFinally 6 Tuple UAdd UnaryOp USub While With withitem Yield YieldFrom Deprecated since Python 3.8. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Deprecated since Python 3.9. \u21a9 \u21a9 Not documented. \u21a9 \u21a9 \u21a9 print became a builtin (instead of a keyword) in Python 3. \u21a9 Now ExceptHandler , in the handlers attribute of Try nodes. \u21a9 Now a list of expressions in the finalbody attribute of Try nodes. \u21a9","title":"AST nodes"},{"location":"reference/SUMMARY/","text":"griffe agents base extensions hybrid inspector nodes visitor cli collections dataclasses docstrings dataclasses google markdown numpy parsers sphinx utils encoders exceptions expressions finder importer loader logger mixins stats","title":"SUMMARY"},{"location":"reference/griffe/","text":"griffe package. Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.","title":"griffe"},{"location":"reference/griffe/cli/","text":"Module that contains the command line application. get_parser () \u00a4 Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-y\" , \"--sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-d\" , \"--docstyle\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) parser . add_argument ( \"-D\" , \"--docopts\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) parser . add_argument ( \"-e\" , \"--extensions\" , default = {}, type = json . loads , help = \"A list of extensions to use.\" , ) parser . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-L\" , \"--log-level\" , metavar = \"LEVEL\" , default = os . getenv ( \"GRIFFE_LOG_LEVEL\" , \"INFO\" ) . upper (), choices = _level_choices , type = str . upper , help = \"Set the log level: DEBUG, INFO, WARNING, ERROR, CRITICAL.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {package} .\" , ) parser . add_argument ( \"-r\" , \"--resolve-aliases\" , action = \"store_true\" , help = \"Whether to resolve aliases.\" , ) parser . add_argument ( \"-I\" , \"--resolve-implicit\" , action = \"store_true\" , help = \"Whether to resolve implicitely exported aliases as well. \" \"Aliases are explicitely exported when defined in '__all__'.\" , ) parser . add_argument ( \"-U\" , \"--resolve-external\" , action = \"store_true\" , help = \"Whether to resolve aliases pointing to external/unknown modules (not loaded directly).\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"-S\" , \"--stats\" , action = \"store_true\" , help = \"Show statistics at the end.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser main ( args = None ) \u00a4 Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\"Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) try : level = getattr ( logging , opts . log_level ) except AttributeError : choices = \"', '\" . join ( _level_choices ) print ( f \"griffe: error: env var GRIFFE_LOG_LEVEL: invalid level ' { opts . log_level } ' (choose from ' { choices } ')\" , file = sys . stderr , ) sys . exit ( 1 ) logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = level ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . sys_path : search . extend ( sys . path ) try : extensions = load_extensions ( opts . extensions ) except ExtensionError as error : print ( f \"griffe: error: { error } \" , file = sys . stderr ) return 1 loader = _load_packages ( opts . packages , extensions , search , opts . docstyle , opts . docopts , opts . resolve_aliases , not opts . resolve_implicit , not opts . resolve_external , ) packages = loader . modules_collection . members started = datetime . now () if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = JSONEncoder , indent = 2 , full = opts . full ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = JSONEncoder , indent = 2 , full = opts . full ) _print_data ( serialized , output ) elapsed = datetime . now () - started if opts . stats : logger . info ( _stats ({ \"time_spent_serializing\" : elapsed . microseconds , ** loader . stats ()})) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"cli"},{"location":"reference/griffe/cli/#griffe.cli.get_parser","text":"Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-y\" , \"--sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-d\" , \"--docstyle\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) parser . add_argument ( \"-D\" , \"--docopts\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) parser . add_argument ( \"-e\" , \"--extensions\" , default = {}, type = json . loads , help = \"A list of extensions to use.\" , ) parser . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-L\" , \"--log-level\" , metavar = \"LEVEL\" , default = os . getenv ( \"GRIFFE_LOG_LEVEL\" , \"INFO\" ) . upper (), choices = _level_choices , type = str . upper , help = \"Set the log level: DEBUG, INFO, WARNING, ERROR, CRITICAL.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {package} .\" , ) parser . add_argument ( \"-r\" , \"--resolve-aliases\" , action = \"store_true\" , help = \"Whether to resolve aliases.\" , ) parser . add_argument ( \"-I\" , \"--resolve-implicit\" , action = \"store_true\" , help = \"Whether to resolve implicitely exported aliases as well. \" \"Aliases are explicitely exported when defined in '__all__'.\" , ) parser . add_argument ( \"-U\" , \"--resolve-external\" , action = \"store_true\" , help = \"Whether to resolve aliases pointing to external/unknown modules (not loaded directly).\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"-S\" , \"--stats\" , action = \"store_true\" , help = \"Show statistics at the end.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser","title":"get_parser()"},{"location":"reference/griffe/cli/#griffe.cli.main","text":"Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\"Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) try : level = getattr ( logging , opts . log_level ) except AttributeError : choices = \"', '\" . join ( _level_choices ) print ( f \"griffe: error: env var GRIFFE_LOG_LEVEL: invalid level ' { opts . log_level } ' (choose from ' { choices } ')\" , file = sys . stderr , ) sys . exit ( 1 ) logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = level ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . sys_path : search . extend ( sys . path ) try : extensions = load_extensions ( opts . extensions ) except ExtensionError as error : print ( f \"griffe: error: { error } \" , file = sys . stderr ) return 1 loader = _load_packages ( opts . packages , extensions , search , opts . docstyle , opts . docopts , opts . resolve_aliases , not opts . resolve_implicit , not opts . resolve_external , ) packages = loader . modules_collection . members started = datetime . now () if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = JSONEncoder , indent = 2 , full = opts . full ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = JSONEncoder , indent = 2 , full = opts . full ) _print_data ( serialized , output ) elapsed = datetime . now () - started if opts . stats : logger . info ( _stats ({ \"time_spent_serializing\" : elapsed . microseconds , ** loader . stats ()})) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"main()"},{"location":"reference/griffe/collections/","text":"This module stores collections of data, useful during parsing. LinesCollection () \u00a4 A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 18 19 20 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {} __getattr__ ( self , name , default = None ) \u00a4 Lookup attributes into underlying dict. Parameters: name ( str ) \u2013 The attribute name. default ( Any ) \u2013 A default value. Returns: Any \u2013 The attribute of the underlying dict. Source code in griffe/collections.py 34 35 36 37 38 39 40 41 42 43 44 def __getattr__ ( self , name : str , default : Any = None ) -> Any : \"\"\"Lookup attributes into underlying dict. Parameters: name: The attribute name. default: A default value. Returns: The attribute of the underlying dict. \"\"\" return getattr ( self . _data , name , default ) tokens ( self , path ) \u00a4 Tokenize the code. Parameters: path ( Path ) \u2013 The filepath to get the tokens of. Returns: tuple [ list [ tokenize . TokenInfo ], defaultdict ] \u2013 A token list and a mapping of tokens by line number. Source code in griffe/collections.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table ModulesCollection () \u00a4 Bases: GetMembersMixin , SetCollectionMembersMixin A collection of modules, allowing easy access to members. Source code in griffe/collections.py 65 66 67 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"collections"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection","text":"A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 18 19 20 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {}","title":"LinesCollection"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.__getattr__","text":"Lookup attributes into underlying dict. Parameters: name ( str ) \u2013 The attribute name. default ( Any ) \u2013 A default value. Returns: Any \u2013 The attribute of the underlying dict. Source code in griffe/collections.py 34 35 36 37 38 39 40 41 42 43 44 def __getattr__ ( self , name : str , default : Any = None ) -> Any : \"\"\"Lookup attributes into underlying dict. Parameters: name: The attribute name. default: A default value. Returns: The attribute of the underlying dict. \"\"\" return getattr ( self . _data , name , default )","title":"__getattr__()"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.tokens","text":"Tokenize the code. Parameters: path ( Path ) \u2013 The filepath to get the tokens of. Returns: tuple [ list [ tokenize . TokenInfo ], defaultdict ] \u2013 A token list and a mapping of tokens by line number. Source code in griffe/collections.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table","title":"tokens()"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection","text":"Bases: GetMembersMixin , SetCollectionMembersMixin A collection of modules, allowing easy access to members. Source code in griffe/collections.py 65 66 67 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"ModulesCollection"},{"location":"reference/griffe/dataclasses/","text":"This module contains the data classes that represent Python objects. The different objects are modules, classes, functions, and attribute (variables like module/class/instance attributes). Alias ( name , target , * , lineno = None , endlineno = None , parent = None ) \u00a4 Bases: ObjectAliasMixin This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( None ) \u2013 The alias parent. target_path ( str ) \u2013 The alias target path. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . target_path : str = target else : self . _target = target self . target_path = target . path if parent is not None : with suppress ( AliasResolutionError ): target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent self . _passed_through : bool = False as_dict ( self , full = False , ** kwargs ) \u00a4 Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base kind ( self ) \u00a4 Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind. Source code in griffe/dataclasses.py 807 808 809 810 811 812 813 814 815 816 817 818 @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except ( AliasResolutionError , CyclicAliasError ): return Kind . ALIAS modules_collection ( self ) \u00a4 Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 845 846 847 848 849 850 851 852 853 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent path ( self ) \u00a4 Return the dotted path / import path of this object. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 836 837 838 839 840 841 842 843 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent resolve_target ( self ) \u00a4 Resolve the target. Raises: AliasResolutionError \u2013 When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. CyclicAliasError \u2013 When the resolved target is the alias itself. Source code in griffe/dataclasses.py 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. CyclicAliasError: When the resolved target is the alias itself. \"\"\" try : resolved = self . modules_collection [ self . target_path ] except KeyError as error : raise AliasResolutionError ( self . target_path ) from error if resolved is self : raise CyclicAliasError ([ self . target_path ]) self . _target = resolved if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target resolved ( self ) \u00a4 Tell whether this alias' target is resolved. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 899 900 901 902 903 904 905 906 @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None wildcard ( self ) \u00a4 Return the module on which the wildcard import is performed (if any). Returns: str | None \u2013 The wildcard imported module, or None. Source code in griffe/dataclasses.py 908 909 910 911 912 913 914 915 916 917 @cached_property def wildcard ( self ) -> str | None : \"\"\"Return the module on which the wildcard import is performed (if any). Returns: The wildcard imported module, or None. \"\"\" if self . name . endswith ( \"/*\" ): return self . target_path return None Attribute ( * args , value = None , annotation = None , ** kwargs ) \u00a4 Bases: Object The class representing a Python module/class/instance attribute. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base Class ( * args , bases = None , decorators = None , ** kwargs ) \u00a4 Bases: Object The class representing a Python class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression | str ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] as_dict ( self , ** kwargs ) \u00a4 Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base Decorator ( lineno , endlineno ) \u00a4 This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Parameters: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 49 50 51 52 53 54 55 56 57 def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno as_dict ( self , ** kwargs ) \u00a4 Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } Docstring ( value , * , lineno = None , endlineno = None , parent = None , parser = None , parser_options = None ) \u00a4 This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} as_dict ( self , full = False , docstring_parser = None , ** kwargs ) \u00a4 Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base lines ( self ) \u00a4 Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines. Source code in griffe/dataclasses.py 122 123 124 125 126 127 128 129 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) parse ( self , parser = None , ** options ) \u00a4 Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 140 141 142 143 144 145 146 147 148 149 150 151 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) parsed ( self ) \u00a4 Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 131 132 133 134 135 136 137 138 @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () Function ( * args , parameters = None , returns = None , decorators = None , ** kwargs ) \u00a4 Bases: Object The class representing a Python function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] annotation ( self ) \u00a4 Return the return annotation. Returns: str | Name | Expression | None \u2013 The function return annotation. Source code in griffe/dataclasses.py 1124 1125 1126 1127 1128 1129 1130 1131 @property def annotation ( self ) -> str | Name | Expression | None : \"\"\"Return the return annotation. Returns: The function return annotation. \"\"\" return self . returns as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base Kind \u00a4 Bases: enum . Enum Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind. Module ( * args , filepath = None , ** kwargs ) \u00a4 Bases: Object The class representing a Python module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path | list [ Path ] | None ) \u2013 The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 946 947 948 949 950 951 952 953 954 955 def __init__ ( self , * args : Any , filepath : Path | list [ Path ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | list [ Path ] | None = filepath as_dict ( self , ** kwargs ) \u00a4 Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base filepath ( self ) \u00a4 Get the file path of this module. Raises: BuiltinModuleError \u2013 When the instance filepath is None. Returns: Path | list [ Path ] \u2013 The module's file path. Source code in griffe/dataclasses.py 968 969 970 971 972 973 974 975 976 977 978 979 980 @property def filepath ( self ) -> Path | list [ Path ]: \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath is_init_module ( self ) \u00a4 Tell if this module is an __init__.py module. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 982 983 984 985 986 987 988 989 990 991 992 993 994 @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" if isinstance ( self . filepath , list ): return False try : return self . filepath . name . split ( \".\" , 1 )[ 0 ] == \"__init__\" except BuiltinModuleError : return False is_namespace_package ( self ) \u00a4 Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return self . parent is None and isinstance ( self . filepath , list ) except BuiltinModuleError : return False is_namespace_subpackage ( self ) \u00a4 Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and isinstance ( self . filepath , list ) and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False is_package ( self ) \u00a4 Tell if this module is a package (top module). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 996 997 998 999 1000 1001 1002 1003 @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module is_subpackage ( self ) \u00a4 Tell if this module is a subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 1005 1006 1007 1008 1009 1010 1011 1012 @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module Object ( name , * , lineno = None , endlineno = None , docstring = None , parent = None , lines_collection = None , modules_collection = None ) \u00a4 Bases: GetMembersMixin , SetMembersMixin , ObjectAliasMixin An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self as_dict ( self , full = False , ** kwargs ) \u00a4 Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base attributes ( self ) \u00a4 Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes. Source code in griffe/dataclasses.py 474 475 476 477 478 479 480 481 @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc] canonical_path ( self ) \u00a4 Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 565 566 567 568 569 570 571 572 573 574 575 576 @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if self . parent is None : return self . name return \".\" . join (( self . parent . path , self . name )) classes ( self ) \u00a4 Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes. Source code in griffe/dataclasses.py 456 457 458 459 460 461 462 463 @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc] filepath ( self ) \u00a4 Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Path | list [ Path ] \u2013 A file path or a list of directories. Source code in griffe/dataclasses.py 511 512 513 514 515 516 517 518 519 520 521 522 523 @cached_property def filepath ( self ) -> Path | list [ Path ]: \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path or a list of directories. \"\"\" return self . module . filepath filter_members ( self , * predicates ) \u00a4 Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members functions ( self ) \u00a4 Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions. Source code in griffe/dataclasses.py 465 466 467 468 469 470 471 472 @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc] has_docstring ( self ) \u00a4 Tell if this object has a non-empty docstring. Source code in griffe/dataclasses.py 345 346 347 348 @property def has_docstring ( self ) -> bool : \"\"\"Tell if this object has a non-empty docstring.\"\"\" return bool ( self . docstring ) # noqa: DAR201 has_docstrings ( self ) \u00a4 Tell if this object or any of its members has a non-empty docstring. Source code in griffe/dataclasses.py 350 351 352 353 354 355 356 357 358 @property def has_docstrings ( self ) -> bool : \"\"\"Tell if this object or any of its members has a non-empty docstring.\"\"\" if self . has_docstring : # noqa: DAR201 return True for member in self . members . values (): if ( not member . is_alias or member . resolved ) and member . has_docstring : # type: ignore[union-attr] return True return False has_labels ( self , labels ) \u00a4 Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 419 420 421 422 423 424 425 426 427 428 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) is_attribute ( self ) \u00a4 Tell if this object is an attribute. Source code in griffe/dataclasses.py 414 415 416 417 @property def is_attribute ( self ) -> bool : \"\"\"Tell if this object is an attribute.\"\"\" return self . kind is Kind . ATTRIBUTE # noqa: DAR201 is_class ( self ) \u00a4 Tell if this object is a class. Source code in griffe/dataclasses.py 404 405 406 407 @property def is_class ( self ) -> bool : \"\"\"Tell if this object is a class.\"\"\" return self . kind is Kind . CLASS # noqa: DAR201 is_function ( self ) \u00a4 Tell if this object is a function. Source code in griffe/dataclasses.py 409 410 411 412 @property def is_function ( self ) -> bool : \"\"\"Tell if this object is a function.\"\"\" return self . kind is Kind . FUNCTION # noqa: DAR201 is_kind ( self , kind ) \u00a4 Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Raises: ValueError \u2013 When an empty set is given as argument. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind is_module ( self ) \u00a4 Tell if this object is a module. Source code in griffe/dataclasses.py 399 400 401 402 @property def is_module ( self ) -> bool : \"\"\"Tell if this object is a module.\"\"\" return self . kind is Kind . MODULE # noqa: DAR201 lines ( self ) \u00a4 Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines. Source code in griffe/dataclasses.py 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] if isinstance ( filepath , list ): return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno try : lines = self . lines_collection [ filepath ] except KeyError : return [] if self . lineno is None or self . endlineno is None : return lines return lines [ self . lineno - 1 : self . endlineno ] lines_collection ( self ) \u00a4 Return the lines collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: LinesCollection \u2013 A lines collection. Source code in griffe/dataclasses.py 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection member_is_exported ( self , member , explicitely = True ) \u00a4 Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported, unless it's a module and it was not imported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely and ( member . is_alias or not member . is_module or member . name in self . imports ) return member . name in self . exports module ( self ) \u00a4 Return the parent module of this object. Raises: ValueError \u2013 When the object is not a module and does not have a parent. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError modules ( self ) \u00a4 Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules. Source code in griffe/dataclasses.py 447 448 449 450 451 452 453 454 @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc] modules_collection ( self ) \u00a4 Return the modules collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection package ( self ) \u00a4 Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 499 500 501 502 503 504 505 506 507 508 509 @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module path ( self ) \u00a4 Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 554 555 556 557 558 559 560 561 562 563 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path relative_filepath ( self ) \u00a4 Return the file path where this object was defined, relative to the top module path. Raises: ValueError \u2013 When the relative path could not be computed. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 @cached_property # noqa: WPS231 def relative_filepath ( self ) -> Path : # noqa: WPS231 \"\"\"Return the file path where this object was defined, relative to the top module path. Raises: ValueError: When the relative path could not be computed. Returns: A file path. \"\"\" package_path = self . package . filepath if isinstance ( self . module . filepath , list ): if isinstance ( package_path , list ): for pkg_path in package_path : for self_path in self . module . filepath : with suppress ( ValueError ): return self_path . relative_to ( pkg_path . parent ) else : for self_path in self . module . filepath : # noqa: WPS440 with suppress ( ValueError ): return self_path . relative_to ( package_path . parent . parent ) raise ValueError if isinstance ( package_path , list ): for pkg_path in package_path : # noqa: WPS440 with suppress ( ValueError ): return self . module . filepath . relative_to ( pkg_path . parent ) raise ValueError return self . module . filepath . relative_to ( package_path . parent . parent ) resolve ( self , name ) \u00a4 Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Raises: NameResolutionError \u2013 When the name could not be resolved. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members : if self . members [ name ] . is_alias : return self . members [ name ] . target_path # type: ignore[union-attr] return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) source ( self ) \u00a4 Return the source code of this object. Returns: str \u2013 The source code. Source code in griffe/dataclasses.py 636 637 638 639 640 641 642 643 @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) Parameter ( name , * , annotation = None , kind = None , default = None ) \u00a4 This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default as_dict ( self , ** kwargs ) \u00a4 Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , } ParameterKind \u00a4 Bases: enum . Enum Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter. Parameters ( * parameters ) \u00a4 This class is a container for parameters. It allows to get parameters using their position (index) or their name. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 222 223 224 225 226 227 228 229 230 231 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) add ( self , parameter ) \u00a4 Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Raises: ValueError \u2013 When a parameter with the same name is already present. Source code in griffe/dataclasses.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"dataclasses"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias","text":"Bases: ObjectAliasMixin This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( None ) \u2013 The alias parent. target_path ( str ) \u2013 The alias target path. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . target_path : str = target else : self . _target = target self . target_path = target . path if parent is not None : with suppress ( AliasResolutionError ): target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent self . _passed_through : bool = False","title":"Alias"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.as_dict","text":"Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.kind","text":"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind. Source code in griffe/dataclasses.py 807 808 809 810 811 812 813 814 815 816 817 818 @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except ( AliasResolutionError , CyclicAliasError ): return Kind . ALIAS","title":"kind()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.modules_collection","text":"Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 845 846 847 848 849 850 851 852 853 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent","title":"modules_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.path","text":"Return the dotted path / import path of this object. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 836 837 838 839 840 841 842 843 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent","title":"path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolve_target","text":"Resolve the target. Raises: AliasResolutionError \u2013 When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. CyclicAliasError \u2013 When the resolved target is the alias itself. Source code in griffe/dataclasses.py 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. CyclicAliasError: When the resolved target is the alias itself. \"\"\" try : resolved = self . modules_collection [ self . target_path ] except KeyError as error : raise AliasResolutionError ( self . target_path ) from error if resolved is self : raise CyclicAliasError ([ self . target_path ]) self . _target = resolved if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target","title":"resolve_target()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolved","text":"Tell whether this alias' target is resolved. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 899 900 901 902 903 904 905 906 @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None","title":"resolved()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.wildcard","text":"Return the module on which the wildcard import is performed (if any). Returns: str | None \u2013 The wildcard imported module, or None. Source code in griffe/dataclasses.py 908 909 910 911 912 913 914 915 916 917 @cached_property def wildcard ( self ) -> str | None : \"\"\"Return the module on which the wildcard import is performed (if any). Returns: The wildcard imported module, or None. \"\"\" if self . name . endswith ( \"/*\" ): return self . target_path return None","title":"wildcard()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute","text":"Bases: Object The class representing a Python module/class/instance attribute. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation","title":"Attribute"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.as_dict","text":"Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class","text":"Bases: Object The class representing a Python class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression | str ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or []","title":"Class"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.as_dict","text":"Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator","text":"This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Parameters: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 49 50 51 52 53 54 55 56 57 def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno","title":"Decorator"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.as_dict","text":"Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring","text":"This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {}","title":"Docstring"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.as_dict","text":"Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.lines","text":"Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines. Source code in griffe/dataclasses.py 122 123 124 125 126 127 128 129 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" )","title":"lines()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parse","text":"Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 140 141 142 143 144 145 146 147 148 149 150 151 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options ))","title":"parse()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parsed","text":"Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 131 132 133 134 135 136 137 138 @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse ()","title":"parsed()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function","text":"Bases: Object The class representing a Python function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or []","title":"Function"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.annotation","text":"Return the return annotation. Returns: str | Name | Expression | None \u2013 The function return annotation. Source code in griffe/dataclasses.py 1124 1125 1126 1127 1128 1129 1130 1131 @property def annotation ( self ) -> str | Name | Expression | None : \"\"\"Return the return annotation. Returns: The function return annotation. \"\"\" return self . returns","title":"annotation()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.as_dict","text":"Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind","text":"Bases: enum . Enum Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind.","title":"Kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module","text":"Bases: Object The class representing a Python module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path | list [ Path ] | None ) \u2013 The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 946 947 948 949 950 951 952 953 954 955 def __init__ ( self , * args : Any , filepath : Path | list [ Path ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | list [ Path ] | None = filepath","title":"Module"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.as_dict","text":"Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.filepath","text":"Get the file path of this module. Raises: BuiltinModuleError \u2013 When the instance filepath is None. Returns: Path | list [ Path ] \u2013 The module's file path. Source code in griffe/dataclasses.py 968 969 970 971 972 973 974 975 976 977 978 979 980 @property def filepath ( self ) -> Path | list [ Path ]: \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath","title":"filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_init_module","text":"Tell if this module is an __init__.py module. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 982 983 984 985 986 987 988 989 990 991 992 993 994 @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" if isinstance ( self . filepath , list ): return False try : return self . filepath . name . split ( \".\" , 1 )[ 0 ] == \"__init__\" except BuiltinModuleError : return False","title":"is_init_module()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_package","text":"Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return self . parent is None and isinstance ( self . filepath , list ) except BuiltinModuleError : return False","title":"is_namespace_package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_subpackage","text":"Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and isinstance ( self . filepath , list ) and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False","title":"is_namespace_subpackage()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_package","text":"Tell if this module is a package (top module). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 996 997 998 999 1000 1001 1002 1003 @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module","title":"is_package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_subpackage","text":"Tell if this module is a subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 1005 1006 1007 1008 1009 1010 1011 1012 @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module","title":"is_subpackage()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object","text":"Bases: GetMembersMixin , SetMembersMixin , ObjectAliasMixin An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self","title":"Object"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.as_dict","text":"Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.attributes","text":"Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes. Source code in griffe/dataclasses.py 474 475 476 477 478 479 480 481 @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc]","title":"attributes()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.canonical_path","text":"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 565 566 567 568 569 570 571 572 573 574 575 576 @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if self . parent is None : return self . name return \".\" . join (( self . parent . path , self . name ))","title":"canonical_path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.classes","text":"Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes. Source code in griffe/dataclasses.py 456 457 458 459 460 461 462 463 @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc]","title":"classes()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filepath","text":"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Path | list [ Path ] \u2013 A file path or a list of directories. Source code in griffe/dataclasses.py 511 512 513 514 515 516 517 518 519 520 521 522 523 @cached_property def filepath ( self ) -> Path | list [ Path ]: \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path or a list of directories. \"\"\" return self . module . filepath","title":"filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filter_members","text":"Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members","title":"filter_members()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.functions","text":"Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions. Source code in griffe/dataclasses.py 465 466 467 468 469 470 471 472 @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc]","title":"functions()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstring","text":"Tell if this object has a non-empty docstring. Source code in griffe/dataclasses.py 345 346 347 348 @property def has_docstring ( self ) -> bool : \"\"\"Tell if this object has a non-empty docstring.\"\"\" return bool ( self . docstring ) # noqa: DAR201","title":"has_docstring()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstrings","text":"Tell if this object or any of its members has a non-empty docstring. Source code in griffe/dataclasses.py 350 351 352 353 354 355 356 357 358 @property def has_docstrings ( self ) -> bool : \"\"\"Tell if this object or any of its members has a non-empty docstring.\"\"\" if self . has_docstring : # noqa: DAR201 return True for member in self . members . values (): if ( not member . is_alias or member . resolved ) and member . has_docstring : # type: ignore[union-attr] return True return False","title":"has_docstrings()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_labels","text":"Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 419 420 421 422 423 424 425 426 427 428 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels )","title":"has_labels()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_attribute","text":"Tell if this object is an attribute. Source code in griffe/dataclasses.py 414 415 416 417 @property def is_attribute ( self ) -> bool : \"\"\"Tell if this object is an attribute.\"\"\" return self . kind is Kind . ATTRIBUTE # noqa: DAR201","title":"is_attribute()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_class","text":"Tell if this object is a class. Source code in griffe/dataclasses.py 404 405 406 407 @property def is_class ( self ) -> bool : \"\"\"Tell if this object is a class.\"\"\" return self . kind is Kind . CLASS # noqa: DAR201","title":"is_class()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_function","text":"Tell if this object is a function. Source code in griffe/dataclasses.py 409 410 411 412 @property def is_function ( self ) -> bool : \"\"\"Tell if this object is a function.\"\"\" return self . kind is Kind . FUNCTION # noqa: DAR201","title":"is_function()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_kind","text":"Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Raises: ValueError \u2013 When an empty set is given as argument. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind","title":"is_kind()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_module","text":"Tell if this object is a module. Source code in griffe/dataclasses.py 399 400 401 402 @property def is_module ( self ) -> bool : \"\"\"Tell if this object is a module.\"\"\" return self . kind is Kind . MODULE # noqa: DAR201","title":"is_module()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines","text":"Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines. Source code in griffe/dataclasses.py 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] if isinstance ( filepath , list ): return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno try : lines = self . lines_collection [ filepath ] except KeyError : return [] if self . lineno is None or self . endlineno is None : return lines return lines [ self . lineno - 1 : self . endlineno ]","title":"lines()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines_collection","text":"Return the lines collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: LinesCollection \u2013 A lines collection. Source code in griffe/dataclasses.py 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection","title":"lines_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.member_is_exported","text":"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported, unless it's a module and it was not imported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely and ( member . is_alias or not member . is_module or member . name in self . imports ) return member . name in self . exports","title":"member_is_exported()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.module","text":"Return the parent module of this object. Raises: ValueError \u2013 When the object is not a module and does not have a parent. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError","title":"module()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules","text":"Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules. Source code in griffe/dataclasses.py 447 448 449 450 451 452 453 454 @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc]","title":"modules()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules_collection","text":"Return the modules collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection","title":"modules_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.package","text":"Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 499 500 501 502 503 504 505 506 507 508 509 @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module","title":"package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.path","text":"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 554 555 556 557 558 559 560 561 562 563 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path","title":"path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.relative_filepath","text":"Return the file path where this object was defined, relative to the top module path. Raises: ValueError \u2013 When the relative path could not be computed. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 @cached_property # noqa: WPS231 def relative_filepath ( self ) -> Path : # noqa: WPS231 \"\"\"Return the file path where this object was defined, relative to the top module path. Raises: ValueError: When the relative path could not be computed. Returns: A file path. \"\"\" package_path = self . package . filepath if isinstance ( self . module . filepath , list ): if isinstance ( package_path , list ): for pkg_path in package_path : for self_path in self . module . filepath : with suppress ( ValueError ): return self_path . relative_to ( pkg_path . parent ) else : for self_path in self . module . filepath : # noqa: WPS440 with suppress ( ValueError ): return self_path . relative_to ( package_path . parent . parent ) raise ValueError if isinstance ( package_path , list ): for pkg_path in package_path : # noqa: WPS440 with suppress ( ValueError ): return self . module . filepath . relative_to ( pkg_path . parent ) raise ValueError return self . module . filepath . relative_to ( package_path . parent . parent )","title":"relative_filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.resolve","text":"Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Raises: NameResolutionError \u2013 When the name could not be resolved. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members : if self . members [ name ] . is_alias : return self . members [ name ] . target_path # type: ignore[union-attr] return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name )","title":"resolve()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.source","text":"Return the source code of this object. Returns: str \u2013 The source code. Source code in griffe/dataclasses.py 636 637 638 639 640 641 642 643 @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines ))","title":"source()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter","text":"This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default","title":"Parameter"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.as_dict","text":"Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind","text":"Bases: enum . Enum Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter.","title":"ParameterKind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters","text":"This class is a container for parameters. It allows to get parameters using their position (index) or their name. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 222 223 224 225 226 227 228 229 230 231 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter )","title":"Parameters"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.add","text":"Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Raises: ValueError \u2013 When a parameter with the same name is already present. Source code in griffe/dataclasses.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"add()"},{"location":"reference/griffe/encoders/","text":"This module contains data encoders/serializers and decoders/deserializers. The available formats are: JSON : see the JSONEncoder and json_decoder . JSONEncoder ( * args , full = False , docstring_parser = None , docstring_options = None , ** kwargs ) \u00a4 Bases: json . JSONEncoder JSON encoder. JSON encoders can be used directly, or through the json.dump or json.dumps methods. Examples: Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the json_decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [`json_decoder`][griffe.encoders.json_decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} default ( self , obj ) \u00a4 Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 89 90 91 92 93 94 95 96 97 98 99 100 101 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _json_encoder_map . get ( type ( obj ), super () . default )( obj ) json_decoder ( obj_dict ) \u00a4 Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Examples: Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Object | Alias | Parameter \u2013 An instance of a data class. Source code in griffe/encoders.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def json_decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Object | Alias | Parameter : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Examples: >>> import json >>> from griffe.encoders import json_decoder >>> json.loads(..., object_hook=json_decoder) Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : try : kind = Kind ( obj_dict [ \"kind\" ]) except ValueError : return _load_parameter ( obj_dict ) return _loader_map [ kind ]( obj_dict ) return obj_dict","title":"encoders"},{"location":"reference/griffe/encoders/#griffe.encoders.JSONEncoder","text":"Bases: json . JSONEncoder JSON encoder. JSON encoders can be used directly, or through the json.dump or json.dumps methods. Examples: Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the json_decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [`json_decoder`][griffe.encoders.json_decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {}","title":"JSONEncoder"},{"location":"reference/griffe/encoders/#griffe.encoders.JSONEncoder.default","text":"Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 89 90 91 92 93 94 95 96 97 98 99 100 101 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _json_encoder_map . get ( type ( obj ), super () . default )( obj )","title":"default()"},{"location":"reference/griffe/encoders/#griffe.encoders.json_decoder","text":"Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Examples: Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Object | Alias | Parameter \u2013 An instance of a data class. Source code in griffe/encoders.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def json_decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Object | Alias | Parameter : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Examples: >>> import json >>> from griffe.encoders import json_decoder >>> json.loads(..., object_hook=json_decoder) Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : try : kind = Kind ( obj_dict [ \"kind\" ]) except ValueError : return _load_parameter ( obj_dict ) return _loader_map [ kind ]( obj_dict ) return obj_dict","title":"json_decoder()"},{"location":"reference/griffe/exceptions/","text":"This module contains all the exceptions specific to Griffe. AliasResolutionError ( target_path ) \u00a4 Bases: GriffeError Exception for alias that cannot be resolved. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 30 31 32 33 34 35 36 37 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"Could not resolve { self . target_path } \" ) BuiltinModuleError \u00a4 Bases: GriffeError Exception raised when trying to access the filepath of a builtin module. CyclicAliasError ( chain ) \u00a4 Bases: GriffeError Exception raised when a cycle is detected in aliases. Parameters: chain ( list [ str ] ) \u2013 The cyclic chain of items (such as target path). Source code in griffe/exceptions.py 43 44 45 46 47 48 49 50 def __init__ ( self , chain : list [ str ]) -> None : \"\"\"Initialize the exception. Parameters: chain: The cyclic chain of items (such as target path). \"\"\" self . chain : list [ str ] = chain super () . __init__ ( \"Cyclic aliases detected: \\n \" + \" \\n \" . join ( self . chain )) ExtensionError \u00a4 Bases: GriffeError Base class for errors raised by extensions. ExtensionNotLoadedError \u00a4 Bases: ExtensionError Exception raised when an extension could not be loaded. GriffeError \u00a4 Bases: Exception The base exception for all Griffe errors. LastNodeError \u00a4 Bases: GriffeError Exception raised when trying to access a next or previous node. LoadingError \u00a4 Bases: GriffeError The base exception for all Griffe errors. NameResolutionError \u00a4 Bases: GriffeError Exception for names that cannot be resolved in a object scope. RootNodeError \u00a4 Bases: GriffeError Exception raised when trying to use siblings properties on a root node. UnhandledEditablesModuleError \u00a4 Bases: GriffeError Exception for unhandled editables modules, when searching modules. UnhandledPthFileError \u00a4 Bases: GriffeError Exception for unhandled .pth files, when searching modules. UnimportableModuleError \u00a4 Bases: GriffeError Exception for modules that cannot be imported.","title":"exceptions"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError","text":"Bases: GriffeError Exception for alias that cannot be resolved. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 30 31 32 33 34 35 36 37 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"Could not resolve { self . target_path } \" )","title":"AliasResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.BuiltinModuleError","text":"Bases: GriffeError Exception raised when trying to access the filepath of a builtin module.","title":"BuiltinModuleError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.CyclicAliasError","text":"Bases: GriffeError Exception raised when a cycle is detected in aliases. Parameters: chain ( list [ str ] ) \u2013 The cyclic chain of items (such as target path). Source code in griffe/exceptions.py 43 44 45 46 47 48 49 50 def __init__ ( self , chain : list [ str ]) -> None : \"\"\"Initialize the exception. Parameters: chain: The cyclic chain of items (such as target path). \"\"\" self . chain : list [ str ] = chain super () . __init__ ( \"Cyclic aliases detected: \\n \" + \" \\n \" . join ( self . chain ))","title":"CyclicAliasError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionError","text":"Bases: GriffeError Base class for errors raised by extensions.","title":"ExtensionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionNotLoadedError","text":"Bases: ExtensionError Exception raised when an extension could not be loaded.","title":"ExtensionNotLoadedError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.GriffeError","text":"Bases: Exception The base exception for all Griffe errors.","title":"GriffeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LastNodeError","text":"Bases: GriffeError Exception raised when trying to access a next or previous node.","title":"LastNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LoadingError","text":"Bases: GriffeError The base exception for all Griffe errors.","title":"LoadingError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.NameResolutionError","text":"Bases: GriffeError Exception for names that cannot be resolved in a object scope.","title":"NameResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.RootNodeError","text":"Bases: GriffeError Exception raised when trying to use siblings properties on a root node.","title":"RootNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnhandledEditablesModuleError","text":"Bases: GriffeError Exception for unhandled editables modules, when searching modules.","title":"UnhandledEditablesModuleError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnhandledPthFileError","text":"Bases: GriffeError Exception for unhandled .pth files, when searching modules.","title":"UnhandledPthFileError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnimportableModuleError","text":"Bases: GriffeError Exception for modules that cannot be imported.","title":"UnimportableModuleError"},{"location":"reference/griffe/expressions/","text":"This module contains the data classes that represent resolvable names and expressions. Expression ( * values ) \u00a4 Bases: list This class represents a Python expression. For example, it can represent complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 81 82 83 84 85 86 87 88 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) full ( self ) \u00a4 Return self as a string. This property is only useful to the AST utils. Returns: str \u2013 Self as a string. Source code in griffe/expressions.py 110 111 112 113 114 115 116 117 118 119 @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self ) is_tuple ( self ) \u00a4 Tell whether this expression represents a tuple. Returns: bool \u2013 True or False. Source code in griffe/expressions.py 121 122 123 124 125 126 127 128 @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\" tuple_item ( self , nth ) \u00a4 Return the n-th item of this tuple expression. Parameters: nth ( int ) \u2013 The item number. Returns: str | Name \u2013 A string or name. Source code in griffe/expressions.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ] Name ( source , full ) \u00a4 This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full as_dict ( self , ** kwargs ) \u00a4 Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 69 70 71 72 73 74 75 76 77 78 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full } brief ( self ) \u00a4 Return the brief source name. Returns: str \u2013 The last part of the source name. Source code in griffe/expressions.py 60 61 62 63 64 65 66 67 @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ] full ( self ) \u00a4 Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source. Source code in griffe/expressions.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full","title":"expressions"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression","text":"Bases: list This class represents a Python expression. For example, it can represent complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 81 82 83 84 85 86 87 88 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values )","title":"Expression"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.full","text":"Return self as a string. This property is only useful to the AST utils. Returns: str \u2013 Self as a string. Source code in griffe/expressions.py 110 111 112 113 114 115 116 117 118 119 @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self )","title":"full()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_tuple","text":"Tell whether this expression represents a tuple. Returns: bool \u2013 True or False. Source code in griffe/expressions.py 121 122 123 124 125 126 127 128 @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\"","title":"is_tuple()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.tuple_item","text":"Return the n-th item of this tuple expression. Parameters: nth ( int ) \u2013 The item number. Returns: str | Name \u2013 A string or name. Source code in griffe/expressions.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ]","title":"tuple_item()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name","text":"This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full","title":"Name"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.as_dict","text":"Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 69 70 71 72 73 74 75 76 77 78 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full }","title":"as_dict()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.brief","text":"Return the brief source name. Returns: str \u2013 The last part of the source name. Source code in griffe/expressions.py 60 61 62 63 64 65 66 67 @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ]","title":"brief()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.full","text":"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source. Source code in griffe/expressions.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full","title":"full()"},{"location":"reference/griffe/finder/","text":"This module contains the code allowing to find modules. ModuleFinder ( search_paths = None ) \u00a4 The Griffe finder, allowing to find modules on the file system. Parameters: search_paths ( Sequence [ str | Path ] | None ) \u2013 Optional paths to search into. Source code in griffe/finder.py 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , search_paths : Sequence [ str | Path ] | None = None ) -> None : \"\"\"Initialize the finder. Parameters: search_paths: Optional paths to search into. \"\"\" self . _paths_contents : dict [ Path , list [ Path ]] = {} # optimization: pre-compute Paths to relieve CPU when joining paths self . search_paths = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] if bool ( search_paths ): # without custom search paths, sys.path is used, and is already extended from .pth files self . _extend_from_pth_files () self . _extend_from_editables_modules () find_module ( self , module_name ) \u00a4 Find a module. Parameters: module_name ( str ) \u2013 The module name. Raises: ModuleNotFoundError \u2013 When the module cannot be found. Returns: Path | list [ Path ] \u2013 The module file path. Source code in griffe/finder.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def find_module ( self , module_name : str ) -> Path | list [ Path ]: # noqa: WPS231 \"\"\"Find a module. Parameters: module_name: The module name. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" filepaths = [ Path ( module_name ), # TODO: handle .py[cod] and .so files? Path ( f \" { module_name } .py\" ), ] namespace_dirs = [] for path in self . search_paths : # noqa: WPS440 path_contents = self . _contents ( path ) if path_contents : for choice in filepaths : abs_path = path / choice if abs_path in path_contents : if abs_path . suffix : return abs_path else : init_module = abs_path / \"__init__.py\" if init_module . exists (): return init_module else : namespace_dirs . append ( abs_path ) if namespace_dirs : return namespace_dirs raise ModuleNotFoundError ( module_name ) find_spec ( self , module , try_relative_path = True ) \u00a4 Find the top module of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module ( str | Path ) \u2013 The module name or path. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError \u2013 When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist ModuleNotFoundError \u2013 When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file Returns: tuple [ str , Package ] \u2013 The name of the module (or package), the name of its top module, and the path(s) of its top module. Source code in griffe/finder.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def find_spec ( self , module : str | Path , try_relative_path : bool = True , ) -> tuple [ str , Package ]: \"\"\"Find the top module of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module: The module name or path. try_relative_path: Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError: When a Path was passed and the module could not be found: - the directory has no `__init__.py` file in it - the path does not exist ModuleNotFoundError: When a string was passed and the module could not be found: - no `module/__init__.py` - no `module.py` - no `module.pth` - no `module` directory (namespace packages) - or unsupported .pth file Returns: The name of the module (or package), the name of its top module, and the path(s) of its top module. \"\"\" module_path : Path | list [ Path ] top_module_path : Path | list [ Path ] if isinstance ( module , Path ): module_name , module_path = self . _module_name_path ( module ) # type: ignore[arg-type] top_module_name = self . _top_module_name ( module_path ) elif try_relative_path : try : module_name , module_path = self . _module_name_path ( Path ( module )) except FileNotFoundError : module_name = module # type: ignore[assignment] top_module_name = module . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] else : top_module_name = self . _top_module_name ( module_path ) else : module_name = module top_module_name = module . split ( \".\" , 1 )[ 0 ] top_module_path = self . find_module ( top_module_name ) return module_name , Package ( top_module_name , top_module_path ) iter_submodules ( self , path ) \u00a4 Iterate on a module's submodules, if any. Parameters: path ( Path | list [ Path ] ) \u2013 The module path. Yields: name_parts ( tuple [ str , ...] ) \u2013 The parts of a submodule name. filepath ( Path ) \u2013 A submodule filepath. Source code in griffe/finder.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def iter_submodules ( self , path : Path | list [ Path ]) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS231,WPS234 \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. Yields: name_parts (tuple[str, ...]): The parts of a submodule name. filepath (Path): A submodule filepath. \"\"\" if isinstance ( path , list ): for path_elem in path : yield from self . iter_submodules ( path_elem ) return if path . stem == \"__init__\" : path = path . parent # optimization: just check if the file name ends with .py[cod]/.so # (to distinguish it from a directory), # not if it's an actual file elif path . suffix in self . extensions_set : return for subpath in self . _filter_py_modules ( path ): rel_subpath = subpath . relative_to ( path ) py_file = rel_subpath . suffix == \".py\" stem = rel_subpath . stem if not py_file : # .py[cod] and .so files look like `name.cpython-38-x86_64-linux-gnu.ext` stem = stem . split ( \".\" , 1 )[ 0 ] if stem == \"__init__\" : # optimization: since it's a relative path, # if it has only one part and is named __init__, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath elif py_file : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath else : yield rel_subpath . with_name ( stem ) . parts , subpath submodules ( self , module ) \u00a4 Return the list of a module's submodules. Parameters: module ( Module ) \u2013 The parent module. Returns: list [ NamePartsAndPathType ] \u2013 A list of tuples containing the parts of the submodule name and its path. Source code in griffe/finder.py 195 196 197 198 199 200 201 202 203 204 def submodules ( self , module : Module ) -> list [ NamePartsAndPathType ]: \"\"\"Return the list of a module's submodules. Parameters: module: The parent module. Returns: A list of tuples containing the parts of the submodule name and its path. \"\"\" return sorted ( self . iter_submodules ( module . filepath ), key = _module_depth ) Package ( name , path ) \u00a4 This class is a simple placeholder used during the process of finding modules. Parameters: name ( str ) \u2013 The package name. path ( Path | list [ Path ] ) \u2013 The package path(s). Source code in griffe/finder.py 18 19 20 21 22 23 24 25 26 def __init__ ( self , name : str , path : Path | list [ Path ]) -> None : \"\"\"Initialize the package. Parameters: name: The package name. path: The package path(s). \"\"\" self . name : str = name self . path : Path | list [ Path ] = path is_namespace ( self ) \u00a4 Tell if this package is a namespace one. Returns: bool \u2013 True or false. Source code in griffe/finder.py 31 32 33 34 35 36 37 38 @property def is_namespace ( self ) -> bool : \"\"\"Tell if this package is a namespace one. Returns: True or false. \"\"\" return isinstance ( self . path , list )","title":"finder"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder","text":"The Griffe finder, allowing to find modules on the file system. Parameters: search_paths ( Sequence [ str | Path ] | None ) \u2013 Optional paths to search into. Source code in griffe/finder.py 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , search_paths : Sequence [ str | Path ] | None = None ) -> None : \"\"\"Initialize the finder. Parameters: search_paths: Optional paths to search into. \"\"\" self . _paths_contents : dict [ Path , list [ Path ]] = {} # optimization: pre-compute Paths to relieve CPU when joining paths self . search_paths = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] if bool ( search_paths ): # without custom search paths, sys.path is used, and is already extended from .pth files self . _extend_from_pth_files () self . _extend_from_editables_modules ()","title":"ModuleFinder"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.find_module","text":"Find a module. Parameters: module_name ( str ) \u2013 The module name. Raises: ModuleNotFoundError \u2013 When the module cannot be found. Returns: Path | list [ Path ] \u2013 The module file path. Source code in griffe/finder.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def find_module ( self , module_name : str ) -> Path | list [ Path ]: # noqa: WPS231 \"\"\"Find a module. Parameters: module_name: The module name. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" filepaths = [ Path ( module_name ), # TODO: handle .py[cod] and .so files? Path ( f \" { module_name } .py\" ), ] namespace_dirs = [] for path in self . search_paths : # noqa: WPS440 path_contents = self . _contents ( path ) if path_contents : for choice in filepaths : abs_path = path / choice if abs_path in path_contents : if abs_path . suffix : return abs_path else : init_module = abs_path / \"__init__.py\" if init_module . exists (): return init_module else : namespace_dirs . append ( abs_path ) if namespace_dirs : return namespace_dirs raise ModuleNotFoundError ( module_name )","title":"find_module()"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.find_spec","text":"Find the top module of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module ( str | Path ) \u2013 The module name or path. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError \u2013 When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist ModuleNotFoundError \u2013 When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file Returns: tuple [ str , Package ] \u2013 The name of the module (or package), the name of its top module, and the path(s) of its top module. Source code in griffe/finder.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def find_spec ( self , module : str | Path , try_relative_path : bool = True , ) -> tuple [ str , Package ]: \"\"\"Find the top module of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module: The module name or path. try_relative_path: Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError: When a Path was passed and the module could not be found: - the directory has no `__init__.py` file in it - the path does not exist ModuleNotFoundError: When a string was passed and the module could not be found: - no `module/__init__.py` - no `module.py` - no `module.pth` - no `module` directory (namespace packages) - or unsupported .pth file Returns: The name of the module (or package), the name of its top module, and the path(s) of its top module. \"\"\" module_path : Path | list [ Path ] top_module_path : Path | list [ Path ] if isinstance ( module , Path ): module_name , module_path = self . _module_name_path ( module ) # type: ignore[arg-type] top_module_name = self . _top_module_name ( module_path ) elif try_relative_path : try : module_name , module_path = self . _module_name_path ( Path ( module )) except FileNotFoundError : module_name = module # type: ignore[assignment] top_module_name = module . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] else : top_module_name = self . _top_module_name ( module_path ) else : module_name = module top_module_name = module . split ( \".\" , 1 )[ 0 ] top_module_path = self . find_module ( top_module_name ) return module_name , Package ( top_module_name , top_module_path )","title":"find_spec()"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.iter_submodules","text":"Iterate on a module's submodules, if any. Parameters: path ( Path | list [ Path ] ) \u2013 The module path. Yields: name_parts ( tuple [ str , ...] ) \u2013 The parts of a submodule name. filepath ( Path ) \u2013 A submodule filepath. Source code in griffe/finder.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def iter_submodules ( self , path : Path | list [ Path ]) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS231,WPS234 \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. Yields: name_parts (tuple[str, ...]): The parts of a submodule name. filepath (Path): A submodule filepath. \"\"\" if isinstance ( path , list ): for path_elem in path : yield from self . iter_submodules ( path_elem ) return if path . stem == \"__init__\" : path = path . parent # optimization: just check if the file name ends with .py[cod]/.so # (to distinguish it from a directory), # not if it's an actual file elif path . suffix in self . extensions_set : return for subpath in self . _filter_py_modules ( path ): rel_subpath = subpath . relative_to ( path ) py_file = rel_subpath . suffix == \".py\" stem = rel_subpath . stem if not py_file : # .py[cod] and .so files look like `name.cpython-38-x86_64-linux-gnu.ext` stem = stem . split ( \".\" , 1 )[ 0 ] if stem == \"__init__\" : # optimization: since it's a relative path, # if it has only one part and is named __init__, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath elif py_file : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath else : yield rel_subpath . with_name ( stem ) . parts , subpath","title":"iter_submodules()"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.submodules","text":"Return the list of a module's submodules. Parameters: module ( Module ) \u2013 The parent module. Returns: list [ NamePartsAndPathType ] \u2013 A list of tuples containing the parts of the submodule name and its path. Source code in griffe/finder.py 195 196 197 198 199 200 201 202 203 204 def submodules ( self , module : Module ) -> list [ NamePartsAndPathType ]: \"\"\"Return the list of a module's submodules. Parameters: module: The parent module. Returns: A list of tuples containing the parts of the submodule name and its path. \"\"\" return sorted ( self . iter_submodules ( module . filepath ), key = _module_depth )","title":"submodules()"},{"location":"reference/griffe/finder/#griffe.finder.Package","text":"This class is a simple placeholder used during the process of finding modules. Parameters: name ( str ) \u2013 The package name. path ( Path | list [ Path ] ) \u2013 The package path(s). Source code in griffe/finder.py 18 19 20 21 22 23 24 25 26 def __init__ ( self , name : str , path : Path | list [ Path ]) -> None : \"\"\"Initialize the package. Parameters: name: The package name. path: The package path(s). \"\"\" self . name : str = name self . path : Path | list [ Path ] = path","title":"Package"},{"location":"reference/griffe/finder/#griffe.finder.Package.is_namespace","text":"Tell if this package is a namespace one. Returns: bool \u2013 True or false. Source code in griffe/finder.py 31 32 33 34 35 36 37 38 @property def is_namespace ( self ) -> bool : \"\"\"Tell if this package is a namespace one. Returns: True or false. \"\"\" return isinstance ( self . path , list )","title":"is_namespace()"},{"location":"reference/griffe/importer/","text":"This module contains utilities to dynamically import objects. dynamic_import ( import_path , import_paths = None ) \u00a4 Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path ( str ) \u2013 The path of the object to import. import_paths ( list [ Path ] | None ) \u2013 The paths to import the object from. Raises: ModuleNotFoundError \u2013 When the object's module could not be found. ImportError \u2013 When there was an import error or when couldn't get the attribute. Returns: Any \u2013 The imported object. Source code in griffe/importer.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def dynamic_import ( import_path : str , import_paths : list [ Path ] | None = None ) -> Any : # noqa: WPS231 \"\"\"Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path: The path of the object to import. import_paths: The paths to import the object from. Raises: ModuleNotFoundError: When the object's module could not be found. ImportError: When there was an import error or when couldn't get the attribute. Returns: The imported object. \"\"\" module_parts : list [ str ] = import_path . split ( \".\" ) object_parts : list [ str ] = [] errors = [] with sys_path ( * ( import_paths or ())): while True : module_path = \".\" . join ( module_parts ) try : # noqa: WPS503 (false-positive) module = import_module ( module_path ) except ModuleNotFoundError as error : if len ( module_parts ) == 1 : raise errors . append ( str ( error )) object_parts . insert ( 0 , module_parts . pop ( - 1 )) else : break # Sometimes extra dependencies are not installed, # and therefore we aren't able to import the leaf module, # so we end up with its parent instead, on which we can't # get the attribute either. In that case we re-raise an # ImportError for consistency. # See https://github.com/mkdocstrings/mkdocstrings/issues/380 value = module for part in object_parts : try : value = getattr ( value , part ) except AttributeError as error : # noqa: WPS440 raise ImportError ( \" \\n \" . join ( errors )) from error return value sys_path ( * paths ) \u00a4 Redefine sys.path temporarily. Parameters: *paths ( str | Path ) \u2013 The paths to use when importing modules. If no paths are given, keep sys.path untouched. Yields: Iterator [None] \u2013 Nothing. Source code in griffe/importer.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @contextmanager def sys_path ( * paths : str | Path ) -> Iterator [ None ]: \"\"\"Redefine `sys.path` temporarily. Parameters: *paths: The paths to use when importing modules. If no paths are given, keep `sys.path` untouched. Yields: Nothing. \"\"\" if not paths : yield return old_path = sys . path sys . path = [ str ( path ) for path in paths ] try : yield finally : sys . path = old_path","title":"importer"},{"location":"reference/griffe/importer/#griffe.importer.dynamic_import","text":"Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path ( str ) \u2013 The path of the object to import. import_paths ( list [ Path ] | None ) \u2013 The paths to import the object from. Raises: ModuleNotFoundError \u2013 When the object's module could not be found. ImportError \u2013 When there was an import error or when couldn't get the attribute. Returns: Any \u2013 The imported object. Source code in griffe/importer.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def dynamic_import ( import_path : str , import_paths : list [ Path ] | None = None ) -> Any : # noqa: WPS231 \"\"\"Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path: The path of the object to import. import_paths: The paths to import the object from. Raises: ModuleNotFoundError: When the object's module could not be found. ImportError: When there was an import error or when couldn't get the attribute. Returns: The imported object. \"\"\" module_parts : list [ str ] = import_path . split ( \".\" ) object_parts : list [ str ] = [] errors = [] with sys_path ( * ( import_paths or ())): while True : module_path = \".\" . join ( module_parts ) try : # noqa: WPS503 (false-positive) module = import_module ( module_path ) except ModuleNotFoundError as error : if len ( module_parts ) == 1 : raise errors . append ( str ( error )) object_parts . insert ( 0 , module_parts . pop ( - 1 )) else : break # Sometimes extra dependencies are not installed, # and therefore we aren't able to import the leaf module, # so we end up with its parent instead, on which we can't # get the attribute either. In that case we re-raise an # ImportError for consistency. # See https://github.com/mkdocstrings/mkdocstrings/issues/380 value = module for part in object_parts : try : value = getattr ( value , part ) except AttributeError as error : # noqa: WPS440 raise ImportError ( \" \\n \" . join ( errors )) from error return value","title":"dynamic_import()"},{"location":"reference/griffe/importer/#griffe.importer.sys_path","text":"Redefine sys.path temporarily. Parameters: *paths ( str | Path ) \u2013 The paths to use when importing modules. If no paths are given, keep sys.path untouched. Yields: Iterator [None] \u2013 Nothing. Source code in griffe/importer.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @contextmanager def sys_path ( * paths : str | Path ) -> Iterator [ None ]: \"\"\"Redefine `sys.path` temporarily. Parameters: *paths: The paths to use when importing modules. If no paths are given, keep `sys.path` untouched. Yields: Nothing. \"\"\" if not paths : yield return old_path = sys . path sys . path = [ str ( path ) for path in paths ] try : yield finally : sys . path = old_path","title":"sys_path()"},{"location":"reference/griffe/loader/","text":"This module contains the code allowing to load modules data. This is the entrypoint to use griffe programatically: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) GriffeLoader ( extensions = None , search_paths = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 The Griffe loader, allowing to load data from modules. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/loader.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. search_paths: The paths to search into. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () self . finder : ModuleFinder = ModuleFinder ( search_paths ) self . _time_stats : dict = { \"time_spent_visiting\" : 0 , \"time_spent_inspecting\" : 0 , } patch_ast () expand_wildcards ( self , obj , seen = None ) \u00a4 Expand wildcards: try to recursively expand all found wildcards. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. seen ( set | None ) \u2013 Used to avoid infinite recursion. Source code in griffe/loader.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def expand_wildcards ( self , obj : Object , seen : set | None = None ) -> None : # noqa: WPS231 \"\"\"Expand wildcards: try to recursively expand all found wildcards. Parameters: obj: The object and its members to recurse on. seen: Used to avoid infinite recursion. \"\"\" expanded = {} to_remove = [] seen = seen or set () seen . add ( obj . path ) for member in obj . members . values (): if member . is_alias and member . wildcard : # type: ignore[union-attr] # we know it's an alias package = member . wildcard . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] if obj . package . path != package and package not in self . modules_collection : try : self . load_module ( package , try_relative_path = False ) except ImportError as error : logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) continue self . expand_wildcards ( self . modules_collection [ member . target_path ]) # type: ignore[union-attr] expanded . update ( self . _expand_wildcard ( member )) # type: ignore[arg-type] to_remove . append ( member . name ) elif not member . is_alias and member . is_module and member . path not in seen : self . expand_wildcards ( member , seen ) # type: ignore[arg-type] for name in to_remove : del obj [ name ] # noqa: WPS420 for new_member in list ( expanded . values ()): if new_member . is_alias : try : # TODO: maybe don't shortcut aliases: # we want to keep public paths alias = Alias ( new_member . name , new_member . target ) # type: ignore[union-attr] except AliasResolutionError : alias = new_member # type: ignore[assignment] # noqa: WPS437 except CyclicAliasError as error : # noqa: WPS440 logger . debug ( str ( error )) continue else : alias = Alias ( new_member . name , new_member ) obj [ new_member . name ] = alias load_module ( self , module , submodules = True , try_relative_path = True ) \u00a4 Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. Raises: LoadingError \u2013 When loading a module failed for various reasons. Returns: Module \u2013 A module. Source code in griffe/loader.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def load_module ( self , module : str | Path , submodules : bool = True , try_relative_path : bool = True , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. try_relative_path: Whether to try finding the module as a relative path. Raises: LoadingError: When loading a module failed for various reasons. Returns: A module. \"\"\" module_name : str if module in _builtin_modules : logger . debug ( f \" { module } is a builtin module: inspecting\" ) module_name = module # type: ignore[assignment] top_module = self . _inspect_module ( module ) # type: ignore[arg-type] return self . _store_and_return ( module_name , top_module ) try : module_name , package = self . finder . find_spec ( module , try_relative_path ) except ModuleNotFoundError : logger . debug ( f \"Could not find { module } : trying inspection\" ) module_name = module # type: ignore[assignment] top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : logger . debug ( f \"Found { module } : loading\" ) try : # noqa: WPS505 top_module = self . _load_module ( package . name , package . path , submodules = submodules ) except LoadingError as error : # noqa: WPS440 logger . error ( str ( error )) raise return self . _store_and_return ( module_name , top_module ) resolve_aliases ( self , only_exported = True , only_known_modules = True , max_iterations = None ) \u00a4 Resolve aliases. Parameters: only_exported ( bool ) \u2013 When true, only try to resolve an alias if it is explicitely exported. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to resolve aliases. max_iterations ( int | None ) \u2013 Maximum number of iterations on the loader modules collection. Returns: tuple [ set [ str ], int ] \u2013 The unresolved aliases and the number of iterations done. Source code in griffe/loader.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def resolve_aliases ( # noqa: WPS231 self , only_exported : bool = True , only_known_modules : bool = True , max_iterations : int | None = None , ) -> tuple [ set [ str ], int ]: \"\"\"Resolve aliases. Parameters: only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. max_iterations: Maximum number of iterations on the loader modules collection. Returns: The unresolved aliases and the number of iterations done. \"\"\" if max_iterations is None : max_iterations = float ( \"inf\" ) # type: ignore[assignment] prev_unresolved : set [ str ] = set () unresolved : set [ str ] = set ( \"0\" ) # init to enter loop iteration = 0 collection = self . modules_collection . members for w_module in list ( collection . values ()): self . expand_wildcards ( w_module ) while unresolved and unresolved != prev_unresolved and iteration < max_iterations : # type: ignore[operator] prev_unresolved = unresolved - { \"0\" } unresolved = set () resolved : set [ str ] = set () iteration += 1 for module_name in list ( collection . keys ()): module = collection [ module_name ] next_resolved , next_unresolved = self . resolve_module_aliases ( module , only_exported , only_known_modules ) resolved |= next_resolved unresolved |= next_unresolved logger . debug ( f \"Iteration { iteration } finished, { len ( resolved ) } aliases resolved, still { len ( unresolved ) } to go\" ) return unresolved , iteration resolve_module_aliases ( self , obj , only_exported = True , only_known_modules = True , seen = None ) \u00a4 Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 When true, only try to resolve an alias if it is explicitely exported. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to resolve aliases. seen ( set | None ) \u2013 Used to avoid infinite recursion. Returns: tuple [ set [ str ], set [ str ]] \u2013 Both sets of resolved and unresolved aliases. Source code in griffe/loader.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def resolve_module_aliases ( # noqa: WPS231 self , obj : Object , only_exported : bool = True , only_known_modules : bool = True , seen : set | None = None , ) -> tuple [ set [ str ], set [ str ]]: \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. seen: Used to avoid infinite recursion. Returns: Both sets of resolved and unresolved aliases. \"\"\" resolved = set () unresolved = set () seen = seen or set () seen . add ( obj . path ) for member in obj . members . values (): # noqa: WPS440 if member . is_alias : if member . wildcard or member . resolved : # type: ignore[union-attr] continue if only_exported and not member . is_explicitely_exported : continue try : member . resolve_target () # type: ignore[union-attr] except AliasResolutionError as error : # noqa: WPS440 path = member . path target = error . target_path # type: ignore[union-attr] # noqa: WPS437 logger . debug ( f \"Alias resolution error for { path } -> { target } \" ) unresolved . add ( path ) package = target . split ( \".\" , 1 )[ 0 ] load_module = ( not only_known_modules and obj . package . path != package and package not in self . modules_collection ) if load_module : try : # noqa: WPS505 self . load_module ( package , try_relative_path = False ) except ImportError as error : # noqa: WPS440 logger . debug ( f \"Could not follow alias { member . path } : { error } \" ) except CyclicAliasError as error : logger . debug ( str ( error )) else : logger . debug ( f \"Alias { member . path } was resolved to { member . target . path } \" ) # type: ignore[union-attr] resolved . add ( member . path ) elif member . kind in { Kind . MODULE , Kind . CLASS } and member . path not in seen : sub_resolved , sub_unresolved = self . resolve_module_aliases ( member , only_exported , only_known_modules , seen # type: ignore[arg-type] ) resolved |= sub_resolved unresolved |= sub_unresolved return resolved , unresolved stats ( self ) \u00a4 Compute some statistics. Returns: dict \u2013 Some statistics. Source code in griffe/loader.py 288 289 290 291 292 293 294 def stats ( self ) -> dict : \"\"\"Compute some statistics. Returns: Some statistics. \"\"\" return { ** stats ( self ), ** self . _time_stats }","title":"loader"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader","text":"The Griffe loader, allowing to load data from modules. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/loader.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , extensions : Extensions | None = None , search_paths : Sequence [ str | Path ] | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. search_paths: The paths to search into. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () self . finder : ModuleFinder = ModuleFinder ( search_paths ) self . _time_stats : dict = { \"time_spent_visiting\" : 0 , \"time_spent_inspecting\" : 0 , } patch_ast ()","title":"GriffeLoader"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.expand_wildcards","text":"Expand wildcards: try to recursively expand all found wildcards. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. seen ( set | None ) \u2013 Used to avoid infinite recursion. Source code in griffe/loader.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def expand_wildcards ( self , obj : Object , seen : set | None = None ) -> None : # noqa: WPS231 \"\"\"Expand wildcards: try to recursively expand all found wildcards. Parameters: obj: The object and its members to recurse on. seen: Used to avoid infinite recursion. \"\"\" expanded = {} to_remove = [] seen = seen or set () seen . add ( obj . path ) for member in obj . members . values (): if member . is_alias and member . wildcard : # type: ignore[union-attr] # we know it's an alias package = member . wildcard . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] if obj . package . path != package and package not in self . modules_collection : try : self . load_module ( package , try_relative_path = False ) except ImportError as error : logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) continue self . expand_wildcards ( self . modules_collection [ member . target_path ]) # type: ignore[union-attr] expanded . update ( self . _expand_wildcard ( member )) # type: ignore[arg-type] to_remove . append ( member . name ) elif not member . is_alias and member . is_module and member . path not in seen : self . expand_wildcards ( member , seen ) # type: ignore[arg-type] for name in to_remove : del obj [ name ] # noqa: WPS420 for new_member in list ( expanded . values ()): if new_member . is_alias : try : # TODO: maybe don't shortcut aliases: # we want to keep public paths alias = Alias ( new_member . name , new_member . target ) # type: ignore[union-attr] except AliasResolutionError : alias = new_member # type: ignore[assignment] # noqa: WPS437 except CyclicAliasError as error : # noqa: WPS440 logger . debug ( str ( error )) continue else : alias = Alias ( new_member . name , new_member ) obj [ new_member . name ] = alias","title":"expand_wildcards()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.load_module","text":"Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. Raises: LoadingError \u2013 When loading a module failed for various reasons. Returns: Module \u2013 A module. Source code in griffe/loader.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def load_module ( self , module : str | Path , submodules : bool = True , try_relative_path : bool = True , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. try_relative_path: Whether to try finding the module as a relative path. Raises: LoadingError: When loading a module failed for various reasons. Returns: A module. \"\"\" module_name : str if module in _builtin_modules : logger . debug ( f \" { module } is a builtin module: inspecting\" ) module_name = module # type: ignore[assignment] top_module = self . _inspect_module ( module ) # type: ignore[arg-type] return self . _store_and_return ( module_name , top_module ) try : module_name , package = self . finder . find_spec ( module , try_relative_path ) except ModuleNotFoundError : logger . debug ( f \"Could not find { module } : trying inspection\" ) module_name = module # type: ignore[assignment] top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : logger . debug ( f \"Found { module } : loading\" ) try : # noqa: WPS505 top_module = self . _load_module ( package . name , package . path , submodules = submodules ) except LoadingError as error : # noqa: WPS440 logger . error ( str ( error )) raise return self . _store_and_return ( module_name , top_module )","title":"load_module()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_aliases","text":"Resolve aliases. Parameters: only_exported ( bool ) \u2013 When true, only try to resolve an alias if it is explicitely exported. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to resolve aliases. max_iterations ( int | None ) \u2013 Maximum number of iterations on the loader modules collection. Returns: tuple [ set [ str ], int ] \u2013 The unresolved aliases and the number of iterations done. Source code in griffe/loader.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def resolve_aliases ( # noqa: WPS231 self , only_exported : bool = True , only_known_modules : bool = True , max_iterations : int | None = None , ) -> tuple [ set [ str ], int ]: \"\"\"Resolve aliases. Parameters: only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. max_iterations: Maximum number of iterations on the loader modules collection. Returns: The unresolved aliases and the number of iterations done. \"\"\" if max_iterations is None : max_iterations = float ( \"inf\" ) # type: ignore[assignment] prev_unresolved : set [ str ] = set () unresolved : set [ str ] = set ( \"0\" ) # init to enter loop iteration = 0 collection = self . modules_collection . members for w_module in list ( collection . values ()): self . expand_wildcards ( w_module ) while unresolved and unresolved != prev_unresolved and iteration < max_iterations : # type: ignore[operator] prev_unresolved = unresolved - { \"0\" } unresolved = set () resolved : set [ str ] = set () iteration += 1 for module_name in list ( collection . keys ()): module = collection [ module_name ] next_resolved , next_unresolved = self . resolve_module_aliases ( module , only_exported , only_known_modules ) resolved |= next_resolved unresolved |= next_unresolved logger . debug ( f \"Iteration { iteration } finished, { len ( resolved ) } aliases resolved, still { len ( unresolved ) } to go\" ) return unresolved , iteration","title":"resolve_aliases()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_module_aliases","text":"Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 When true, only try to resolve an alias if it is explicitely exported. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to resolve aliases. seen ( set | None ) \u2013 Used to avoid infinite recursion. Returns: tuple [ set [ str ], set [ str ]] \u2013 Both sets of resolved and unresolved aliases. Source code in griffe/loader.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def resolve_module_aliases ( # noqa: WPS231 self , obj : Object , only_exported : bool = True , only_known_modules : bool = True , seen : set | None = None , ) -> tuple [ set [ str ], set [ str ]]: \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. seen: Used to avoid infinite recursion. Returns: Both sets of resolved and unresolved aliases. \"\"\" resolved = set () unresolved = set () seen = seen or set () seen . add ( obj . path ) for member in obj . members . values (): # noqa: WPS440 if member . is_alias : if member . wildcard or member . resolved : # type: ignore[union-attr] continue if only_exported and not member . is_explicitely_exported : continue try : member . resolve_target () # type: ignore[union-attr] except AliasResolutionError as error : # noqa: WPS440 path = member . path target = error . target_path # type: ignore[union-attr] # noqa: WPS437 logger . debug ( f \"Alias resolution error for { path } -> { target } \" ) unresolved . add ( path ) package = target . split ( \".\" , 1 )[ 0 ] load_module = ( not only_known_modules and obj . package . path != package and package not in self . modules_collection ) if load_module : try : # noqa: WPS505 self . load_module ( package , try_relative_path = False ) except ImportError as error : # noqa: WPS440 logger . debug ( f \"Could not follow alias { member . path } : { error } \" ) except CyclicAliasError as error : logger . debug ( str ( error )) else : logger . debug ( f \"Alias { member . path } was resolved to { member . target . path } \" ) # type: ignore[union-attr] resolved . add ( member . path ) elif member . kind in { Kind . MODULE , Kind . CLASS } and member . path not in seen : sub_resolved , sub_unresolved = self . resolve_module_aliases ( member , only_exported , only_known_modules , seen # type: ignore[arg-type] ) resolved |= sub_resolved unresolved |= sub_unresolved return resolved , unresolved","title":"resolve_module_aliases()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.stats","text":"Compute some statistics. Returns: dict \u2013 Some statistics. Source code in griffe/loader.py 288 289 290 291 292 293 294 def stats ( self ) -> dict : \"\"\"Compute some statistics. Returns: Some statistics. \"\"\" return { ** stats ( self ), ** self . _time_stats }","title":"stats()"},{"location":"reference/griffe/logger/","text":"This module contains logging utilities. We provide the patch_loggers function so dependant libraries can patch loggers as they see fit. For example, to fit in the MkDocs logging configuration and prefix each log message with the module name: import logging from griffe.logger import patch_loggers class LoggerAdapter ( logging . LoggerAdapter ): def __init__ ( self , prefix , logger ): super () . __init__ ( logger , {}) self . prefix = prefix def process ( self , msg , kwargs ): return f \" { self . prefix } : { msg } \" , kwargs def get_logger ( name ): logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) return LoggerAdapter ( name , logger ) patch_loggers ( get_logger ) get_logger ( name ) \u00a4 Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: _Logger \u2013 The logger. Source code in griffe/logger.py 61 62 63 64 65 66 67 68 69 70 def get_logger ( name : str ) -> _Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return _Logger ( name ) patch_loggers ( get_logger_func ) \u00a4 Patch loggers. Parameters: get_logger_func ( Callable [[ str ], Any ] ) \u2013 A function accepting a name as parameter and returning a logger. Source code in griffe/logger.py 73 74 75 76 77 78 79 def patch_loggers ( get_logger_func : Callable [[ str ], Any ]) -> None : \"\"\"Patch loggers. Parameters: get_logger_func: A function accepting a name as parameter and returning a logger. \"\"\" _Logger . _patch_loggers ( get_logger_func ) # noqa: WPS437","title":"logger"},{"location":"reference/griffe/logger/#griffe.logger.get_logger","text":"Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: _Logger \u2013 The logger. Source code in griffe/logger.py 61 62 63 64 65 66 67 68 69 70 def get_logger ( name : str ) -> _Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return _Logger ( name )","title":"get_logger()"},{"location":"reference/griffe/logger/#griffe.logger.patch_loggers","text":"Patch loggers. Parameters: get_logger_func ( Callable [[ str ], Any ] ) \u2013 A function accepting a name as parameter and returning a logger. Source code in griffe/logger.py 73 74 75 76 77 78 79 def patch_loggers ( get_logger_func : Callable [[ str ], Any ]) -> None : \"\"\"Patch loggers. Parameters: get_logger_func: A function accepting a name as parameter and returning a logger. \"\"\" _Logger . _patch_loggers ( get_logger_func ) # noqa: WPS437","title":"patch_loggers()"},{"location":"reference/griffe/mixins/","text":"This module contains some mixins classes about accessing and setting members. DelMembersMixin \u00a4 This mixin adds a __delitem__ method to a class. GetMembersMixin \u00a4 This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance. ObjectAliasMixin \u00a4 A mixin for methods that appear both in objects and aliases, unchanged. is_explicitely_exported ( self ) \u00a4 Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 104 105 106 107 108 109 110 111 @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) is_exported ( self , explicitely = True ) \u00a4 Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 93 94 95 96 97 98 99 100 101 102 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined] is_implicitely_exported ( self ) \u00a4 Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 113 114 115 116 117 118 119 120 @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined] SetCollectionMembersMixin \u00a4 Bases: DelMembersMixin This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its _modules_collection attribute is set as well. SetMembersMixin \u00a4 Bases: DelMembersMixin This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well.","title":"mixins"},{"location":"reference/griffe/mixins/#griffe.mixins.DelMembersMixin","text":"This mixin adds a __delitem__ method to a class.","title":"DelMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin","text":"This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance.","title":"GetMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin","text":"A mixin for methods that appear both in objects and aliases, unchanged.","title":"ObjectAliasMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_explicitely_exported","text":"Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 104 105 106 107 108 109 110 111 @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True )","title":"is_explicitely_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_exported","text":"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 93 94 95 96 97 98 99 100 101 102 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined]","title":"is_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_implicitely_exported","text":"Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 113 114 115 116 117 118 119 120 @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined]","title":"is_implicitely_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.SetCollectionMembersMixin","text":"Bases: DelMembersMixin This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its _modules_collection attribute is set as well.","title":"SetCollectionMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin","text":"Bases: DelMembersMixin This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well.","title":"SetMembersMixin"},{"location":"reference/griffe/stats/","text":"This module contains utilities to compute loading statistics. stats ( loader ) \u00a4 Return some loading statistics. Parameters: loader ( GriffeLoader ) \u2013 The loader to compute stats from. Returns: dict \u2013 Some statistics. Source code in griffe/stats.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def stats ( loader : GriffeLoader ) -> dict : \"\"\"Return some loading statistics. Parameters: loader: The loader to compute stats from. Returns: Some statistics. \"\"\" modules_by_extension = { \"\" : 0 , \".py\" : 0 , \".pyc\" : 0 , \".pyo\" : 0 , \".pyd\" : 0 , \".so\" : 0 , } top_modules = loader . modules_collection . members . values () for module in top_modules : _sum_extensions ( modules_by_extension , module ) n_lines = sum ( len ( lines ) for lines in loader . lines_collection . values ()) return { \"packages\" : len ( top_modules ), \"modules\" : len ( top_modules ) + sum ( _n_modules ( mod ) for mod in top_modules ), \"classes\" : sum ( _n_classes ( mod ) for mod in top_modules ), \"functions\" : sum ( _n_functions ( mod ) for mod in top_modules ), \"attributes\" : sum ( _n_attributes ( mod ) for mod in top_modules ), \"modules_by_extension\" : modules_by_extension , \"lines\" : n_lines , }","title":"stats"},{"location":"reference/griffe/stats/#griffe.stats.stats","text":"Return some loading statistics. Parameters: loader ( GriffeLoader ) \u2013 The loader to compute stats from. Returns: dict \u2013 Some statistics. Source code in griffe/stats.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def stats ( loader : GriffeLoader ) -> dict : \"\"\"Return some loading statistics. Parameters: loader: The loader to compute stats from. Returns: Some statistics. \"\"\" modules_by_extension = { \"\" : 0 , \".py\" : 0 , \".pyc\" : 0 , \".pyo\" : 0 , \".pyd\" : 0 , \".so\" : 0 , } top_modules = loader . modules_collection . members . values () for module in top_modules : _sum_extensions ( modules_by_extension , module ) n_lines = sum ( len ( lines ) for lines in loader . lines_collection . values ()) return { \"packages\" : len ( top_modules ), \"modules\" : len ( top_modules ) + sum ( _n_modules ( mod ) for mod in top_modules ), \"classes\" : sum ( _n_classes ( mod ) for mod in top_modules ), \"functions\" : sum ( _n_functions ( mod ) for mod in top_modules ), \"attributes\" : sum ( _n_attributes ( mod ) for mod in top_modules ), \"modules_by_extension\" : modules_by_extension , \"lines\" : n_lines , }","title":"stats()"},{"location":"reference/griffe/agents/","text":"These modules contain the different agents that are able to extract data.","title":"agents"},{"location":"reference/griffe/agents/base/","text":"This module contains the base classes for dealing with extensions. BaseInspector \u00a4 The base class for inspectors. generic_inspect ( self , node ) \u00a4 Inspect the children of a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect (its children). Source code in griffe/agents/base.py 40 41 42 43 44 45 def generic_inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\" inspect ( self , node ) \u00a4 Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/base.py 32 33 34 35 36 37 38 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node ) BaseVisitor \u00a4 The base class for visitors. generic_visit ( self , node ) \u00a4 Visit the children of a node. Parameters: node ( ast . AST ) \u2013 The node to visit (its children). Source code in griffe/agents/base.py 21 22 23 24 25 26 def generic_visit ( self , node : ast . AST ) -> None : \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\" visit ( self , node ) \u00a4 Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/base.py 13 14 15 16 17 18 19 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined]","title":"base"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector","text":"The base class for inspectors.","title":"BaseInspector"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.generic_inspect","text":"Inspect the children of a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect (its children). Source code in griffe/agents/base.py 40 41 42 43 44 45 def generic_inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\"","title":"generic_inspect()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.inspect","text":"Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/base.py 32 33 34 35 36 37 38 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node )","title":"inspect()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor","text":"The base class for visitors.","title":"BaseVisitor"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.generic_visit","text":"Visit the children of a node. Parameters: node ( ast . AST ) \u2013 The node to visit (its children). Source code in griffe/agents/base.py 21 22 23 24 25 26 def generic_visit ( self , node : ast . AST ) -> None : \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\"","title":"generic_visit()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.visit","text":"Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/base.py 13 14 15 16 17 18 19 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined]","title":"visit()"},{"location":"reference/griffe/agents/inspector/","text":"This module defines introspection mechanisms. Sometimes we cannot get the source code of a module or an object, typically built-in modules like itertools . The only way to know what they are made of is to actually import them and inspect their contents. Sometimes, even if the source code is available, loading the object is desired because it was created or modified dynamically, and our node visitor is not powerful enough to infer all these dynamic modifications. In this case, we always try to visit the code first, and only then we load the object to update the data with introspection. This module exposes a public function, inspect() , which inspects the module using inspect.getmembers() , and returns a new Module instance, populating its members recursively, by using a NodeVisitor -like class. The inspection agent works similarly to the regular \"node visitor\" agent, in that it maintains a state with the current object being handled, and recursively handle its members. Inspector ( module_name , filepath , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None ) \u00a4 Bases: BaseInspector This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path | None ) \u2013 The optional filepath. extensions ( Extensions ) \u2013 Extensions to use when inspecting. parent ( Module | None ) \u2013 The module parent. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Source code in griffe/agents/inspector.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () generic_inspect ( self , node ) \u00a4 Extend the base generic inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) for child in node . children : child_module_path = _should_create_alias ( node , child , self . current . module . path ) if child_module_path : child_name = getattr ( child . obj , \"__name__\" , child . name ) target_path = f \" { child_module_path } . { child_name } \" self . current [ child . name ] = Alias ( child . name , target_path ) else : self . inspect ( child ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node ) get_module ( self , import_paths = None ) \u00a4 Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Parameters: import_paths ( list [ Path ] | None ) \u2013 Paths replacing sys.path to import the module. Returns: Module \u2013 A module instance. Source code in griffe/agents/inspector.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def get_module ( self , import_paths : list [ Path ] | None = None ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Parameters: import_paths: Paths replacing `sys.path` to import the module. Returns: A module instance. \"\"\" import_path = self . module_name if self . parent is not None : import_path = f \" { self . parent . path } . { import_path } \" value = dynamic_import ( import_path , import_paths ) top_node = ObjectNode ( value , self . module_name ) self . inspect ( top_node ) return self . current . module handle_attribute ( self , node , annotation = None ) \u00a4 Handle an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. annotation ( str | Name | Expression | None ) \u2013 A potentiel annotation. Source code in griffe/agents/inspector.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO: to improve parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) try : value = repr ( node . obj ) except Exception : # could trigger anything value = None docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj ) handle_function ( self , node , labels = None ) \u00a4 Handle a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/inspector.py 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ( AttributeError , ValueError , TokenError , TypeError ): parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter , parent = self . current ) for parameter in signature . parameters . values ()] ) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = _convert_object_to_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function inspect ( self , node ) \u00a4 Extend the base inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 211 212 213 214 215 216 217 218 219 220 221 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node ) inspect_attribute ( self , node ) \u00a4 Inspect an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 389 390 391 392 393 394 395 def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node ) inspect_builtin_function ( self , node ) \u00a4 Inspect a builtin function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 325 326 327 328 329 330 331 def inspect_builtin_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) inspect_builtin_method ( self , node ) \u00a4 Inspect a builtin method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 301 302 303 304 305 306 307 def inspect_builtin_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) inspect_cached_property ( self , node ) \u00a4 Inspect a cached property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 341 342 343 344 345 346 347 def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" }) inspect_class ( self , node ) \u00a4 Inspect a class. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment] inspect_classmethod ( self , node ) \u00a4 Inspect a class method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 285 286 287 288 289 290 291 def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" }) inspect_coroutine ( self , node ) \u00a4 Inspect a coroutine. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 317 318 319 320 321 322 323 def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" }) inspect_function ( self , node ) \u00a4 Inspect a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 333 334 335 336 337 338 339 def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) inspect_method ( self , node ) \u00a4 Inspect a method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 309 310 311 312 313 314 315 def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) inspect_method_descriptor ( self , node ) \u00a4 Inspect a method descriptor. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 293 294 295 296 297 298 299 def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" }) inspect_module ( self , node ) \u00a4 Inspect a module. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node ) inspect_property ( self , node ) \u00a4 Inspect a property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 349 350 351 352 353 354 355 def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" }) inspect_staticmethod ( self , node ) \u00a4 Inspect a static method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 277 278 279 280 281 282 283 def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" }) inspect ( module_name , * , filepath = None , import_paths = None , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None ) \u00a4 Inspect a module. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path | None ) \u2013 The module file path. import_paths ( list [ Path ] | None ) \u2013 Paths to import the module from. extensions ( Extensions | None ) \u2013 The extensions to use when inspecting the module. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/inspector.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def inspect ( module_name : str , * , filepath : Path | None = None , import_paths : list [ Path ] | None = None , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Inspect a module. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. import_paths: Paths to import the module from. extensions: The extensions to use when inspecting the module. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" if not import_paths and filepath : import_paths = [ filepath . parent ] return Inspector ( module_name , filepath , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ( import_paths )","title":"inspector"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector","text":"Bases: BaseInspector This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path | None ) \u2013 The optional filepath. extensions ( Extensions ) \u2013 Extensions to use when inspecting. parent ( Module | None ) \u2013 The module parent. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Source code in griffe/agents/inspector.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection ()","title":"Inspector"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.generic_inspect","text":"Extend the base generic inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) for child in node . children : child_module_path = _should_create_alias ( node , child , self . current . module . path ) if child_module_path : child_name = getattr ( child . obj , \"__name__\" , child . name ) target_path = f \" { child_module_path } . { child_name } \" self . current [ child . name ] = Alias ( child . name , target_path ) else : self . inspect ( child ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node )","title":"generic_inspect()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.get_module","text":"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Parameters: import_paths ( list [ Path ] | None ) \u2013 Paths replacing sys.path to import the module. Returns: Module \u2013 A module instance. Source code in griffe/agents/inspector.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def get_module ( self , import_paths : list [ Path ] | None = None ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Parameters: import_paths: Paths replacing `sys.path` to import the module. Returns: A module instance. \"\"\" import_path = self . module_name if self . parent is not None : import_path = f \" { self . parent . path } . { import_path } \" value = dynamic_import ( import_path , import_paths ) top_node = ObjectNode ( value , self . module_name ) self . inspect ( top_node ) return self . current . module","title":"get_module()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_attribute","text":"Handle an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. annotation ( str | Name | Expression | None ) \u2013 A potentiel annotation. Source code in griffe/agents/inspector.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO: to improve parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) try : value = repr ( node . obj ) except Exception : # could trigger anything value = None docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj )","title":"handle_attribute()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_function","text":"Handle a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/inspector.py 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ( AttributeError , ValueError , TokenError , TypeError ): parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter , parent = self . current ) for parameter in signature . parameters . values ()] ) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = _convert_object_to_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function","title":"handle_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect","text":"Extend the base inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 211 212 213 214 215 216 217 218 219 220 221 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node )","title":"inspect()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_attribute","text":"Inspect an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 389 390 391 392 393 394 395 def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node )","title":"inspect_attribute()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_function","text":"Inspect a builtin function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 325 326 327 328 329 330 331 def inspect_builtin_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" })","title":"inspect_builtin_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_method","text":"Inspect a builtin method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 301 302 303 304 305 306 307 def inspect_builtin_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" })","title":"inspect_builtin_method()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_cached_property","text":"Inspect a cached property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 341 342 343 344 345 346 347 def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" })","title":"inspect_cached_property()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_class","text":"Inspect a class. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"inspect_class()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_classmethod","text":"Inspect a class method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 285 286 287 288 289 290 291 def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" })","title":"inspect_classmethod()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_coroutine","text":"Inspect a coroutine. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 317 318 319 320 321 322 323 def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" })","title":"inspect_coroutine()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_function","text":"Inspect a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 333 334 335 336 337 338 339 def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node )","title":"inspect_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method","text":"Inspect a method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 309 310 311 312 313 314 315 def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node )","title":"inspect_method()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method_descriptor","text":"Inspect a method descriptor. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 293 294 295 296 297 298 299 def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" })","title":"inspect_method_descriptor()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_module","text":"Inspect a module. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node )","title":"inspect_module()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_property","text":"Inspect a property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 349 350 351 352 353 354 355 def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" })","title":"inspect_property()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_staticmethod","text":"Inspect a static method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 277 278 279 280 281 282 283 def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" })","title":"inspect_staticmethod()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.inspect","text":"Inspect a module. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path | None ) \u2013 The module file path. import_paths ( list [ Path ] | None ) \u2013 Paths to import the module from. extensions ( Extensions | None ) \u2013 The extensions to use when inspecting the module. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/inspector.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def inspect ( module_name : str , * , filepath : Path | None = None , import_paths : list [ Path ] | None = None , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Inspect a module. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. import_paths: Paths to import the module from. extensions: The extensions to use when inspecting the module. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" if not import_paths and filepath : import_paths = [ filepath . parent ] return Inspector ( module_name , filepath , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ( import_paths )","title":"inspect()"},{"location":"reference/griffe/agents/nodes/","text":"This module contains utilities for extracting information from nodes. ASTNode \u00a4 This class is dynamically added to the bases of each AST node class. children ( self ) \u00a4 Build and return the children of this node. Returns: Sequence [ ASTNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children first_child ( self ) \u00a4 Return the first child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error kind ( self ) \u00a4 Return the kind of this node. Returns: str \u2013 The node kind. Source code in griffe/agents/nodes.py 107 108 109 110 111 112 113 114 @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower () last_child ( self ) \u00a4 Return the lasts child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error next ( self ) \u00a4 Return the next sibling of this node. Raises: LastNodeError \u2013 When the node does not have next siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error next_siblings ( self ) \u00a4 Return the next siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The next siblings. Source code in griffe/agents/nodes.py 165 166 167 168 169 170 171 172 173 174 @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :] position ( self ) \u00a4 Tell the position of this node amongst its siblings. Raises: RootNodeError \u2013 When the node doesn't have a parent. Returns: int \u2013 The node position amongst its siblings. Source code in griffe/agents/nodes.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error previous ( self ) \u00a4 Return the previous sibling of this node. Raises: LastNodeError \u2013 When the node does not have previous siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error previous_siblings ( self ) \u00a4 Return the previous siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The previous siblings. Source code in griffe/agents/nodes.py 154 155 156 157 158 159 160 161 162 163 @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ] siblings ( self ) \u00a4 Return the siblings of this node. Returns: Sequence [ ASTNode ] \u2013 The siblings. Source code in griffe/agents/nodes.py 176 177 178 179 180 181 182 183 @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ] ObjectKind \u00a4 Bases: enum . Enum Enumeration for the different kinds of objects. ObjectNode ( obj , name , parent = None ) \u00a4 Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj ( Any ) \u2013 The actual Python object. name ( str ) \u2013 The Python object's name. parent ( ObjectNode | None ) \u2013 The parent node. Parameters: obj ( Any ) \u2013 A Python object. name ( str ) \u2013 The object's name. parent ( ObjectNode | None ) \u2013 The object's parent node. Source code in griffe/agents/nodes.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent children ( self ) \u00a4 Build and return the children of this node. Returns: Sequence [ ObjectNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 342 343 344 345 346 347 348 349 350 351 352 353 @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( name , member ): children . append ( ObjectNode ( member , name , parent = self )) return children is_builtin_function ( self ) \u00a4 Tell if this node's object is a builtin function. Returns: bool \u2013 If this node's object is a builtin function. Source code in griffe/agents/nodes.py 385 386 387 388 389 390 391 392 393 @cached_property def is_builtin_function ( self ) -> bool : \"\"\" Tell if this node's object is a builtin function. Returns: If this node's object is a builtin function. \"\"\" return inspect . isbuiltin ( self . obj ) is_builtin_method ( self ) \u00a4 Tell if this node's object is a builtin method. Returns: bool \u2013 If this node's object is a builtin method. Source code in griffe/agents/nodes.py 459 460 461 462 463 464 465 466 467 @cached_property def is_builtin_method ( self ) -> bool : \"\"\" Tell if this node's object is a builtin method. Returns: If this node's object is a builtin method. \"\"\" return self . is_builtin_function and self . parent_is_class is_cached_property ( self ) \u00a4 Tell if this node's object is a cached property. Returns: bool \u2013 If this node's object is a cached property. Source code in griffe/agents/nodes.py 415 416 417 418 419 420 421 422 423 @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property ) is_class ( self ) \u00a4 Tell if this node's object is a class. Returns: bool \u2013 If this node's object is a class. Source code in griffe/agents/nodes.py 365 366 367 368 369 370 371 372 373 @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj ) is_classmethod ( self ) \u00a4 Tell if this node's object is a classmethod. Returns: bool \u2013 If this node's object is a classmethod. Source code in griffe/agents/nodes.py 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod ) is_coroutine ( self ) \u00a4 Tell if this node's object is a coroutine. Returns: bool \u2013 If this node's object is a coroutine. Source code in griffe/agents/nodes.py 395 396 397 398 399 400 401 402 403 @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj ) is_function ( self ) \u00a4 Tell if this node's object is a function. Returns: bool \u2013 If this node's object is a function. Source code in griffe/agents/nodes.py 375 376 377 378 379 380 381 382 383 @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj ) is_method ( self ) \u00a4 Tell if this node's object is a method. Returns: bool \u2013 If this node's object is a method. Source code in griffe/agents/nodes.py 435 436 437 438 439 440 441 442 443 444 @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type ) is_method_descriptor ( self ) \u00a4 Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: bool \u2013 If this node's object is a method descriptor. Source code in griffe/agents/nodes.py 446 447 448 449 450 451 452 453 454 455 456 457 @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj ) is_module ( self ) \u00a4 Tell if this node's object is a module. Returns: bool \u2013 The root of the tree. Source code in griffe/agents/nodes.py 355 356 357 358 359 360 361 362 363 @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj ) is_property ( self ) \u00a4 Tell if this node's object is a property. Returns: bool \u2013 If this node's object is a property. Source code in griffe/agents/nodes.py 405 406 407 408 409 410 411 412 413 @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property is_staticmethod ( self ) \u00a4 Tell if this node's object is a staticmethod. Returns: bool \u2013 If this node's object is a staticmethod. Source code in griffe/agents/nodes.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod ) kind ( self ) \u00a4 Return the kind of this node. Returns: ObjectKind \u2013 The node kind. Source code in griffe/agents/nodes.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_builtin_method : return ObjectKind . BUILTIN_METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_builtin_function : return ObjectKind . BUILTIN_FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE parent_is_class ( self ) \u00a4 Tell if the object of this node's parent is a class. Returns: bool \u2013 If the object of this node's parent is a class. Source code in griffe/agents/nodes.py 425 426 427 428 429 430 431 432 433 @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class ) get_annotation ( node , parent ) \u00a4 Extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 679 680 681 682 683 684 685 686 687 688 689 690 691 def get_annotation ( node : AST | None , parent : Module | Class ) -> str | Name | Expression | None : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" if node is None : return None return _get_annotation ( node , parent ) get_docstring ( node , strict = False ) \u00a4 Extract a docstring. Parameters: node ( AST ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/agents/nodes.py 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 def get_docstring ( node : AST , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore[attr-defined] doc = node . body [ 0 ] . value # type: ignore[attr-defined] else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno # type: ignore[attr-defined] if isinstance ( doc , NodeStr ): return doc . s , doc . lineno , doc . end_lineno # type: ignore[attr-defined] return None , None , None get_instance_names ( node ) \u00a4 Extract names from an assignment node, only for instance attributes. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 def get_instance_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )] get_name ( node ) \u00a4 Extract name from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: str \u2013 A list of names. Source code in griffe/agents/nodes.py 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 def get_name ( node : AST ) -> str : \"\"\"Extract name from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_name_map [ type ( node )]( node ) get_names ( node ) \u00a4 Extract names from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 def get_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map [ type ( node )]( node ) get_parameter_default ( node , filepath , lines_collection ) \u00a4 Extract the default value of a function parameter. Parameters: node ( AST ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/agents/nodes.py 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 def get_parameter_default ( node : AST , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None if isinstance ( node , NodeConstant ): return repr ( node . value ) if isinstance ( node , NodeStr ): return repr ( node . s ) if isinstance ( node , NodeName ): return node . id if node . lineno == node . end_lineno : # type: ignore[attr-defined] return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # type: ignore[attr-defined] # TODO: handle multiple line defaults return None get_value ( node ) \u00a4 Extract a complex value as a string. Parameters: node ( AST ) \u2013 The node to extract the value from. Returns: str \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 def get_value ( node : AST ) -> str : \"\"\"Extract a complex value as a string. Parameters: node: The node to extract the value from. Returns: The unparsed code of the node. \"\"\" return _node_value_map [ type ( node )]( node ) parse__all__ ( node ) \u00a4 Get the values declared in __all__ . Parameters: node ( NodeAssign ) \u2013 The assignment node. Returns: set [ str ] \u2013 A set of names. Source code in griffe/agents/nodes.py 540 541 542 543 544 545 546 547 548 549 def parse__all__ ( node : NodeAssign ) -> set [ str ]: # noqa: WPS116,WPS120,WPS440 \"\"\"Get the values declared in `__all__`. Parameters: node: The assignment node. Returns: A set of names. \"\"\" return { elt . value for elt in node . value . elts } # type: ignore[attr-defined] relative_to_absolute ( node , name , current_module ) \u00a4 Convert a relative import path to an absolute one. Parameters: node ( NodeImportFrom ) \u2013 The \"from ... import ...\" AST node. name ( NodeAlias ) \u2013 The imported name. current_module ( Module ) \u2013 The module in which the import happens. Returns: str \u2013 The absolute import path. Source code in griffe/agents/nodes.py 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 def relative_to_absolute ( node : NodeImportFrom , name : NodeAlias , current_module : Module ) -> str : \"\"\"Convert a relative import path to an absolute one. Parameters: node: The \"from ... import ...\" AST node. name: The imported name. current_module: The module in which the import happens. Returns: The absolute import path. \"\"\" level = node . level if level > 0 and current_module . is_package or current_module . is_subpackage : level -= 1 while level > 0 and current_module . parent is not None : current_module = current_module . parent # type: ignore[assignment] level -= 1 base = current_module . path + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" return base + node_module + name . name","title":"nodes"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode","text":"This class is dynamically added to the bases of each AST node class.","title":"ASTNode"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.children","text":"Build and return the children of this node. Returns: Sequence [ ASTNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children","title":"children()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.first_child","text":"Return the first child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error","title":"first_child()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.kind","text":"Return the kind of this node. Returns: str \u2013 The node kind. Source code in griffe/agents/nodes.py 107 108 109 110 111 112 113 114 @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower ()","title":"kind()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.last_child","text":"Return the lasts child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error","title":"last_child()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next","text":"Return the next sibling of this node. Raises: LastNodeError \u2013 When the node does not have next siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error","title":"next()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next_siblings","text":"Return the next siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The next siblings. Source code in griffe/agents/nodes.py 165 166 167 168 169 170 171 172 173 174 @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :]","title":"next_siblings()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.position","text":"Tell the position of this node amongst its siblings. Raises: RootNodeError \u2013 When the node doesn't have a parent. Returns: int \u2013 The node position amongst its siblings. Source code in griffe/agents/nodes.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error","title":"position()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous","text":"Return the previous sibling of this node. Raises: LastNodeError \u2013 When the node does not have previous siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error","title":"previous()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous_siblings","text":"Return the previous siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The previous siblings. Source code in griffe/agents/nodes.py 154 155 156 157 158 159 160 161 162 163 @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ]","title":"previous_siblings()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.siblings","text":"Return the siblings of this node. Returns: Sequence [ ASTNode ] \u2013 The siblings. Source code in griffe/agents/nodes.py 176 177 178 179 180 181 182 183 @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ]","title":"siblings()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind","text":"Bases: enum . Enum Enumeration for the different kinds of objects.","title":"ObjectKind"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode","text":"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj ( Any ) \u2013 The actual Python object. name ( str ) \u2013 The Python object's name. parent ( ObjectNode | None ) \u2013 The parent node. Parameters: obj ( Any ) \u2013 A Python object. name ( str ) \u2013 The object's name. parent ( ObjectNode | None ) \u2013 The object's parent node. Source code in griffe/agents/nodes.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent","title":"ObjectNode"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.children","text":"Build and return the children of this node. Returns: Sequence [ ObjectNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 342 343 344 345 346 347 348 349 350 351 352 353 @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( name , member ): children . append ( ObjectNode ( member , name , parent = self )) return children","title":"children()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_function","text":"Tell if this node's object is a builtin function. Returns: bool \u2013 If this node's object is a builtin function. Source code in griffe/agents/nodes.py 385 386 387 388 389 390 391 392 393 @cached_property def is_builtin_function ( self ) -> bool : \"\"\" Tell if this node's object is a builtin function. Returns: If this node's object is a builtin function. \"\"\" return inspect . isbuiltin ( self . obj )","title":"is_builtin_function()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_method","text":"Tell if this node's object is a builtin method. Returns: bool \u2013 If this node's object is a builtin method. Source code in griffe/agents/nodes.py 459 460 461 462 463 464 465 466 467 @cached_property def is_builtin_method ( self ) -> bool : \"\"\" Tell if this node's object is a builtin method. Returns: If this node's object is a builtin method. \"\"\" return self . is_builtin_function and self . parent_is_class","title":"is_builtin_method()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_cached_property","text":"Tell if this node's object is a cached property. Returns: bool \u2013 If this node's object is a cached property. Source code in griffe/agents/nodes.py 415 416 417 418 419 420 421 422 423 @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property )","title":"is_cached_property()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_class","text":"Tell if this node's object is a class. Returns: bool \u2013 If this node's object is a class. Source code in griffe/agents/nodes.py 365 366 367 368 369 370 371 372 373 @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj )","title":"is_class()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_classmethod","text":"Tell if this node's object is a classmethod. Returns: bool \u2013 If this node's object is a classmethod. Source code in griffe/agents/nodes.py 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod )","title":"is_classmethod()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_coroutine","text":"Tell if this node's object is a coroutine. Returns: bool \u2013 If this node's object is a coroutine. Source code in griffe/agents/nodes.py 395 396 397 398 399 400 401 402 403 @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj )","title":"is_coroutine()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_function","text":"Tell if this node's object is a function. Returns: bool \u2013 If this node's object is a function. Source code in griffe/agents/nodes.py 375 376 377 378 379 380 381 382 383 @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj )","title":"is_function()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method","text":"Tell if this node's object is a method. Returns: bool \u2013 If this node's object is a method. Source code in griffe/agents/nodes.py 435 436 437 438 439 440 441 442 443 444 @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type )","title":"is_method()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method_descriptor","text":"Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: bool \u2013 If this node's object is a method descriptor. Source code in griffe/agents/nodes.py 446 447 448 449 450 451 452 453 454 455 456 457 @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj )","title":"is_method_descriptor()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_module","text":"Tell if this node's object is a module. Returns: bool \u2013 The root of the tree. Source code in griffe/agents/nodes.py 355 356 357 358 359 360 361 362 363 @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj )","title":"is_module()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_property","text":"Tell if this node's object is a property. Returns: bool \u2013 If this node's object is a property. Source code in griffe/agents/nodes.py 405 406 407 408 409 410 411 412 413 @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property","title":"is_property()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_staticmethod","text":"Tell if this node's object is a staticmethod. Returns: bool \u2013 If this node's object is a staticmethod. Source code in griffe/agents/nodes.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod )","title":"is_staticmethod()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.kind","text":"Return the kind of this node. Returns: ObjectKind \u2013 The node kind. Source code in griffe/agents/nodes.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_builtin_method : return ObjectKind . BUILTIN_METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_builtin_function : return ObjectKind . BUILTIN_FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE","title":"kind()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.parent_is_class","text":"Tell if the object of this node's parent is a class. Returns: bool \u2013 If the object of this node's parent is a class. Source code in griffe/agents/nodes.py 425 426 427 428 429 430 431 432 433 @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class )","title":"parent_is_class()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_annotation","text":"Extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 679 680 681 682 683 684 685 686 687 688 689 690 691 def get_annotation ( node : AST | None , parent : Module | Class ) -> str | Name | Expression | None : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" if node is None : return None return _get_annotation ( node , parent )","title":"get_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_docstring","text":"Extract a docstring. Parameters: node ( AST ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/agents/nodes.py 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 def get_docstring ( node : AST , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore[attr-defined] doc = node . body [ 0 ] . value # type: ignore[attr-defined] else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno # type: ignore[attr-defined] if isinstance ( doc , NodeStr ): return doc . s , doc . lineno , doc . end_lineno # type: ignore[attr-defined] return None , None , None","title":"get_docstring()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_instance_names","text":"Extract names from an assignment node, only for instance attributes. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 def get_instance_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )]","title":"get_instance_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_name","text":"Extract name from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: str \u2013 A list of names. Source code in griffe/agents/nodes.py 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 def get_name ( node : AST ) -> str : \"\"\"Extract name from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_name_map [ type ( node )]( node )","title":"get_name()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_names","text":"Extract names from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 def get_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map [ type ( node )]( node )","title":"get_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_parameter_default","text":"Extract the default value of a function parameter. Parameters: node ( AST ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/agents/nodes.py 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 def get_parameter_default ( node : AST , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None if isinstance ( node , NodeConstant ): return repr ( node . value ) if isinstance ( node , NodeStr ): return repr ( node . s ) if isinstance ( node , NodeName ): return node . id if node . lineno == node . end_lineno : # type: ignore[attr-defined] return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # type: ignore[attr-defined] # TODO: handle multiple line defaults return None","title":"get_parameter_default()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_value","text":"Extract a complex value as a string. Parameters: node ( AST ) \u2013 The node to extract the value from. Returns: str \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 def get_value ( node : AST ) -> str : \"\"\"Extract a complex value as a string. Parameters: node: The node to extract the value from. Returns: The unparsed code of the node. \"\"\" return _node_value_map [ type ( node )]( node )","title":"get_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.parse__all__","text":"Get the values declared in __all__ . Parameters: node ( NodeAssign ) \u2013 The assignment node. Returns: set [ str ] \u2013 A set of names. Source code in griffe/agents/nodes.py 540 541 542 543 544 545 546 547 548 549 def parse__all__ ( node : NodeAssign ) -> set [ str ]: # noqa: WPS116,WPS120,WPS440 \"\"\"Get the values declared in `__all__`. Parameters: node: The assignment node. Returns: A set of names. \"\"\" return { elt . value for elt in node . value . elts } # type: ignore[attr-defined]","title":"parse__all__()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.relative_to_absolute","text":"Convert a relative import path to an absolute one. Parameters: node ( NodeImportFrom ) \u2013 The \"from ... import ...\" AST node. name ( NodeAlias ) \u2013 The imported name. current_module ( Module ) \u2013 The module in which the import happens. Returns: str \u2013 The absolute import path. Source code in griffe/agents/nodes.py 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 def relative_to_absolute ( node : NodeImportFrom , name : NodeAlias , current_module : Module ) -> str : \"\"\"Convert a relative import path to an absolute one. Parameters: node: The \"from ... import ...\" AST node. name: The imported name. current_module: The module in which the import happens. Returns: The absolute import path. \"\"\" level = node . level if level > 0 and current_module . is_package or current_module . is_subpackage : level -= 1 while level > 0 and current_module . parent is not None : current_module = current_module . parent # type: ignore[assignment] level -= 1 base = current_module . path + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" return base + node_module + name . name","title":"relative_to_absolute()"},{"location":"reference/griffe/agents/visitor/","text":"Code parsing and data extraction utilies. This module exposes a public function, visit() , which parses the module code using parse() , and returns a new Module instance, populating its members recursively, by using a NodeVisitor -like class. Visitor ( module_name , filepath , code , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 Bases: BaseVisitor This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path ) \u2013 The module filepath. code ( str ) \u2013 The module source code. extensions ( Extensions ) \u2013 The extensions to use when visiting. parent ( Module | None ) \u2013 An optional parent for the final module object. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/agents/visitor.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () generic_visit ( self , node ) \u00a4 Extend the base generic visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 173 174 175 176 177 178 179 180 181 182 183 184 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node ) get_module ( self ) \u00a4 Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: Module \u2013 A module instance. Source code in griffe/agents/visitor.py 147 148 149 150 151 152 153 154 155 156 157 158 159 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module handle_attribute ( self , node , annotation = None ) \u00a4 Handle an attribute (assignment) node. Parameters: node ( ast . Assign | ast . AnnAssign ) \u2013 The node to visit. annotation ( str | Name | Expression | None ) \u2013 A potential annotation. Source code in griffe/agents/visitor.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module-attribute\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class-attribute\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance-attribute\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times # TODO: might be better to inspect if isinstance ( node . parent , ( ast . If , ast . ExceptHandler )): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = parse__all__ ( node ) # type: ignore[arg-type] handle_function ( self , node , labels = None ) \u00a4 Handle a function definition node. Parameters: node ( ast . AsyncFunctionDef | ast . FunctionDef ) \u2013 The node to visit. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/visitor.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # TODO: handle member already exist, setter of property # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] visit ( self , node ) \u00a4 Extend the base visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 161 162 163 164 165 166 167 168 169 170 171 def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node ) visit_annassign ( self , node ) \u00a4 Visit an annotated assignment node. Parameters: node ( ast . AnnAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 498 499 500 501 502 503 504 def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current )) visit_assign ( self , node ) \u00a4 Visit an assignment node. Parameters: node ( ast . Assign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 490 491 492 493 494 495 496 def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node ) visit_asyncfunctiondef ( self , node ) \u00a4 Visit an async function definition node. Parameters: node ( ast . AsyncFunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 361 362 363 364 365 366 367 def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" }) visit_classdef ( self , node ) \u00a4 Visit a class definition node. Parameters: node ( ast . ClassDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] visit_functiondef ( self , node ) \u00a4 Visit a function definition node. Parameters: node ( ast . FunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 353 354 355 356 357 358 359 def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node ) visit_import ( self , node ) \u00a4 Visit an import node. Parameters: node ( ast . Import ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name alias_name = name . asname or alias_path . split ( \".\" , 1 )[ 0 ] self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) visit_importfrom ( self , node ) \u00a4 Visit an \"import from\" node. Parameters: node ( ast . ImportFrom ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 def visit_importfrom ( self , node : ast . ImportFrom ) -> None : # noqa: WPS231 \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : if not node . module and node . level == 1 : if not name . asname : # special case: when being in `a` and doing `from . import b`, # we are effectively creating a member `b` in `a` that is pointing to `a.b` # -> cyclic alias! in that case, we just skip it, as both the member and module # have the same name and can be accessed the same way continue alias_path = relative_to_absolute ( node , name , self . current . module ) if name . name == \"*\" : alias_name = alias_path . replace ( \".\" , \"/\" ) # type: ignore[union-attr] alias_path = alias_path . replace ( \".*\" , \"\" ) else : alias_name = name . asname or name . name self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , # type: ignore[arg-type] lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) visit_module ( self , node ) \u00a4 Visit a module node. Parameters: node ( ast . Module ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node ) patch_ast () \u00a4 Extend the base ast.AST class to provide more functionality. Source code in griffe/agents/visitor.py 510 511 512 513 514 515 516 517 518 519 def patch_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if ast . AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , ASTNode ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442 visit ( module_name , filepath , code , * , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/visitor.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def visit ( module_name : str , filepath : Path , code : str , * , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. Returns: The module, with its members populated. \"\"\" return Visitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , ) . get_module ()","title":"visitor"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor","text":"Bases: BaseVisitor This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path ) \u2013 The module filepath. code ( str ) \u2013 The module source code. extensions ( Extensions ) \u2013 The extensions to use when visiting. parent ( Module | None ) \u2013 An optional parent for the final module object. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/agents/visitor.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection ()","title":"Visitor"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.generic_visit","text":"Extend the base generic visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 173 174 175 176 177 178 179 180 181 182 183 184 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node )","title":"generic_visit()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.get_module","text":"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: Module \u2013 A module instance. Source code in griffe/agents/visitor.py 147 148 149 150 151 152 153 154 155 156 157 158 159 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module","title":"get_module()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_attribute","text":"Handle an attribute (assignment) node. Parameters: node ( ast . Assign | ast . AnnAssign ) \u2013 The node to visit. annotation ( str | Name | Expression | None ) \u2013 A potential annotation. Source code in griffe/agents/visitor.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module-attribute\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class-attribute\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance-attribute\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times # TODO: might be better to inspect if isinstance ( node . parent , ( ast . If , ast . ExceptHandler )): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = parse__all__ ( node ) # type: ignore[arg-type]","title":"handle_attribute()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_function","text":"Handle a function definition node. Parameters: node ( ast . AsyncFunctionDef | ast . FunctionDef ) \u2013 The node to visit. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/visitor.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # TODO: handle member already exist, setter of property # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"handle_function()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit","text":"Extend the base visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 161 162 163 164 165 166 167 168 169 170 171 def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node )","title":"visit()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_annassign","text":"Visit an annotated assignment node. Parameters: node ( ast . AnnAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 498 499 500 501 502 503 504 def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current ))","title":"visit_annassign()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_assign","text":"Visit an assignment node. Parameters: node ( ast . Assign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 490 491 492 493 494 495 496 def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node )","title":"visit_assign()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_asyncfunctiondef","text":"Visit an async function definition node. Parameters: node ( ast . AsyncFunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 361 362 363 364 365 366 367 def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" })","title":"visit_asyncfunctiondef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_classdef","text":"Visit a class definition node. Parameters: node ( ast . ClassDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"visit_classdef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_functiondef","text":"Visit a function definition node. Parameters: node ( ast . FunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 353 354 355 356 357 358 359 def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node )","title":"visit_functiondef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_import","text":"Visit an import node. Parameters: node ( ast . Import ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name alias_name = name . asname or alias_path . split ( \".\" , 1 )[ 0 ] self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node )","title":"visit_import()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_importfrom","text":"Visit an \"import from\" node. Parameters: node ( ast . ImportFrom ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 def visit_importfrom ( self , node : ast . ImportFrom ) -> None : # noqa: WPS231 \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : if not node . module and node . level == 1 : if not name . asname : # special case: when being in `a` and doing `from . import b`, # we are effectively creating a member `b` in `a` that is pointing to `a.b` # -> cyclic alias! in that case, we just skip it, as both the member and module # have the same name and can be accessed the same way continue alias_path = relative_to_absolute ( node , name , self . current . module ) if name . name == \"*\" : alias_name = alias_path . replace ( \".\" , \"/\" ) # type: ignore[union-attr] alias_path = alias_path . replace ( \".*\" , \"\" ) else : alias_name = name . asname or name . name self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , # type: ignore[arg-type] lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node )","title":"visit_importfrom()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_module","text":"Visit a module node. Parameters: node ( ast . Module ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node )","title":"visit_module()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.patch_ast","text":"Extend the base ast.AST class to provide more functionality. Source code in griffe/agents/visitor.py 510 511 512 513 514 515 516 517 518 519 def patch_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if ast . AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , ASTNode ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442","title":"patch_ast()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.visit","text":"Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/visitor.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def visit ( module_name : str , filepath : Path , code : str , * , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. Returns: The module, with its members populated. \"\"\" return Visitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , ) . get_module ()","title":"visit()"},{"location":"reference/griffe/agents/extensions/","text":"This module is the public interface to import elements from the base. Extensions ( * extensions ) \u00a4 This class helps iterating on extensions that should run at different times. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) add ( self , * extensions ) \u00a4 Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 107 108 109 110 111 112 113 114 115 116 117 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) after_children_inspection ( self ) \u00a4 Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 201 202 203 204 205 206 207 208 @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] after_children_visit ( self ) \u00a4 Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 165 166 167 168 169 170 171 172 @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] after_inspection ( self ) \u00a4 Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 210 211 212 213 214 215 216 217 @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ] after_visit ( self ) \u00a4 Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 174 175 176 177 178 179 180 181 @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] attach_inspector ( self , parent_inspector ) \u00a4 Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 133 134 135 136 137 138 139 140 141 142 143 144 145 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self attach_visitor ( self , parent_visitor ) \u00a4 Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 119 120 121 122 123 124 125 126 127 128 129 130 131 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self before_children_inspection ( self ) \u00a4 Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 192 193 194 195 196 197 198 199 @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] before_children_visit ( self ) \u00a4 Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 156 157 158 159 160 161 162 163 @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] before_inspection ( self ) \u00a4 Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 183 184 185 186 187 188 189 190 @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] before_visit ( self ) \u00a4 Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 147 148 149 150 151 152 153 154 @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] InspectorExtension () \u00a4 Bases: BaseInspector The object inspector extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 3 4 5 6 def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment] attach ( self , inspector ) \u00a4 Attach the parent inspector to this extension. Parameters: inspector ( Inspector ) \u2013 The parent inspector. Source code in griffe/agents/extensions/base.py 74 75 76 77 78 79 80 def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector inspect ( self , node ) \u00a4 Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/extensions/base.py 82 83 84 85 86 87 88 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node ) VisitorExtension () \u00a4 Bases: BaseVisitor The node visitor extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 3 4 5 6 def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment] attach ( self , visitor ) \u00a4 Attach the parent visitor to this extension. Parameters: visitor ( Visitor ) \u2013 The parent visitor. Source code in griffe/agents/extensions/base.py 47 48 49 50 51 52 53 def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor visit ( self , node ) \u00a4 Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/extensions/base.py 55 56 57 58 59 60 61 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined] When \u00a4 Bases: enum . Enum This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection. load_extension ( extension ) \u00a4 Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Raises: ExtensionNotLoadedError \u2013 When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Raises: ExtensionNotLoadedError: When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" try : ext_module = dynamic_import ( import_path ) except ModuleNotFoundError as error : raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' could not be found\" ) from error except ImportError as error : raise ExtensionNotLoadedError ( f \"Error while importing extension module ' { import_path } ': { error } \" ) from error try : return ext_module . Extension ( ** options ) except AttributeError as error : # noqa: WPS440 raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' has no 'Extension' attribute\" ) from error load_extensions ( exts ) \u00a4 Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"extensions"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.Extensions","text":"This class helps iterating on extensions that should run at different times. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions )","title":"Extensions"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.add","text":"Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 107 108 109 110 111 112 113 114 115 116 117 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension )","title":"add()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_children_inspection","text":"Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 201 202 203 204 205 206 207 208 @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ]","title":"after_children_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_children_visit","text":"Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 165 166 167 168 169 170 171 172 @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ]","title":"after_children_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_inspection","text":"Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 210 211 212 213 214 215 216 217 @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ]","title":"after_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_visit","text":"Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 174 175 176 177 178 179 180 181 @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ]","title":"after_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.attach_inspector","text":"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 133 134 135 136 137 138 139 140 141 142 143 144 145 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self","title":"attach_inspector()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.attach_visitor","text":"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 119 120 121 122 123 124 125 126 127 128 129 130 131 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self","title":"attach_visitor()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_children_inspection","text":"Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 192 193 194 195 196 197 198 199 @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ]","title":"before_children_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_children_visit","text":"Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 156 157 158 159 160 161 162 163 @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ]","title":"before_children_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_inspection","text":"Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 183 184 185 186 187 188 189 190 @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ]","title":"before_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_visit","text":"Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 147 148 149 150 151 152 153 154 @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ]","title":"before_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.InspectorExtension","text":"Bases: BaseInspector The object inspector extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 3 4 5 6 def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment]","title":"InspectorExtension"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.InspectorExtension.attach","text":"Attach the parent inspector to this extension. Parameters: inspector ( Inspector ) \u2013 The parent inspector. Source code in griffe/agents/extensions/base.py 74 75 76 77 78 79 80 def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector","title":"attach()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.InspectorExtension.inspect","text":"Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/extensions/base.py 82 83 84 85 86 87 88 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node )","title":"inspect()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.VisitorExtension","text":"Bases: BaseVisitor The node visitor extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 3 4 5 6 def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment]","title":"VisitorExtension"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.VisitorExtension.attach","text":"Attach the parent visitor to this extension. Parameters: visitor ( Visitor ) \u2013 The parent visitor. Source code in griffe/agents/extensions/base.py 47 48 49 50 51 52 53 def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor","title":"attach()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.VisitorExtension.visit","text":"Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/extensions/base.py 55 56 57 58 59 60 61 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined]","title":"visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.When","text":"Bases: enum . Enum This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection.","title":"When"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.load_extension","text":"Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Raises: ExtensionNotLoadedError \u2013 When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Raises: ExtensionNotLoadedError: When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" try : ext_module = dynamic_import ( import_path ) except ModuleNotFoundError as error : raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' could not be found\" ) from error except ImportError as error : raise ExtensionNotLoadedError ( f \"Error while importing extension module ' { import_path } ': { error } \" ) from error try : return ext_module . Extension ( ** options ) except AttributeError as error : # noqa: WPS440 raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' has no 'Extension' attribute\" ) from error","title":"load_extension()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.load_extensions","text":"Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"load_extensions()"},{"location":"reference/griffe/agents/extensions/hybrid/","text":"This extension provides an hybrid behavior while loading data. HybridExtension ( extension ) \u00a4 Bases: VisitorExtension Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. Parameters: extension ( str | dict [ str , Any ] ) \u2013 The name or configuration of another extension. Raises: ExtensionError \u2013 When the passed extension is not an inspector extension. Source code in griffe/agents/extensions/hybrid.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ ()","title":"hybrid"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension","text":"Bases: VisitorExtension Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. Parameters: extension ( str | dict [ str , Any ] ) \u2013 The name or configuration of another extension. Raises: ExtensionError \u2013 When the passed extension is not an inspector extension. Source code in griffe/agents/extensions/hybrid.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ ()","title":"HybridExtension"},{"location":"reference/griffe/docstrings/","text":"This module exposes objects related to docstrings. Parser \u00a4 Bases: enum . Enum Enumeration for the different docstring parsers. parse ( docstring , parser , ** options ) \u00a4 Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) # type: ignore[operator] return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"docstrings"},{"location":"reference/griffe/docstrings/#griffe.docstrings.Parser","text":"Bases: enum . Enum Enumeration for the different docstring parsers.","title":"Parser"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parse","text":"Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) # type: ignore[operator] return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/dataclasses/","text":"This module contains the dataclasses related to docstrings. DocstringAdmonition ( * , kind , contents ) \u00a4 This base class represents admonitions. Attributes: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Parameters: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 63 64 65 66 67 68 69 70 71 def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents as_dict ( self , ** kwargs ) \u00a4 Return this admonition's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , } DocstringAttribute \u00a4 Bases: DocstringNamedElement This class represents a documented module/class attribute. DocstringElement ( * , description , annotation = None ) \u00a4 This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 96 97 98 99 100 101 102 103 104 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , } DocstringNamedElement ( name , * , description , annotation = None , value = None ) \u00a4 Bases: DocstringElement This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None , ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base DocstringParameter \u00a4 Bases: DocstringNamedElement This class represent a documented function parameter. DocstringRaise \u00a4 Bases: DocstringElement This class represents a documented raise value. DocstringReceive \u00a4 Bases: DocstringNamedElement This class represents a documented receive value. DocstringReturn \u00a4 Bases: DocstringNamedElement This class represents a documented return value. DocstringSection ( kind , value , title = None ) \u00a4 Placeholder. Parameters: kind ( DocstringSectionKind ) \u2013 The section kind. value ( Any ) \u2013 The section value. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title as_dict ( self , ** kwargs ) \u00a4 Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base DocstringSectionKind \u00a4 Bases: enum . Enum The possible section kinds. DocstringWarn \u00a4 Bases: DocstringElement This class represents a documented warn value. DocstringYield \u00a4 Bases: DocstringNamedElement This class represents a documented yield value.","title":"dataclasses"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition","text":"This base class represents admonitions. Attributes: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Parameters: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 63 64 65 66 67 68 69 70 71 def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents","title":"DocstringAdmonition"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.as_dict","text":"Return this admonition's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , }","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAttribute","text":"Bases: DocstringNamedElement This class represents a documented module/class attribute.","title":"DocstringAttribute"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement","text":"This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 96 97 98 99 100 101 102 103 104 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation","title":"DocstringElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.as_dict","text":"Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , }","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement","text":"Bases: DocstringElement This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None , ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value","title":"DocstringNamedElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.as_dict","text":"Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter","text":"Bases: DocstringNamedElement This class represent a documented function parameter.","title":"DocstringParameter"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringRaise","text":"Bases: DocstringElement This class represents a documented raise value.","title":"DocstringRaise"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReceive","text":"Bases: DocstringNamedElement This class represents a documented receive value.","title":"DocstringReceive"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReturn","text":"Bases: DocstringNamedElement This class represents a documented return value.","title":"DocstringReturn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection","text":"Placeholder. Parameters: kind ( DocstringSectionKind ) \u2013 The section kind. value ( Any ) \u2013 The section value. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title","title":"DocstringSection"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.as_dict","text":"Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind","text":"Bases: enum . Enum The possible section kinds.","title":"DocstringSectionKind"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringWarn","text":"Bases: DocstringElement This class represents a documented warn value.","title":"DocstringWarn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringYield","text":"Bases: DocstringNamedElement This class represents a documented yield value.","title":"DocstringYield"},{"location":"reference/griffe/docstrings/google/","text":"This module defines functions to parse Google-style docstrings into structured data. parse ( docstring , ignore_init_summary = False , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. ignore_init_summary ( bool ) \u2013 Whether to ignore the summary in __init__ methods' docstrings. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 def parse ( # noqa: WPS231 docstring : Docstring , ignore_init_summary : bool = False , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines ignore_summary = ( ignore_init_summary # noqa: WPS222 and docstring . parent is not None and docstring . parent . name == \"__init__\" and docstring . parent . is_function and docstring . parent . parent is not None and docstring . parent . parent . is_class ) if ignore_summary : offset = 2 else : offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : # TODO: once Python 3.7 is dropped, use walrus operator match = _RE_ADMONITION . match ( lines [ offset ]) if match : groups = match . groupdict () title = groups [ \"title\" ] admonition_type = groups [ \"type\" ] if admonition_type . lower () in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type . lower ()]] section , offset = reader ( docstring , offset + 1 ) if section : section . title = title sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : if title is None : title = admonition_type admonition_type = admonition_type . lower () . replace ( \" \" , \"-\" ) sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type , contents = contents ), title = title , ) ) else : with suppress ( IndexError ): current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"google"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. ignore_init_summary ( bool ) \u2013 Whether to ignore the summary in __init__ methods' docstrings. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 def parse ( # noqa: WPS231 docstring : Docstring , ignore_init_summary : bool = False , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines ignore_summary = ( ignore_init_summary # noqa: WPS222 and docstring . parent is not None and docstring . parent . name == \"__init__\" and docstring . parent . is_function and docstring . parent . parent is not None and docstring . parent . parent . is_class ) if ignore_summary : offset = 2 else : offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : # TODO: once Python 3.7 is dropped, use walrus operator match = _RE_ADMONITION . match ( lines [ offset ]) if match : groups = match . groupdict () title = groups [ \"title\" ] admonition_type = groups [ \"type\" ] if admonition_type . lower () in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type . lower ()]] section , offset = reader ( docstring , offset + 1 ) if section : section . title = title sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : if title is None : title = admonition_type admonition_type = admonition_type . lower () . replace ( \" \" , \"-\" ) sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type , contents = contents ), title = title , ) ) else : with suppress ( IndexError ): current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/markdown/","text":"This module defines functions and classes to parse Markdown docstrings into structured data.","title":"markdown"},{"location":"reference/griffe/docstrings/numpy/","text":"This module defines functions to parse Numpy-style docstrings into structured data. Based on https://numpydoc.readthedocs.io/en/latest/format.html , it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification. Rejected as non particularly Pythonic or useful as sections: See also: this section feels too subjective (specially crafted as a standard for Numpy itself), and there are may ways to reference related items in a docstring, depending on the chosen markup. Methods: with a good documentation renderer, methods are easily made accessible or hidden. Griffe also has a goal of making the merging of inherited methods configurable (on/off). Rejected as naturally handled by the user-chosen markup: Warnings: this is just markup. Notes: again, just markup. References: again, just markup. The following sections are supported: Deprecated (revisited): we expect a title instead of an RST directive. Python has support for deprecating things, so it feels natural to structure deprecations. Parameters: obviously. Returns: obviously. Yields: obviously. Receives: less used than Yields, but very natural/Pythonic as well. Other parameters: used here as documentation for keyword parameters. Raises: obviously. Warns: less used than Raises, but very natural/Pythonic as well. Examples: obviously. Special handling for non-code-blocks >>> . Attributes: obviously. parse ( docstring , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"numpy"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/parsers/","text":"This module imports all the defined parsers. Parser \u00a4 Bases: enum . Enum Enumeration for the different docstring parsers. parse ( docstring , parser , ** options ) \u00a4 Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) # type: ignore[operator] return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parsers"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser","text":"Bases: enum . Enum Enumeration for the different docstring parsers.","title":"Parser"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.parse","text":"Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) # type: ignore[operator] return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/sphinx/","text":"This module defines functions to parse Sphinx docstrings into structured data. Credits to Patrick Lannigan ( @plannigan ) who originally added the parser in the pytkdocs project . See https://github.com/mkdocstrings/pytkdocs/pull/71 . FieldType \u00a4 Maps directive names to parser functions. matches ( self , line ) \u00a4 Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/sphinx.py 47 48 49 50 51 52 53 54 55 56 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names ) ParsedDirective \u00a4 Directive information that has been parsed from a docstring. ParsedValues \u00a4 Values parsed from the docstring to be used to produce sections. parse ( docstring , ** options ) \u00a4 Parse a Sphinx-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/sphinx.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse a Sphinx-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore[misc,operator] break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"sphinx"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.FieldType","text":"Maps directive names to parser functions.","title":"FieldType"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.FieldType.matches","text":"Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/sphinx.py 47 48 49 50 51 52 53 54 55 56 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names )","title":"matches()"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.ParsedDirective","text":"Directive information that has been parsed from a docstring.","title":"ParsedDirective"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.ParsedValues","text":"Values parsed from the docstring to be used to produce sections.","title":"ParsedValues"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.parse","text":"Parse a Sphinx-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/sphinx.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse a Sphinx-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore[misc,operator] break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"parse()"},{"location":"reference/griffe/docstrings/utils/","text":"This module contains utilities for docstrings parsers. parse_annotation ( annotation , docstring ) \u00a4 Parse a string into a true name or expression that can be resolved later. Parameters: annotation ( str ) \u2013 The annotation to parse. docstring ( Docstring ) \u2013 The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression. Returns: str | Name | Expression \u2013 The string unchanged, or a new name or expression. Source code in griffe/docstrings/utils.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def parse_annotation ( annotation : str , docstring : Docstring ) -> str | Name | Expression : \"\"\"Parse a string into a true name or expression that can be resolved later. Parameters: annotation: The annotation to parse. docstring: The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression. Returns: The string unchanged, or a new name or expression. \"\"\" with suppress ( AttributeError , SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) if code . body : return get_annotation ( code . body , parent = docstring . parent ) or annotation # type: ignore[arg-type] return annotation warning ( name ) \u00a4 Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore[union-attr] except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { ( docstring . lineno or 0 ) + offset } : { message } \" ) return warn","title":"utils"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.parse_annotation","text":"Parse a string into a true name or expression that can be resolved later. Parameters: annotation ( str ) \u2013 The annotation to parse. docstring ( Docstring ) \u2013 The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression. Returns: str | Name | Expression \u2013 The string unchanged, or a new name or expression. Source code in griffe/docstrings/utils.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def parse_annotation ( annotation : str , docstring : Docstring ) -> str | Name | Expression : \"\"\"Parse a string into a true name or expression that can be resolved later. Parameters: annotation: The annotation to parse. docstring: The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression. Returns: The string unchanged, or a new name or expression. \"\"\" with suppress ( AttributeError , SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) if code . body : return get_annotation ( code . body , parent = docstring . parent ) or annotation # type: ignore[arg-type] return annotation","title":"parse_annotation()"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.warning","text":"Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore[union-attr] except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { ( docstring . lineno or 0 ) + offset } : { message } \" ) return warn","title":"warning()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}