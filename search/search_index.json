{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"griffe \u00a4 Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Work in progress! Requirements \u00a4 Griffe requires Python 3.8 or above. To install Python 3.8, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - bash ) \" # install Python 3.8 pyenv install 3 .8.12 # make it available globally pyenv global system 3 .8.12 Installation \u00a4 With pip : python3.8 -m pip install griffe With pipx : python3.8 -m pip install --user pipx pipx install --python python3.8 griffe Usage \u00a4 On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples. Todo \u00a4 Design: Navigable trees (nodes and data) Extension system Performance (loading data, no serialization) sync: ~60 KLoC/s, ~330 files/s async: ~100 KLoC/s, ~550 files/s Loader/Visitor: Docstrings Line numbers Parsing: see below Labels Modules Classes Bases (parent classes) Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring Decorators Functions Arguments Return annotation (names, constants, attributes) Decorators Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Data (variables/attributes) Docstrings Value Name resolution Per-object scope Load external packages resursively (inheritance) Resolve everything that is an ast.Name Resolve names inside more complex expressions? Calls, exprs, etc. Lines collection (lines for each module) Extension system Node-visiting extensions Post-processing extensions Docstrings parsers Structured format Styles Google RST Numpy epydoc New Markdown-based format? For graceful degradation Serializer: JSON Nested Flat API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword arguments Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only argument Changed position of positional or keyword argument Changed type of argument Changed type of public module attribute Changed return type of a public function/method Added argument without a default value Removed keyword-only argument without a default value, without **kwargs to swallow it Removed positional-only argument without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Overview"},{"location":"#griffe","text":"Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Work in progress!","title":"griffe"},{"location":"#requirements","text":"Griffe requires Python 3.8 or above. To install Python 3.8, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - bash ) \" # install Python 3.8 pyenv install 3 .8.12 # make it available globally pyenv global system 3 .8.12","title":"Requirements"},{"location":"#installation","text":"With pip : python3.8 -m pip install griffe With pipx : python3.8 -m pip install --user pipx pipx install --python python3.8 griffe","title":"Installation"},{"location":"#usage","text":"On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples.","title":"Usage"},{"location":"#todo","text":"Design: Navigable trees (nodes and data) Extension system Performance (loading data, no serialization) sync: ~60 KLoC/s, ~330 files/s async: ~100 KLoC/s, ~550 files/s Loader/Visitor: Docstrings Line numbers Parsing: see below Labels Modules Classes Bases (parent classes) Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring Decorators Functions Arguments Return annotation (names, constants, attributes) Decorators Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Data (variables/attributes) Docstrings Value Name resolution Per-object scope Load external packages resursively (inheritance) Resolve everything that is an ast.Name Resolve names inside more complex expressions? Calls, exprs, etc. Lines collection (lines for each module) Extension system Node-visiting extensions Post-processing extensions Docstrings parsers Structured format Styles Google RST Numpy epydoc New Markdown-based format? For graceful degradation Serializer: JSON Nested Flat API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword arguments Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only argument Changed position of positional or keyword argument Changed type of argument Changed type of public module attribute Changed return type of a public function/method Added argument without a default value Removed keyword-only argument without a default value, without **kwargs to swallow it Removed positional-only argument without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Todo"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.2.0 - 2021-09-25 \u00a4 Compare with 0.1.0 Features \u00a4 Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli). 0.1.0 - 2021-09-09 \u00a4 Compare with first commit Features \u00a4 Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#020-2021-09-25","text":"Compare with 0.1.0","title":"0.2.0 - 2021-09-25"},{"location":"changelog/#features","text":"Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements","text":"Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#010-2021-09-09","text":"Compare with first commit","title":"0.1.0 - 2021-09-09"},{"location":"changelog/#features_1","text":"Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build griffe . Thank you! python | pdm | copier-pdm Direct dependencies \u00a4 aiofiles | autoflake | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | toml | wps-light Indirect dependencies \u00a4 ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | click | colorama | coverage | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | regex | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typing-extensions | watchdog | wheel | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build griffe . Thank you! python | pdm | copier-pdm","title":"Credits"},{"location":"credits/#direct-dependencies","text":"aiofiles | autoflake | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | toml | wps-light","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | click | colorama | coverage | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | regex | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typing-extensions | watchdog | wheel | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2021, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"usage/","text":"Usage \u00a4 On the command line \u00a4 Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError . With Python \u00a4 Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) If you don't want to recurse in the submodules: fastapi = griffe . load_module ( \"fastapi\" , recursive = False ) Extensions \u00a4 You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import Extension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( Extension ): when = When . visit_stops def visit_ClassDef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE> methods to visit nodes of certain types, and act on their properties. Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not call the .generic_visit(node) method in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children (what the generic_visit does). You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_FunctionDef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, data See the data classes ( Module , Class , Function and Data ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit starts: When.visit_starts . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current ) is not yet instantiated. before the children visit starts: When.children_visit_starts . If this node represents a data object, the object ( self.visitor.current ) is now instantiated. Children have not yet been visited. after the children visit stops: When.children_visit_stops . Children have now been visited. after the visit stops: When.visit_stops See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . children_visit_stops By default, it will run it when the visit for the node stops: that's when all the data for this node and its children is loaded. ??? Nodes - `Constant` - `Num` - `Str` - `FormattedValue` - `JoinedStr` - `Bytes` - `List` - `Tuple` - `Set` - `Dict` - `Ellipsis` - `NameConstant` - `Name` - `Load` - `Store` - `Del` - `Starred` - `Expr` - `NamedExpr` - `UnaryOp` - `UAdd` - `USub` - `Not` - `Invert` - `BinOp` - `Add` - `Sub` - `Mult` - `Div` - `FloorDiv` - `Mod` - `Pow` - `LShift` - `RShift` - `BitOr` - `BitXor` - `BitAnd` - `MatMult` - `BoolOp` - `And` - `Or` - `Compare` - `Eq` - `NotEq` - `Lt` - `LtE` - `Gt` - `GtE` - `Is` - `IsNot` - `In` - `NotIn` - `Call` - `keyword` - `IfExp` - `Attribute` - `Subscript` - `Index` - `Slice` - `ExtSlice` - `ListComp` - `SetComp` - `GeneratorExp` - `DictComp` - `comprehension` - `Assign` - `AnnAssign` - `AugAssign` - `Print` - `Raise` - `Assert` - `Delete` - `Pass` - `Import` - `ImportFrom` - `alias` - `If` - `For` - `While` - `Break` - `Continue` - `Try` - `TryFinally` - `TryExcept` - `ExceptHandler` - `With` - `withitem` - `Lambda` - `arguments` - `arg` - `Return` - `Yield` - `YieldFrom` - `Global` - `NonLocal` - `AsyncFunctionDef` - `Await` - `AsyncFor` - `AsyncWith` - `Module` - `Interactive` - `Expression` - `ClassDef` - `FunctionDef` - `MatchOr` - `MatchAs` - `MatchClass` - `MatchMapping` - `MatchStar` - `MatchSequence` - `MatchSingleton` - `MatchValue` - `match_case` - `pattern` - `Match`","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#on-the-command-line","text":"Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError .","title":"On the command line"},{"location":"usage/#with-python","text":"Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) If you don't want to recurse in the submodules: fastapi = griffe . load_module ( \"fastapi\" , recursive = False )","title":"With Python"},{"location":"usage/#extensions","text":"You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import Extension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( Extension ): when = When . visit_stops def visit_ClassDef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE> methods to visit nodes of certain types, and act on their properties. Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not call the .generic_visit(node) method in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children (what the generic_visit does). You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_FunctionDef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, data See the data classes ( Module , Class , Function and Data ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit starts: When.visit_starts . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current ) is not yet instantiated. before the children visit starts: When.children_visit_starts . If this node represents a data object, the object ( self.visitor.current ) is now instantiated. Children have not yet been visited. after the children visit stops: When.children_visit_stops . Children have now been visited. after the visit stops: When.visit_stops See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . children_visit_stops By default, it will run it when the visit for the node stops: that's when all the data for this node and its children is loaded. ??? Nodes - `Constant` - `Num` - `Str` - `FormattedValue` - `JoinedStr` - `Bytes` - `List` - `Tuple` - `Set` - `Dict` - `Ellipsis` - `NameConstant` - `Name` - `Load` - `Store` - `Del` - `Starred` - `Expr` - `NamedExpr` - `UnaryOp` - `UAdd` - `USub` - `Not` - `Invert` - `BinOp` - `Add` - `Sub` - `Mult` - `Div` - `FloorDiv` - `Mod` - `Pow` - `LShift` - `RShift` - `BitOr` - `BitXor` - `BitAnd` - `MatMult` - `BoolOp` - `And` - `Or` - `Compare` - `Eq` - `NotEq` - `Lt` - `LtE` - `Gt` - `GtE` - `Is` - `IsNot` - `In` - `NotIn` - `Call` - `keyword` - `IfExp` - `Attribute` - `Subscript` - `Index` - `Slice` - `ExtSlice` - `ListComp` - `SetComp` - `GeneratorExp` - `DictComp` - `comprehension` - `Assign` - `AnnAssign` - `AugAssign` - `Print` - `Raise` - `Assert` - `Delete` - `Pass` - `Import` - `ImportFrom` - `alias` - `If` - `For` - `While` - `Break` - `Continue` - `Try` - `TryFinally` - `TryExcept` - `ExceptHandler` - `With` - `withitem` - `Lambda` - `arguments` - `arg` - `Return` - `Yield` - `YieldFrom` - `Global` - `NonLocal` - `AsyncFunctionDef` - `Await` - `AsyncFor` - `AsyncWith` - `Module` - `Interactive` - `Expression` - `ClassDef` - `FunctionDef` - `MatchOr` - `MatchAs` - `MatchClass` - `MatchMapping` - `MatchStar` - `MatchSequence` - `MatchSingleton` - `MatchValue` - `match_case` - `pattern` - `Match`","title":"Extensions"},{"location":"reference/SUMMARY/","text":"griffe __init__.py __main__.py cli.py collections.py dataclasses.py docstrings __init__.py dataclasses.py google.py markdown.py numpy.py parsers.py rst.py utils.py encoders.py extended_ast.py extensions __init__.py base.py loader.py logger.py visitor.py","title":"SUMMARY"},{"location":"reference/__init__/","text":"griffe package. Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.","title":"__init__.py"},{"location":"reference/__main__/","text":"Entry-point module, in case you use python -m griffe . Why does this file exist, and why __main__ ? For more info, read: https://www.python.org/dev/peps/pep-0338/ https://docs.python.org/3/using/cmdline.html#cmdoption-m","title":"__main__.py"},{"location":"reference/cli/","text":"Module that contains the command line application. get_parser () \u00a4 Return the program argument parser. Returns: Type Description argparse.ArgumentParser The argument parser for the program. Source code in griffe/cli.py def get_parser () -> argparse . ArgumentParser : \"\"\" Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async-loader\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-a\" , \"--append-sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {{package}}.\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser main ( args = None ) \u00a4 Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: Name Type Description Default args list[str] | None Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in griffe/cli.py def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\" Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) # type: ignore logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = logging . WARNING ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . append_sys_path : search . extend ( sys . path ) extend_ast () extensions = Extensions () if opts . async_loader : loop = asyncio . get_event_loop () coroutine = _load_packages_async ( opts . packages , extensions = extensions , search_paths = search ) packages = loop . run_until_complete ( coroutine ) else : packages = _load_packages ( opts . packages , extensions = extensions , search_paths = search ) if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = Encoder , indent = 2 , full = False ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = Encoder , indent = 2 , full = False ) _print_data ( serialized , output ) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"cli.py"},{"location":"reference/cli/#griffe.cli.get_parser","text":"Return the program argument parser. Returns: Type Description argparse.ArgumentParser The argument parser for the program. Source code in griffe/cli.py def get_parser () -> argparse . ArgumentParser : \"\"\" Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async-loader\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-a\" , \"--append-sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {{package}}.\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser","title":"get_parser()"},{"location":"reference/cli/#griffe.cli.main","text":"Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: Name Type Description Default args list[str] | None Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in griffe/cli.py def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\" Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) # type: ignore logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = logging . WARNING ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . append_sys_path : search . extend ( sys . path ) extend_ast () extensions = Extensions () if opts . async_loader : loop = asyncio . get_event_loop () coroutine = _load_packages_async ( opts . packages , extensions = extensions , search_paths = search ) packages = loop . run_until_complete ( coroutine ) else : packages = _load_packages ( opts . packages , extensions = extensions , search_paths = search ) if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = Encoder , indent = 2 , full = False ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = Encoder , indent = 2 , full = False ) _print_data ( serialized , output ) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"main()"},{"location":"reference/collections/","text":"This module stores collections of data, useful during parsing. lines_collection : dict \u00a4 A simple dictionary containing lines of modules. It will probably be made more powerful later.","title":"collections.py"},{"location":"reference/collections/#griffe.collections.lines_collection","text":"A simple dictionary containing lines of modules. It will probably be made more powerful later.","title":"lines_collection"},{"location":"reference/dataclasses/","text":"This module contains the data classes that represent Python objects. The different objects are modules, classes, functions, and data (variables like module/class/instance attributes). Argument \u00a4 This class represent a function argument. Attributes: Name Type Description name str The argument name. annotation str | None The argument annotation, if any. kind ParameterKind | None The argument kind (see inspect.Parameter.kind ). default str | None The argument default, if any. __init__ ( self , name , * , annotation = None , kind = None , default = None ) special \u00a4 Initialize the argument. Parameters: Name Type Description Default name str The argument name. required annotation str | None The argument annotation, if any. None kind ParameterKind | None The argument kind (see inspect.Parameter.kind ). None default str | None The argument default, if any. None Source code in griffe/dataclasses.py def __init__ ( self , name : str , * , annotation : str | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the argument. Arguments: name: The argument name. annotation: The argument annotation, if any. kind: The argument kind (see [`inspect.Parameter.kind`][]). default: The argument default, if any. \"\"\" self . name : str = name self . annotation : str | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default as_dict ( self , ** kwargs ) \u00a4 Return this argument's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this argument's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , } Arguments \u00a4 This class is a container for arguments. It allows to get arguments using their position (index) or their name. __init__ ( self , * arguments ) special \u00a4 Initialize the arguments container. Parameters: Name Type Description Default *arguments Argument The initial arguments to add to the container. () Source code in griffe/dataclasses.py def __init__ ( self , * arguments : Argument ) -> None : \"\"\"Initialize the arguments container. Arguments: *arguments: The initial arguments to add to the container. \"\"\" self . _arguments_list : list [ Argument ] = [] self . _arguments_dict : dict [ str , Argument ] = {} for argument in arguments : self . add ( argument ) add ( self , argument ) \u00a4 Add an argument to the container. Parameters: Name Type Description Default argument Argument The function argument to add. required Exceptions: Type Description ValueError When an argument with the same name is already present. Source code in griffe/dataclasses.py def add ( self , argument : Argument ) -> None : \"\"\"Add an argument to the container. Arguments: argument: The function argument to add. Raises: ValueError: When an argument with the same name is already present. \"\"\" if argument . name not in self . _arguments_dict : self . _arguments_dict [ argument . name ] = argument self . _arguments_list . append ( argument ) else : raise ValueError ( f \"argument { argument . name } already present\" ) Class ( Object ) \u00a4 The class representing a Python class. __init__ ( self , * args , * , bases = None , decorators = None , ** kwargs ) special \u00a4 Initialize the class. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () bases list[str] | None The list of base classes, if any. None decorators list[Decorator] | None The class decorators, if any. None **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , bases : list [ str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs , ) -> None : \"\"\"Initialize the class. Arguments: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases = bases or [] self . decorators = decorators or [] as_dict ( self , ** kwargs ) \u00a4 Return this class' data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this class' data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base Data ( Object ) \u00a4 The class representing a Python module/class/instance attribute. __init__ ( self , * args , * , value = None , annotation = None , ** kwargs ) special \u00a4 Initialize the function. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () value str | None The data value, if any. None annotation str | None The data annotation, if any. None **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , value : str | None = None , annotation : str | None = None , ** kwargs , ) -> None : \"\"\"Initialize the function. Arguments: *args: See [`griffe.dataclasses.Object`][]. value: The data value, if any. annotation: The data annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base Decorator \u00a4 This class represents decorators. Attributes: Name Type Description lineno int | None The starting line number. endlineno int | None The ending line number. __init__ ( self , lineno , endlineno ) special \u00a4 Initialize the decorator. Parameters: Name Type Description Default lineno int | None The starting line number. required endlineno int | None The ending line number. required Source code in griffe/dataclasses.py def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Arguments: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno as_dict ( self , ** kwargs ) \u00a4 Return this decorator's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } Docstring \u00a4 This class represents docstrings. Attributes: Name Type Description value str The actual documentation string, cleaned up. lineno int | None The starting line number. endlineno int | None The ending line number. parent Module | Class | Function | Data | None The parent object on which this docstring is attached. lines : list [ str ] cached property writable \u00a4 Returns the lines of the docstring. Returns: Type Description list[str] The docstring's lines. parsed : list [ DocstringSection ] cached property writable \u00a4 Return the docstring, parsed into structured data. Returns: Type Description list[DocstringSection] The parsed docstring. __init__ ( self , value , lineno , endlineno , parent = None ) special \u00a4 Initialize the docstring. Parameters: Name Type Description Default value str The docstring value. required lineno int | None The starting line number. required endlineno int | None The ending line number. required parent Module | Class | Function | Data | None The parent object on which this docstring is attached. None Source code in griffe/dataclasses.py def __init__ ( self , value : str , lineno : int | None , endlineno : int | None , parent : Module | Class | Function | Data | None = None , ) -> None : \"\"\"Initialize the docstring. Arguments: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | Function | Data | None = parent as_dict ( self , full = False , docstring_parser = Parser . google , ** kwargs ) \u00a4 Return this docstring's data as a dictionary. Parameters: Name Type Description Default full bool Whether to return full info, or just base info. False docstring_parser Parser The docstring docstring_parser to parse the docstring with. Parser.google **kwargs Additional serialization or docstring parsing options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , full : bool = False , docstring_parser : Parser = Parser . google , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Arguments: full: Whether to return full info, or just base info. docstring_parser: The docstring docstring_parser to parse the docstring with. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base parse ( self , docstring_parser = Parser . google , ** options ) \u00a4 Parse the docstring into structured data. Parameters: Name Type Description Default docstring_parser Parser The docstring parser to use. Parser.google **options Additional docstring parsing options. {} Returns: Type Description list[DocstringSection] The parsed docstring. Source code in griffe/dataclasses.py def parse ( self , docstring_parser : Parser = Parser . google , ** options ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Arguments: docstring_parser: The docstring parser to use. **options: Additional docstring parsing options. Returns: The parsed docstring. \"\"\" return parse ( self , docstring_parser , ** options ) Function ( Object ) \u00a4 The class representing a Python function. __init__ ( self , * args , * , arguments = None , returns = None , decorators = None , ** kwargs ) special \u00a4 Initialize the function. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () arguments Arguments | None The function arguments. None returns str | None The function return annotation. None decorators list[Decorator] | None The function decorators, if any. None **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , arguments : Arguments | None = None , returns : str | None = None , decorators : list [ Decorator ] | None = None , ** kwargs , ) -> None : \"\"\"Initialize the function. Arguments: *args: See [`griffe.dataclasses.Object`][]. arguments: The function arguments. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . arguments = arguments or Arguments () self . returns = returns self . decorators = decorators or [] as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"arguments\" ] = [ arg . as_dict ( ** kwargs ) for arg in self . arguments ] base [ \"returns\" ] = self . returns return base Kind ( Enum ) \u00a4 Enumeration of the different objects kinds. Attributes: Name Type Description MODULE str The module kind. CLASS str The class kind. FUNCTION str The function kind. DATA str The data kind. Module ( Object ) \u00a4 The class representing a Python module. filepath : Path property readonly \u00a4 Get the file path of this module. Returns: Type Description Path The module's file path. is_init_module : bool cached property writable \u00a4 Tell if this module is an __init__.py module. Returns: Type Description bool True or False. is_namespace_package : bool cached property writable \u00a4 Tell if this module is a namespace package (top folder, no __init__.py ). Returns: Type Description bool True or False. is_namespace_subpackage : bool cached property writable \u00a4 Tell if this module is a namespace subpackage. Returns: Type Description bool True or False. is_package : bool cached property writable \u00a4 Tell if this module is a package (top module). Returns: Type Description bool True or False. is_subpackage : bool cached property writable \u00a4 Tell if this module is a subpackage. Returns: Type Description bool True or False. __init__ ( self , * args , * , filepath , ** kwargs ) special \u00a4 Initialize the module. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () filepath Path The module file path. It can be null for namespace packages. required **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , filepath : Path , ** kwargs ) -> None : \"\"\"Initialize the module. Arguments: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path. It can be null for namespace packages. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path = filepath as_dict ( self , ** kwargs ) \u00a4 Return this module's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this module's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . filepath ) if self . filepath else None return base Object \u00a4 An abstract class representing a Python object. Attributes: Name Type Description kind Kind The object kind. name str The object name. lineno int | None The object starting line, or None for modules. Lines start at 1. endlineno int | None The object ending line (inclusive), or None for modules. docstring Docstring | None The object docstring. parent Module | Class | None The object parent, or None if it is the top module. members dict[str, Module | Class | Function | Data] The object members. labels set[str] The object labels. filepath : Path | None cached property writable \u00a4 Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Type Description Path | None A file path. module : Module cached property writable \u00a4 Return the parent module of this object. Exceptions: Type Description ValueError When the object is not a module and does not have a parent. Returns: Type Description Module The parent module. package : Module cached property writable \u00a4 Return the absolute top module (the package) of this object. Returns: Type Description Module The parent module. path : str cached property writable \u00a4 Return the dotted path / import path of this object. Returns: Type Description str A dotted path. relative_filepath : Path | None cached property writable \u00a4 Return the file path where this object was defined, relative to the top module path. Returns: Type Description Path | None A file path. __init__ ( self , name , lineno = None , endlineno = None , docstring = None ) special \u00a4 Initialize the object. Parameters: Name Type Description Default name str The object name, as declared in the code. required lineno int | None The object starting line, or None for modules. Lines start at 1. None endlineno int | None The object ending line (inclusive), or None for modules. None docstring Docstring | None The object docstring. None Source code in griffe/dataclasses.py def __init__ ( self , name : str , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , ) -> None : \"\"\"Initialize the object. Arguments: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = None self . members : dict [ str , Module | Class | Function | Data ] = {} self . labels : set [ str ] = set () # attach the docstring to this object if docstring : docstring . parent = self # type: ignore as_dict ( self , full = False , ** kwargs ) \u00a4 Return this object's data as a dictionary. Parameters: Name Type Description Default full bool Whether to return full info, or just base info. False **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , full : bool = False , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Arguments: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base","title":"dataclasses.py"},{"location":"reference/dataclasses/#griffe.dataclasses.Argument","text":"This class represent a function argument. Attributes: Name Type Description name str The argument name. annotation str | None The argument annotation, if any. kind ParameterKind | None The argument kind (see inspect.Parameter.kind ). default str | None The argument default, if any.","title":"Argument"},{"location":"reference/dataclasses/#griffe.dataclasses.Argument.__init__","text":"Initialize the argument. Parameters: Name Type Description Default name str The argument name. required annotation str | None The argument annotation, if any. None kind ParameterKind | None The argument kind (see inspect.Parameter.kind ). None default str | None The argument default, if any. None Source code in griffe/dataclasses.py def __init__ ( self , name : str , * , annotation : str | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the argument. Arguments: name: The argument name. annotation: The argument annotation, if any. kind: The argument kind (see [`inspect.Parameter.kind`][]). default: The argument default, if any. \"\"\" self . name : str = name self . annotation : str | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Argument.as_dict","text":"Return this argument's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this argument's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , }","title":"as_dict()"},{"location":"reference/dataclasses/#griffe.dataclasses.Arguments","text":"This class is a container for arguments. It allows to get arguments using their position (index) or their name.","title":"Arguments"},{"location":"reference/dataclasses/#griffe.dataclasses.Arguments.__init__","text":"Initialize the arguments container. Parameters: Name Type Description Default *arguments Argument The initial arguments to add to the container. () Source code in griffe/dataclasses.py def __init__ ( self , * arguments : Argument ) -> None : \"\"\"Initialize the arguments container. Arguments: *arguments: The initial arguments to add to the container. \"\"\" self . _arguments_list : list [ Argument ] = [] self . _arguments_dict : dict [ str , Argument ] = {} for argument in arguments : self . add ( argument )","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Arguments.add","text":"Add an argument to the container. Parameters: Name Type Description Default argument Argument The function argument to add. required Exceptions: Type Description ValueError When an argument with the same name is already present. Source code in griffe/dataclasses.py def add ( self , argument : Argument ) -> None : \"\"\"Add an argument to the container. Arguments: argument: The function argument to add. Raises: ValueError: When an argument with the same name is already present. \"\"\" if argument . name not in self . _arguments_dict : self . _arguments_dict [ argument . name ] = argument self . _arguments_list . append ( argument ) else : raise ValueError ( f \"argument { argument . name } already present\" )","title":"add()"},{"location":"reference/dataclasses/#griffe.dataclasses.Class","text":"The class representing a Python class.","title":"Class"},{"location":"reference/dataclasses/#griffe.dataclasses.Class.__init__","text":"Initialize the class. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () bases list[str] | None The list of base classes, if any. None decorators list[Decorator] | None The class decorators, if any. None **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , bases : list [ str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs , ) -> None : \"\"\"Initialize the class. Arguments: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases = bases or [] self . decorators = decorators or []","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Class.as_dict","text":"Return this class' data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this class' data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base","title":"as_dict()"},{"location":"reference/dataclasses/#griffe.dataclasses.Data","text":"The class representing a Python module/class/instance attribute.","title":"Data"},{"location":"reference/dataclasses/#griffe.dataclasses.Data.__init__","text":"Initialize the function. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () value str | None The data value, if any. None annotation str | None The data annotation, if any. None **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , value : str | None = None , annotation : str | None = None , ** kwargs , ) -> None : \"\"\"Initialize the function. Arguments: *args: See [`griffe.dataclasses.Object`][]. value: The data value, if any. annotation: The data annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | None = annotation","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Data.as_dict","text":"Return this function's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base","title":"as_dict()"},{"location":"reference/dataclasses/#griffe.dataclasses.Decorator","text":"This class represents decorators. Attributes: Name Type Description lineno int | None The starting line number. endlineno int | None The ending line number.","title":"Decorator"},{"location":"reference/dataclasses/#griffe.dataclasses.Decorator.__init__","text":"Initialize the decorator. Parameters: Name Type Description Default lineno int | None The starting line number. required endlineno int | None The ending line number. required Source code in griffe/dataclasses.py def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Arguments: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Decorator.as_dict","text":"Return this decorator's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , }","title":"as_dict()"},{"location":"reference/dataclasses/#griffe.dataclasses.Docstring","text":"This class represents docstrings. Attributes: Name Type Description value str The actual documentation string, cleaned up. lineno int | None The starting line number. endlineno int | None The ending line number. parent Module | Class | Function | Data | None The parent object on which this docstring is attached.","title":"Docstring"},{"location":"reference/dataclasses/#griffe.dataclasses.Docstring.lines","text":"Returns the lines of the docstring. Returns: Type Description list[str] The docstring's lines.","title":"lines"},{"location":"reference/dataclasses/#griffe.dataclasses.Docstring.parsed","text":"Return the docstring, parsed into structured data. Returns: Type Description list[DocstringSection] The parsed docstring.","title":"parsed"},{"location":"reference/dataclasses/#griffe.dataclasses.Docstring.__init__","text":"Initialize the docstring. Parameters: Name Type Description Default value str The docstring value. required lineno int | None The starting line number. required endlineno int | None The ending line number. required parent Module | Class | Function | Data | None The parent object on which this docstring is attached. None Source code in griffe/dataclasses.py def __init__ ( self , value : str , lineno : int | None , endlineno : int | None , parent : Module | Class | Function | Data | None = None , ) -> None : \"\"\"Initialize the docstring. Arguments: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | Function | Data | None = parent","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Docstring.as_dict","text":"Return this docstring's data as a dictionary. Parameters: Name Type Description Default full bool Whether to return full info, or just base info. False docstring_parser Parser The docstring docstring_parser to parse the docstring with. Parser.google **kwargs Additional serialization or docstring parsing options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , full : bool = False , docstring_parser : Parser = Parser . google , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Arguments: full: Whether to return full info, or just base info. docstring_parser: The docstring docstring_parser to parse the docstring with. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base","title":"as_dict()"},{"location":"reference/dataclasses/#griffe.dataclasses.Docstring.parse","text":"Parse the docstring into structured data. Parameters: Name Type Description Default docstring_parser Parser The docstring parser to use. Parser.google **options Additional docstring parsing options. {} Returns: Type Description list[DocstringSection] The parsed docstring. Source code in griffe/dataclasses.py def parse ( self , docstring_parser : Parser = Parser . google , ** options ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Arguments: docstring_parser: The docstring parser to use. **options: Additional docstring parsing options. Returns: The parsed docstring. \"\"\" return parse ( self , docstring_parser , ** options )","title":"parse()"},{"location":"reference/dataclasses/#griffe.dataclasses.Function","text":"The class representing a Python function.","title":"Function"},{"location":"reference/dataclasses/#griffe.dataclasses.Function.__init__","text":"Initialize the function. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () arguments Arguments | None The function arguments. None returns str | None The function return annotation. None decorators list[Decorator] | None The function decorators, if any. None **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , arguments : Arguments | None = None , returns : str | None = None , decorators : list [ Decorator ] | None = None , ** kwargs , ) -> None : \"\"\"Initialize the function. Arguments: *args: See [`griffe.dataclasses.Object`][]. arguments: The function arguments. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . arguments = arguments or Arguments () self . returns = returns self . decorators = decorators or []","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Function.as_dict","text":"Return this function's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this function's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"arguments\" ] = [ arg . as_dict ( ** kwargs ) for arg in self . arguments ] base [ \"returns\" ] = self . returns return base","title":"as_dict()"},{"location":"reference/dataclasses/#griffe.dataclasses.Kind","text":"Enumeration of the different objects kinds. Attributes: Name Type Description MODULE str The module kind. CLASS str The class kind. FUNCTION str The function kind. DATA str The data kind.","title":"Kind"},{"location":"reference/dataclasses/#griffe.dataclasses.Module","text":"The class representing a Python module.","title":"Module"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.filepath","text":"Get the file path of this module. Returns: Type Description Path The module's file path.","title":"filepath"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_init_module","text":"Tell if this module is an __init__.py module. Returns: Type Description bool True or False.","title":"is_init_module"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_namespace_package","text":"Tell if this module is a namespace package (top folder, no __init__.py ). Returns: Type Description bool True or False.","title":"is_namespace_package"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_namespace_subpackage","text":"Tell if this module is a namespace subpackage. Returns: Type Description bool True or False.","title":"is_namespace_subpackage"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_package","text":"Tell if this module is a package (top module). Returns: Type Description bool True or False.","title":"is_package"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_subpackage","text":"Tell if this module is a subpackage. Returns: Type Description bool True or False.","title":"is_subpackage"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.__init__","text":"Initialize the module. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () filepath Path The module file path. It can be null for namespace packages. required **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , filepath : Path , ** kwargs ) -> None : \"\"\"Initialize the module. Arguments: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path. It can be null for namespace packages. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path = filepath","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.as_dict","text":"Return this module's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: # type: ignore \"\"\"Return this module's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . filepath ) if self . filepath else None return base","title":"as_dict()"},{"location":"reference/dataclasses/#griffe.dataclasses.Object","text":"An abstract class representing a Python object. Attributes: Name Type Description kind Kind The object kind. name str The object name. lineno int | None The object starting line, or None for modules. Lines start at 1. endlineno int | None The object ending line (inclusive), or None for modules. docstring Docstring | None The object docstring. parent Module | Class | None The object parent, or None if it is the top module. members dict[str, Module | Class | Function | Data] The object members. labels set[str] The object labels.","title":"Object"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.filepath","text":"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Type Description Path | None A file path.","title":"filepath"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.module","text":"Return the parent module of this object. Exceptions: Type Description ValueError When the object is not a module and does not have a parent. Returns: Type Description Module The parent module.","title":"module"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.package","text":"Return the absolute top module (the package) of this object. Returns: Type Description Module The parent module.","title":"package"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.path","text":"Return the dotted path / import path of this object. Returns: Type Description str A dotted path.","title":"path"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.relative_filepath","text":"Return the file path where this object was defined, relative to the top module path. Returns: Type Description Path | None A file path.","title":"relative_filepath"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.__init__","text":"Initialize the object. Parameters: Name Type Description Default name str The object name, as declared in the code. required lineno int | None The object starting line, or None for modules. Lines start at 1. None endlineno int | None The object ending line (inclusive), or None for modules. None docstring Docstring | None The object docstring. None Source code in griffe/dataclasses.py def __init__ ( self , name : str , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , ) -> None : \"\"\"Initialize the object. Arguments: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = None self . members : dict [ str , Module | Class | Function | Data ] = {} self . labels : set [ str ] = set () # attach the docstring to this object if docstring : docstring . parent = self # type: ignore","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.as_dict","text":"Return this object's data as a dictionary. Parameters: Name Type Description Default full bool Whether to return full info, or just base info. False **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , full : bool = False , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Arguments: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base","title":"as_dict()"},{"location":"reference/encoders/","text":"This module contains data encoders/serializers and decoders/deserializers. The available formats are: JSON: see the encoder and decoder . Encoder ( JSONEncoder ) \u00a4 JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json . dumps ( ... , cls = Encoder , full = True , ** kwargs ) __init__ ( self , * args , * , full = False , docstring_parser = Parser . google , docstring_options = None , ** kwargs ) special \u00a4 Initialize the encoder. Parameters: Name Type Description Default *args See json.JSONEncoder . () full bool Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. False docstring_parser Parser The docstring parser to use. Parser.google docstring_options dict[str, Any] Additional docstring parsing options. None **kwargs See json.JSONEncoder . {} Source code in griffe/encoders.py def __init__ ( self , * args , full : bool = False , docstring_parser : Parser = Parser . google , docstring_options : dict [ str , Any ] = None , ** kwargs ) -> None : \"\"\"Initialize the encoder. Arguments: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} default ( self , obj ) \u00a4 Return a serializable representation of the given object. Parameters: Name Type Description Default obj Any The object to serialize. required Returns: Type Description Any A serializable representation. Source code in griffe/encoders.py def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Arguments: obj: The object to serialize. Returns: A serializable representation. \"\"\" if hasattr ( obj , \"as_dict\" ): return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) if isinstance ( obj , ( Path , ParameterKind )): return str ( obj ) if isinstance ( obj , Enum ): return obj . value if isinstance ( obj , set ): return list ( obj ) return super () . default ( obj ) decoder ( obj_dict ) \u00a4 Decode dictionaries as data classes. The [ json.loads ] method walks the tree from bottom to top. Parameters: Name Type Description Default obj_dict The dictionary to decode. required Returns: Type Description Module | Class | Function | Data An instance of a data class. Source code in griffe/encoders.py def decoder ( obj_dict ) -> Module | Class | Function | Data : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`] method walks the tree from bottom to top. Arguments: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( name = obj_dict [ \"name\" ], filepath = Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) elif kind == Kind . DATA : return Data ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) return obj_dict","title":"encoders.py"},{"location":"reference/encoders/#griffe.encoders.Encoder","text":"JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json . dumps ( ... , cls = Encoder , full = True , ** kwargs )","title":"Encoder"},{"location":"reference/encoders/#griffe.encoders.Encoder.__init__","text":"Initialize the encoder. Parameters: Name Type Description Default *args See json.JSONEncoder . () full bool Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. False docstring_parser Parser The docstring parser to use. Parser.google docstring_options dict[str, Any] Additional docstring parsing options. None **kwargs See json.JSONEncoder . {} Source code in griffe/encoders.py def __init__ ( self , * args , full : bool = False , docstring_parser : Parser = Parser . google , docstring_options : dict [ str , Any ] = None , ** kwargs ) -> None : \"\"\"Initialize the encoder. Arguments: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {}","title":"__init__()"},{"location":"reference/encoders/#griffe.encoders.Encoder.default","text":"Return a serializable representation of the given object. Parameters: Name Type Description Default obj Any The object to serialize. required Returns: Type Description Any A serializable representation. Source code in griffe/encoders.py def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Arguments: obj: The object to serialize. Returns: A serializable representation. \"\"\" if hasattr ( obj , \"as_dict\" ): return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) if isinstance ( obj , ( Path , ParameterKind )): return str ( obj ) if isinstance ( obj , Enum ): return obj . value if isinstance ( obj , set ): return list ( obj ) return super () . default ( obj )","title":"default()"},{"location":"reference/encoders/#griffe.encoders.decoder","text":"Decode dictionaries as data classes. The [ json.loads ] method walks the tree from bottom to top. Parameters: Name Type Description Default obj_dict The dictionary to decode. required Returns: Type Description Module | Class | Function | Data An instance of a data class. Source code in griffe/encoders.py def decoder ( obj_dict ) -> Module | Class | Function | Data : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`] method walks the tree from bottom to top. Arguments: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( name = obj_dict [ \"name\" ], filepath = Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) elif kind == Kind . DATA : return Data ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) return obj_dict","title":"decoder()"},{"location":"reference/extended_ast/","text":"This module, when imported, will patch the ast.AST class. It will add the following attributes and properties to it: node.parent (attribute): The parent node, or None node.children (attribute): A list of children nodes. node.siblings (cached property): A list of siblings nodes. node.position (cached property): The position of the node within its siblings. node.previous_siblings (cached property): The siblings appearing before this node, starting from the closest. node.next_siblings (cached property): The siblings appearing after this node, starting from the closest. node.previous (cached property): The immediate previous node. node.next (cached property): The immediate next node. All these properties will raise a RootNodeError if they are accessed from the root node. The next and previous properties will raise a LastNodeError if there is no next or previous node. LastNodeError ( Exception ) \u00a4 Exception raised when trying to access a next or previous node. RootNodeError ( Exception ) \u00a4 Exception raised when trying to use siblings properties on a root node. extend_ast () \u00a4 Extend the base ast.AST class to provide more functionality. Source code in griffe/extended_ast.py def extend_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , _ExtendedAST ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442","title":"extended_ast.py"},{"location":"reference/extended_ast/#griffe.extended_ast.LastNodeError","text":"Exception raised when trying to access a next or previous node.","title":"LastNodeError"},{"location":"reference/extended_ast/#griffe.extended_ast.RootNodeError","text":"Exception raised when trying to use siblings properties on a root node.","title":"RootNodeError"},{"location":"reference/extended_ast/#griffe.extended_ast.extend_ast","text":"Extend the base ast.AST class to provide more functionality. Source code in griffe/extended_ast.py def extend_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , _ExtendedAST ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442","title":"extend_ast()"},{"location":"reference/loader/","text":"This module contains the code allowing to find module and load their data. This is the entrypoint to use griffe programatically: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) AsyncGriffeLoader ( _BaseGriffeLoader ) \u00a4 The asynchronous Griffe loader, allowing to load data from modules. Attributes: Name Type Description extensions The extensions to use. load_module ( self , module , submodules = True , search_paths = None ) async \u00a4 Load a module. Parameters: Name Type Description Default module str | Path The module name or path. required submodules bool Whether to recurse on the submodules. True search_paths list[str | Path] | None The paths to search into. None Returns: Type Description Module A module. Source code in griffe/loader.py async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : list [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Arguments: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) return await self . _load_module_path ( module_name , module_path , submodules = submodules ) GriffeLoader ( _BaseGriffeLoader ) \u00a4 The Griffe loader, allowing to load data from modules. Attributes: Name Type Description extensions The extensions to use. load_module ( self , module , submodules = True , search_paths = None ) \u00a4 Load a module. Parameters: Name Type Description Default module str | Path The module name or path. required submodules bool Whether to recurse on the submodules. True search_paths list[str | Path] | None The paths to search into. None Returns: Type Description Module A module. Source code in griffe/loader.py def load_module ( self , module : str | Path , submodules : bool = True , search_paths : list [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Arguments: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) return self . _load_module_path ( module_name , module_path , submodules = submodules ) find_module ( module_name , search_paths = None ) \u00a4 Find a module in a given list of paths or in sys.path . Parameters: Name Type Description Default module_name str The module name. required search_paths list[str | Path] | None The paths to search into. None Exceptions: Type Description ModuleNotFoundError When the module cannot be found. Returns: Type Description Path The module file path. Source code in griffe/loader.py def find_module ( module_name : str , search_paths : list [ str | Path ] | None = None ) -> Path : \"\"\"Find a module in a given list of paths or in `sys.path`. Arguments: module_name: The module name. search_paths: The paths to search into. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" # optimization: pre-compute Paths to relieve CPU when joining paths search = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] parts = module_name . split ( \".\" ) filenames = [ Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), ] for path in search : for choice in filenames : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): return abs_path raise ModuleNotFoundError ( module_name ) iter_submodules ( path ) \u00a4 Iterate on a module's submodules, if any. Parameters: Name Type Description Default path Path The module path. required Yields This generator yields tuples containing the parts of the submodule name as well as its filepath. Source code in griffe/loader.py def iter_submodules ( path : Path ) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS234 \"\"\"Iterate on a module's submodules, if any. Arguments: path: The module path. Yields: This generator yields tuples containing the parts of the submodule name as well as its filepath. \"\"\" if path . name == \"__init__.py\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix == \".py\" : return for subpath in path . rglob ( \"*.py\" ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . name == \"__init__.py\" : # optimization: since it's a relative path, # if it has only one part and is named __init__.py, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath else : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath module_name_path ( path ) \u00a4 Get the module name and path from a path. Parameters: Name Type Description Default path Path A directory or file path. Paths to __init__.py files will be resolved to their parent directory. required Exceptions: Type Description FileNotFoundError When: the directory has no __init__.py file in it the path does not exist Returns: Type Description tuple[str, Path] The name of the module (or package) and its path. Source code in griffe/loader.py def module_name_path ( path : Path ) -> tuple [ str , Path ]: \"\"\"Get the module name and path from a path. Arguments: path: A directory or file path. Paths to `__init__.py` files will be resolved to their parent directory. Raises: FileNotFoundError: When: - the directory has no `__init__.py` file in it - the path does not exist Returns: The name of the module (or package) and its path. \"\"\" if path . is_dir (): module_path = path / \"__init__.py\" if module_path . exists (): return path . name , module_path raise FileNotFoundError if path . exists (): if path . stem == \"__init__\" : if path . parent . is_absolute (): return path . parent . name , path return path . parent . resolve () . name , path return path . stem , path raise FileNotFoundError","title":"loader.py"},{"location":"reference/loader/#griffe.loader.AsyncGriffeLoader","text":"The asynchronous Griffe loader, allowing to load data from modules. Attributes: Name Type Description extensions The extensions to use.","title":"AsyncGriffeLoader"},{"location":"reference/loader/#griffe.loader.AsyncGriffeLoader.load_module","text":"Load a module. Parameters: Name Type Description Default module str | Path The module name or path. required submodules bool Whether to recurse on the submodules. True search_paths list[str | Path] | None The paths to search into. None Returns: Type Description Module A module. Source code in griffe/loader.py async def load_module ( self , module : str | Path , submodules : bool = True , search_paths : list [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Arguments: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) return await self . _load_module_path ( module_name , module_path , submodules = submodules )","title":"load_module()"},{"location":"reference/loader/#griffe.loader.GriffeLoader","text":"The Griffe loader, allowing to load data from modules. Attributes: Name Type Description extensions The extensions to use.","title":"GriffeLoader"},{"location":"reference/loader/#griffe.loader.GriffeLoader.load_module","text":"Load a module. Parameters: Name Type Description Default module str | Path The module name or path. required submodules bool Whether to recurse on the submodules. True search_paths list[str | Path] | None The paths to search into. None Returns: Type Description Module A module. Source code in griffe/loader.py def load_module ( self , module : str | Path , submodules : bool = True , search_paths : list [ str | Path ] | None = None , ) -> Module : \"\"\"Load a module. Arguments: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. Returns: A module. \"\"\" module_name , module_path = self . _module_name_and_path ( module , search_paths ) return self . _load_module_path ( module_name , module_path , submodules = submodules )","title":"load_module()"},{"location":"reference/loader/#griffe.loader.find_module","text":"Find a module in a given list of paths or in sys.path . Parameters: Name Type Description Default module_name str The module name. required search_paths list[str | Path] | None The paths to search into. None Exceptions: Type Description ModuleNotFoundError When the module cannot be found. Returns: Type Description Path The module file path. Source code in griffe/loader.py def find_module ( module_name : str , search_paths : list [ str | Path ] | None = None ) -> Path : \"\"\"Find a module in a given list of paths or in `sys.path`. Arguments: module_name: The module name. search_paths: The paths to search into. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" # optimization: pre-compute Paths to relieve CPU when joining paths search = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] parts = module_name . split ( \".\" ) filenames = [ Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), ] for path in search : for choice in filenames : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): return abs_path raise ModuleNotFoundError ( module_name )","title":"find_module()"},{"location":"reference/loader/#griffe.loader.iter_submodules","text":"Iterate on a module's submodules, if any. Parameters: Name Type Description Default path Path The module path. required Yields This generator yields tuples containing the parts of the submodule name as well as its filepath. Source code in griffe/loader.py def iter_submodules ( path : Path ) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS234 \"\"\"Iterate on a module's submodules, if any. Arguments: path: The module path. Yields: This generator yields tuples containing the parts of the submodule name as well as its filepath. \"\"\" if path . name == \"__init__.py\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix == \".py\" : return for subpath in path . rglob ( \"*.py\" ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . name == \"__init__.py\" : # optimization: since it's a relative path, # if it has only one part and is named __init__.py, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath else : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath","title":"iter_submodules()"},{"location":"reference/loader/#griffe.loader.module_name_path","text":"Get the module name and path from a path. Parameters: Name Type Description Default path Path A directory or file path. Paths to __init__.py files will be resolved to their parent directory. required Exceptions: Type Description FileNotFoundError When: the directory has no __init__.py file in it the path does not exist Returns: Type Description tuple[str, Path] The name of the module (or package) and its path. Source code in griffe/loader.py def module_name_path ( path : Path ) -> tuple [ str , Path ]: \"\"\"Get the module name and path from a path. Arguments: path: A directory or file path. Paths to `__init__.py` files will be resolved to their parent directory. Raises: FileNotFoundError: When: - the directory has no `__init__.py` file in it - the path does not exist Returns: The name of the module (or package) and its path. \"\"\" if path . is_dir (): module_path = path / \"__init__.py\" if module_path . exists (): return path . name , module_path raise FileNotFoundError if path . exists (): if path . stem == \"__init__\" : if path . parent . is_absolute (): return path . parent . name , path return path . parent . resolve () . name , path return path . stem , path raise FileNotFoundError","title":"module_name_path()"},{"location":"reference/logger/","text":"This module contains logging utilities. We provide the get_logger function so dependant libraries can patch it as they see fit. For example, to fit in the MkDocs logging configuration and prefix each log message with the module name: import logging from griffe import logger as griffe_logger class LoggerAdapter ( logging . LoggerAdapter ): def __init__ ( self , prefix , logger ): super () . __init__ ( logger , {}) self . prefix = prefix def process ( self , msg , kwargs ): return f \" { self . prefix } : { msg } \" , kwargs def get_logger ( name ): logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) return LoggerAdapter ( name , logger ) griffe_logger . get_logger = get_logger get_logger ( name ) \u00a4 Create and return a new logger instance. Parameters: Name Type Description Default name str The logger name. required Returns: Type Description Logger The logger. Source code in griffe/logger.py def get_logger ( name : str ) -> logging . Logger : \"\"\"Create and return a new logger instance. Arguments: name: The logger name. Returns: The logger. \"\"\" return logging . getLogger ( name )","title":"logger.py"},{"location":"reference/logger/#griffe.logger.get_logger","text":"Create and return a new logger instance. Parameters: Name Type Description Default name str The logger name. required Returns: Type Description Logger The logger. Source code in griffe/logger.py def get_logger ( name : str ) -> logging . Logger : \"\"\"Create and return a new logger instance. Arguments: name: The logger name. Returns: The logger. \"\"\" return logging . getLogger ( name )","title":"get_logger()"},{"location":"reference/visitor/","text":"Code parsing and data extraction utilies. This module exposes a public function, visit() , which parses the module code using parse() , and returns a new Module instance, populating its members recursively, by using a custom NodeVisitor class. visit ( module_name , filepath , code , extensions = None ) \u00a4 Parse and visit a module file. Parameters: Name Type Description Default module_name str The module name (as when importing [from] it). required filepath Path The module file path. required code str The module contents. required extensions Extensions | None The extensions to use when visiting the AST. None Returns: Type Description Module The module, with its members populated. Source code in griffe/visitor.py def visit ( module_name : str , filepath : Path , code : str , extensions : Extensions | None = None , ) -> Module : \"\"\"Parse and visit a module file. Arguments: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. Returns: The module, with its members populated. \"\"\" return _MainVisitor ( module_name , filepath , code , extensions or Extensions ()) . get_module ()","title":"visitor.py"},{"location":"reference/visitor/#griffe.visitor.visit","text":"Parse and visit a module file. Parameters: Name Type Description Default module_name str The module name (as when importing [from] it). required filepath Path The module file path. required code str The module contents. required extensions Extensions | None The extensions to use when visiting the AST. None Returns: Type Description Module The module, with its members populated. Source code in griffe/visitor.py def visit ( module_name : str , filepath : Path , code : str , extensions : Extensions | None = None , ) -> Module : \"\"\"Parse and visit a module file. Arguments: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. Returns: The module, with its members populated. \"\"\" return _MainVisitor ( module_name , filepath , code , extensions or Extensions ()) . get_module ()","title":"visit()"},{"location":"reference/docstrings/__init__/","text":"This module exposes objects related to docstrings.","title":"__init__.py"},{"location":"reference/docstrings/dataclasses/","text":"This module contains the dataclasses related to docstrings. DocstringAdmonition \u00a4 This base class represents admonitions. Attributes: Name Type Description kind str The admonition kind. contents str The admonition contents. __init__ ( self , * , kind , contents ) special \u00a4 Initialize the admonition. Parameters: Name Type Description Default kind str The admonition kind. required contents str The admonition contents. required Source code in griffe/docstrings/dataclasses.py def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Arguments: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents as_dict ( self , ** kwargs ) \u00a4 Return this admonition's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/docstrings/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , } DocstringArgument ( DocstringNamedElement ) \u00a4 This class represent a documented function argument. DocstringAttribute ( DocstringNamedElement ) \u00a4 This class represents a documented module/class attribute. DocstringElement \u00a4 This base class represents annotated, nameless elements. Attributes: Name Type Description annotation str | None The element annotation, if any. description str The element description. __init__ ( self , * , description , annotation = None ) special \u00a4 Initialize the element. Parameters: Name Type Description Default annotation str | None The element annotation, if any. None description str The element description. required Source code in griffe/docstrings/dataclasses.py def __init__ ( self , * , description : str , annotation : str | None = None ) -> None : \"\"\"Initialize the element. Arguments: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/docstrings/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , } DocstringException ( DocstringElement ) \u00a4 This class represents a documented exception. DocstringNamedElement ( DocstringElement ) \u00a4 This base class represents annotated, named elements. Attributes: Name Type Description name str The element name. value str | None The element value, as a string, if any. __init__ ( self , name , * , description , annotation = None , value = None ) special \u00a4 Initialize the element. Parameters: Name Type Description Default name str The element name. required description str The element description. required annotation str | None The element annotation, if any. None value str | None The element value, as a string. None Source code in griffe/docstrings/dataclasses.py def __init__ ( self , name : str , * , description : str , annotation : str | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Arguments: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/docstrings/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base DocstringRaise ( DocstringElement ) \u00a4 This class represents a documented raise value. DocstringReceive ( DocstringElement ) \u00a4 This class represents a documented receive value. DocstringReturn ( DocstringElement ) \u00a4 This class represents a documented return value. DocstringSection \u00a4 Placeholder. __init__ ( self , kind , value , title = None ) special \u00a4 Initialize the section. Parameters: Name Type Description Default kind DocstringSectionKind The section kind. required value Any The section value. required title str | None An optional title. None Source code in griffe/docstrings/dataclasses.py def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Arguments: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title as_dict ( self , ** kwargs ) \u00a4 Return this section's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/docstrings/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base DocstringSectionKind ( Enum ) \u00a4 The possible section kinds. DocstringWarn ( DocstringElement ) \u00a4 This class represents a documented warn value. DocstringYield ( DocstringElement ) \u00a4 This class represents a documented yield value.","title":"dataclasses.py"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition","text":"This base class represents admonitions. Attributes: Name Type Description kind str The admonition kind. contents str The admonition contents.","title":"DocstringAdmonition"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.__init__","text":"Initialize the admonition. Parameters: Name Type Description Default kind str The admonition kind. required contents str The admonition contents. required Source code in griffe/docstrings/dataclasses.py def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Arguments: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents","title":"__init__()"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.as_dict","text":"Return this admonition's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/docstrings/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , }","title":"as_dict()"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringArgument","text":"This class represent a documented function argument.","title":"DocstringArgument"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAttribute","text":"This class represents a documented module/class attribute.","title":"DocstringAttribute"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement","text":"This base class represents annotated, nameless elements. Attributes: Name Type Description annotation str | None The element annotation, if any. description str The element description.","title":"DocstringElement"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.__init__","text":"Initialize the element. Parameters: Name Type Description Default annotation str | None The element annotation, if any. None description str The element description. required Source code in griffe/docstrings/dataclasses.py def __init__ ( self , * , description : str , annotation : str | None = None ) -> None : \"\"\"Initialize the element. Arguments: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | None = annotation","title":"__init__()"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.as_dict","text":"Return this element's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/docstrings/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , }","title":"as_dict()"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringException","text":"This class represents a documented exception.","title":"DocstringException"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement","text":"This base class represents annotated, named elements. Attributes: Name Type Description name str The element name. value str | None The element value, as a string, if any.","title":"DocstringNamedElement"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.__init__","text":"Initialize the element. Parameters: Name Type Description Default name str The element name. required description str The element description. required annotation str | None The element annotation, if any. None value str | None The element value, as a string. None Source code in griffe/docstrings/dataclasses.py def __init__ ( self , name : str , * , description : str , annotation : str | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Arguments: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value","title":"__init__()"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.as_dict","text":"Return this element's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/docstrings/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base","title":"as_dict()"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringRaise","text":"This class represents a documented raise value.","title":"DocstringRaise"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReceive","text":"This class represents a documented receive value.","title":"DocstringReceive"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReturn","text":"This class represents a documented return value.","title":"DocstringReturn"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection","text":"Placeholder.","title":"DocstringSection"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.__init__","text":"Initialize the section. Parameters: Name Type Description Default kind DocstringSectionKind The section kind. required value Any The section value. required title str | None An optional title. None Source code in griffe/docstrings/dataclasses.py def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Arguments: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title","title":"__init__()"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.as_dict","text":"Return this section's data as a dictionary. Parameters: Name Type Description Default **kwargs Additional serialization options. {} Returns: Type Description dict[str, Any] A dictionary. Source code in griffe/docstrings/dataclasses.py def as_dict ( self , ** kwargs ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Arguments: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base","title":"as_dict()"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind","text":"The possible section kinds.","title":"DocstringSectionKind"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringWarn","text":"This class represents a documented warn value.","title":"DocstringWarn"},{"location":"reference/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringYield","text":"This class represents a documented yield value.","title":"DocstringYield"},{"location":"reference/docstrings/google/","text":"This module defines functions to parse Google-style docstrings into structured data. parse ( docstring , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: Name Type Description Default docstring Docstring The docstring to parse. required **options Additional parsing options. {} Returns: Type Description list[DocstringSection] A list of docstring sections. Source code in griffe/docstrings/google.py def parse ( # noqa: WPS231 docstring : Docstring , ** options , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Arguments: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) elif match := _RE_ADMONITION . match ( lines [ index ]): # noqa: WPS332 groups = match . groupdict () admonition_type = groups [ \"type\" ] . lower () if admonition_type in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), title = groups [ \"title\" ], ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type ]] section , index = reader ( docstring , index + 1 ) if section : sections . append ( section ) else : contents , index = _read_block ( docstring , index + 1 ) if contents : sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type , contents = contents ), title = groups [ \"title\" ], ) ) else : index -= 1 current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"google.py"},{"location":"reference/docstrings/google/#griffe.docstrings.google.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: Name Type Description Default docstring Docstring The docstring to parse. required **options Additional parsing options. {} Returns: Type Description list[DocstringSection] A list of docstring sections. Source code in griffe/docstrings/google.py def parse ( # noqa: WPS231 docstring : Docstring , ** options , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Arguments: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) elif match := _RE_ADMONITION . match ( lines [ index ]): # noqa: WPS332 groups = match . groupdict () admonition_type = groups [ \"type\" ] . lower () if admonition_type in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), title = groups [ \"title\" ], ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type ]] section , index = reader ( docstring , index + 1 ) if section : sections . append ( section ) else : contents , index = _read_block ( docstring , index + 1 ) if contents : sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type , contents = contents ), title = groups [ \"title\" ], ) ) else : index -= 1 current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/docstrings/markdown/","text":"This module defines functions and classes to parse Markdown docstrings into structured data.","title":"markdown.py"},{"location":"reference/docstrings/numpy/","text":"This module defines functions to parse Numpy-style docstrings into structured data. Based on https://numpydoc.readthedocs.io/en/latest/format.html , it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification. Rejected as non particularly Pythonic or useful as sections: See also: this section feels too subjective (specially crafted as a standard for Numpy itself), and there are may ways to reference related items in a docstring, depending on the chosen markup. Methods: with a good documentation renderer, methods are easily made accessible or hidden. Griffe also has a goal of making the merging of inherited methods configurable (on/off). Rejected as naturally handled by the user-chosen markup: Warnings: this is just markup. Notes: again, just markup. References: again, just markup. The following sections are supported: Deprecated (revisited): we expect a title instead of an RST directive. Python has support for deprecating things, so it feels natural to structure deprecations. Parameters: obviously. Returns: obviously. Yields: obviously. Receives: less used than Yields, but very natural/Pythonic as well. Other parameters: used here as documentation for keyword arguments. Raises: obviously. Warns: less used than Raises, but very natural/Pythonic as well. Examples: obviously. Special handling for non-code-blocks >>> . Attributes: obviously. parse ( docstring , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: Name Type Description Default docstring Docstring The docstring to parse. required **options Additional parsing options. {} Returns: Type Description list[DocstringSection] A list of docstring sections. Source code in griffe/docstrings/numpy.py def parse ( # noqa: WPS231 docstring : Docstring , ** options , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Arguments: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"numpy.py"},{"location":"reference/docstrings/numpy/#griffe.docstrings.numpy.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: Name Type Description Default docstring Docstring The docstring to parse. required **options Additional parsing options. {} Returns: Type Description list[DocstringSection] A list of docstring sections. Source code in griffe/docstrings/numpy.py def parse ( # noqa: WPS231 docstring : Docstring , ** options , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Arguments: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/docstrings/parsers/","text":"This module imports all the defined parsers. Parser ( Enum ) \u00a4 Enumeration for the different docstring parsers. parse ( docstring , docstring_parser , ** options ) \u00a4 Parse the docstring. Parameters: Name Type Description Default docstring Docstring The docstring to parse. required docstring_parser Parser The parsing docstring_parser to use. required **options The options accepted by the parser. {} Returns: Type Description list[DocstringSection] A list of docstring sections. Source code in griffe/docstrings/parsers.py def parse ( docstring : Docstring , docstring_parser : Parser , ** options ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Arguments: docstring: The docstring to parse. docstring_parser: The parsing docstring_parser to use. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" return parsers [ docstring_parser ]( docstring , ** options )","title":"parsers.py"},{"location":"reference/docstrings/parsers/#griffe.docstrings.parsers.Parser","text":"Enumeration for the different docstring parsers.","title":"Parser"},{"location":"reference/docstrings/parsers/#griffe.docstrings.parsers.parse","text":"Parse the docstring. Parameters: Name Type Description Default docstring Docstring The docstring to parse. required docstring_parser Parser The parsing docstring_parser to use. required **options The options accepted by the parser. {} Returns: Type Description list[DocstringSection] A list of docstring sections. Source code in griffe/docstrings/parsers.py def parse ( docstring : Docstring , docstring_parser : Parser , ** options ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Arguments: docstring: The docstring to parse. docstring_parser: The parsing docstring_parser to use. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" return parsers [ docstring_parser ]( docstring , ** options )","title":"parse()"},{"location":"reference/docstrings/rst/","text":"This module defines functions to parse RST-style docstrings into structured data. Credits to Patrick Lannigan ( @plannigan ) who originally added the parser in the pytkdocs project . See https://github.com/mkdocstrings/pytkdocs/pull/71 . AttributesDict ( dict ) \u00a4 Attribute details. FieldType dataclass \u00a4 Maps directive names to parser functions. matches ( self , line ) \u00a4 Check if a line matches the field type. Parameters: Name Type Description Default line str Line to check against required Returns: Type Description bool True if the line matches the field type, False otherwise. Source code in griffe/docstrings/rst.py def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Arguments: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names ) ParsedDirective dataclass \u00a4 Directive information that has been parsed from a docstring. ParsedValues dataclass \u00a4 Values parsed from the docstring to be used to produce sections. parse ( docstring , ** options ) \u00a4 Parse an RST-styled docstring. Parameters: Name Type Description Default docstring Docstring The docstring to parse. required **options Additional parsing options. {} Returns: Type Description list[DocstringSection] A list of docstring sections. Source code in griffe/docstrings/rst.py def parse ( docstring : Docstring , ** options ) -> list [ DocstringSection ]: \"\"\"Parse an RST-styled docstring. Arguments: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"rst.py"},{"location":"reference/docstrings/rst/#griffe.docstrings.rst.AttributesDict","text":"Attribute details.","title":"AttributesDict"},{"location":"reference/docstrings/rst/#griffe.docstrings.rst.FieldType","text":"Maps directive names to parser functions.","title":"FieldType"},{"location":"reference/docstrings/rst/#griffe.docstrings.rst.FieldType.matches","text":"Check if a line matches the field type. Parameters: Name Type Description Default line str Line to check against required Returns: Type Description bool True if the line matches the field type, False otherwise. Source code in griffe/docstrings/rst.py def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Arguments: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names )","title":"matches()"},{"location":"reference/docstrings/rst/#griffe.docstrings.rst.ParsedDirective","text":"Directive information that has been parsed from a docstring.","title":"ParsedDirective"},{"location":"reference/docstrings/rst/#griffe.docstrings.rst.ParsedValues","text":"Values parsed from the docstring to be used to produce sections.","title":"ParsedValues"},{"location":"reference/docstrings/rst/#griffe.docstrings.rst.parse","text":"Parse an RST-styled docstring. Parameters: Name Type Description Default docstring Docstring The docstring to parse. required **options Additional parsing options. {} Returns: Type Description list[DocstringSection] A list of docstring sections. Source code in griffe/docstrings/rst.py def parse ( docstring : Docstring , ** options ) -> list [ DocstringSection ]: \"\"\"Parse an RST-styled docstring. Arguments: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"parse()"},{"location":"reference/docstrings/utils/","text":"This module contains utilities for docstrings parsers. warning ( name ) \u00a4 Create and return a warn function. Parameters: Name Type Description Default name str The logger name. required Returns: Type Description Callable[[Docstring, int, str], None] A function used to log parsing warnings. Source code in griffe/docstrings/utils.py def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Arguments: name: The logger name. Returns: A function used to log parsing warnings. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 \"\"\"Log a warning message by prefixing it with the filepath and line number. Arguments: docstring: The docstring object. offset: The offset in the docstring lines. message: The message to log. \"\"\" try : prefix = docstring . parent . filepath # type: ignore except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { docstring . lineno + offset } : { message } \" ) # type: ignore return warn","title":"utils.py"},{"location":"reference/docstrings/utils/#griffe.docstrings.utils.warning","text":"Create and return a warn function. Parameters: Name Type Description Default name str The logger name. required Returns: Type Description Callable[[Docstring, int, str], None] A function used to log parsing warnings. Source code in griffe/docstrings/utils.py def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Arguments: name: The logger name. Returns: A function used to log parsing warnings. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 \"\"\"Log a warning message by prefixing it with the filepath and line number. Arguments: docstring: The docstring object. offset: The offset in the docstring lines. message: The message to log. \"\"\" try : prefix = docstring . parent . filepath # type: ignore except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { docstring . lineno + offset } : { message } \" ) # type: ignore return warn","title":"warning()"},{"location":"reference/extensions/__init__/","text":"This module is the public interface to import elements from the base.","title":"__init__.py"},{"location":"reference/extensions/base/","text":"This module contains the base classes for dealing with extensions. Extension ( _BaseVisitor ) \u00a4 The node visitor extension base class, to inherit from. __init__ ( self , main_visitor ) special \u00a4 Initialize the visitor extension. Parameters: Name Type Description Default main_visitor MainVisitor The main visitor. required Source code in griffe/extensions/base.py def __init__ ( self , main_visitor : MainVisitor ) -> None : \"\"\"Initialize the visitor extension. Arguments: main_visitor: The main visitor. \"\"\" super () . __init__ () self . visitor = main_visitor Extensions \u00a4 This class helps iterating on extensions that should run at different times. need_parents : bool property readonly \u00a4 Tell if any of the contained extensions needs access to the whole parents chain while visiting. Returns: Type Description bool True or False. when_children_visit_starts : list [ Extension ] property readonly \u00a4 Return the visitors that run when the children visit starts. Returns: Type Description list[Extension] Visitors. when_children_visit_stops : list [ Extension ] property readonly \u00a4 Return the visitors that run when the children visit stops. Returns: Type Description list[Extension] Visitors. when_visit_starts : list [ Extension ] property readonly \u00a4 Return the visitors that run when the visit starts. Returns: Type Description list[Extension] Visitors. when_visit_stops : list [ Extension ] property readonly \u00a4 Return the visitors that run when the visit stops. Returns: Type Description list[Extension] Visitors. __init__ ( self , * extensions_classes ) special \u00a4 Initialize the extensions container. Parameters: Name Type Description Default *extensions_classes Type[Extension] The extensions to add. () Source code in griffe/extensions/base.py def __init__ ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Initialize the extensions container. Arguments: *extensions_classes: The extensions to add. \"\"\" self . _classes : list [ Type [ Extension ]] = list ( extensions_classes ) self . _instances : dict [ When , list [ Extension ]] = {} add ( self , * extensions_classes ) \u00a4 Add visitor extensions to this container. Parameters: Name Type Description Default *extensions_classes Type[Extension] The extensions to add. () Source code in griffe/extensions/base.py def add ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Add visitor extensions to this container. Arguments: *extensions_classes: The extensions to add. \"\"\" self . _classes . extend ( extensions_classes ) instantiate ( self , main_visitor ) \u00a4 Clear and instantiate the visitor classes. Parameters: Name Type Description Default main_visitor MainVisitor The main visitor, leading the visit. required Returns: Type Description Extensions Self, conveniently. Source code in griffe/extensions/base.py def instantiate ( self , main_visitor : MainVisitor ) -> Extensions : \"\"\"Clear and instantiate the visitor classes. Arguments: main_visitor: The main visitor, leading the visit. Returns: Self, conveniently. \"\"\" # clear instances for when in When : self . _instances [ when ] = [] # create instances for visitor_class in self . _classes : self . _instances [ visitor_class . when ] . append ( visitor_class ( main_visitor )) return self when ( self , when ) \u00a4 Return the visitors that run at the given time. Parameters: Name Type Description Default when When The selected time. required Returns: Type Description list[Extension] Visitors. Source code in griffe/extensions/base.py def when ( self , when : When ) -> list [ Extension ]: \"\"\"Return the visitors that run at the given time. Arguments: when: The selected time. Returns: Visitors. \"\"\" return self . _instances [ when ] When ( Enum ) \u00a4 This enumeration contains the different times at which an extension is used. Attributes: Name Type Description visit_starts int For each node, before starting the visit. children_visit_starts int For each node, after the visit has started, and before starting to visit children. children_visit_stops int For each node, after the children have been visited, and before finishing the visit. visit_stops int For each node, after finishing the visit.","title":"base.py"},{"location":"reference/extensions/base/#griffe.extensions.base.Extension","text":"The node visitor extension base class, to inherit from.","title":"Extension"},{"location":"reference/extensions/base/#griffe.extensions.base.Extension.__init__","text":"Initialize the visitor extension. Parameters: Name Type Description Default main_visitor MainVisitor The main visitor. required Source code in griffe/extensions/base.py def __init__ ( self , main_visitor : MainVisitor ) -> None : \"\"\"Initialize the visitor extension. Arguments: main_visitor: The main visitor. \"\"\" super () . __init__ () self . visitor = main_visitor","title":"__init__()"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions","text":"This class helps iterating on extensions that should run at different times.","title":"Extensions"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.need_parents","text":"Tell if any of the contained extensions needs access to the whole parents chain while visiting. Returns: Type Description bool True or False.","title":"need_parents"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when_children_visit_starts","text":"Return the visitors that run when the children visit starts. Returns: Type Description list[Extension] Visitors.","title":"when_children_visit_starts"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when_children_visit_stops","text":"Return the visitors that run when the children visit stops. Returns: Type Description list[Extension] Visitors.","title":"when_children_visit_stops"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when_visit_starts","text":"Return the visitors that run when the visit starts. Returns: Type Description list[Extension] Visitors.","title":"when_visit_starts"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when_visit_stops","text":"Return the visitors that run when the visit stops. Returns: Type Description list[Extension] Visitors.","title":"when_visit_stops"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.__init__","text":"Initialize the extensions container. Parameters: Name Type Description Default *extensions_classes Type[Extension] The extensions to add. () Source code in griffe/extensions/base.py def __init__ ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Initialize the extensions container. Arguments: *extensions_classes: The extensions to add. \"\"\" self . _classes : list [ Type [ Extension ]] = list ( extensions_classes ) self . _instances : dict [ When , list [ Extension ]] = {}","title":"__init__()"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.add","text":"Add visitor extensions to this container. Parameters: Name Type Description Default *extensions_classes Type[Extension] The extensions to add. () Source code in griffe/extensions/base.py def add ( self , * extensions_classes : Type [ Extension ]) -> None : \"\"\"Add visitor extensions to this container. Arguments: *extensions_classes: The extensions to add. \"\"\" self . _classes . extend ( extensions_classes )","title":"add()"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.instantiate","text":"Clear and instantiate the visitor classes. Parameters: Name Type Description Default main_visitor MainVisitor The main visitor, leading the visit. required Returns: Type Description Extensions Self, conveniently. Source code in griffe/extensions/base.py def instantiate ( self , main_visitor : MainVisitor ) -> Extensions : \"\"\"Clear and instantiate the visitor classes. Arguments: main_visitor: The main visitor, leading the visit. Returns: Self, conveniently. \"\"\" # clear instances for when in When : self . _instances [ when ] = [] # create instances for visitor_class in self . _classes : self . _instances [ visitor_class . when ] . append ( visitor_class ( main_visitor )) return self","title":"instantiate()"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when","text":"Return the visitors that run at the given time. Parameters: Name Type Description Default when When The selected time. required Returns: Type Description list[Extension] Visitors. Source code in griffe/extensions/base.py def when ( self , when : When ) -> list [ Extension ]: \"\"\"Return the visitors that run at the given time. Arguments: when: The selected time. Returns: Visitors. \"\"\" return self . _instances [ when ]","title":"when()"},{"location":"reference/extensions/base/#griffe.extensions.base.When","text":"This enumeration contains the different times at which an extension is used. Attributes: Name Type Description visit_starts int For each node, before starting the visit. children_visit_starts int For each node, after the visit has started, and before starting to visit children. children_visit_stops int For each node, after the children have been visited, and before finishing the visit. visit_stops int For each node, after finishing the visit.","title":"When"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}