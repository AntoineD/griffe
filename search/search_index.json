{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"griffe \u00a4 Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Work in progress! Requirements \u00a4 griffe requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7.12 # make it available globally pyenv global system 3 .7.12 Installation \u00a4 With pip : pip install griffe With pipx : python3.7 -m pip install --user pipx pipx install griffe Usage \u00a4 On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples. Todo \u00a4 Visitor/Inspector: Labels Attribute: ? Function: ? Class: ? Module: ? Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring (could be an extension) Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Support for wildcard imports Extensions Post-processing extensions Third-party libraries we could provide support for: Django support Marshmallow support Pydantic support Docstrings parsers epydoc New Markdown-based format? For graceful degradation Serializer: Flat JSON JSON schema API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Overview"},{"location":"#griffe","text":"Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Work in progress!","title":"griffe"},{"location":"#requirements","text":"griffe requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7.12 # make it available globally pyenv global system 3 .7.12","title":"Requirements"},{"location":"#installation","text":"With pip : pip install griffe With pipx : python3.7 -m pip install --user pipx pipx install griffe","title":"Installation"},{"location":"#usage","text":"On the command line , pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] See the Usage section for more examples. With Python: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) See the Usage section for more examples.","title":"Usage"},{"location":"#todo","text":"Visitor/Inspector: Labels Attribute: ? Function: ? Class: ? Module: ? Merging inherited members into class. Needs to be able to post-process classes, and to compute their MRO (C3Linearization, see docspec/pydocspec issues). Merging __init__ method's docstring into class' docstring (could be an extension) Support for typing.overload decorator. We'll probably need to add an overloads attribute to Function , to store the list of @overload -decorated functions, because currently different members of a same object cannot have the same names. Support for wildcard imports Extensions Post-processing extensions Third-party libraries we could provide support for: Django support Marshmallow support Pydantic support Docstrings parsers epydoc New Markdown-based format? For graceful degradation Serializer: Flat JSON JSON schema API diff: Mecanism to cache APIs? Should users version them, or store them somewhere (docs)? Ability to return warnings (things that are not backward-compatibility-friendly) List of things to consider for warnings Multiple positional-or-keyword parameters Public imports in public modules Private things made public through imports/assignments Too many public things? Generally annoying. Configuration? Ability to compare two APIs to return breaking changes List of things to consider for breaking changes Changed position of positional only parameter Changed position of positional or keyword parameter Changed type of parameter Changed type of public module attribute Changed return type of a public function/method Added parameter without a default value Removed keyword-only parameter without a default value, without **kwargs to swallow it Removed positional-only parameter without a default value, without *args to swallow it Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it Removed public module/class/function/method/attribute All of the previous even when parent is private (could be publicly imported or assigned somewhere), and later be smarter: public assign/import makes private things public! Inheritance: removed base, or added/changed base that changes MRO","title":"Todo"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.9.0 - 2022-01-04 \u00a4 Compare with 0.8.0 Features \u00a4 Loader option to only follow aliases in known modules ( 879d91b by Timoth\u00e9e Mazzucotelli). Use aliases when inspecting too ( 60439ee by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Handle more errors when loading modules ( 1aa571a by Timoth\u00e9e Mazzucotelli). Handle more errors when getting signature ( 2db85e7 by Timoth\u00e9e Mazzucotelli). Fix checking parent truthfulness ( 6129e50 by Timoth\u00e9e Mazzucotelli). Fix getting subscript value ( 1699f12 by Timoth\u00e9e Mazzucotelli). Support yield nodes ( 7d536d5 by Timoth\u00e9e Mazzucotelli). Exclude some special low-level members that cause cyclic issues ( b54ab34 by Timoth\u00e9e Mazzucotelli). Fix transforming elements of signatures to annotations ( e278c11 by Timoth\u00e9e Mazzucotelli). Detect cyclic aliases and prevent resolution errors ( de5dd12 by Timoth\u00e9e Mazzucotelli). Don't crash while trying to get the representation of an attribute value ( 77ac55d by Timoth\u00e9e Mazzucotelli). Fix building value for joined strings ( 6154b69 by Timoth\u00e9e Mazzucotelli). Fix prevention of cycles while building objects nodes ( 48062ac by Timoth\u00e9e Mazzucotelli). Better handle relative imports ( 91b42de by Timoth\u00e9e Mazzucotelli). Fix Google parser missing lines ending with colon ( 2f7969c by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Improve alias resolution robustness ( e708139 by Timoth\u00e9e Mazzucotelli). Remove async loader for now ( acc5ecf by Timoth\u00e9e Mazzucotelli). Improve handling of Google admonitions ( 8aa5ed0 by Timoth\u00e9e Mazzucotelli). Better handling of import errors and system exits while inspecting modules ( 7ba1589 by Timoth\u00e9e Mazzucotelli). Empty generic visit/inspect methods in base classes ( 338760e by Timoth\u00e9e Mazzucotelli). 0.8.0 - 2022-01-02 \u00a4 Compare with 0.7.1 Features \u00a4 Support getting attribute annotation from parent in RST docstring parser ( 25db61a by Timoth\u00e9e Mazzucotelli). Handle relative imports ( 62b0927 by Timoth\u00e9e Mazzucotelli). Support wildcard imports ( 77a3cb7 by Timoth\u00e9e Mazzucotelli). Support configuring log level (CLI/env var) ( 839d78e by Timoth\u00e9e Mazzucotelli). Support loading *.py[cod] and *.so modules ( cd98a6f by Timoth\u00e9e Mazzucotelli). Support inspecting builtin functions/methods ( aa1fce3 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Handle extensions errors ( 11278ca by Timoth\u00e9e Mazzucotelli). Don't always try to find a module as a relative path ( e6df277 by Timoth\u00e9e Mazzucotelli). Improve loggers patching ( f4b262a by Timoth\u00e9e Mazzucotelli). Improve dynamic imports ( 2998195 by Timoth\u00e9e Mazzucotelli). 0.7.1 - 2021-12-28 \u00a4 Compare with 0.7.0 Code Refactoring \u00a4 Only log warning if async mode is used ( 356e848 by Timoth\u00e9e Mazzucotelli). 0.7.0 - 2021-12-28 \u00a4 Compare with 0.6.0 Features \u00a4 Support more nodes on Python 3.7 ( 7f2c4ec by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Don't crash on syntax errors and log an error ( 10bb6b1 by Timoth\u00e9e Mazzucotelli). 0.6.0 - 2021-12-27 \u00a4 Compare with 0.5.0 Features \u00a4 Support more AST nodes ( cd1b305 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Use annotation getter for base classes ( 8b1a7ed by Timoth\u00e9e Mazzucotelli). 0.5.0 - 2021-12-20 \u00a4 Compare with 0.4.0 Features \u00a4 Add support for Python 3.7 ( 4535adc by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Don't propagate aliases of an alias ( 8af48f8 by Timoth\u00e9e Mazzucotelli). Don't reassign members defined in except clauses ( d918b4e by Timoth\u00e9e Mazzucotelli). 0.4.0 - 2021-11-28 \u00a4 Compare with 0.3.0 Features \u00a4 Add a prototype 'hybrid' extension ( 8cb3c16 by Timoth\u00e9e Mazzucotelli). Allow passing extensions config as JSON on the CLI ( 9a7fa8b by Timoth\u00e9e Mazzucotelli). Support names for returns, yields and receives sections items ( 1c5a4c9 by Timoth\u00e9e Mazzucotelli). Store aliases on each object ( 91ba643 by Timoth\u00e9e Mazzucotelli). Support in[tro]spection ( 3a0587d by Timoth\u00e9e Mazzucotelli). Support multiple return, yield and receive items ( 0fc70cb by Timoth\u00e9e Mazzucotelli). Support namespace packages ( 2414c8e by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Fix extensions loader ( 78fb70b by Timoth\u00e9e Mazzucotelli). Avoid visiting/inspecting multiple times ( 75a8a8b by Timoth\u00e9e Mazzucotelli). Set modules collection attribute earlier ( 592c0bd by Timoth\u00e9e Mazzucotelli). Support inequality nodes ( b0ed247 by Timoth\u00e9e Mazzucotelli). Handle Div nodes for values ( 272e4d6 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Set log level to INFO ( 718e73e by Timoth\u00e9e Mazzucotelli). Add target setter ( 7f0064c by Timoth\u00e9e Mazzucotelli). Reorganize conditions ( 15ab876 by Timoth\u00e9e Mazzucotelli). Avoid recursion loops ( ea6acec by Timoth\u00e9e Mazzucotelli). Update aliases when replacing a member ( 99a0f8b by Timoth\u00e9e Mazzucotelli). Reorganize code ( 31fcdb1 by Timoth\u00e9e Mazzucotelli). Replace DocstringException with DocstringRaise ( d5ed87a by Timoth\u00e9e Mazzucotelli). Refactor loaders ( d9b94bb by Timoth\u00e9e Mazzucotelli). Improve typing ( e08bcfa by Timoth\u00e9e Mazzucotelli). 0.3.0 - 2021-11-21 \u00a4 Compare with 0.2.0 Features \u00a4 Handle aliases and their resolution ( 67ae903 by Timoth\u00e9e Mazzucotelli). Resolve annotations in docstrings ( 847384a by Timoth\u00e9e Mazzucotelli). Resolve annotations ( 6451eff by Timoth\u00e9e Mazzucotelli). Add lines property to objects ( 7daf7db by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each object ( 07a1d2e by Timoth\u00e9e Mazzucotelli). Get attributes annotations from parent ( 003b990 by Timoth\u00e9e Mazzucotelli). Draft extensions loader ( 17ccd03 by Timoth\u00e9e Mazzucotelli). Add properties to objects ( 0ec301a by Timoth\u00e9e Mazzucotelli). Handle .pth files when searching modules ( 2a2e182 by Timoth\u00e9e Mazzucotelli). Add default property to docstring parameters ( 6298ba3 by Timoth\u00e9e Mazzucotelli). Accept RST and Numpy parsers ( 1cf147d by Timoth\u00e9e Mazzucotelli). Support data (attributes/variables) ( dce84d1 by Timoth\u00e9e Mazzucotelli). Add Numpy-style parser ( ad5b72d by Timoth\u00e9e Mazzucotelli). Support more section kinds in Google-style ( 9d3d047 by Timoth\u00e9e Mazzucotelli). Add docstring section kinds ( b270483 by Timoth\u00e9e Mazzucotelli). Accept initial arguments when creating container ( 90c5956 by Timoth\u00e9e Mazzucotelli). Add an RST-style docstring parser ( 742e7b2 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Improve JSON encoder perfs ( 6a78eb0 by Timoth\u00e9e Mazzucotelli). Bug Fixes \u00a4 Handle serialization of Posix paths ( 3a66b95 by Timoth\u00e9e Mazzucotelli). Fix list annotation getter ( 5ae800a by Timoth\u00e9e Mazzucotelli). Show accurate line number in Google warnings ( 2953590 by Timoth\u00e9e Mazzucotelli). Fix assignment names getters ( 6990846 by Timoth\u00e9e Mazzucotelli). Fix async loader (passing parent) ( 57e866e by Timoth\u00e9e Mazzucotelli). Fix exception name ( 4b8b85d by Timoth\u00e9e Mazzucotelli). Fix Google sections titles logic ( 87dd329 by Timoth\u00e9e Mazzucotelli). Prepend current module to base classes (still needs resolution) ( a4b1dee by Timoth\u00e9e Mazzucotelli). Fix Google admonition regex ( 3902e74 by Timoth\u00e9e Mazzucotelli). Fix docstring getter ( 1442eba by Timoth\u00e9e Mazzucotelli). Fix getting arguments defaults in the Google-style parser ( 67adbaf by Timoth\u00e9e Mazzucotelli). Fix getting arguments annotations in the Google-style parser ( 8bcbfba by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Export parsers and main function in docstrings module ( 96469da by Timoth\u00e9e Mazzucotelli). Remove top exports ( cd76694 by Timoth\u00e9e Mazzucotelli). Reorganize exceptions ( 7f9b805 by Timoth\u00e9e Mazzucotelli). Avoid circular import ( ef27dcd by Timoth\u00e9e Mazzucotelli). Rename index to [new] offset ( c07cc7d by Timoth\u00e9e Mazzucotelli). Reorganize code ( 5f4fff2 by Timoth\u00e9e Mazzucotelli). Use keyword only parameters ( d34edd6 by Timoth\u00e9e Mazzucotelli). Default to no parsing for serialization ( 8fecd9e by Timoth\u00e9e Mazzucotelli). Always extend AST ( c227ae6 by Timoth\u00e9e Mazzucotelli). Set default for kwargs parameters ( 7a0b85e by Timoth\u00e9e Mazzucotelli). Rename visitor method ( 3e0c43c by Timoth\u00e9e Mazzucotelli). Improve typing ( ac86f17 by Timoth\u00e9e Mazzucotelli). Fix typo ( a9ed6e9 by Timoth\u00e9e Mazzucotelli). Rewrite ParameterKind ( 90249df by Timoth\u00e9e Mazzucotelli). Add bool methods to docstrings and objects ( 548f72e by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each docstring ( 752e084 by Timoth\u00e9e Mazzucotelli). Skip attribute assignments ( e9cc2cd by Timoth\u00e9e Mazzucotelli). Improve visitor getters ( 2ea88c0 by Timoth\u00e9e Mazzucotelli). Use relative filepath in docstring warnings ( e894df7 by Timoth\u00e9e Mazzucotelli). Set submodules parent earlier ( 53767c0 by Timoth\u00e9e Mazzucotelli). Rename Data to Attribute ( febc12e by Timoth\u00e9e Mazzucotelli). Rename arguments to parameters ( 957856c by Timoth\u00e9e Mazzucotelli). Improve annotation support ( 5b2262f by Timoth\u00e9e Mazzucotelli). Always set parent ( cae85de by Timoth\u00e9e Mazzucotelli). Factorize function handling ( dfece1c by Timoth\u00e9e Mazzucotelli). Privatize stuff, fix loggers ( 5513ed5 by Timoth\u00e9e Mazzucotelli). Use keyword only arguments ( e853fe9 by Timoth\u00e9e Mazzucotelli). Set default values for Argument arguments ( d5cccaa by Timoth\u00e9e Mazzucotelli). Swallow extra parsing options ( 3d9ebe7 by Timoth\u00e9e Mazzucotelli). Rename start_index argument to offset ( dd88358 by Timoth\u00e9e Mazzucotelli). Reuse parsers warn function ( 03dfdd3 by Timoth\u00e9e Mazzucotelli). 0.2.0 - 2021-09-25 \u00a4 Compare with 0.1.0 Features \u00a4 Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli). Performance Improvements \u00a4 Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli). 0.1.0 - 2021-09-09 \u00a4 Compare with first commit Features \u00a4 Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#090-2022-01-04","text":"Compare with 0.8.0","title":"0.9.0 - 2022-01-04"},{"location":"changelog/#features","text":"Loader option to only follow aliases in known modules ( 879d91b by Timoth\u00e9e Mazzucotelli). Use aliases when inspecting too ( 60439ee by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes","text":"Handle more errors when loading modules ( 1aa571a by Timoth\u00e9e Mazzucotelli). Handle more errors when getting signature ( 2db85e7 by Timoth\u00e9e Mazzucotelli). Fix checking parent truthfulness ( 6129e50 by Timoth\u00e9e Mazzucotelli). Fix getting subscript value ( 1699f12 by Timoth\u00e9e Mazzucotelli). Support yield nodes ( 7d536d5 by Timoth\u00e9e Mazzucotelli). Exclude some special low-level members that cause cyclic issues ( b54ab34 by Timoth\u00e9e Mazzucotelli). Fix transforming elements of signatures to annotations ( e278c11 by Timoth\u00e9e Mazzucotelli). Detect cyclic aliases and prevent resolution errors ( de5dd12 by Timoth\u00e9e Mazzucotelli). Don't crash while trying to get the representation of an attribute value ( 77ac55d by Timoth\u00e9e Mazzucotelli). Fix building value for joined strings ( 6154b69 by Timoth\u00e9e Mazzucotelli). Fix prevention of cycles while building objects nodes ( 48062ac by Timoth\u00e9e Mazzucotelli). Better handle relative imports ( 91b42de by Timoth\u00e9e Mazzucotelli). Fix Google parser missing lines ending with colon ( 2f7969c by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Improve alias resolution robustness ( e708139 by Timoth\u00e9e Mazzucotelli). Remove async loader for now ( acc5ecf by Timoth\u00e9e Mazzucotelli). Improve handling of Google admonitions ( 8aa5ed0 by Timoth\u00e9e Mazzucotelli). Better handling of import errors and system exits while inspecting modules ( 7ba1589 by Timoth\u00e9e Mazzucotelli). Empty generic visit/inspect methods in base classes ( 338760e by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#080-2022-01-02","text":"Compare with 0.7.1","title":"0.8.0 - 2022-01-02"},{"location":"changelog/#features_1","text":"Support getting attribute annotation from parent in RST docstring parser ( 25db61a by Timoth\u00e9e Mazzucotelli). Handle relative imports ( 62b0927 by Timoth\u00e9e Mazzucotelli). Support wildcard imports ( 77a3cb7 by Timoth\u00e9e Mazzucotelli). Support configuring log level (CLI/env var) ( 839d78e by Timoth\u00e9e Mazzucotelli). Support loading *.py[cod] and *.so modules ( cd98a6f by Timoth\u00e9e Mazzucotelli). Support inspecting builtin functions/methods ( aa1fce3 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_1","text":"Handle extensions errors ( 11278ca by Timoth\u00e9e Mazzucotelli). Don't always try to find a module as a relative path ( e6df277 by Timoth\u00e9e Mazzucotelli). Improve loggers patching ( f4b262a by Timoth\u00e9e Mazzucotelli). Improve dynamic imports ( 2998195 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#071-2021-12-28","text":"Compare with 0.7.0","title":"0.7.1 - 2021-12-28"},{"location":"changelog/#code-refactoring_2","text":"Only log warning if async mode is used ( 356e848 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#070-2021-12-28","text":"Compare with 0.6.0","title":"0.7.0 - 2021-12-28"},{"location":"changelog/#features_2","text":"Support more nodes on Python 3.7 ( 7f2c4ec by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_3","text":"Don't crash on syntax errors and log an error ( 10bb6b1 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#060-2021-12-27","text":"Compare with 0.5.0","title":"0.6.0 - 2021-12-27"},{"location":"changelog/#features_3","text":"Support more AST nodes ( cd1b305 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#code-refactoring_4","text":"Use annotation getter for base classes ( 8b1a7ed by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#050-2021-12-20","text":"Compare with 0.4.0","title":"0.5.0 - 2021-12-20"},{"location":"changelog/#features_4","text":"Add support for Python 3.7 ( 4535adc by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_1","text":"Don't propagate aliases of an alias ( 8af48f8 by Timoth\u00e9e Mazzucotelli). Don't reassign members defined in except clauses ( d918b4e by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#040-2021-11-28","text":"Compare with 0.3.0","title":"0.4.0 - 2021-11-28"},{"location":"changelog/#features_5","text":"Add a prototype 'hybrid' extension ( 8cb3c16 by Timoth\u00e9e Mazzucotelli). Allow passing extensions config as JSON on the CLI ( 9a7fa8b by Timoth\u00e9e Mazzucotelli). Support names for returns, yields and receives sections items ( 1c5a4c9 by Timoth\u00e9e Mazzucotelli). Store aliases on each object ( 91ba643 by Timoth\u00e9e Mazzucotelli). Support in[tro]spection ( 3a0587d by Timoth\u00e9e Mazzucotelli). Support multiple return, yield and receive items ( 0fc70cb by Timoth\u00e9e Mazzucotelli). Support namespace packages ( 2414c8e by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#bug-fixes_2","text":"Fix extensions loader ( 78fb70b by Timoth\u00e9e Mazzucotelli). Avoid visiting/inspecting multiple times ( 75a8a8b by Timoth\u00e9e Mazzucotelli). Set modules collection attribute earlier ( 592c0bd by Timoth\u00e9e Mazzucotelli). Support inequality nodes ( b0ed247 by Timoth\u00e9e Mazzucotelli). Handle Div nodes for values ( 272e4d6 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_5","text":"Set log level to INFO ( 718e73e by Timoth\u00e9e Mazzucotelli). Add target setter ( 7f0064c by Timoth\u00e9e Mazzucotelli). Reorganize conditions ( 15ab876 by Timoth\u00e9e Mazzucotelli). Avoid recursion loops ( ea6acec by Timoth\u00e9e Mazzucotelli). Update aliases when replacing a member ( 99a0f8b by Timoth\u00e9e Mazzucotelli). Reorganize code ( 31fcdb1 by Timoth\u00e9e Mazzucotelli). Replace DocstringException with DocstringRaise ( d5ed87a by Timoth\u00e9e Mazzucotelli). Refactor loaders ( d9b94bb by Timoth\u00e9e Mazzucotelli). Improve typing ( e08bcfa by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#030-2021-11-21","text":"Compare with 0.2.0","title":"0.3.0 - 2021-11-21"},{"location":"changelog/#features_6","text":"Handle aliases and their resolution ( 67ae903 by Timoth\u00e9e Mazzucotelli). Resolve annotations in docstrings ( 847384a by Timoth\u00e9e Mazzucotelli). Resolve annotations ( 6451eff by Timoth\u00e9e Mazzucotelli). Add lines property to objects ( 7daf7db by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each object ( 07a1d2e by Timoth\u00e9e Mazzucotelli). Get attributes annotations from parent ( 003b990 by Timoth\u00e9e Mazzucotelli). Draft extensions loader ( 17ccd03 by Timoth\u00e9e Mazzucotelli). Add properties to objects ( 0ec301a by Timoth\u00e9e Mazzucotelli). Handle .pth files when searching modules ( 2a2e182 by Timoth\u00e9e Mazzucotelli). Add default property to docstring parameters ( 6298ba3 by Timoth\u00e9e Mazzucotelli). Accept RST and Numpy parsers ( 1cf147d by Timoth\u00e9e Mazzucotelli). Support data (attributes/variables) ( dce84d1 by Timoth\u00e9e Mazzucotelli). Add Numpy-style parser ( ad5b72d by Timoth\u00e9e Mazzucotelli). Support more section kinds in Google-style ( 9d3d047 by Timoth\u00e9e Mazzucotelli). Add docstring section kinds ( b270483 by Timoth\u00e9e Mazzucotelli). Accept initial arguments when creating container ( 90c5956 by Timoth\u00e9e Mazzucotelli). Add an RST-style docstring parser ( 742e7b2 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements","text":"Improve JSON encoder perfs ( 6a78eb0 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#bug-fixes_3","text":"Handle serialization of Posix paths ( 3a66b95 by Timoth\u00e9e Mazzucotelli). Fix list annotation getter ( 5ae800a by Timoth\u00e9e Mazzucotelli). Show accurate line number in Google warnings ( 2953590 by Timoth\u00e9e Mazzucotelli). Fix assignment names getters ( 6990846 by Timoth\u00e9e Mazzucotelli). Fix async loader (passing parent) ( 57e866e by Timoth\u00e9e Mazzucotelli). Fix exception name ( 4b8b85d by Timoth\u00e9e Mazzucotelli). Fix Google sections titles logic ( 87dd329 by Timoth\u00e9e Mazzucotelli). Prepend current module to base classes (still needs resolution) ( a4b1dee by Timoth\u00e9e Mazzucotelli). Fix Google admonition regex ( 3902e74 by Timoth\u00e9e Mazzucotelli). Fix docstring getter ( 1442eba by Timoth\u00e9e Mazzucotelli). Fix getting arguments defaults in the Google-style parser ( 67adbaf by Timoth\u00e9e Mazzucotelli). Fix getting arguments annotations in the Google-style parser ( 8bcbfba by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_6","text":"Export parsers and main function in docstrings module ( 96469da by Timoth\u00e9e Mazzucotelli). Remove top exports ( cd76694 by Timoth\u00e9e Mazzucotelli). Reorganize exceptions ( 7f9b805 by Timoth\u00e9e Mazzucotelli). Avoid circular import ( ef27dcd by Timoth\u00e9e Mazzucotelli). Rename index to [new] offset ( c07cc7d by Timoth\u00e9e Mazzucotelli). Reorganize code ( 5f4fff2 by Timoth\u00e9e Mazzucotelli). Use keyword only parameters ( d34edd6 by Timoth\u00e9e Mazzucotelli). Default to no parsing for serialization ( 8fecd9e by Timoth\u00e9e Mazzucotelli). Always extend AST ( c227ae6 by Timoth\u00e9e Mazzucotelli). Set default for kwargs parameters ( 7a0b85e by Timoth\u00e9e Mazzucotelli). Rename visitor method ( 3e0c43c by Timoth\u00e9e Mazzucotelli). Improve typing ( ac86f17 by Timoth\u00e9e Mazzucotelli). Fix typo ( a9ed6e9 by Timoth\u00e9e Mazzucotelli). Rewrite ParameterKind ( 90249df by Timoth\u00e9e Mazzucotelli). Add bool methods to docstrings and objects ( 548f72e by Timoth\u00e9e Mazzucotelli). Allow setting docstring parser and options on each docstring ( 752e084 by Timoth\u00e9e Mazzucotelli). Skip attribute assignments ( e9cc2cd by Timoth\u00e9e Mazzucotelli). Improve visitor getters ( 2ea88c0 by Timoth\u00e9e Mazzucotelli). Use relative filepath in docstring warnings ( e894df7 by Timoth\u00e9e Mazzucotelli). Set submodules parent earlier ( 53767c0 by Timoth\u00e9e Mazzucotelli). Rename Data to Attribute ( febc12e by Timoth\u00e9e Mazzucotelli). Rename arguments to parameters ( 957856c by Timoth\u00e9e Mazzucotelli). Improve annotation support ( 5b2262f by Timoth\u00e9e Mazzucotelli). Always set parent ( cae85de by Timoth\u00e9e Mazzucotelli). Factorize function handling ( dfece1c by Timoth\u00e9e Mazzucotelli). Privatize stuff, fix loggers ( 5513ed5 by Timoth\u00e9e Mazzucotelli). Use keyword only arguments ( e853fe9 by Timoth\u00e9e Mazzucotelli). Set default values for Argument arguments ( d5cccaa by Timoth\u00e9e Mazzucotelli). Swallow extra parsing options ( 3d9ebe7 by Timoth\u00e9e Mazzucotelli). Rename start_index argument to offset ( dd88358 by Timoth\u00e9e Mazzucotelli). Reuse parsers warn function ( 03dfdd3 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#020-2021-09-25","text":"Compare with 0.1.0","title":"0.2.0 - 2021-09-25"},{"location":"changelog/#features_7","text":"Add Google-style docstring parser ( cdefccc by Timoth\u00e9e Mazzucotelli). Support all kinds of functions arguments ( c177562 by Timoth\u00e9e Mazzucotelli). Initial support for class decorators and bases ( 8e229aa by Timoth\u00e9e Mazzucotelli). Add functions decorators support ( fee304d by Timoth\u00e9e Mazzucotelli). Add async loader ( 3218bd0 by Timoth\u00e9e Mazzucotelli). Add relative file path and package properties ( d26ee1f by Timoth\u00e9e Mazzucotelli). Add search and output option to the CLI ( 3b37692 by Timoth\u00e9e Mazzucotelli). Load docstrings and functions arguments ( cdf29a3 by Timoth\u00e9e Mazzucotelli). Support paths in loader ( 8f4df75 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#performance-improvements_1","text":"Avoid name lookups in visitor ( 00de148 by Timoth\u00e9e Mazzucotelli). Factorize and improve main and extensions visitors ( 9b27b56 by Timoth\u00e9e Mazzucotelli). Delegate children computation at runtime ( 8d54c87 by Timoth\u00e9e Mazzucotelli). Cache dataclasses properties ( 2d7447d by Timoth\u00e9e Mazzucotelli). Optimize node linker ( 03f955e by Timoth\u00e9e Mazzucotelli). Optimize docstring getter ( 4a05516 by Timoth\u00e9e Mazzucotelli).","title":"Performance Improvements"},{"location":"changelog/#010-2021-09-09","text":"Compare with first commit","title":"0.1.0 - 2021-09-09"},{"location":"changelog/#features_8","text":"Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build griffe . Thank you! python | pdm | copier-pdm Direct dependencies \u00a4 aiofiles | autoflake | black | cached_property | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | markdown-callouts | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | safety | toml | types-aiofiles | types-markdown | types-toml | wps-light Indirect dependencies \u00a4 ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | idna | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typed-ast | typing-extensions | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build griffe . Thank you! python | pdm | copier-pdm","title":"Credits"},{"location":"credits/#direct-dependencies","text":"aiofiles | autoflake | black | cached_property | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | markdown-callouts | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | safety | toml | types-aiofiles | types-markdown | types-toml | wps-light","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | astor | astunparse | atomicwrites | attrs | bandit | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | idna | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typed-ast | typing-extensions | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2021, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"usage/","text":"Usage \u00a4 On the command line \u00a4 Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError . With Python \u00a4 Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) If you don't want to recurse in the submodules: fastapi = griffe . load_module ( \"fastapi\" , submodules = False ) Extensions \u00a4 You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import VisitorExtension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( VisitorExtension ): when = When . after_all def visit_classdef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of a custom version of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE_LOWER> methods to visit nodes of certain types, and act on their properties. Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not call the .generic_visit(node) method in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children (what the generic_visit does). You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_functiondef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, attribute See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit/inspection: When.before_all . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is not yet instantiated. before the children visit/inspection: When.before_children . If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is now instantiated. Children have not yet been visited/inspected. after the children visit/inspection: When.after_children . Children have now been visited/inspected. after the visit/inspection: When.after_all See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . after_children By default, it will run the extension after the visit/inspection of the node: that's when the full data for this node and its children is loaded. AST nodes \u00a4 Nodes Add alias And AnnAssign arg arguments Assert Assign AsyncFor AsyncFunctionDef AsyncWith Attribute AugAssign Await BinOp BitAnd BitOr BitXor BoolOp Break Bytes 1 Call ClassDef Compare comprehension Constant Continue Del Delete Dict DictComp Div Ellipsis 1 Eq ExceptHandler Expr Expression 1 ExtSlice 2 FloorDiv For FormattedValue FunctionDef GeneratorExp Global Gt GtE If IfExp Import ImportFrom In Index 2 Interactive 3 Invert Is IsNot JoinedStr keyword Lambda List ListComp Load LShift Lt LtE Match MatchAs match_case MatchClass MatchMapping MatchOr MatchSequence MatchSingleton MatchStar MatchValue MatMult Mod Module 3 Mult Name NameConstant 1 NamedExpr Nonlocal Not NotEq NotIn Num 1 Or Pass pattern 3 Pow Print 4 Raise Return RShift Set SetComp Slice Starred Store Str 1 Sub Subscript Try TryExcept 5 TryFinally 6 Tuple UAdd UnaryOp USub While With withitem Yield YieldFrom Deprecated since Python 3.8. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Deprecated since Python 3.9. \u21a9 \u21a9 Not documented. \u21a9 \u21a9 \u21a9 print became a builtin (instead of a keyword) in Python 3. \u21a9 Now ExceptHandler , in the handlers attribute of Try nodes. \u21a9 Now a list of expressions in the finalbody attribute of Try nodes. \u21a9","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#on-the-command-line","text":"Pass the names of packages to the griffe command: $ griffe httpx fastapi [ { \"name\": \"httpx\", ... } ] It will output a JSON-serialized version of the packages signatures. Try it out on Griffe itself: $ griffe griffe [ { \"name\": \"griffe\", ... } ] By default, Griffe will search in sys.path , so if you installed it through pipx , there are few chances it will find your packages. To explicitely specify search paths, use the -s, --search <PATH> option. You can use it multiple times. You can also add the search paths to the PYTHONPATH environment variable. If Griffe can't find the packages, it will fail with a ModuleNotFoundError .","title":"On the command line"},{"location":"usage/#with-python","text":"Create a loader to load modules data, recursively: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) If you don't want to recurse in the submodules: fastapi = griffe . load_module ( \"fastapi\" , submodules = False )","title":"With Python"},{"location":"usage/#extensions","text":"You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import VisitorExtension , Extensions , When # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( VisitorExtension ): when = When . after_all def visit_classdef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions ( TheirExtension , ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) Extensions are subclasses of a custom version of ast.NodeVisitor . Griffe uses a node visitor as well, that we will call the main visitor . The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.). Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the visit_<NODE_TYPE_LOWER> methods to visit nodes of certain types, and act on their properties. Important note Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not call the .generic_visit(node) method in your .visit_* methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children (what the generic_visit does). You can access the main visitor state and data through the .visitor attribute, and the nodes instances are extended with additional attributes and properties: class MyExtension ( Extension ): def visit_functiondef ( self , node ) -> None : node . parent # the parent node node . children # the list of children nodes node . siblings # all the siblings nodes, from top to bottom node . previous_siblings # only the previous siblings, from closest to top node . next_siblings # only the next siblings, from closest to bottom node . previous # first previous sibling node . next # first next sibling self . visitor # the main visitor self . visitor . current # the current data object self . visitor . current . kind # the kind of object: module, class, function, attribute See the data classes ( Module , Class , Function and Attribute ) for a complete description of their methods and attributes. Extensions are run at certain moments while walking the Abstract Syntax Tree (AST): before the visit/inspection: When.before_all . The current node has been grafted to its parent. If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is not yet instantiated. before the children visit/inspection: When.before_children . If this node represents a data object, the object ( self.visitor.current / self.inspector.current ) is now instantiated. Children have not yet been visited/inspected. after the children visit/inspection: When.after_children . Children have now been visited/inspected. after the visit/inspection: When.after_all See the When enumeration . To tell the main visitor to run your extension at a certain time, set its when attribute: class MyExtension ( Extension ): when = When . after_children By default, it will run the extension after the visit/inspection of the node: that's when the full data for this node and its children is loaded.","title":"Extensions"},{"location":"usage/#ast-nodes","text":"Nodes Add alias And AnnAssign arg arguments Assert Assign AsyncFor AsyncFunctionDef AsyncWith Attribute AugAssign Await BinOp BitAnd BitOr BitXor BoolOp Break Bytes 1 Call ClassDef Compare comprehension Constant Continue Del Delete Dict DictComp Div Ellipsis 1 Eq ExceptHandler Expr Expression 1 ExtSlice 2 FloorDiv For FormattedValue FunctionDef GeneratorExp Global Gt GtE If IfExp Import ImportFrom In Index 2 Interactive 3 Invert Is IsNot JoinedStr keyword Lambda List ListComp Load LShift Lt LtE Match MatchAs match_case MatchClass MatchMapping MatchOr MatchSequence MatchSingleton MatchStar MatchValue MatMult Mod Module 3 Mult Name NameConstant 1 NamedExpr Nonlocal Not NotEq NotIn Num 1 Or Pass pattern 3 Pow Print 4 Raise Return RShift Set SetComp Slice Starred Store Str 1 Sub Subscript Try TryExcept 5 TryFinally 6 Tuple UAdd UnaryOp USub While With withitem Yield YieldFrom Deprecated since Python 3.8. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Deprecated since Python 3.9. \u21a9 \u21a9 Not documented. \u21a9 \u21a9 \u21a9 print became a builtin (instead of a keyword) in Python 3. \u21a9 Now ExceptHandler , in the handlers attribute of Try nodes. \u21a9 Now a list of expressions in the finalbody attribute of Try nodes. \u21a9","title":"AST nodes"},{"location":"reference/SUMMARY/","text":"griffe agents base extensions hybrid inspector nodes visitor cli collections dataclasses docstrings dataclasses google markdown numpy parsers rst utils encoders exceptions expressions importer loader logger mixins","title":"SUMMARY"},{"location":"reference/griffe/","text":"griffe package. Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.","title":"griffe"},{"location":"reference/griffe/cli/","text":"Module that contains the command line application. _level_choices = ( 'DEBUG' , 'INFO' , 'WARNING' , 'ERROR' , 'CRITICAL' ) \u00a4 logger = get_logger ( __name__ ) \u00a4 _load_packages ( packages , extensions , search_paths , docstring_parser , docstring_options , resolve_aliases = True , only_exported = True , only_known_modules = True ) \u00a4 Source code in griffe/cli.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def _load_packages ( packages : Sequence [ str ], extensions : Extensions | None , search_paths : Sequence [ str ], docstring_parser : Parser | None , docstring_options : dict [ str , Any ], resolve_aliases : bool = True , only_exported : bool = True , only_known_modules : bool = True , ): loader = GriffeLoader ( extensions = extensions , docstring_parser = docstring_parser , docstring_options = docstring_options , ) for package in packages : logger . info ( f \"Loading package { package } \" ) try : loader . load_module ( package , search_paths = search_paths ) except ModuleNotFoundError as error : logger . error ( f \"Could not find package { package } : { error } \" ) except ImportError as error : logger . error ( f \"Tried but could not import package { package } : { error } \" ) if resolve_aliases : unresolved , iterations = loader . resolve_aliases ( only_exported , only_known_modules ) if unresolved : logger . info ( f \" { len ( unresolved ) } aliases were still unresolved after { iterations } iterations\" ) else : logger . info ( f \"All aliases were resolved after { iterations } iterations\" ) return loader . modules_collection . members _print_data ( data , output_file ) \u00a4 Source code in griffe/cli.py 35 36 37 38 39 40 def _print_data ( data : str , output_file : str ): if output_file is sys . stdout : print ( data ) else : with open ( output_file , \"w\" ) as fd : print ( data , file = fd ) get_parser () \u00a4 Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async-loader\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-a\" , \"--append-sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-d\" , \"--docstyle\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) parser . add_argument ( \"-D\" , \"--docopts\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) parser . add_argument ( \"-e\" , \"--extensions\" , default = {}, type = json . loads , help = \"A list of extensions to use.\" , ) parser . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-L\" , \"--log-level\" , metavar = \"LEVEL\" , default = os . getenv ( \"GRIFFE_LOG_LEVEL\" , \"INFO\" ) . upper (), choices = _level_choices , type = str . upper , help = \"Set the log level: DEBUG, INFO, WARNING, ERROR, CRITICAL.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {{package}}.\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser main ( args = None ) \u00a4 Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\"Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) try : level = getattr ( logging , opts . log_level ) except AttributeError : choices = \"', '\" . join ( _level_choices ) print ( f \"griffe: error: env var GRIFFE_LOG_LEVEL: invalid level ' { opts . log_level } ' (choose from ' { choices } ')\" , file = sys . stderr , ) sys . exit ( 1 ) logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = level ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . append_sys_path : search . extend ( sys . path ) try : extensions = load_extensions ( opts . extensions ) except ExtensionError as error : print ( f \"griffe: error: { error } \" , file = sys . stderr ) return 1 packages = _load_packages ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output ) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"cli"},{"location":"reference/griffe/cli/#griffe.cli._level_choices","text":"","title":"_level_choices"},{"location":"reference/griffe/cli/#griffe.cli.logger","text":"","title":"logger"},{"location":"reference/griffe/cli/#griffe.cli._load_packages","text":"Source code in griffe/cli.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def _load_packages ( packages : Sequence [ str ], extensions : Extensions | None , search_paths : Sequence [ str ], docstring_parser : Parser | None , docstring_options : dict [ str , Any ], resolve_aliases : bool = True , only_exported : bool = True , only_known_modules : bool = True , ): loader = GriffeLoader ( extensions = extensions , docstring_parser = docstring_parser , docstring_options = docstring_options , ) for package in packages : logger . info ( f \"Loading package { package } \" ) try : loader . load_module ( package , search_paths = search_paths ) except ModuleNotFoundError as error : logger . error ( f \"Could not find package { package } : { error } \" ) except ImportError as error : logger . error ( f \"Tried but could not import package { package } : { error } \" ) if resolve_aliases : unresolved , iterations = loader . resolve_aliases ( only_exported , only_known_modules ) if unresolved : logger . info ( f \" { len ( unresolved ) } aliases were still unresolved after { iterations } iterations\" ) else : logger . info ( f \"All aliases were resolved after { iterations } iterations\" ) return loader . modules_collection . members","title":"_load_packages()"},{"location":"reference/griffe/cli/#griffe.cli._print_data","text":"Source code in griffe/cli.py 35 36 37 38 39 40 def _print_data ( data : str , output_file : str ): if output_file is sys . stdout : print ( data ) else : with open ( output_file , \"w\" ) as fd : print ( data , file = fd )","title":"_print_data()"},{"location":"reference/griffe/cli/#griffe.cli.get_parser","text":"Return the program argument parser. Returns: argparse . ArgumentParser \u2013 The argument parser for the program. Source code in griffe/cli.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" , add_help = False ) parser . add_argument ( \"-A\" , \"--async-loader\" , action = \"store_true\" , help = \"Whether to read files on disk asynchronously. \" \"Very large projects with many files will be processed faster. \" \"Small projects with a few files will not see any speed up.\" , ) parser . add_argument ( \"-a\" , \"--append-sys-path\" , action = \"store_true\" , help = \"Whether to append sys.path to search paths specified with -s.\" , ) parser . add_argument ( \"-d\" , \"--docstyle\" , default = None , type = Parser , help = \"The docstring style to parse.\" , ) parser . add_argument ( \"-D\" , \"--docopts\" , default = {}, type = json . loads , help = \"The options for the docstring parser.\" , ) parser . add_argument ( \"-e\" , \"--extensions\" , default = {}, type = json . loads , help = \"A list of extensions to use.\" , ) parser . add_argument ( \"-f\" , \"--full\" , action = \"store_true\" , default = False , help = \"Whether to dump full data in JSON.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"Show this help message and exit.\" , ) parser . add_argument ( \"-L\" , \"--log-level\" , metavar = \"LEVEL\" , default = os . getenv ( \"GRIFFE_LOG_LEVEL\" , \"INFO\" ) . upper (), choices = _level_choices , type = str . upper , help = \"Set the log level: DEBUG, INFO, WARNING, ERROR, CRITICAL.\" , ) parser . add_argument ( \"-o\" , \"--output\" , default = sys . stdout , help = \"Output file. Supports templating to output each package in its own file, with {{package}}.\" , ) parser . add_argument ( \"-s\" , \"--search\" , action = \"append\" , type = Path , help = \"Paths to search packages into.\" , ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser","title":"get_parser()"},{"location":"reference/griffe/cli/#griffe.cli.main","text":"Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: args ( list [ str ] | None ) \u2013 Arguments passed from the command line. Returns: int \u2013 An exit code. Source code in griffe/cli.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def main ( args : list [ str ] | None = None ) -> int : # noqa: WPS231 \"\"\"Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Parameters: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) try : level = getattr ( logging , opts . log_level ) except AttributeError : choices = \"', '\" . join ( _level_choices ) print ( f \"griffe: error: env var GRIFFE_LOG_LEVEL: invalid level ' { opts . log_level } ' (choose from ' { choices } ')\" , file = sys . stderr , ) sys . exit ( 1 ) logging . basicConfig ( format = \" %(levelname)-10s %(message)s \" , level = level ) # noqa: WPS323 output = opts . output per_package_output = False if isinstance ( output , str ) and output . format ( package = \"package\" ) != output : per_package_output = True search = opts . search if opts . append_sys_path : search . extend ( sys . path ) try : extensions = load_extensions ( opts . extensions ) except ExtensionError as error : print ( f \"griffe: error: { error } \" , file = sys . stderr ) return 1 packages = _load_packages ( opts . packages , extensions , search , opts . docstyle , opts . docopts ) if per_package_output : for package_name , data in packages . items (): serialized = json . dumps ( data , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output . format ( package = package_name )) else : serialized = json . dumps ( packages , cls = Encoder , indent = 2 , full = opts . full ) _print_data ( serialized , output ) return 0 if len ( packages ) == len ( opts . packages ) else 1","title":"main()"},{"location":"reference/griffe/collections/","text":"This module stores collections of data, useful during parsing. LinesCollection \u00a4 A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class LinesCollection : \"\"\"A simple dictionary containing the modules source code lines.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {} def __getitem__ ( self , key : Path ) -> list [ str ]: return self . _data [ key ] def __setitem__ ( self , key : Path , value : list [ str ]) -> None : self . _data [ key ] = value def __bool__ ( self ): return True # TODO: remove once Python 3.7 support is dropped @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table _data : dict [ Path , list [ str ]] = {} \u00a4 __bool__ ( self ) \u00a4 Source code in griffe/collections.py 31 32 def __bool__ ( self ): return True __getitem__ ( self , key ) \u00a4 Source code in griffe/collections.py 25 26 def __getitem__ ( self , key : Path ) -> list [ str ]: return self . _data [ key ] __init__ ( self ) \u00a4 Initialize the collection. Source code in griffe/collections.py 21 22 23 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {} __setitem__ ( self , key , value ) \u00a4 Source code in griffe/collections.py 28 29 def __setitem__ ( self , key : Path , value : list [ str ]) -> None : self . _data [ key ] = value tokens ( self , path ) \u00a4 Tokenize the code. Parameters: path ( Path ) \u2013 The filepath to get the tokens of. Returns: tuple [ list [ tokenize . TokenInfo ], defaultdict ] \u2013 A token list and a mapping of tokens by line number. Source code in griffe/collections.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table ModulesCollection ( GetMembersMixin , SetCollectionMembersMixin ) \u00a4 A collection of modules, allowing easy access to members. Source code in griffe/collections.py 53 54 55 56 57 58 59 60 61 62 63 64 class ModulesCollection ( GetMembersMixin , SetCollectionMembersMixin ): \"\"\"A collection of modules, allowing easy access to members.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {} def __bool__ ( self ): return True def __contains__ ( self , item : Any ) -> bool : return item in self . members members : dict [ str , Module ] = {} \u00a4 __bool__ ( self ) \u00a4 Source code in griffe/collections.py 60 61 def __bool__ ( self ): return True __contains__ ( self , item ) \u00a4 Source code in griffe/collections.py 63 64 def __contains__ ( self , item : Any ) -> bool : return item in self . members __init__ ( self ) \u00a4 Initialize the collection. Source code in griffe/collections.py 56 57 58 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"collections"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection","text":"A simple dictionary containing the modules source code lines. Source code in griffe/collections.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class LinesCollection : \"\"\"A simple dictionary containing the modules source code lines.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {} def __getitem__ ( self , key : Path ) -> list [ str ]: return self . _data [ key ] def __setitem__ ( self , key : Path , value : list [ str ]) -> None : self . _data [ key ] = value def __bool__ ( self ): return True # TODO: remove once Python 3.7 support is dropped @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table","title":"LinesCollection"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection._data","text":"","title":"_data"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.__bool__","text":"Source code in griffe/collections.py 31 32 def __bool__ ( self ): return True","title":"__bool__()"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.__getitem__","text":"Source code in griffe/collections.py 25 26 def __getitem__ ( self , key : Path ) -> list [ str ]: return self . _data [ key ]","title":"__getitem__()"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.__init__","text":"Initialize the collection. Source code in griffe/collections.py 21 22 23 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . _data : dict [ Path , list [ str ]] = {}","title":"__init__()"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.__setitem__","text":"Source code in griffe/collections.py 28 29 def __setitem__ ( self , key : Path , value : list [ str ]) -> None : self . _data [ key ] = value","title":"__setitem__()"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.tokens","text":"Tokenize the code. Parameters: path ( Path ) \u2013 The filepath to get the tokens of. Returns: tuple [ list [ tokenize . TokenInfo ], defaultdict ] \u2013 A token list and a mapping of tokens by line number. Source code in griffe/collections.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @lru_cache ( maxsize = None ) def tokens ( self , path : Path ) -> tuple [ list [ tokenize . TokenInfo ], defaultdict ]: \"\"\"Tokenize the code. Parameters: path: The filepath to get the tokens of. Returns: A token list and a mapping of tokens by line number. \"\"\" readline = BytesIO ( \" \\n \" . join ( self [ path ]) . encode ()) . readline tokens = list ( tokenize . tokenize ( readline )) token_table = defaultdict ( list ) # mapping line numbers to token numbers for index , token in enumerate ( tokens ): token_table [ token . start [ 0 ]] . append ( index ) return tokens , token_table","title":"tokens()"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection","text":"A collection of modules, allowing easy access to members. Source code in griffe/collections.py 53 54 55 56 57 58 59 60 61 62 63 64 class ModulesCollection ( GetMembersMixin , SetCollectionMembersMixin ): \"\"\"A collection of modules, allowing easy access to members.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {} def __bool__ ( self ): return True def __contains__ ( self , item : Any ) -> bool : return item in self . members","title":"ModulesCollection"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.members","text":"","title":"members"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.__bool__","text":"Source code in griffe/collections.py 60 61 def __bool__ ( self ): return True","title":"__bool__()"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.__contains__","text":"Source code in griffe/collections.py 63 64 def __contains__ ( self , item : Any ) -> bool : return item in self . members","title":"__contains__()"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.__init__","text":"Initialize the collection. Source code in griffe/collections.py 56 57 58 def __init__ ( self ) -> None : \"\"\"Initialize the collection.\"\"\" self . members : dict [ str , Module ] = {}","title":"__init__()"},{"location":"reference/griffe/dataclasses/","text":"This module contains the data classes that represent Python objects. The different objects are modules, classes, functions, and attribute (variables like module/class/instance attributes). Alias ( ObjectAliasMixin ) \u00a4 This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent \u2013 The alias parent. Source code in griffe/dataclasses.py 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 class Alias ( ObjectAliasMixin ): \"\"\"This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: - line numbers are those of the alias, not the target - the path is the alias path, not the canonical one - the name can be different from the target's - if the target can be resolved, the kind is the target's kind - if the target cannot be resolved, the kind becomes [Kind.ALIAS][griffe.dataclasses.Kind] Attributes: name: The alias name. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" is_alias : bool = True def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path if parent is not None : with suppress ( AliasResolutionError ): target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent self . _passed_through : bool = False def __getattr__ ( self , name : str ) -> Any : # forward everything to the target if self . _passed_through : raise CyclicAliasError ([ self . _target_path ]) self . _passed_through = True try : attr = getattr ( self . target , name ) except CyclicAliasError as error : raise CyclicAliasError ([ self . _target_path ] + error . chain ) finally : self . _passed_through = False return attr def __getitem__ ( self , key ): # not handled by __getattr__ return self . target [ key ] def __setitem__ ( self , key , value ): # not handled by __getattr__ self . target [ key ] = value @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS @property def parent ( self ) -> Module | Class | None : \"\"\"Return the parent of this alias. Returns: The parent. \"\"\" return self . _parent @parent . setter def parent ( self , value : Module | Class ) -> None : self . _parent = value if self . resolved : with suppress ( AliasResolutionError ): self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just checked the target is not None @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent @property def target ( self ) -> Object | Alias : \"\"\"Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: The resolved target. \"\"\" if not self . resolved : self . resolve_target () return self . _target # type: ignore[return-value] # cannot return None, exception is raised @target . setter def target ( self , value : Object | Alias ) -> None : self . _target = value if self . parent is not None : self . _target . aliases [ self . path ] = self def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None @cached_property def wildcard ( self ) -> str | None : \"\"\"Return the module on which the wildcard import is performed (if any). Returns: The wildcard imported module, or None. \"\"\" if self . name . endswith ( \"/*\" ): return self . _target_path return None def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base _parent : Module | Class | None = parent \u00a4 _passed_through : bool = False \u00a4 _target = target \u00a4 _target_path = target . path \u00a4 endlineno : int | None = endlineno \u00a4 is_alias : bool = True \u00a4 lineno : int | None = lineno \u00a4 name : str = name \u00a4 __getattr__ ( self , name ) \u00a4 Source code in griffe/dataclasses.py 721 722 723 724 725 726 727 728 729 730 731 732 def __getattr__ ( self , name : str ) -> Any : # forward everything to the target if self . _passed_through : raise CyclicAliasError ([ self . _target_path ]) self . _passed_through = True try : attr = getattr ( self . target , name ) except CyclicAliasError as error : raise CyclicAliasError ([ self . _target_path ] + error . chain ) finally : self . _passed_through = False return attr __getitem__ ( self , key ) \u00a4 Source code in griffe/dataclasses.py 734 735 736 def __getitem__ ( self , key ): # not handled by __getattr__ return self . target [ key ] __init__ ( self , name , target , * , lineno = None , endlineno = None , parent = None ) \u00a4 Initialize the alias. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path if parent is not None : with suppress ( AliasResolutionError ): target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent self . _passed_through : bool = False __setitem__ ( self , key , value ) \u00a4 Source code in griffe/dataclasses.py 738 739 740 def __setitem__ ( self , key , value ): # not handled by __getattr__ self . target [ key ] = value as_dict ( self , full = False , ** kwargs ) \u00a4 Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base kind ( self ) \u00a4 Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind. Source code in griffe/dataclasses.py 742 743 744 745 746 747 748 749 750 751 752 753 @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS modules_collection ( self ) \u00a4 Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 780 781 782 783 784 785 786 787 788 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent parent ( self , value ) \u00a4 Source code in griffe/dataclasses.py 764 765 766 767 768 769 @parent . setter def parent ( self , value : Module | Class ) -> None : self . _parent = value if self . resolved : with suppress ( AliasResolutionError ): self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just checked the target is not None path ( self ) \u00a4 Return the dotted path / import path of this object. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 771 772 773 774 775 776 777 778 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent resolve_target ( self ) \u00a4 Resolve the target. Raises: AliasResolutionError \u2013 When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. Source code in griffe/dataclasses.py 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target resolved ( self ) \u00a4 Tell whether this alias' target is resolved. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 827 828 829 830 831 832 833 834 @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None target ( self , value ) \u00a4 Source code in griffe/dataclasses.py 804 805 806 807 808 @target . setter def target ( self , value : Object | Alias ) -> None : self . _target = value if self . parent is not None : self . _target . aliases [ self . path ] = self wildcard ( self ) \u00a4 Return the module on which the wildcard import is performed (if any). Returns: str | None \u2013 The wildcard imported module, or None. Source code in griffe/dataclasses.py 836 837 838 839 840 841 842 843 844 845 @cached_property def wildcard ( self ) -> str | None : \"\"\"Return the module on which the wildcard import is performed (if any). Returns: The wildcard imported module, or None. \"\"\" if self . name . endswith ( \"/*\" ): return self . _target_path return None Attribute ( Object ) \u00a4 The class representing a Python module/class/instance attribute. Source code in griffe/dataclasses.py 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 class Attribute ( Object ): \"\"\"The class representing a Python module/class/instance attribute.\"\"\" kind = Kind . ATTRIBUTE def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base annotation : str | Name | Expression | None = annotation \u00a4 kind = Kind . ATTRIBUTE \u00a4 value : str | None = value \u00a4 __init__ ( self , * args , value = None , annotation = None , ** kwargs ) \u00a4 Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base Class ( Object ) \u00a4 The class representing a Python class. Source code in griffe/dataclasses.py 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 class Class ( Object ): \"\"\"The class representing a Python class.\"\"\" kind = Kind . CLASS def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base bases : list [ Name | Expression | str ] = bases or [] \u00a4 decorators : list [ Decorator ] = decorators or [] \u00a4 kind = Kind . CLASS \u00a4 __init__ ( self , * args , bases = None , decorators = None , ** kwargs ) \u00a4 Initialize the class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression | str ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] as_dict ( self , ** kwargs ) \u00a4 Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base Decorator \u00a4 This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Decorator : \"\"\"This class represents decorators. Attributes: lineno: The starting line number. endlineno: The ending line number. \"\"\" def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } endlineno : int | None = endlineno \u00a4 lineno : int | None = lineno \u00a4 __init__ ( self , lineno , endlineno ) \u00a4 Initialize the decorator. Parameters: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 57 58 59 60 61 62 63 64 65 def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno as_dict ( self , ** kwargs ) \u00a4 Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } Docstring \u00a4 This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. Source code in griffe/dataclasses.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Docstring : \"\"\"This class represents docstrings. Attributes: value: The actual documentation string, cleaned up. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. \"\"\" def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} def __bool__ ( self ): return bool ( self . value ) @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base endlineno : int | None = endlineno \u00a4 lineno : int | None = lineno \u00a4 parent : Object | None = parent \u00a4 parser : Parser | None = parser \u00a4 parser_options : dict [ str , Any ] = parser_options or {} \u00a4 value : str = inspect . cleandoc ( value ) \u00a4 __bool__ ( self ) \u00a4 Source code in griffe/dataclasses.py 119 120 def __bool__ ( self ): return bool ( self . value ) __init__ ( self , value , * , lineno = None , endlineno = None , parent = None , parser = None , parser_options = None ) \u00a4 Initialize the docstring. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} as_dict ( self , full = False , docstring_parser = None , ** kwargs ) \u00a4 Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base lines ( self ) \u00a4 Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines. Source code in griffe/dataclasses.py 122 123 124 125 126 127 128 129 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) parse ( self , parser = None , ** options ) \u00a4 Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 140 141 142 143 144 145 146 147 148 149 150 151 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) parsed ( self ) \u00a4 Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 131 132 133 134 135 136 137 138 @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () Function ( Object ) \u00a4 The class representing a Python function. Source code in griffe/dataclasses.py 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 class Function ( Object ): \"\"\"The class representing a Python function.\"\"\" kind = Kind . FUNCTION def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base decorators : list [ Decorator ] = decorators or [] \u00a4 kind = Kind . FUNCTION \u00a4 parameters : Parameters = parameters or Parameters () \u00a4 returns : str | Name | Expression | None = returns \u00a4 __init__ ( self , * args , parameters = None , returns = None , decorators = None , ** kwargs ) \u00a4 Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] as_dict ( self , ** kwargs ) \u00a4 Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base Kind ( enum . Enum ) \u00a4 Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind. Source code in griffe/dataclasses.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class Kind ( enum . Enum ): \"\"\"Enumeration of the different objects kinds. Attributes: MODULE: The module kind. CLASS: The class kind. FUNCTION: The function kind. ATTRIBUTE: The attribute kind. \"\"\" MODULE : str = \"module\" CLASS : str = \"class\" FUNCTION : str = \"function\" ATTRIBUTE : str = \"attribute\" ALIAS : str = \"alias\" ALIAS : str = 'alias' \u00a4 ATTRIBUTE : str = 'attribute' \u00a4 CLASS : str = 'class' \u00a4 FUNCTION : str = 'function' \u00a4 MODULE : str = 'module' \u00a4 Module ( Object ) \u00a4 The class representing a Python module. Source code in griffe/dataclasses.py 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 class Module ( Object ): \"\"\"The class representing a Python module.\"\"\" kind = Kind . MODULE def __init__ ( self , * args : Any , filepath : Path | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | None = filepath def __repr__ ( self ) -> str : try : return f \"<Module( { self . filepath !r} )>\" except BuiltinModuleError : return f \"<Module( { self . name !r} )>\" @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" try : return self . filepath . name == \"__init__.py\" except BuiltinModuleError : return False @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return self . parent is None and self . filepath . is_dir () except BuiltinModuleError : return False @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and self . filepath . is_dir () and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base _filepath : Path | None = filepath \u00a4 kind = Kind . MODULE \u00a4 __init__ ( self , * args , filepath = None , ** kwargs ) \u00a4 Initialize the module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path | None ) \u2013 The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 879 880 881 882 883 884 885 886 887 888 def __init__ ( self , * args : Any , filepath : Path | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | None = filepath __repr__ ( self ) \u00a4 Source code in griffe/dataclasses.py 890 891 892 893 894 def __repr__ ( self ) -> str : try : return f \"<Module( { self . filepath !r} )>\" except BuiltinModuleError : return f \"<Module( { self . name !r} )>\" as_dict ( self , ** kwargs ) \u00a4 Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 970 971 972 973 974 975 976 977 978 979 980 981 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base filepath ( self ) \u00a4 Get the file path of this module. Raises: BuiltinModuleError \u2013 When the instance filepath is None. Returns: Path \u2013 The module's file path. Source code in griffe/dataclasses.py 896 897 898 899 900 901 902 903 904 905 906 907 908 @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath is_init_module ( self ) \u00a4 Tell if this module is an __init__.py module. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 910 911 912 913 914 915 916 917 918 919 920 @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" try : return self . filepath . name == \"__init__.py\" except BuiltinModuleError : return False is_namespace_package ( self ) \u00a4 Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 940 941 942 943 944 945 946 947 948 949 950 @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return self . parent is None and self . filepath . is_dir () except BuiltinModuleError : return False is_namespace_subpackage ( self ) \u00a4 Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and self . filepath . is_dir () and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False is_package ( self ) \u00a4 Tell if this module is a package (top module). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 922 923 924 925 926 927 928 929 @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module is_subpackage ( self ) \u00a4 Tell if this module is a subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 931 932 933 934 935 936 937 938 @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module Object ( GetMembersMixin , SetMembersMixin , ObjectAliasMixin ) \u00a4 An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Source code in griffe/dataclasses.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 class Object ( GetMembersMixin , SetMembersMixin , ObjectAliasMixin ): \"\"\"An abstract class representing a Python object. Attributes: kind: The object kind. name: The object name. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent, or None if it is the top module. members: The object members. labels: The object labels. \"\"\" kind : Kind is_alias : bool = False def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self def __repr__ ( self ) -> str : return f \"< { self . __class__ . __name__ } ( { self . name !r} , { self . lineno !r} , { self . endlineno !r} )>\" @property def has_docstring ( self ) -> bool : \"\"\"Tell if this object has a non-empty docstring.\"\"\" return bool ( self . docstring ) # noqa: DAR201 @property def has_docstrings ( self ) -> bool : \"\"\"Tell if this object or any of its members has a non-empty docstring.\"\"\" return self . has_docstring or any ( member . has_docstrings for member in self . members . values ()) # noqa: DAR201 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc] @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc] @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc] @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc] @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if self . parent is None : return self . name return \".\" . join (( self . parent . path , self . name )) @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno if self . lineno is None or self . endlineno is None : return self . lines_collection [ filepath ] return self . lines_collection [ filepath ][ self . lineno - 1 : self . endlineno ] @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base # TODO: remove once Python 3.7 support is dropped @property def _endlineno ( self ) -> int : if self . kind is Kind . MODULE : return len ( self . lines_collection [ self . filepath ]) tokens , tokens_by_line = self . lines_collection . tokens ( self . filepath ) first_token_index = tokens_by_line [ self . lineno ][ 0 ] blockfinder = inspect . BlockFinder () with suppress ( inspect . EndOfBlock , IndentationError ): for token in tokens [ first_token_index :]: blockfinder . tokeneater ( * token ) return blockfinder . last _lines_collection : LinesCollection | None = lines_collection \u00a4 _modules_collection : ModulesCollection | None = modules_collection \u00a4 aliases : dict [ str , Alias ] = {} \u00a4 docstring : Docstring | None = docstring \u00a4 endlineno : int | None = endlineno \u00a4 exports : set [ str ] | None = None \u00a4 imports : dict [ str , str ] = {} \u00a4 is_alias : bool = False \u00a4 kind : Kind = None \u00a4 labels : set [ str ] = set () \u00a4 lineno : int | None = lineno \u00a4 members : dict [ str , Object | Alias ] = {} \u00a4 name : str = name \u00a4 parent : Module | Class | None = parent \u00a4 __init__ ( self , name , * , lineno = None , endlineno = None , docstring = None , parent = None , lines_collection = None , modules_collection = None ) \u00a4 Initialize the object. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self __repr__ ( self ) \u00a4 Source code in griffe/dataclasses.py 339 340 def __repr__ ( self ) -> str : return f \"< { self . __class__ . __name__ } ( { self . name !r} , { self . lineno !r} , { self . endlineno !r} )>\" _endlineno ( self ) \u00a4 Source code in griffe/dataclasses.py 651 652 653 654 655 656 657 658 659 660 661 @property def _endlineno ( self ) -> int : if self . kind is Kind . MODULE : return len ( self . lines_collection [ self . filepath ]) tokens , tokens_by_line = self . lines_collection . tokens ( self . filepath ) first_token_index = tokens_by_line [ self . lineno ][ 0 ] blockfinder = inspect . BlockFinder () with suppress ( inspect . EndOfBlock , IndentationError ): for token in tokens [ first_token_index :]: blockfinder . tokeneater ( * token ) return blockfinder . last as_dict ( self , full = False , ** kwargs ) \u00a4 Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base attributes ( self ) \u00a4 Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes. Source code in griffe/dataclasses.py 445 446 447 448 449 450 451 452 @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc] canonical_path ( self ) \u00a4 Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 516 517 518 519 520 521 522 523 524 525 526 527 @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if self . parent is None : return self . name return \".\" . join (( self . parent . path , self . name )) classes ( self ) \u00a4 Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes. Source code in griffe/dataclasses.py 427 428 429 430 431 432 433 434 @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc] filepath ( self ) \u00a4 Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 482 483 484 485 486 487 488 489 490 491 492 493 494 @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath filter_members ( self , * predicates ) \u00a4 Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members functions ( self ) \u00a4 Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions. Source code in griffe/dataclasses.py 436 437 438 439 440 441 442 443 @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc] has_docstring ( self ) \u00a4 Tell if this object has a non-empty docstring. Source code in griffe/dataclasses.py 342 343 344 345 @property def has_docstring ( self ) -> bool : \"\"\"Tell if this object has a non-empty docstring.\"\"\" return bool ( self . docstring ) # noqa: DAR201 has_docstrings ( self ) \u00a4 Tell if this object or any of its members has a non-empty docstring. Source code in griffe/dataclasses.py 347 348 349 350 @property def has_docstrings ( self ) -> bool : \"\"\"Tell if this object or any of its members has a non-empty docstring.\"\"\" return self . has_docstring or any ( member . has_docstrings for member in self . members . values ()) # noqa: DAR201 has_labels ( self , labels ) \u00a4 Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 390 391 392 393 394 395 396 397 398 399 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) is_kind ( self , kind ) \u00a4 Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Raises: ValueError \u2013 When an empty set is given as argument. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind lines ( self ) \u00a4 Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines. Source code in griffe/dataclasses.py 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno if self . lineno is None or self . endlineno is None : return self . lines_collection [ filepath ] return self . lines_collection [ filepath ][ self . lineno - 1 : self . endlineno ] lines_collection ( self ) \u00a4 Return the lines collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: LinesCollection \u2013 A lines collection. Source code in griffe/dataclasses.py 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection member_is_exported ( self , member , explicitely = True ) \u00a4 Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports module ( self ) \u00a4 Return the parent module of this object. Raises: ValueError \u2013 When the object is not a module and does not have a parent. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError modules ( self ) \u00a4 Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules. Source code in griffe/dataclasses.py 418 419 420 421 422 423 424 425 @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc] modules_collection ( self ) \u00a4 Return the modules collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection package ( self ) \u00a4 Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 470 471 472 473 474 475 476 477 478 479 480 @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module path ( self ) \u00a4 Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 505 506 507 508 509 510 511 512 513 514 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path relative_filepath ( self ) \u00a4 Return the file path where this object was defined, relative to the top module path. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 496 497 498 499 500 501 502 503 @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) resolve ( self , name ) \u00a4 Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Raises: NameResolutionError \u2013 When the name could not be resolved. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) source ( self ) \u00a4 Return the source code of this object. Returns: str \u2013 The source code. Source code in griffe/dataclasses.py 581 582 583 584 585 586 587 588 @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) Parameter \u00a4 This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class Parameter : \"\"\"This class represent a function parameter. Attributes: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , } annotation : str | Name | Expression | None = annotation \u00a4 default : str | None = default \u00a4 kind : ParameterKind | None = kind \u00a4 name : str = name \u00a4 __init__ ( self , name , * , annotation = None , kind = None , default = None ) \u00a4 Initialize the parameter. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default as_dict ( self , ** kwargs ) \u00a4 Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , } ParameterKind ( enum . Enum ) \u00a4 Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter. Source code in griffe/dataclasses.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ParameterKind ( enum . Enum ): \"\"\"Enumeration of the different parameter kinds. Attributes: positional_only: Positional-only parameter. positional_or_keyword: Positional or keyword parameter. var_positional: Variadic positional parameter. keyword_only: Keyword-only parameter. var_keyword: Variadic keyword parameter. \"\"\" positional_only : str = \"positional-only\" positional_or_keyword : str = \"positional or keyword\" var_positional : str = \"variadic positional\" keyword_only : str = \"keyword-only\" var_keyword : str = \"variadic keyword\" keyword_only : str = 'keyword-only' \u00a4 positional_only : str = 'positional-only' \u00a4 positional_or_keyword : str = 'positional or keyword' \u00a4 var_keyword : str = 'variadic keyword' \u00a4 var_positional : str = 'variadic positional' \u00a4 Parameters \u00a4 This class is a container for parameters. It allows to get parameters using their position (index) or their name. Source code in griffe/dataclasses.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class Parameters : \"\"\"This class is a container for parameters. It allows to get parameters using their position (index) or their name. \"\"\" def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) def __getitem__ ( self , name_or_index : int | str ) -> Parameter : if isinstance ( name_or_index , int ): return self . _parameters_list [ name_or_index ] return self . _parameters_dict [ name_or_index ] def __len__ ( self ): return len ( self . _parameters_list ) def __iter__ ( self ): return iter ( self . _parameters_list ) def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" ) _parameters_dict : dict [ str , Parameter ] = {} \u00a4 _parameters_list : list [ Parameter ] = [] \u00a4 __getitem__ ( self , name_or_index ) \u00a4 Source code in griffe/dataclasses.py 239 240 241 242 def __getitem__ ( self , name_or_index : int | str ) -> Parameter : if isinstance ( name_or_index , int ): return self . _parameters_list [ name_or_index ] return self . _parameters_dict [ name_or_index ] __init__ ( self , * parameters ) \u00a4 Initialize the parameters container. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 228 229 230 231 232 233 234 235 236 237 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) __iter__ ( self ) \u00a4 Source code in griffe/dataclasses.py 247 248 def __iter__ ( self ): return iter ( self . _parameters_list ) __len__ ( self ) \u00a4 Source code in griffe/dataclasses.py 244 245 def __len__ ( self ): return len ( self . _parameters_list ) add ( self , parameter ) \u00a4 Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Raises: ValueError \u2013 When a parameter with the same name is already present. Source code in griffe/dataclasses.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"dataclasses"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias","text":"This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: line numbers are those of the alias, not the target the path is the alias path, not the canonical one the name can be different from the target's if the target can be resolved, the kind is the target's kind if the target cannot be resolved, the kind becomes Kind.ALIAS Attributes: name ( str ) \u2013 The alias name. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent \u2013 The alias parent. Source code in griffe/dataclasses.py 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 class Alias ( ObjectAliasMixin ): \"\"\"This class represents an alias, or indirection, to an object declared in another module. Aliases represent objects that are in the scope of a module or class, but were imported from another module. They behave almost exactly like regular objects, to a few exceptions: - line numbers are those of the alias, not the target - the path is the alias path, not the canonical one - the name can be different from the target's - if the target can be resolved, the kind is the target's kind - if the target cannot be resolved, the kind becomes [Kind.ALIAS][griffe.dataclasses.Kind] Attributes: name: The alias name. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" is_alias : bool = True def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path if parent is not None : with suppress ( AliasResolutionError ): target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent self . _passed_through : bool = False def __getattr__ ( self , name : str ) -> Any : # forward everything to the target if self . _passed_through : raise CyclicAliasError ([ self . _target_path ]) self . _passed_through = True try : attr = getattr ( self . target , name ) except CyclicAliasError as error : raise CyclicAliasError ([ self . _target_path ] + error . chain ) finally : self . _passed_through = False return attr def __getitem__ ( self , key ): # not handled by __getattr__ return self . target [ key ] def __setitem__ ( self , key , value ): # not handled by __getattr__ self . target [ key ] = value @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS @property def parent ( self ) -> Module | Class | None : \"\"\"Return the parent of this alias. Returns: The parent. \"\"\" return self . _parent @parent . setter def parent ( self , value : Module | Class ) -> None : self . _parent = value if self . resolved : with suppress ( AliasResolutionError ): self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just checked the target is not None @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent @property def target ( self ) -> Object | Alias : \"\"\"Resolve and return the target, if possible. Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target. Returns: The resolved target. \"\"\" if not self . resolved : self . resolve_target () return self . _target # type: ignore[return-value] # cannot return None, exception is raised @target . setter def target ( self , value : Object | Alias ) -> None : self . _target = value if self . parent is not None : self . _target . aliases [ self . path ] = self def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None @cached_property def wildcard ( self ) -> str | None : \"\"\"Return the module on which the wildcard import is performed (if any). Returns: The wildcard imported module, or None. \"\"\" if self . name . endswith ( \"/*\" ): return self . _target_path return None def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base","title":"Alias"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias._parent","text":"","title":"_parent"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias._passed_through","text":"","title":"_passed_through"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias._target","text":"","title":"_target"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias._target_path","text":"","title":"_target_path"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.endlineno","text":"","title":"endlineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.is_alias","text":"","title":"is_alias"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.lineno","text":"","title":"lineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.name","text":"","title":"name"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.__getattr__","text":"Source code in griffe/dataclasses.py 721 722 723 724 725 726 727 728 729 730 731 732 def __getattr__ ( self , name : str ) -> Any : # forward everything to the target if self . _passed_through : raise CyclicAliasError ([ self . _target_path ]) self . _passed_through = True try : attr = getattr ( self . target , name ) except CyclicAliasError as error : raise CyclicAliasError ([ self . _target_path ] + error . chain ) finally : self . _passed_through = False return attr","title":"__getattr__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.__getitem__","text":"Source code in griffe/dataclasses.py 734 735 736 def __getitem__ ( self , key ): # not handled by __getattr__ return self . target [ key ]","title":"__getitem__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.__init__","text":"Initialize the alias. Parameters: name ( str ) \u2013 The alias name. target ( str | Object | Alias ) \u2013 If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno ( int | None ) \u2013 The alias starting line number. endlineno ( int | None ) \u2013 The alias ending line number. parent ( Module | Class | None ) \u2013 The alias parent. Source code in griffe/dataclasses.py 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 def __init__ ( self , name : str , target : str | Object | Alias , * , lineno : int | None = None , endlineno : int | None = None , parent : Module | Class | None = None , ) -> None : \"\"\"Initialize the alias. Parameters: name: The alias name. target: If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set. lineno: The alias starting line number. endlineno: The alias ending line number. parent: The alias parent. \"\"\" self . name : str = name if isinstance ( target , str ): self . _target : Object | Alias | None = None self . _target_path : str = target else : self . _target = target self . _target_path = target . path if parent is not None : with suppress ( AliasResolutionError ): target . aliases [ self . path ] = self self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . _parent : Module | Class | None = parent self . _passed_through : bool = False","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.__setitem__","text":"Source code in griffe/dataclasses.py 738 739 740 def __setitem__ ( self , key , value ): # not handled by __getattr__ self . target [ key ] = value","title":"__setitem__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.as_dict","text":"Return this alias' data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this alias' data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : Kind . ALIAS , \"name\" : self . name , \"target_path\" : self . _target_path , } if full : base [ \"path\" ] = self . path if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.kind","text":"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: Kind \u2013 A kind. Source code in griffe/dataclasses.py 742 743 744 745 746 747 748 749 750 751 752 753 @property def kind ( self ) -> Kind : \"\"\"Return the target's kind, or Kind.ALIAS if the target cannot be resolved. Returns: A kind. \"\"\" # custom behavior to avoid raising exceptions try : return self . target . kind except AliasResolutionError : return Kind . ALIAS","title":"kind()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.modules_collection","text":"Return the modules collection attached to the alias parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 780 781 782 783 784 785 786 787 788 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to the alias parents. Returns: A modules collection. \"\"\" # no need to forward to the target return self . parent . modules_collection # type: ignore[union-attr] # we assume there's always a parent","title":"modules_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.parent","text":"Source code in griffe/dataclasses.py 764 765 766 767 768 769 @parent . setter def parent ( self , value : Module | Class ) -> None : self . _parent = value if self . resolved : with suppress ( AliasResolutionError ): self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just checked the target is not None","title":"parent()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.path","text":"Return the dotted path / import path of this object. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 771 772 773 774 775 776 777 778 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path / import path of this object. Returns: A dotted path. \"\"\" return \".\" . join (( self . parent . path , self . name )) # type: ignore[union-attr] # we assume there's always a parent","title":"path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolve_target","text":"Resolve the target. Raises: AliasResolutionError \u2013 When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. Source code in griffe/dataclasses.py 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 def resolve_target ( self ) -> None : \"\"\"Resolve the target. Raises: AliasResolutionError: When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection. \"\"\" try : self . _target = self . modules_collection [ self . _target_path ] except KeyError as error : raise AliasResolutionError ( self . _target_path ) from error if self . parent is not None : self . _target . aliases [ self . path ] = self # type: ignore[union-attr] # we just set the target","title":"resolve_target()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolved","text":"Tell whether this alias' target is resolved. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 827 828 829 830 831 832 833 834 @property def resolved ( self ) -> bool : \"\"\"Tell whether this alias' target is resolved. Returns: True or False. \"\"\" return self . _target is not None","title":"resolved()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.target","text":"Source code in griffe/dataclasses.py 804 805 806 807 808 @target . setter def target ( self , value : Object | Alias ) -> None : self . _target = value if self . parent is not None : self . _target . aliases [ self . path ] = self","title":"target()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.wildcard","text":"Return the module on which the wildcard import is performed (if any). Returns: str | None \u2013 The wildcard imported module, or None. Source code in griffe/dataclasses.py 836 837 838 839 840 841 842 843 844 845 @cached_property def wildcard ( self ) -> str | None : \"\"\"Return the module on which the wildcard import is performed (if any). Returns: The wildcard imported module, or None. \"\"\" if self . name . endswith ( \"/*\" ): return self . _target_path return None","title":"wildcard()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute","text":"The class representing a Python module/class/instance attribute. Source code in griffe/dataclasses.py 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 class Attribute ( Object ): \"\"\"The class representing a Python module/class/instance attribute.\"\"\" kind = Kind . ATTRIBUTE def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base","title":"Attribute"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.annotation","text":"","title":"annotation"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.kind","text":"","title":"kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.value","text":"","title":"value"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.__init__","text":"Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . value ( str | None ) \u2013 The attribute value, if any. annotation ( str | Name | Expression | None ) \u2013 The attribute annotation, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 def __init__ ( self , * args : Any , value : str | None = None , annotation : str | Name | Expression | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. value: The attribute value, if any. annotation: The attribute annotation, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . value : str | None = value self . annotation : str | Name | Expression | None = annotation","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.as_dict","text":"Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) if self . value is not None : base [ \"value\" ] = self . value if self . annotation is not None : base [ \"annotation\" ] = self . annotation return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class","text":"The class representing a Python class. Source code in griffe/dataclasses.py 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 class Class ( Object ): \"\"\"The class representing a Python class.\"\"\" kind = Kind . CLASS def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base","title":"Class"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.bases","text":"","title":"bases"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.decorators","text":"","title":"decorators"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.kind","text":"","title":"kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.__init__","text":"Initialize the class. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . bases ( list [ Name | Expression | str ] | None ) \u2013 The list of base classes, if any. decorators ( list [ Decorator ] | None ) \u2013 The class decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 def __init__ ( self , * args : Any , bases : list [ Name | Expression | str ] | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the class. Parameters: *args: See [`griffe.dataclasses.Object`][]. bases: The list of base classes, if any. decorators: The class decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . bases : list [ Name | Expression | str ] = bases or [] self . decorators : list [ Decorator ] = decorators or []","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.as_dict","text":"Return this class' data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this class' data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"bases\" ] = self . bases base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator","text":"This class represents decorators. Attributes: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Decorator : \"\"\"This class represents decorators. Attributes: lineno: The starting line number. endlineno: The ending line number. \"\"\" def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , }","title":"Decorator"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.endlineno","text":"","title":"endlineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.lineno","text":"","title":"lineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.__init__","text":"Initialize the decorator. Parameters: lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. Source code in griffe/dataclasses.py 57 58 59 60 61 62 63 64 65 def __init__ ( self , lineno : int | None , endlineno : int | None ) -> None : \"\"\"Initialize the decorator. Parameters: lineno: The starting line number. endlineno: The ending line number. \"\"\" self . lineno : int | None = lineno self . endlineno : int | None = endlineno","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.as_dict","text":"Return this decorator's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this decorator's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring","text":"This class represents docstrings. Attributes: value ( str ) \u2013 The actual documentation string, cleaned up. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. Source code in griffe/dataclasses.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Docstring : \"\"\"This class represents docstrings. Attributes: value: The actual documentation string, cleaned up. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. \"\"\" def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {} def __bool__ ( self ): return bool ( self . value ) @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" ) @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse () def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options )) def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base","title":"Docstring"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.endlineno","text":"","title":"endlineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.lineno","text":"","title":"lineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parent","text":"","title":"parent"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parser","text":"","title":"parser"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parser_options","text":"","title":"parser_options"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.value","text":"","title":"value"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.__bool__","text":"Source code in griffe/dataclasses.py 119 120 def __bool__ ( self ): return bool ( self . value )","title":"__bool__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.__init__","text":"Initialize the docstring. Parameters: value ( str ) \u2013 The docstring value. lineno ( int | None ) \u2013 The starting line number. endlineno ( int | None ) \u2013 The ending line number. parent ( Object | None ) \u2013 The parent object on which this docstring is attached. parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. parser_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. Source code in griffe/dataclasses.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def __init__ ( self , value : str , * , lineno : int | None = None , endlineno : int | None = None , parent : Object | None = None , parser : Parser | None = None , parser_options : dict [ str , Any ] | None = None , ) -> None : \"\"\"Initialize the docstring. Parameters: value: The docstring value. lineno: The starting line number. endlineno: The ending line number. parent: The parent object on which this docstring is attached. parser: The docstring parser to use. By default, no parsing is done. parser_options: Additional docstring parsing options. \"\"\" self . value : str = inspect . cleandoc ( value ) self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Object | None = parent self . parser : Parser | None = parser self . parser_options : dict [ str , Any ] = parser_options or {}","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.as_dict","text":"Return this docstring's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. docstring_parser ( Parser | None ) \u2013 The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs ( Any ) \u2013 Additional serialization or docstring parsing options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def as_dict ( self , full : bool = False , docstring_parser : Parser | None = None , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this docstring's data as a dictionary. Parameters: full: Whether to return full info, or just base info. docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done. **kwargs: Additional serialization or docstring parsing options. Returns: A dictionary. \"\"\" base : dict [ str , Any ] = { \"value\" : self . value , \"lineno\" : self . lineno , \"endlineno\" : self . endlineno , } if full : base [ \"parsed\" ] = self . parse ( docstring_parser , ** kwargs ) return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.lines","text":"Returns the lines of the docstring. Returns: list [ str ] \u2013 The docstring's lines. Source code in griffe/dataclasses.py 122 123 124 125 126 127 128 129 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Returns the lines of the docstring. Returns: The docstring's lines. \"\"\" return self . value . split ( \" \\n \" )","title":"lines()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parse","text":"Parse the docstring into structured data. Parameters: parser ( Parser | None ) \u2013 The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options ( Any ) \u2013 Additional docstring parsing options. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 140 141 142 143 144 145 146 147 148 149 150 151 def parse ( self , parser : Parser | None = None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring into structured data. Parameters: parser: The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section). **options: Additional docstring parsing options. Returns: The parsed docstring as a list of sections. \"\"\" return parse ( self , parser or self . parser , ** ( options or self . parser_options ))","title":"parse()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parsed","text":"Return the docstring, parsed into structured data. Returns: list [ DocstringSection ] \u2013 The parsed docstring as a list of sections. Source code in griffe/dataclasses.py 131 132 133 134 135 136 137 138 @cached_property def parsed ( self ) -> list [ DocstringSection ]: \"\"\"Return the docstring, parsed into structured data. Returns: The parsed docstring as a list of sections. \"\"\" return self . parse ()","title":"parsed()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function","text":"The class representing a Python function. Source code in griffe/dataclasses.py 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 class Function ( Object ): \"\"\"The class representing a Python function.\"\"\" kind = Kind . FUNCTION def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or [] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base","title":"Function"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.decorators","text":"","title":"decorators"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.kind","text":"","title":"kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.parameters","text":"","title":"parameters"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.returns","text":"","title":"returns"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.__init__","text":"Initialize the function. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . parameters ( Parameters | None ) \u2013 The function parameters. returns ( str | Name | Expression | None ) \u2013 The function return annotation. decorators ( list [ Decorator ] | None ) \u2013 The function decorators, if any. **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def __init__ ( self , * args : Any , parameters : Parameters | None = None , returns : str | Name | Expression | None = None , decorators : list [ Decorator ] | None = None , ** kwargs : Any , ) -> None : \"\"\"Initialize the function. Parameters: *args: See [`griffe.dataclasses.Object`][]. parameters: The function parameters. returns: The function return annotation. decorators: The function decorators, if any. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . parameters : Parameters = parameters or Parameters () self . returns : str | Name | Expression | None = returns self . decorators : list [ Decorator ] = decorators or []","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.as_dict","text":"Return this function's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this function's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"decorators\" ] = [ dec . as_dict ( ** kwargs ) for dec in self . decorators ] base [ \"parameters\" ] = [ param . as_dict ( ** kwargs ) for param in self . parameters ] base [ \"returns\" ] = self . returns return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind","text":"Enumeration of the different objects kinds. Attributes: MODULE ( str ) \u2013 The module kind. CLASS ( str ) \u2013 The class kind. FUNCTION ( str ) \u2013 The function kind. ATTRIBUTE ( str ) \u2013 The attribute kind. Source code in griffe/dataclasses.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class Kind ( enum . Enum ): \"\"\"Enumeration of the different objects kinds. Attributes: MODULE: The module kind. CLASS: The class kind. FUNCTION: The function kind. ATTRIBUTE: The attribute kind. \"\"\" MODULE : str = \"module\" CLASS : str = \"class\" FUNCTION : str = \"function\" ATTRIBUTE : str = \"attribute\" ALIAS : str = \"alias\"","title":"Kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind.ALIAS","text":"","title":"ALIAS"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind.ATTRIBUTE","text":"","title":"ATTRIBUTE"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind.CLASS","text":"","title":"CLASS"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind.FUNCTION","text":"","title":"FUNCTION"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind.MODULE","text":"","title":"MODULE"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module","text":"The class representing a Python module. Source code in griffe/dataclasses.py 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 class Module ( Object ): \"\"\"The class representing a Python module.\"\"\" kind = Kind . MODULE def __init__ ( self , * args : Any , filepath : Path | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | None = filepath def __repr__ ( self ) -> str : try : return f \"<Module( { self . filepath !r} )>\" except BuiltinModuleError : return f \"<Module( { self . name !r} )>\" @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" try : return self . filepath . name == \"__init__.py\" except BuiltinModuleError : return False @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return self . parent is None and self . filepath . is_dir () except BuiltinModuleError : return False @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and self . filepath . is_dir () and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base","title":"Module"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module._filepath","text":"","title":"_filepath"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.kind","text":"","title":"kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.__init__","text":"Initialize the module. Parameters: *args ( Any ) \u2013 See griffe.dataclasses.Object . filepath ( Path | None ) \u2013 The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs ( Any ) \u2013 See griffe.dataclasses.Object . Source code in griffe/dataclasses.py 879 880 881 882 883 884 885 886 887 888 def __init__ ( self , * args : Any , filepath : Path | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the module. Parameters: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path (directory for namespace [sub]packages, none for builtin modules). **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath : Path | None = filepath","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.__repr__","text":"Source code in griffe/dataclasses.py 890 891 892 893 894 def __repr__ ( self ) -> str : try : return f \"<Module( { self . filepath !r} )>\" except BuiltinModuleError : return f \"<Module( { self . name !r} )>\"","title":"__repr__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.as_dict","text":"Return this module's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 970 971 972 973 974 975 976 977 978 979 980 981 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: # type: ignore[override] \"\"\"Return this module's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = super () . as_dict ( ** kwargs ) base [ \"filepath\" ] = str ( self . _filepath ) if self . _filepath else None return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.filepath","text":"Get the file path of this module. Raises: BuiltinModuleError \u2013 When the instance filepath is None. Returns: Path \u2013 The module's file path. Source code in griffe/dataclasses.py 896 897 898 899 900 901 902 903 904 905 906 907 908 @property def filepath ( self ) -> Path : \"\"\"Get the file path of this module. Raises: BuiltinModuleError: When the instance filepath is None. Returns: The module's file path. \"\"\" if self . _filepath is None : raise BuiltinModuleError ( self . name ) return self . _filepath","title":"filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_init_module","text":"Tell if this module is an __init__.py module. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 910 911 912 913 914 915 916 917 918 919 920 @cached_property def is_init_module ( self ) -> bool : \"\"\"Tell if this module is an `__init__.py` module. Returns: True or False. \"\"\" try : return self . filepath . name == \"__init__.py\" except BuiltinModuleError : return False","title":"is_init_module()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_package","text":"Tell if this module is a namespace package (top folder, no __init__.py ). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 940 941 942 943 944 945 946 947 948 949 950 @cached_property def is_namespace_package ( self ) -> bool : \"\"\"Tell if this module is a namespace package (top folder, no `__init__.py`). Returns: True or False. \"\"\" try : return self . parent is None and self . filepath . is_dir () except BuiltinModuleError : return False","title":"is_namespace_package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_subpackage","text":"Tell if this module is a namespace subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 @cached_property def is_namespace_subpackage ( self ) -> bool : \"\"\"Tell if this module is a namespace subpackage. Returns: True or False. \"\"\" try : return ( self . parent is not None and self . filepath . is_dir () and ( cast ( Module , self . parent ) . is_namespace_package or cast ( Module , self . parent ) . is_namespace_subpackage ) ) except BuiltinModuleError : return False","title":"is_namespace_subpackage()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_package","text":"Tell if this module is a package (top module). Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 922 923 924 925 926 927 928 929 @cached_property def is_package ( self ) -> bool : \"\"\"Tell if this module is a package (top module). Returns: True or False. \"\"\" return not bool ( self . parent ) and self . is_init_module","title":"is_package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_subpackage","text":"Tell if this module is a subpackage. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 931 932 933 934 935 936 937 938 @cached_property def is_subpackage ( self ) -> bool : \"\"\"Tell if this module is a subpackage. Returns: True or False. \"\"\" return bool ( self . parent ) and self . is_init_module","title":"is_subpackage()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object","text":"An abstract class representing a Python object. Attributes: kind ( Kind ) \u2013 The object kind. name ( str ) \u2013 The object name. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent, or None if it is the top module. members ( dict [ str , Object | Alias ] ) \u2013 The object members. labels ( set [ str ] ) \u2013 The object labels. Source code in griffe/dataclasses.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 class Object ( GetMembersMixin , SetMembersMixin , ObjectAliasMixin ): \"\"\"An abstract class representing a Python object. Attributes: kind: The object kind. name: The object name. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent, or None if it is the top module. members: The object members. labels: The object labels. \"\"\" kind : Kind is_alias : bool = False def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self def __repr__ ( self ) -> str : return f \"< { self . __class__ . __name__ } ( { self . name !r} , { self . lineno !r} , { self . endlineno !r} )>\" @property def has_docstring ( self ) -> bool : \"\"\"Tell if this object has a non-empty docstring.\"\"\" return bool ( self . docstring ) # noqa: DAR201 @property def has_docstrings ( self ) -> bool : \"\"\"Tell if this object or any of its members has a non-empty docstring.\"\"\" return self . has_docstring or any ( member . has_docstrings for member in self . members . values ()) # noqa: DAR201 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels ) def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc] @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc] @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc] @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc] @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent ) @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if self . parent is None : return self . name return \".\" . join (( self . parent . path , self . name )) @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno if self . lineno is None or self . endlineno is None : return self . lines_collection [ filepath ] return self . lines_collection [ filepath ][ self . lineno - 1 : self . endlineno ] @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines )) def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name ) def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base # TODO: remove once Python 3.7 support is dropped @property def _endlineno ( self ) -> int : if self . kind is Kind . MODULE : return len ( self . lines_collection [ self . filepath ]) tokens , tokens_by_line = self . lines_collection . tokens ( self . filepath ) first_token_index = tokens_by_line [ self . lineno ][ 0 ] blockfinder = inspect . BlockFinder () with suppress ( inspect . EndOfBlock , IndentationError ): for token in tokens [ first_token_index :]: blockfinder . tokeneater ( * token ) return blockfinder . last","title":"Object"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object._lines_collection","text":"","title":"_lines_collection"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object._modules_collection","text":"","title":"_modules_collection"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.aliases","text":"","title":"aliases"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.docstring","text":"","title":"docstring"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.endlineno","text":"","title":"endlineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.exports","text":"","title":"exports"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.imports","text":"","title":"imports"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_alias","text":"","title":"is_alias"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.kind","text":"","title":"kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.labels","text":"","title":"labels"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lineno","text":"","title":"lineno"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.members","text":"","title":"members"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.name","text":"","title":"name"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.parent","text":"","title":"parent"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.__init__","text":"Initialize the object. Parameters: name ( str ) \u2013 The object name, as declared in the code. lineno ( int | None ) \u2013 The object starting line, or None for modules. Lines start at 1. endlineno ( int | None ) \u2013 The object ending line (inclusive), or None for modules. docstring ( Docstring | None ) \u2013 The object docstring. parent ( Module | Class | None ) \u2013 The object parent. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/dataclasses.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def __init__ ( self , name : str , * , lineno : int | None = None , endlineno : int | None = None , docstring : Docstring | None = None , parent : Module | Class | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the object. Parameters: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. docstring: The object docstring. parent: The object parent. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . docstring : Docstring | None = docstring self . parent : Module | Class | None = parent self . members : dict [ str , Object | Alias ] = {} self . labels : set [ str ] = set () self . imports : dict [ str , str ] = {} self . exports : set [ str ] | None = None self . aliases : dict [ str , Alias ] = {} self . _lines_collection : LinesCollection | None = lines_collection self . _modules_collection : ModulesCollection | None = modules_collection # attach the docstring to this object if docstring : docstring . parent = self","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.__repr__","text":"Source code in griffe/dataclasses.py 339 340 def __repr__ ( self ) -> str : return f \"< { self . __class__ . __name__ } ( { self . name !r} , { self . lineno !r} , { self . endlineno !r} )>\"","title":"__repr__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object._endlineno","text":"Source code in griffe/dataclasses.py 651 652 653 654 655 656 657 658 659 660 661 @property def _endlineno ( self ) -> int : if self . kind is Kind . MODULE : return len ( self . lines_collection [ self . filepath ]) tokens , tokens_by_line = self . lines_collection . tokens ( self . filepath ) first_token_index = tokens_by_line [ self . lineno ][ 0 ] blockfinder = inspect . BlockFinder () with suppress ( inspect . EndOfBlock , IndentationError ): for token in tokens [ first_token_index :]: blockfinder . tokeneater ( * token ) return blockfinder . last","title":"_endlineno()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.as_dict","text":"Return this object's data as a dictionary. Parameters: full ( bool ) \u2013 Whether to return full info, or just base info. **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 def as_dict ( self , full : bool = False , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this object's data as a dictionary. Parameters: full: Whether to return full info, or just base info. **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"kind\" : self . kind , \"name\" : self . name , } if full : base . update ( { \"path\" : self . path , \"filepath\" : self . filepath , \"relative_filepath\" : self . relative_filepath , } ) if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if self . docstring : base [ \"docstring\" ] = self . docstring # doing this last for a prettier JSON dump base [ \"labels\" ] = self . labels base [ \"members\" ] = [ member . as_dict ( full = full , ** kwargs ) for member in self . members . values ()] return base","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.attributes","text":"Return the attribute members. Returns: dict [ str , Attribute ] \u2013 A dictionary of attributes. Source code in griffe/dataclasses.py 445 446 447 448 449 450 451 452 @property def attributes ( self ) -> dict [ str , Attribute ]: \"\"\"Return the attribute members. Returns: A dictionary of attributes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . ATTRIBUTE } # type: ignore[misc]","title":"attributes()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.canonical_path","text":"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 516 517 518 519 520 521 522 523 524 525 526 527 @cached_property def canonical_path ( self ) -> str : \"\"\"Return the full dotted path of this object. The canonical path is the path where the object was defined (not imported). Returns: A dotted path. \"\"\" if self . parent is None : return self . name return \".\" . join (( self . parent . path , self . name ))","title":"canonical_path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.classes","text":"Return the class members. Returns: dict [ str , Class ] \u2013 A dictionary of classes. Source code in griffe/dataclasses.py 427 428 429 430 431 432 433 434 @property def classes ( self ) -> dict [ str , Class ]: \"\"\"Return the class members. Returns: A dictionary of classes. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . CLASS } # type: ignore[misc]","title":"classes()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filepath","text":"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 482 483 484 485 486 487 488 489 490 491 492 493 494 @cached_property def filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, `self.module` would trigger a `ValueError` anyway. If it _does_ return None, it means the tree was not built correctly. Returns: A file path. \"\"\" return self . module . filepath","title":"filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filter_members","text":"Filter and return members based on predicates. Parameters: *predicates ( Callable [[ Object | Alias ], bool ] ) \u2013 A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: dict [ str , Object | Alias ] \u2013 A dictionary of members. Source code in griffe/dataclasses.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def filter_members ( self , * predicates : Callable [[ Object | Alias ], bool ]) -> dict [ str , Object | Alias ]: \"\"\"Filter and return members based on predicates. Parameters: *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean. Returns: A dictionary of members. \"\"\" if not predicates : return self . members members : dict [ str , Object | Alias ] = {} for name , member in self . members . items (): if all ( predicate ( member ) for predicate in predicates ): members [ name ] = member return members","title":"filter_members()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.functions","text":"Return the function members. Returns: dict [ str , Function ] \u2013 A dictionary of functions. Source code in griffe/dataclasses.py 436 437 438 439 440 441 442 443 @property def functions ( self ) -> dict [ str , Function ]: \"\"\"Return the function members. Returns: A dictionary of functions. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . FUNCTION } # type: ignore[misc]","title":"functions()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstring","text":"Tell if this object has a non-empty docstring. Source code in griffe/dataclasses.py 342 343 344 345 @property def has_docstring ( self ) -> bool : \"\"\"Tell if this object has a non-empty docstring.\"\"\" return bool ( self . docstring ) # noqa: DAR201","title":"has_docstring()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstrings","text":"Tell if this object or any of its members has a non-empty docstring. Source code in griffe/dataclasses.py 347 348 349 350 @property def has_docstrings ( self ) -> bool : \"\"\"Tell if this object or any of its members has a non-empty docstring.\"\"\" return self . has_docstring or any ( member . has_docstrings for member in self . members . values ()) # noqa: DAR201","title":"has_docstrings()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_labels","text":"Tell if this object has all the given labels. Parameters: labels ( set [ str ] ) \u2013 A set of labels. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 390 391 392 393 394 395 396 397 398 399 def has_labels ( self , labels : set [ str ]) -> bool : \"\"\"Tell if this object has all the given labels. Parameters: labels: A set of labels. Returns: True or False. \"\"\" return all ( label in self . labels for label in labels )","title":"has_labels()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_kind","text":"Tell if this object is of the given kind. Parameters: kind ( str | Kind | set [ str | Kind ] ) \u2013 An instance or set of kinds (strings or enumerations). Raises: ValueError \u2013 When an empty set is given as argument. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 def is_kind ( self , kind : str | Kind | set [ str | Kind ]) -> bool : \"\"\"Tell if this object is of the given kind. Parameters: kind: An instance or set of kinds (strings or enumerations). Raises: ValueError: When an empty set is given as argument. Returns: True or False. \"\"\" if isinstance ( kind , set ): if not kind : raise ValueError ( \"kind must not be an empty set\" ) return self . kind in ( knd if isinstance ( knd , Kind ) else Kind ( knd ) for knd in kind ) # noqa: WPS509,WPS510 if isinstance ( kind , str ): kind = Kind ( kind ) return self . kind is kind","title":"is_kind()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines","text":"Return the lines containing the source of this object. Returns: list [ str ] \u2013 A list of lines. Source code in griffe/dataclasses.py 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 @cached_property def lines ( self ) -> list [ str ]: \"\"\"Return the lines containing the source of this object. Returns: A list of lines. \"\"\" try : filepath = self . filepath except BuiltinModuleError : return [] # TODO: remove once Python 3.7 support is dropped if self . lineno and self . endlineno is None and sys . version_info < ( 3 , 8 ): self . endlineno = self . _endlineno if self . lineno is None or self . endlineno is None : return self . lines_collection [ filepath ] return self . lines_collection [ filepath ][ self . lineno - 1 : self . endlineno ]","title":"lines()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines_collection","text":"Return the lines collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: LinesCollection \u2013 A lines collection. Source code in griffe/dataclasses.py 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 @cached_property def lines_collection ( self ) -> LinesCollection : \"\"\"Return the lines collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A lines collection. \"\"\" if self . _lines_collection is not None : return self . _lines_collection if self . parent is None : raise ValueError ( \"no lines collection in this object or its parents\" ) return self . parent . lines_collection","title":"lines_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.member_is_exported","text":"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the __all__ attribute of its parent module or class. When _all__ is not defined, we consider the member to be implicitely exported. Parameters: member ( Object | Alias ) \u2013 The member to verify. explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/dataclasses.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def member_is_exported ( self , member : Object | Alias , explicitely : bool = True ) -> bool : \"\"\"Tell if a member of this object is \"exported\". By exported, we mean that the object is included in the `__all__` attribute of its parent module or class. When `_all__` is not defined, we consider the member to be *implicitely* exported. Parameters: member: The member to verify. explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" if self . exports is None : return not explicitely return member . name in self . exports","title":"member_is_exported()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.module","text":"Return the parent module of this object. Raises: ValueError \u2013 When the object is not a module and does not have a parent. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 @cached_property def module ( self ) -> Module : \"\"\"Return the parent module of this object. Raises: ValueError: When the object is not a module and does not have a parent. Returns: The parent module. \"\"\" if isinstance ( self , Module ): return self if self . parent is not None : return self . parent . module raise ValueError","title":"module()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules","text":"Return the module members. Returns: dict [ str , Module ] \u2013 A dictionary of modules. Source code in griffe/dataclasses.py 418 419 420 421 422 423 424 425 @property def modules ( self ) -> dict [ str , Module ]: \"\"\"Return the module members. Returns: A dictionary of modules. \"\"\" return { name : member for name , member in self . members . items () if member . kind is Kind . MODULE } # type: ignore[misc]","title":"modules()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules_collection","text":"Return the modules collection attached to this object or its parents. Raises: ValueError \u2013 When no modules collection can be found in the object or its parents. Returns: ModulesCollection \u2013 A modules collection. Source code in griffe/dataclasses.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 @cached_property def modules_collection ( self ) -> ModulesCollection : \"\"\"Return the modules collection attached to this object or its parents. Raises: ValueError: When no modules collection can be found in the object or its parents. Returns: A modules collection. \"\"\" if self . _modules_collection is not None : return self . _modules_collection if self . parent is None : raise ValueError ( \"no modules collection in this object or its parents\" ) return self . parent . modules_collection","title":"modules_collection()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.package","text":"Return the absolute top module (the package) of this object. Returns: Module \u2013 The parent module. Source code in griffe/dataclasses.py 470 471 472 473 474 475 476 477 478 479 480 @cached_property def package ( self ) -> Module : \"\"\"Return the absolute top module (the package) of this object. Returns: The parent module. \"\"\" module = self . module while module . parent : module = module . parent # type: ignore[assignment] # always a module return module","title":"package()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.path","text":"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: str \u2013 A dotted path. Source code in griffe/dataclasses.py 505 506 507 508 509 510 511 512 513 514 @cached_property def path ( self ) -> str : \"\"\"Return the dotted path of this object. On regular objects (not aliases), the path is the canonical path. Returns: A dotted path. \"\"\" return self . canonical_path","title":"path()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.relative_filepath","text":"Return the file path where this object was defined, relative to the top module path. Returns: Path \u2013 A file path. Source code in griffe/dataclasses.py 496 497 498 499 500 501 502 503 @cached_property def relative_filepath ( self ) -> Path : \"\"\"Return the file path where this object was defined, relative to the top module path. Returns: A file path. \"\"\" return self . module . filepath . relative_to ( self . package . filepath . parent . parent )","title":"relative_filepath()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.resolve","text":"Resolve a name within this object's and parents' scope. Parameters: name ( str ) \u2013 The name to resolve. Raises: NameResolutionError \u2013 When the name could not be resolved. Returns: str \u2013 The resolved name. Source code in griffe/dataclasses.py 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 def resolve ( self , name : str ) -> str : \"\"\"Resolve a name within this object's and parents' scope. Parameters: name: The name to resolve. Raises: NameResolutionError: When the name could not be resolved. Returns: The resolved name. \"\"\" if name in self . members and not self . members [ name ] . is_alias : return self . members [ name ] . path if name in self . imports : return self . imports [ name ] if self . parent is None : # could be a built-in raise NameResolutionError ( f \" { name } could not be resolved in the scope of { self . path } \" ) if name == self . parent . name : return self . parent . path return self . parent . resolve ( name )","title":"resolve()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.source","text":"Return the source code of this object. Returns: str \u2013 The source code. Source code in griffe/dataclasses.py 581 582 583 584 585 586 587 588 @cached_property def source ( self ) -> str : \"\"\"Return the source code of this object. Returns: The source code. \"\"\" return dedent ( \" \\n \" . join ( self . lines ))","title":"source()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter","text":"This class represent a function parameter. Attributes: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class Parameter : \"\"\"This class represent a function parameter. Attributes: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , }","title":"Parameter"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.annotation","text":"","title":"annotation"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.default","text":"","title":"default"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.kind","text":"","title":"kind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.name","text":"","title":"name"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.__init__","text":"Initialize the parameter. Parameters: name ( str ) \u2013 The parameter name. annotation ( str | Name | Expression | None ) \u2013 The parameter annotation, if any. kind ( ParameterKind | None ) \u2013 The parameter kind. default ( str | None ) \u2013 The parameter default, if any. Source code in griffe/dataclasses.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def __init__ ( self , name : str , * , annotation : str | Name | Expression | None = None , kind : ParameterKind | None = None , default : str | None = None , ) -> None : \"\"\"Initialize the parameter. Parameters: name: The parameter name. annotation: The parameter annotation, if any. kind: The parameter kind. default: The parameter default, if any. \"\"\" self . name : str = name self . annotation : str | Name | Expression | None = annotation self . kind : ParameterKind | None = kind self . default : str | None = default","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.as_dict","text":"Return this parameter's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/dataclasses.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this parameter's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"name\" : self . name , \"annotation\" : self . annotation , \"kind\" : self . kind , \"default\" : self . default , }","title":"as_dict()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind","text":"Enumeration of the different parameter kinds. Attributes: positional_only ( str ) \u2013 Positional-only parameter. positional_or_keyword ( str ) \u2013 Positional or keyword parameter. var_positional ( str ) \u2013 Variadic positional parameter. keyword_only ( str ) \u2013 Keyword-only parameter. var_keyword ( str ) \u2013 Variadic keyword parameter. Source code in griffe/dataclasses.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ParameterKind ( enum . Enum ): \"\"\"Enumeration of the different parameter kinds. Attributes: positional_only: Positional-only parameter. positional_or_keyword: Positional or keyword parameter. var_positional: Variadic positional parameter. keyword_only: Keyword-only parameter. var_keyword: Variadic keyword parameter. \"\"\" positional_only : str = \"positional-only\" positional_or_keyword : str = \"positional or keyword\" var_positional : str = \"variadic positional\" keyword_only : str = \"keyword-only\" var_keyword : str = \"variadic keyword\"","title":"ParameterKind"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind.keyword_only","text":"","title":"keyword_only"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind.positional_only","text":"","title":"positional_only"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind.positional_or_keyword","text":"","title":"positional_or_keyword"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind.var_keyword","text":"","title":"var_keyword"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind.var_positional","text":"","title":"var_positional"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters","text":"This class is a container for parameters. It allows to get parameters using their position (index) or their name. Source code in griffe/dataclasses.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class Parameters : \"\"\"This class is a container for parameters. It allows to get parameters using their position (index) or their name. \"\"\" def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter ) def __getitem__ ( self , name_or_index : int | str ) -> Parameter : if isinstance ( name_or_index , int ): return self . _parameters_list [ name_or_index ] return self . _parameters_dict [ name_or_index ] def __len__ ( self ): return len ( self . _parameters_list ) def __iter__ ( self ): return iter ( self . _parameters_list ) def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"Parameters"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters._parameters_dict","text":"","title":"_parameters_dict"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters._parameters_list","text":"","title":"_parameters_list"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.__getitem__","text":"Source code in griffe/dataclasses.py 239 240 241 242 def __getitem__ ( self , name_or_index : int | str ) -> Parameter : if isinstance ( name_or_index , int ): return self . _parameters_list [ name_or_index ] return self . _parameters_dict [ name_or_index ]","title":"__getitem__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.__init__","text":"Initialize the parameters container. Parameters: *parameters ( Parameter ) \u2013 The initial parameters to add to the container. Source code in griffe/dataclasses.py 228 229 230 231 232 233 234 235 236 237 def __init__ ( self , * parameters : Parameter ) -> None : \"\"\"Initialize the parameters container. Parameters: *parameters: The initial parameters to add to the container. \"\"\" self . _parameters_list : list [ Parameter ] = [] self . _parameters_dict : dict [ str , Parameter ] = {} for parameter in parameters : self . add ( parameter )","title":"__init__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.__iter__","text":"Source code in griffe/dataclasses.py 247 248 def __iter__ ( self ): return iter ( self . _parameters_list )","title":"__iter__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.__len__","text":"Source code in griffe/dataclasses.py 244 245 def __len__ ( self ): return len ( self . _parameters_list )","title":"__len__()"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.add","text":"Add a parameter to the container. Parameters: parameter ( Parameter ) \u2013 The function parameter to add. Raises: ValueError \u2013 When a parameter with the same name is already present. Source code in griffe/dataclasses.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def add ( self , parameter : Parameter ) -> None : \"\"\"Add a parameter to the container. Parameters: parameter: The function parameter to add. Raises: ValueError: When a parameter with the same name is already present. \"\"\" if parameter . name not in self . _parameters_dict : self . _parameters_dict [ parameter . name ] = parameter self . _parameters_list . append ( parameter ) else : raise ValueError ( f \"parameter { parameter . name } already present\" )","title":"add()"},{"location":"reference/griffe/encoders/","text":"This module contains data encoders/serializers and decoders/deserializers. The available formats are: JSON : see the encoder and decoder . _type_map : dict [ Type , Callable [[ Any ], Any ]] = { Path : str , PosixPath : str , ParameterKind : _enum_value , Kind : _enum_value , set : list } \u00a4 Encoder ( json . JSONEncoder ) \u00a4 JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: Source code in griffe/encoders.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class Encoder ( json . JSONEncoder ): \"\"\"JSON encoder. JSON encoders are not used directly, but through the [`json.dump`][] or [`json.dumps`][] methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json.dumps(..., cls=Encoder, full=True, **kwargs) \"\"\" def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj ) docstring_options : dict [ str , Any ] = docstring_options or {} \u00a4 docstring_parser : Parser | None = docstring_parser \u00a4 full : bool = full \u00a4 __init__ ( self , * args , full = False , docstring_parser = None , docstring_options = None , ** kwargs ) \u00a4 Initialize the encoder. Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} default ( self , obj ) \u00a4 Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 70 71 72 73 74 75 76 77 78 79 80 81 82 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj ) _enum_value ( obj ) \u00a4 Source code in griffe/encoders.py 18 19 def _enum_value ( obj ): return obj . value decoder ( obj_dict ) \u00a4 Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Object \u2013 An instance of a data class. Source code in griffe/encoders.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Object : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( name = obj_dict [ \"name\" ], filepath = Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) elif kind == Kind . ATTRIBUTE : return Attribute ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) return obj_dict","title":"encoders"},{"location":"reference/griffe/encoders/#griffe.encoders._type_map","text":"","title":"_type_map"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder","text":"JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: Source code in griffe/encoders.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class Encoder ( json . JSONEncoder ): \"\"\"JSON encoder. JSON encoders are not used directly, but through the [`json.dump`][] or [`json.dumps`][] methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json.dumps(..., cls=Encoder, full=True, **kwargs) \"\"\" def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj )","title":"Encoder"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder.docstring_options","text":"","title":"docstring_options"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder.docstring_parser","text":"","title":"docstring_parser"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder.full","text":"","title":"full"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder.__init__","text":"Initialize the encoder. Parameters: *args ( Any ) \u2013 See json.JSONEncoder . full ( bool ) \u2013 Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. **kwargs ( Any ) \u2013 See json.JSONEncoder . Source code in griffe/encoders.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , * args : Any , full : bool = False , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , ** kwargs : Any ) -> None : \"\"\"Initialize the encoder. Parameters: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full : bool = full self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {}","title":"__init__()"},{"location":"reference/griffe/encoders/#griffe.encoders.Encoder.default","text":"Return a serializable representation of the given object. Parameters: obj ( Any ) \u2013 The object to serialize. Returns: Any \u2013 A serializable representation. Source code in griffe/encoders.py 70 71 72 73 74 75 76 77 78 79 80 81 82 def default ( self , obj : Any ) -> Any : # noqa: WPS212 \"\"\"Return a serializable representation of the given object. Parameters: obj: The object to serialize. Returns: A serializable representation. \"\"\" try : return obj . as_dict ( full = self . full , docstring_parser = self . docstring_parser , ** self . docstring_options ) except AttributeError : return _type_map . get ( type ( obj ), super () . default )( obj )","title":"default()"},{"location":"reference/griffe/encoders/#griffe.encoders._enum_value","text":"Source code in griffe/encoders.py 18 19 def _enum_value ( obj ): return obj . value","title":"_enum_value()"},{"location":"reference/griffe/encoders/#griffe.encoders.decoder","text":"Decode dictionaries as data classes. The json.loads method walks the tree from bottom to top. Parameters: obj_dict ( dict [ str , Any ] ) \u2013 The dictionary to decode. Returns: dict [ str , Any ] | Object \u2013 An instance of a data class. Source code in griffe/encoders.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def decoder ( obj_dict : dict [ str , Any ]) -> dict [ str , Any ] | Object : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`][] method walks the tree from bottom to top. Parameters: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( name = obj_dict [ \"name\" ], filepath = Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) elif kind == Kind . ATTRIBUTE : return Attribute ( name = obj_dict [ \"name\" ], lineno = obj_dict [ \"lineno\" ], endlineno = obj_dict [ \"endlineno\" ]) return obj_dict","title":"decoder()"},{"location":"reference/griffe/exceptions/","text":"This module contains all the exceptions specific to Griffe. AliasResolutionError ( GriffeError ) \u00a4 Exception for alias that cannot be resolved. Source code in griffe/exceptions.py 22 23 24 25 26 27 28 29 30 31 32 class AliasResolutionError ( GriffeError ): \"\"\"Exception for alias that cannot be resolved.\"\"\" def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"Could not resolve { self . target_path } \" ) target_path : str = target_path \u00a4 __init__ ( self , target_path ) \u00a4 Initialize the exception. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 25 26 27 28 29 30 31 32 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"Could not resolve { self . target_path } \" ) BuiltinModuleError ( GriffeError ) \u00a4 Exception raised when trying to access the filepath of a builtin module. Source code in griffe/exceptions.py 56 57 class BuiltinModuleError ( GriffeError ): \"\"\"Exception raised when trying to access the filepath of a builtin module.\"\"\" CyclicAliasError ( GriffeError ) \u00a4 Exception raised when a cycle is detected in aliases. Source code in griffe/exceptions.py 35 36 37 38 39 40 41 42 43 44 45 class CyclicAliasError ( GriffeError ): \"\"\"Exception raised when a cycle is detected in aliases.\"\"\" def __init__ ( self , chain : list [ str ]) -> None : \"\"\"Initialize the exception. Parameters: chain: The cyclic chain of items (such as target path). \"\"\" self . chain : list [ str ] = chain super () . __init__ ( \"Cyclic aliases detected: \\n \" + \" \\n \" . join ( self . chain )) chain : list [ str ] = chain \u00a4 __init__ ( self , chain ) \u00a4 Initialize the exception. Parameters: chain ( list [ str ] ) \u2013 The cyclic chain of items (such as target path). Source code in griffe/exceptions.py 38 39 40 41 42 43 44 45 def __init__ ( self , chain : list [ str ]) -> None : \"\"\"Initialize the exception. Parameters: chain: The cyclic chain of items (such as target path). \"\"\" self . chain : list [ str ] = chain super () . __init__ ( \"Cyclic aliases detected: \\n \" + \" \\n \" . join ( self . chain )) ExtensionError ( GriffeError ) \u00a4 Base class for errors raised by extensions. Source code in griffe/exceptions.py 60 61 class ExtensionError ( GriffeError ): \"\"\"Base class for errors raised by extensions.\"\"\" ExtensionNotLoadedError ( ExtensionError ) \u00a4 Exception raised when an extension could not be loaded. Source code in griffe/exceptions.py 64 65 class ExtensionNotLoadedError ( ExtensionError ): \"\"\"Exception raised when an extension could not be loaded.\"\"\" GriffeError ( Exception ) \u00a4 The base exception for all Griffe errors. Source code in griffe/exceptions.py 6 7 class GriffeError ( Exception ): \"\"\"The base exception for all Griffe errors.\"\"\" LastNodeError ( GriffeError ) \u00a4 Exception raised when trying to access a next or previous node. Source code in griffe/exceptions.py 48 49 class LastNodeError ( GriffeError ): \"\"\"Exception raised when trying to access a next or previous node.\"\"\" NameResolutionError ( GriffeError ) \u00a4 Exception for names that cannot be resolved in a object scope. Source code in griffe/exceptions.py 10 11 class NameResolutionError ( GriffeError ): \"\"\"Exception for names that cannot be resolved in a object scope.\"\"\" RootNodeError ( GriffeError ) \u00a4 Exception raised when trying to use siblings properties on a root node. Source code in griffe/exceptions.py 52 53 class RootNodeError ( GriffeError ): \"\"\"Exception raised when trying to use siblings properties on a root node.\"\"\" UnhandledPthFileError ( GriffeError ) \u00a4 Exception for unhandled .path files, when searching modules. Source code in griffe/exceptions.py 14 15 class UnhandledPthFileError ( GriffeError ): \"\"\"Exception for unhandled .path files, when searching modules.\"\"\" UnimportableModuleError ( GriffeError ) \u00a4 Exception for modules that cannot be imported. Source code in griffe/exceptions.py 18 19 class UnimportableModuleError ( GriffeError ): \"\"\"Exception for modules that cannot be imported.\"\"\"","title":"exceptions"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError","text":"Exception for alias that cannot be resolved. Source code in griffe/exceptions.py 22 23 24 25 26 27 28 29 30 31 32 class AliasResolutionError ( GriffeError ): \"\"\"Exception for alias that cannot be resolved.\"\"\" def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"Could not resolve { self . target_path } \" )","title":"AliasResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError.target_path","text":"","title":"target_path"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError.__init__","text":"Initialize the exception. Parameters: target_path ( str ) \u2013 The problematic target path. Source code in griffe/exceptions.py 25 26 27 28 29 30 31 32 def __init__ ( self , target_path : str ) -> None : \"\"\"Initialize the exception. Parameters: target_path: The problematic target path. \"\"\" self . target_path : str = target_path super () . __init__ ( f \"Could not resolve { self . target_path } \" )","title":"__init__()"},{"location":"reference/griffe/exceptions/#griffe.exceptions.BuiltinModuleError","text":"Exception raised when trying to access the filepath of a builtin module. Source code in griffe/exceptions.py 56 57 class BuiltinModuleError ( GriffeError ): \"\"\"Exception raised when trying to access the filepath of a builtin module.\"\"\"","title":"BuiltinModuleError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.CyclicAliasError","text":"Exception raised when a cycle is detected in aliases. Source code in griffe/exceptions.py 35 36 37 38 39 40 41 42 43 44 45 class CyclicAliasError ( GriffeError ): \"\"\"Exception raised when a cycle is detected in aliases.\"\"\" def __init__ ( self , chain : list [ str ]) -> None : \"\"\"Initialize the exception. Parameters: chain: The cyclic chain of items (such as target path). \"\"\" self . chain : list [ str ] = chain super () . __init__ ( \"Cyclic aliases detected: \\n \" + \" \\n \" . join ( self . chain ))","title":"CyclicAliasError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.CyclicAliasError.chain","text":"","title":"chain"},{"location":"reference/griffe/exceptions/#griffe.exceptions.CyclicAliasError.__init__","text":"Initialize the exception. Parameters: chain ( list [ str ] ) \u2013 The cyclic chain of items (such as target path). Source code in griffe/exceptions.py 38 39 40 41 42 43 44 45 def __init__ ( self , chain : list [ str ]) -> None : \"\"\"Initialize the exception. Parameters: chain: The cyclic chain of items (such as target path). \"\"\" self . chain : list [ str ] = chain super () . __init__ ( \"Cyclic aliases detected: \\n \" + \" \\n \" . join ( self . chain ))","title":"__init__()"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionError","text":"Base class for errors raised by extensions. Source code in griffe/exceptions.py 60 61 class ExtensionError ( GriffeError ): \"\"\"Base class for errors raised by extensions.\"\"\"","title":"ExtensionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionNotLoadedError","text":"Exception raised when an extension could not be loaded. Source code in griffe/exceptions.py 64 65 class ExtensionNotLoadedError ( ExtensionError ): \"\"\"Exception raised when an extension could not be loaded.\"\"\"","title":"ExtensionNotLoadedError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.GriffeError","text":"The base exception for all Griffe errors. Source code in griffe/exceptions.py 6 7 class GriffeError ( Exception ): \"\"\"The base exception for all Griffe errors.\"\"\"","title":"GriffeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LastNodeError","text":"Exception raised when trying to access a next or previous node. Source code in griffe/exceptions.py 48 49 class LastNodeError ( GriffeError ): \"\"\"Exception raised when trying to access a next or previous node.\"\"\"","title":"LastNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.NameResolutionError","text":"Exception for names that cannot be resolved in a object scope. Source code in griffe/exceptions.py 10 11 class NameResolutionError ( GriffeError ): \"\"\"Exception for names that cannot be resolved in a object scope.\"\"\"","title":"NameResolutionError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.RootNodeError","text":"Exception raised when trying to use siblings properties on a root node. Source code in griffe/exceptions.py 52 53 class RootNodeError ( GriffeError ): \"\"\"Exception raised when trying to use siblings properties on a root node.\"\"\"","title":"RootNodeError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnhandledPthFileError","text":"Exception for unhandled .path files, when searching modules. Source code in griffe/exceptions.py 14 15 class UnhandledPthFileError ( GriffeError ): \"\"\"Exception for unhandled .path files, when searching modules.\"\"\"","title":"UnhandledPthFileError"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnimportableModuleError","text":"Exception for modules that cannot be imported. Source code in griffe/exceptions.py 18 19 class UnimportableModuleError ( GriffeError ): \"\"\"Exception for modules that cannot be imported.\"\"\"","title":"UnimportableModuleError"},{"location":"reference/griffe/expressions/","text":"This module contains the data classes that represent resolvable names and expressions. Expression ( list ) \u00a4 This class represents a Python expression. For example, it can represents complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Source code in griffe/expressions.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class Expression ( list ): # noqa: WPS600 \"\"\"This class represents a Python expression. For example, it can represents complex annotations such as: - `Optional[Dict[str, Tuple[int, bool]]]` - `str | Callable | list[int]` Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. \"\"\" def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) # for value in values: # if isinstance(value, Expression): # self.extend(value) # else: # self.append(value) def __str__ ( self ): return \"\" . join ( str ( element ) for element in self ) @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self ) @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\" def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ] __init__ ( self , * values ) \u00a4 Initialize the expression. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 93 94 95 96 97 98 99 100 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) __str__ ( self ) \u00a4 Source code in griffe/expressions.py 107 108 def __str__ ( self ): return \"\" . join ( str ( element ) for element in self ) full ( self ) \u00a4 Return self as a string. This property is only useful to the AST utils. Returns: str \u2013 Self as a string. Source code in griffe/expressions.py 110 111 112 113 114 115 116 117 118 119 @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self ) is_tuple ( self ) \u00a4 Tell whether this expression represents a tuple. Returns: bool \u2013 True or False. Source code in griffe/expressions.py 121 122 123 124 125 126 127 128 @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\" tuple_item ( self , nth ) \u00a4 Return the n-th item of this tuple expression. Parameters: nth ( int ) \u2013 The item number. Returns: str | Name \u2013 A string or name. Source code in griffe/expressions.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ] Name \u00a4 This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Source code in griffe/expressions.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class Name : \"\"\"This class represents a Python object identified by a name in a given scope. Attributes: source: The name as written in the source code. \"\"\" def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full def __eq__ ( self , other : Name ) -> bool : # type: ignore[override] return self . source == other . source and self . full == other . full # noqa: WPS437 def __repr__ ( self ) -> str : return f \"Name(source= { self . source !r} , full= { self . full !r} )\" def __str__ ( self ) -> str : return self . source @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full } _full = '' \u00a4 _resolver = full \u00a4 source : str = source \u00a4 __eq__ ( self , other ) \u00a4 Source code in griffe/expressions.py 32 33 def __eq__ ( self , other : Name ) -> bool : # type: ignore[override] return self . source == other . source and self . full == other . full # noqa: WPS437 __init__ ( self , source , full ) \u00a4 Initialize the name. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full __repr__ ( self ) \u00a4 Source code in griffe/expressions.py 35 36 def __repr__ ( self ) -> str : return f \"Name(source= { self . source !r} , full= { self . full !r} )\" __str__ ( self ) \u00a4 Source code in griffe/expressions.py 38 39 def __str__ ( self ) -> str : return self . source as_dict ( self , ** kwargs ) \u00a4 Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 69 70 71 72 73 74 75 76 77 78 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full } brief ( self ) \u00a4 Return the brief source name. Returns: str \u2013 The last part of the source name. Source code in griffe/expressions.py 60 61 62 63 64 65 66 67 @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ] full ( self ) \u00a4 Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source. Source code in griffe/expressions.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full","title":"expressions"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression","text":"This class represents a Python expression. For example, it can represents complex annotations such as: Optional[Dict[str, Tuple[int, bool]]] str | Callable | list[int] Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. Source code in griffe/expressions.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class Expression ( list ): # noqa: WPS600 \"\"\"This class represents a Python expression. For example, it can represents complex annotations such as: - `Optional[Dict[str, Tuple[int, bool]]]` - `str | Callable | list[int]` Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope. \"\"\" def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values ) # for value in values: # if isinstance(value, Expression): # self.extend(value) # else: # self.append(value) def __str__ ( self ): return \"\" . join ( str ( element ) for element in self ) @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self ) @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\" def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ]","title":"Expression"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.__init__","text":"Initialize the expression. Parameters: *values ( str | Expression | Name ) \u2013 The initial values of the expression. Source code in griffe/expressions.py 93 94 95 96 97 98 99 100 def __init__ ( self , * values : str | Expression | Name ) -> None : \"\"\"Initialize the expression. Parameters: *values: The initial values of the expression. \"\"\" super () . __init__ () self . extend ( values )","title":"__init__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.__str__","text":"Source code in griffe/expressions.py 107 108 def __str__ ( self ): return \"\" . join ( str ( element ) for element in self )","title":"__str__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.full","text":"Return self as a string. This property is only useful to the AST utils. Returns: str \u2013 Self as a string. Source code in griffe/expressions.py 110 111 112 113 114 115 116 117 118 119 @property def full ( self ) -> str : \"\"\"Return self as a string. This property is only useful to the AST utils. Returns: Self as a string. \"\"\" return str ( self )","title":"full()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_tuple","text":"Tell whether this expression represents a tuple. Returns: bool \u2013 True or False. Source code in griffe/expressions.py 121 122 123 124 125 126 127 128 @property def is_tuple ( self ) -> bool : \"\"\"Tell whether this expression represents a tuple. Returns: True or False. \"\"\" return str ( self ) . split ( \"[\" , 1 )[ 0 ] . rsplit ( \".\" , 1 )[ - 1 ] . lower () == \"tuple\"","title":"is_tuple()"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.tuple_item","text":"Return the n-th item of this tuple expression. Parameters: nth ( int ) \u2013 The item number. Returns: str | Name \u2013 A string or name. Source code in griffe/expressions.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def tuple_item ( self , nth : int ) -> str | Name : \"\"\"Return the n-th item of this tuple expression. Parameters: nth: The item number. Returns: A string or name. \"\"\" # 0 1 2 3 # N|E [ E ] # N , N , N # 0 1 2 3 4 return self [ 2 ][ 2 * nth ]","title":"tuple_item()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name","text":"This class represents a Python object identified by a name in a given scope. Attributes: source ( str ) \u2013 The name as written in the source code. Source code in griffe/expressions.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class Name : \"\"\"This class represents a Python object identified by a name in a given scope. Attributes: source: The name as written in the source code. \"\"\" def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full def __eq__ ( self , other : Name ) -> bool : # type: ignore[override] return self . source == other . source and self . full == other . full # noqa: WPS437 def __repr__ ( self ) -> str : return f \"Name(source= { self . source !r} , full= { self . full !r} )\" def __str__ ( self ) -> str : return self . source @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ] def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full }","title":"Name"},{"location":"reference/griffe/expressions/#griffe.expressions.Name._full","text":"","title":"_full"},{"location":"reference/griffe/expressions/#griffe.expressions.Name._resolver","text":"","title":"_resolver"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.source","text":"","title":"source"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.__eq__","text":"Source code in griffe/expressions.py 32 33 def __eq__ ( self , other : Name ) -> bool : # type: ignore[override] return self . source == other . source and self . full == other . full # noqa: WPS437","title":"__eq__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.__init__","text":"Initialize the name. Parameters: source ( str ) \u2013 The name as written in the source code. full ( str | Callable ) \u2013 The full, resolved name in the given scope, or a callable to resolve it later. Source code in griffe/expressions.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , source : str , full : str | Callable ) -> None : \"\"\"Initialize the name. Parameters: source: The name as written in the source code. full: The full, resolved name in the given scope, or a callable to resolve it later. \"\"\" self . source : str = source if isinstance ( full , str ): self . _full : str = full self . _resolver : Callable = lambda : None else : self . _full = \"\" self . _resolver = full","title":"__init__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.__repr__","text":"Source code in griffe/expressions.py 35 36 def __repr__ ( self ) -> str : return f \"Name(source= { self . source !r} , full= { self . full !r} )\"","title":"__repr__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.__str__","text":"Source code in griffe/expressions.py 38 39 def __str__ ( self ) -> str : return self . source","title":"__str__()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.as_dict","text":"Return this name's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/expressions.py 69 70 71 72 73 74 75 76 77 78 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this name's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"source\" : self . source , \"full\" : self . full }","title":"as_dict()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.brief","text":"Return the brief source name. Returns: str \u2013 The last part of the source name. Source code in griffe/expressions.py 60 61 62 63 64 65 66 67 @property def brief ( self ) -> str : \"\"\"Return the brief source name. Returns: The last part of the source name. \"\"\" return self . source . rsplit ( \".\" , 1 )[ - 1 ]","title":"brief()"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.full","text":"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: str \u2013 The resolved name or the source. Source code in griffe/expressions.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @property def full ( self ) -> str : \"\"\"Return the full, resolved name. If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source. Returns: The resolved name or the source. \"\"\" if not self . _full : try : self . _full = self . _resolver () or self . source except NameResolutionError : # probably a built-in self . _full = self . source return self . _full","title":"full()"},{"location":"reference/griffe/importer/","text":"This module contains utilities to dynamically import objects. dynamic_import ( import_path ) \u00a4 Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path ( str ) \u2013 The path of the object to import. Raises: ImportError \u2013 When there was an error during import. Returns: Any \u2013 The imported object. Source code in griffe/importer.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def dynamic_import ( import_path : str ) -> Any : \"\"\"Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path: The path of the object to import. Raises: ImportError: When there was an error during import. Returns: The imported object. \"\"\" try : module = __import__ ( import_path , level = 0 ) except Exception as error : raise ImportError ( f \"Error while importing ' { import_path } ': { error } \" ) from error attr_parts = import_path . split ( \".\" )[ 1 :] value = module for part in attr_parts : value = getattr ( value , part ) return value","title":"importer"},{"location":"reference/griffe/importer/#griffe.importer.dynamic_import","text":"Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path ( str ) \u2013 The path of the object to import. Raises: ImportError \u2013 When there was an error during import. Returns: Any \u2013 The imported object. Source code in griffe/importer.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def dynamic_import ( import_path : str ) -> Any : \"\"\"Dynamically import the specified object. It can be a module, class, method, function, attribute, nested arbitrarily. Parameters: import_path: The path of the object to import. Raises: ImportError: When there was an error during import. Returns: The imported object. \"\"\" try : module = __import__ ( import_path , level = 0 ) except Exception as error : raise ImportError ( f \"Error while importing ' { import_path } ': { error } \" ) from error attr_parts = import_path . split ( \".\" )[ 1 :] value = module for part in attr_parts : value = getattr ( value , part ) return value","title":"dynamic_import()"},{"location":"reference/griffe/loader/","text":"This module contains the code allowing to find module and load their data. This is the entrypoint to use griffe programatically: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) NamePartsAndPathType = Tuple [ NamePartsType , Path ] \u00a4 NamePartsType = Tuple [ str , Ellipsis ] \u00a4 _accepted_py_module_extensions = [ '.py' , '.pyc' , '.pyo' , '.pyd' , '.so' ] \u00a4 _builtin_modules : set [ str ] = set ( sys . builtin_module_names ) \u00a4 _extensions_set = set ( _accepted_py_module_extensions ) \u00a4 logger = get_logger ( __name__ ) \u00a4 GriffeLoader \u00a4 The Griffe loader, allowing to load data from modules. Source code in griffe/loader.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 class GriffeLoader : \"\"\"The Griffe loader, allowing to load data from modules.\"\"\" def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () patch_ast () def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , try_relative_path : bool = True , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. try_relative_path: Whether to try finding the module as a relative path. Returns: A module. \"\"\" if module in _builtin_modules : logger . debug ( f \" { module } is a builtin module: inspecting\" ) module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : try : module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths , try_relative_path ) except ModuleNotFoundError : logger . debug ( f \"Could not find { module } : trying inspection\" ) module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : logger . debug ( f \"Found { module } : visiting\" ) top_module = self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index] def resolve_aliases ( # noqa: WPS231 self , only_exported : bool = True , only_known_modules : bool = True , max_iterations : int | None = None , ) -> tuple [ set [ str ], int ]: \"\"\"Resolve aliases. Parameters: only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. max_iterations: Maximum number of iterations on the loader modules collection. Returns: The unresolved aliases and the number of iterations done. \"\"\" if max_iterations is None : max_iterations = float ( \"inf\" ) # type: ignore[assignment] prev_unresolved : set [ str ] = set () unresolved : set [ str ] = set ( \"0\" ) # init to enter loop iterations = 0 collection = self . modules_collection . members while unresolved and unresolved != prev_unresolved and iterations < max_iterations : # type: ignore[operator] prev_unresolved = unresolved unresolved = set () iterations += 1 for module_name in list ( collection . keys ()): module = collection [ module_name ] unresolved |= self . resolve_module_aliases ( module , only_exported , only_known_modules ) logger . debug ( f \"Iteration { iterations } \" ) logger . debug ( f \"prev: { len ( prev_unresolved ) } ; current: { len ( unresolved ) } \" ) logger . debug ( \" \\n - \" + \" \\n - \" . join ( sorted ( unresolved & prev_unresolved ))) return unresolved , iterations def resolve_module_aliases ( # noqa: WPS231 self , obj : Object , only_exported : bool = True , only_known_modules : bool = True , seen : set | None = None , ) -> set [ str ]: \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. seen: Used to avoid infinite recursion. Returns: True if everything was resolved, False otherwise. \"\"\" unresolved = set () expanded = {} to_remove = [] seen = seen or set () seen . add ( obj . path ) # iterate a first time to expand wildcards for member in obj . members . values (): if member . is_alias and member . wildcard : # type: ignore[union-attr] # we know it's an alias package = member . wildcard . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] if obj . package . path != package and package not in self . modules_collection : try : self . load_module ( package , try_relative_path = False ) except ImportError as error : logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) else : expanded . update ( self . _expand_wildcard ( member )) # type: ignore[arg-type] to_remove . append ( member . name ) for name in to_remove : del obj [ name ] # noqa: WPS420 for new_member in expanded . values (): if new_member . is_alias and not new_member . wildcard : # type: ignore[union-attr] try : alias = Alias ( new_member . name , new_member . target ) # type: ignore[union-attr] except AliasResolutionError : alias = Alias ( new_member . name , new_member . _target_path ) # type: ignore[union-attr] # noqa: WPS437 except CyclicAliasError as error : # noqa: WPS440 logger . debug ( str ( error )) else : alias = Alias ( new_member . name , new_member ) obj [ new_member . name ] = alias # iterate a second time to resolve aliases and recurse for member in obj . members . values (): # noqa: WPS440 if member . is_alias : if member . wildcard or member . resolved : # type: ignore[union-attr] continue if only_exported and not member . is_explicitely_exported : continue try : member . resolve_target () # type: ignore[union-attr] except AliasResolutionError as error : # noqa: WPS440 path = member . path target = error . target_path # type: ignore[union-attr] # noqa: WPS437 logger . debug ( f \"Alias resolution error for { path } -> { target } \" ) unresolved . add ( path ) package = target . split ( \".\" , 1 )[ 0 ] load_module = ( not only_known_modules and obj . package . path != package and package not in self . modules_collection ) if load_module : try : # noqa: WPS505 self . load_module ( package , try_relative_path = False ) except ImportError as error : # noqa: WPS440 logger . debug ( f \"Could not follow alias { member . path } : { error } \" ) except CyclicAliasError as error : logger . debug ( str ( error )) else : logger . debug ( f \"Alias { member . path } was resolved to { member . target . path } \" ) # type: ignore[union-attr] elif member . kind in { Kind . MODULE , Kind . CLASS } and member . path not in seen : unresolved |= self . resolve_module_aliases ( member , only_exported , only_known_modules , seen ) # type: ignore[arg-type] return unresolved def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) if module_path . is_dir (): module = self . _create_module ( module_name , module_path ) elif module_path . suffix == \".py\" : code = module_path . read_text () module = self . _visit_module ( code , module_name , module_path , parent ) else : module = self . _inspect_module ( module_name , module_path , parent ) if submodules : self . _load_submodules ( module ) return module def _load_submodules ( self , module : Module ) -> None : for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ): self . _load_submodule ( module , subparts , subpath ) def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : try : member_parent = self . _member_parent ( module , subparts , subpath ) except UnimportableModuleError as error : logger . debug ( f \" { error } . Missing __init__ module?\" ) return try : # noqa: WPS225 member_parent [ subparts [ - 1 ]] = self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent ) except SyntaxError : message = traceback . format_exc ( limit = 0 ) . replace ( \"SyntaxError: invalid syntax\" , \"\" ) . strip () logger . error ( f \"Syntax error: { message } \" ) except ImportError as error : # noqa: WPS440 logger . error ( f \"Import error: { error } \" ) except UnicodeDecodeError as error : # noqa: WPS440 logger . error ( f \"UnicodeDecodeError when loading { subpath } : { error } \" ) except OSError as error : # noqa: WPS440 logger . error ( f \"OSError when loading { subpath } : { error } \" ) def _create_module ( self , module_name : str , module_path : Path ) -> Module : return Module ( module_name , filepath = module_path , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) def _visit_module ( self , code : str , module_name : str , module_path : Path , parent : Module | None = None ) -> Module : self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) return visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) def _inspect_module ( self , module_name : str , filepath : Path | None = None , parent : Module | None = None ) -> Module : try : return inspect ( module_name , filepath = filepath , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) except SystemExit as error : raise ImportError ( f \"Importing ' { module_name } ' raised a system exit\" ) from error def _member_parent ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> Module : parent_parts = subparts [: - 1 ] try : return module [ parent_parts ] except KeyError : if module . is_namespace_package or module . is_namespace_subpackage : member_parent = Module ( subparts [ 0 ], filepath = subpath . parent , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) module [ parent_parts ] = member_parent return member_parent raise UnimportableModuleError ( f \" { subpath } is not importable\" ) def _expand_wildcard ( self , wildcard_obj : Alias ) -> dict [ str , Object | Alias ]: module = self . modules_collection [ wildcard_obj . wildcard ] # type: ignore[index] # we know it's a wildcard explicitely = \"__all__\" in module . members return { name : imported_member for name , imported_member in module . members . items () if imported_member . is_exported ( explicitely = explicitely ) } docstring_options : dict [ str , Any ] = docstring_options or {} \u00a4 docstring_parser : Parser | None = docstring_parser \u00a4 extensions : Extensions = extensions or Extensions () \u00a4 lines_collection : LinesCollection = lines_collection or LinesCollection () \u00a4 modules_collection : ModulesCollection = modules_collection or ModulesCollection () \u00a4 __init__ ( self , extensions = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 Initialize the loader. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/loader.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () patch_ast () _create_module ( self , module_name , module_path ) \u00a4 Source code in griffe/loader.py 297 298 299 300 301 302 303 def _create_module ( self , module_name : str , module_path : Path ) -> Module : return Module ( module_name , filepath = module_path , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) _expand_wildcard ( self , wildcard_obj ) \u00a4 Source code in griffe/loader.py 349 350 351 352 353 354 355 356 def _expand_wildcard ( self , wildcard_obj : Alias ) -> dict [ str , Object | Alias ]: module = self . modules_collection [ wildcard_obj . wildcard ] # type: ignore[index] # we know it's a wildcard explicitely = \"__all__\" in module . members return { name : imported_member for name , imported_member in module . members . items () if imported_member . is_exported ( explicitely = explicitely ) } _inspect_module ( self , module_name , filepath = None , parent = None ) \u00a4 Source code in griffe/loader.py 319 320 321 322 323 324 325 326 327 328 329 330 331 def _inspect_module ( self , module_name : str , filepath : Path | None = None , parent : Module | None = None ) -> Module : try : return inspect ( module_name , filepath = filepath , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) except SystemExit as error : raise ImportError ( f \"Importing ' { module_name } ' raised a system exit\" ) from error _load_module_path ( self , module_name , module_path , submodules = True , parent = None ) \u00a4 Source code in griffe/loader.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) if module_path . is_dir (): module = self . _create_module ( module_name , module_path ) elif module_path . suffix == \".py\" : code = module_path . read_text () module = self . _visit_module ( code , module_name , module_path , parent ) else : module = self . _inspect_module ( module_name , module_path , parent ) if submodules : self . _load_submodules ( module ) return module _load_submodule ( self , module , subparts , subpath ) \u00a4 Source code in griffe/loader.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : try : member_parent = self . _member_parent ( module , subparts , subpath ) except UnimportableModuleError as error : logger . debug ( f \" { error } . Missing __init__ module?\" ) return try : # noqa: WPS225 member_parent [ subparts [ - 1 ]] = self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent ) except SyntaxError : message = traceback . format_exc ( limit = 0 ) . replace ( \"SyntaxError: invalid syntax\" , \"\" ) . strip () logger . error ( f \"Syntax error: { message } \" ) except ImportError as error : # noqa: WPS440 logger . error ( f \"Import error: { error } \" ) except UnicodeDecodeError as error : # noqa: WPS440 logger . error ( f \"UnicodeDecodeError when loading { subpath } : { error } \" ) except OSError as error : # noqa: WPS440 logger . error ( f \"OSError when loading { subpath } : { error } \" ) _load_submodules ( self , module ) \u00a4 Source code in griffe/loader.py 273 274 275 def _load_submodules ( self , module : Module ) -> None : for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ): self . _load_submodule ( module , subparts , subpath ) _member_parent ( self , module , subparts , subpath ) \u00a4 Source code in griffe/loader.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def _member_parent ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> Module : parent_parts = subparts [: - 1 ] try : return module [ parent_parts ] except KeyError : if module . is_namespace_package or module . is_namespace_subpackage : member_parent = Module ( subparts [ 0 ], filepath = subpath . parent , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) module [ parent_parts ] = member_parent return member_parent raise UnimportableModuleError ( f \" { subpath } is not importable\" ) _visit_module ( self , code , module_name , module_path , parent = None ) \u00a4 Source code in griffe/loader.py 305 306 307 308 309 310 311 312 313 314 315 316 317 def _visit_module ( self , code : str , module_name : str , module_path : Path , parent : Module | None = None ) -> Module : self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) return visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) load_module ( self , module , submodules = True , search_paths = None , try_relative_path = True ) \u00a4 Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. Returns: Module \u2013 A module. Source code in griffe/loader.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , try_relative_path : bool = True , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. try_relative_path: Whether to try finding the module as a relative path. Returns: A module. \"\"\" if module in _builtin_modules : logger . debug ( f \" { module } is a builtin module: inspecting\" ) module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : try : module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths , try_relative_path ) except ModuleNotFoundError : logger . debug ( f \"Could not find { module } : trying inspection\" ) module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : logger . debug ( f \"Found { module } : visiting\" ) top_module = self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index] resolve_aliases ( self , only_exported = True , only_known_modules = True , max_iterations = None ) \u00a4 Resolve aliases. Parameters: only_exported ( bool ) \u2013 When true, only try to resolve an alias if it is explicitely exported. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to resolve aliases. max_iterations ( int | None ) \u2013 Maximum number of iterations on the loader modules collection. Returns: tuple [ set [ str ], int ] \u2013 The unresolved aliases and the number of iterations done. Source code in griffe/loader.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def resolve_aliases ( # noqa: WPS231 self , only_exported : bool = True , only_known_modules : bool = True , max_iterations : int | None = None , ) -> tuple [ set [ str ], int ]: \"\"\"Resolve aliases. Parameters: only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. max_iterations: Maximum number of iterations on the loader modules collection. Returns: The unresolved aliases and the number of iterations done. \"\"\" if max_iterations is None : max_iterations = float ( \"inf\" ) # type: ignore[assignment] prev_unresolved : set [ str ] = set () unresolved : set [ str ] = set ( \"0\" ) # init to enter loop iterations = 0 collection = self . modules_collection . members while unresolved and unresolved != prev_unresolved and iterations < max_iterations : # type: ignore[operator] prev_unresolved = unresolved unresolved = set () iterations += 1 for module_name in list ( collection . keys ()): module = collection [ module_name ] unresolved |= self . resolve_module_aliases ( module , only_exported , only_known_modules ) logger . debug ( f \"Iteration { iterations } \" ) logger . debug ( f \"prev: { len ( prev_unresolved ) } ; current: { len ( unresolved ) } \" ) logger . debug ( \" \\n - \" + \" \\n - \" . join ( sorted ( unresolved & prev_unresolved ))) return unresolved , iterations resolve_module_aliases ( self , obj , only_exported = True , only_known_modules = True , seen = None ) \u00a4 Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 When true, only try to resolve an alias if it is explicitely exported. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to resolve aliases. seen ( set | None ) \u2013 Used to avoid infinite recursion. Returns: set [ str ] \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def resolve_module_aliases ( # noqa: WPS231 self , obj : Object , only_exported : bool = True , only_known_modules : bool = True , seen : set | None = None , ) -> set [ str ]: \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. seen: Used to avoid infinite recursion. Returns: True if everything was resolved, False otherwise. \"\"\" unresolved = set () expanded = {} to_remove = [] seen = seen or set () seen . add ( obj . path ) # iterate a first time to expand wildcards for member in obj . members . values (): if member . is_alias and member . wildcard : # type: ignore[union-attr] # we know it's an alias package = member . wildcard . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] if obj . package . path != package and package not in self . modules_collection : try : self . load_module ( package , try_relative_path = False ) except ImportError as error : logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) else : expanded . update ( self . _expand_wildcard ( member )) # type: ignore[arg-type] to_remove . append ( member . name ) for name in to_remove : del obj [ name ] # noqa: WPS420 for new_member in expanded . values (): if new_member . is_alias and not new_member . wildcard : # type: ignore[union-attr] try : alias = Alias ( new_member . name , new_member . target ) # type: ignore[union-attr] except AliasResolutionError : alias = Alias ( new_member . name , new_member . _target_path ) # type: ignore[union-attr] # noqa: WPS437 except CyclicAliasError as error : # noqa: WPS440 logger . debug ( str ( error )) else : alias = Alias ( new_member . name , new_member ) obj [ new_member . name ] = alias # iterate a second time to resolve aliases and recurse for member in obj . members . values (): # noqa: WPS440 if member . is_alias : if member . wildcard or member . resolved : # type: ignore[union-attr] continue if only_exported and not member . is_explicitely_exported : continue try : member . resolve_target () # type: ignore[union-attr] except AliasResolutionError as error : # noqa: WPS440 path = member . path target = error . target_path # type: ignore[union-attr] # noqa: WPS437 logger . debug ( f \"Alias resolution error for { path } -> { target } \" ) unresolved . add ( path ) package = target . split ( \".\" , 1 )[ 0 ] load_module = ( not only_known_modules and obj . package . path != package and package not in self . modules_collection ) if load_module : try : # noqa: WPS505 self . load_module ( package , try_relative_path = False ) except ImportError as error : # noqa: WPS440 logger . debug ( f \"Could not follow alias { member . path } : { error } \" ) except CyclicAliasError as error : logger . debug ( str ( error )) else : logger . debug ( f \"Alias { member . path } was resolved to { member . target . path } \" ) # type: ignore[union-attr] elif member . kind in { Kind . MODULE , Kind . CLASS } and member . path not in seen : unresolved |= self . resolve_module_aliases ( member , only_exported , only_known_modules , seen ) # type: ignore[arg-type] return unresolved _filter_py_modules ( path ) \u00a4 Source code in griffe/loader.py 524 525 526 527 528 529 530 def _filter_py_modules ( path : Path ) -> Iterator [ Path ]: for root , dirs , files in os . walk ( path , topdown = True ): # optimization: modify dirs in-place to exclude __pycache__ directories dirs [:] = [ dir for dir in dirs if dir != \"__pycache__\" ] # noqa: WPS362 for relfile in files : if os . path . splitext ( relfile )[ 1 ] in _extensions_set : yield Path ( root , relfile ) _get_async_reader () \u00a4 Source code in griffe/loader.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @lru_cache ( maxsize = 1 ) def _get_async_reader (): try : # noqa: WPS503 (false-positive) from aiofiles import open as aopen except ModuleNotFoundError : logger . warning ( \"aiofiles is not installed, fallback to blocking read\" ) async def _read_async ( path ): # noqa: WPS430 return path . read_text () else : async def _read_async ( path ): # noqa: WPS430,WPS440 async with aopen ( path ) as fd : return await fd . read () return _read_async _handle_pth_file ( path ) \u00a4 Source code in griffe/loader.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 def _handle_pth_file ( path ): # support for .pth files pointing to a directory instructions = path . read_text () . strip ( \" \\n \" ) . split ( \";\" ) filepaths = [ # TODO: handle .py[cod] and .so files? Path ( instructions [ 0 ], path . stem , \"__init__.py\" ), Path ( instructions [ 0 ], path . stem ), # namespace packages, try last ] for choice in filepaths : if choice . exists (): return choice # support for .pth files written by PDM, using editables module_name = path . stem if instructions [ 0 ] == f \"import _ { module_name } \" : editables_lines = path . with_name ( f \"_ { module_name } .py\" ) . read_text () . splitlines ( keepends = False ) # example line: F.map_module('griffe', '/media/data/dev/griffe/src/griffe/__init__.py') # TODO: write something more robust new_path = Path ( editables_lines [ - 1 ] . split ( \"'\" )[ 3 ]) if new_path . exists (): return new_path raise UnhandledPthFileError ( path ) _module_depth ( name_parts_and_path ) \u00a4 Source code in griffe/loader.py 572 573 def _module_depth ( name_parts_and_path : NamePartsAndPathType ) -> int : return len ( name_parts_and_path [ 0 ]) _module_name_path ( path ) \u00a4 Source code in griffe/loader.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def _module_name_path ( path : Path ) -> tuple [ str , Path ]: # noqa: WPS231 if path . is_dir (): for ext in _accepted_py_module_extensions : module_path = path / f \"__init__ { ext } \" if module_path . exists (): return path . name , module_path raise FileNotFoundError if path . exists (): if path . stem == \"__init__\" : if path . parent . is_absolute (): return path . parent . name , path return path . parent . resolve () . name , path return path . stem , path raise FileNotFoundError _top_name_and_path ( module , search_paths = None , try_relative_path = True ) \u00a4 Source code in griffe/loader.py 359 360 361 362 363 364 365 366 367 368 369 370 def _top_name_and_path ( module : str | Path , search_paths : Sequence [ str | Path ] | None = None , try_relative_path : bool = True , ) -> tuple [ str , str , Path ]: module_name , module_path = find_module_or_path ( module , search_paths , try_relative_path ) module_parts = module_name . split ( \".\" ) top_module_name = module_parts [ 0 ] top_module_path = module_path for _ in range ( len ( module_parts ) - 1 ): top_module_path = top_module_path . parent return module_name , top_module_name , top_module_path find_module ( module_name , search_paths = None ) \u00a4 Find a module in a given list of paths or in sys.path . Parameters: module_name ( str ) \u2013 The module name. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Raises: ModuleNotFoundError \u2013 When the module cannot be found. Returns: Path \u2013 The module file path. Source code in griffe/loader.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def find_module ( module_name : str , search_paths : Sequence [ str | Path ] | None = None ) -> Path : # noqa: WPS231 \"\"\"Find a module in a given list of paths or in `sys.path`. Parameters: module_name: The module name. search_paths: The paths to search into. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" # optimization: pre-compute Paths to relieve CPU when joining paths search = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] parts = module_name . split ( \".\" ) # always search a .pth file first using the first part for path in search : top_pth = Path ( f \" { parts [ 0 ] } .pth\" ) abs_top_pth = path / top_pth if abs_top_pth . exists (): with suppress ( UnhandledPthFileError ): location = _handle_pth_file ( abs_top_pth ) if location . suffix : location = location . parent search = [ location . parent ] # TODO: possible optimization # always break if exists? break # resume regular search filepaths = [ # TODO: handle .py[cod] and .so files? Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .pth\" ), Path ( * parts ), # namespace packages, try last ] for path in search : # noqa: WPS440 for choice in filepaths : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): if abs_path . name . endswith ( \".pth\" ): try : return _handle_pth_file ( abs_path ) except UnhandledPthFileError as error : raise ModuleNotFoundError ( module_name ) from error return abs_path raise ModuleNotFoundError ( module_name ) find_module_or_path ( module , search_paths = None , try_relative_path = True ) \u00a4 Find the name and path of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module ( str | Path ) \u2013 The module name or path. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError \u2013 When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist ModuleNotFoundError \u2013 When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file Returns: tuple [ str , Path ] \u2013 The name of the module (or package) and its path. Source code in griffe/loader.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 def find_module_or_path ( module : str | Path , search_paths : Sequence [ str | Path ] | None = None , try_relative_path : bool = True , ) -> tuple [ str , Path ]: \"\"\"Find the name and path of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module: The module name or path. search_paths: The paths to search into. try_relative_path: Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError: When a Path was passed and the module could not be found: - the directory has no `__init__.py` file in it - the path does not exist ModuleNotFoundError: When a string was passed and the module could not be found: - no `module/__init__.py` - no `module.py` - no `module.pth` - no `module` directory (namespace packages) - or unsupported .pth file Returns: The name of the module (or package) and its path. \"\"\" if isinstance ( module , Path ): # programatically passed a Path, try only that module_name , module_path = _module_name_path ( module ) elif try_relative_path : # passed a string (from CLI or Python code), try both try : module_name , module_path = _module_name_path ( Path ( module )) except FileNotFoundError : module_name = module module_path = find_module ( module_name , search_paths = search_paths ) else : module_name = module module_path = find_module ( module_name , search_paths = search_paths ) return module_name , module_path iter_submodules ( path ) \u00a4 Iterate on a module's submodules, if any. Parameters: path ( Path ) \u2013 The module path. Yields: name_parts ( tuple [ str , Ellipsis] ) \u2013 The parts of a submodule name. filepath ( Path ) \u2013 A submodule filepath. Source code in griffe/loader.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 def iter_submodules ( path : Path ) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS231,WPS234 \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. Yields: name_parts (tuple[str, ...]): The parts of a submodule name. filepath (Path): A submodule filepath. \"\"\" if path . stem == \"__init__\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix in _extensions_set : return for subpath in _filter_py_modules ( path ): rel_subpath = subpath . relative_to ( path ) py_file = rel_subpath . suffix == \".py\" stem = rel_subpath . stem if not py_file : # .py[cod] and .so files look like `name.cpython-38-x86_64-linux-gnu.ext` stem = stem . split ( \".\" , 1 )[ 0 ] if stem == \"__init__\" : # optimization: since it's a relative path, # if it has only one part and is named __init__, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath elif py_file : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath else : yield rel_subpath . with_name ( stem ) . parts , subpath","title":"loader"},{"location":"reference/griffe/loader/#griffe.loader.NamePartsAndPathType","text":"","title":"NamePartsAndPathType"},{"location":"reference/griffe/loader/#griffe.loader.NamePartsType","text":"","title":"NamePartsType"},{"location":"reference/griffe/loader/#griffe.loader._accepted_py_module_extensions","text":"","title":"_accepted_py_module_extensions"},{"location":"reference/griffe/loader/#griffe.loader._builtin_modules","text":"","title":"_builtin_modules"},{"location":"reference/griffe/loader/#griffe.loader._extensions_set","text":"","title":"_extensions_set"},{"location":"reference/griffe/loader/#griffe.loader.logger","text":"","title":"logger"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader","text":"The Griffe loader, allowing to load data from modules. Source code in griffe/loader.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 class GriffeLoader : \"\"\"The Griffe loader, allowing to load data from modules.\"\"\" def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () patch_ast () def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , try_relative_path : bool = True , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. try_relative_path: Whether to try finding the module as a relative path. Returns: A module. \"\"\" if module in _builtin_modules : logger . debug ( f \" { module } is a builtin module: inspecting\" ) module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : try : module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths , try_relative_path ) except ModuleNotFoundError : logger . debug ( f \"Could not find { module } : trying inspection\" ) module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : logger . debug ( f \"Found { module } : visiting\" ) top_module = self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index] def resolve_aliases ( # noqa: WPS231 self , only_exported : bool = True , only_known_modules : bool = True , max_iterations : int | None = None , ) -> tuple [ set [ str ], int ]: \"\"\"Resolve aliases. Parameters: only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. max_iterations: Maximum number of iterations on the loader modules collection. Returns: The unresolved aliases and the number of iterations done. \"\"\" if max_iterations is None : max_iterations = float ( \"inf\" ) # type: ignore[assignment] prev_unresolved : set [ str ] = set () unresolved : set [ str ] = set ( \"0\" ) # init to enter loop iterations = 0 collection = self . modules_collection . members while unresolved and unresolved != prev_unresolved and iterations < max_iterations : # type: ignore[operator] prev_unresolved = unresolved unresolved = set () iterations += 1 for module_name in list ( collection . keys ()): module = collection [ module_name ] unresolved |= self . resolve_module_aliases ( module , only_exported , only_known_modules ) logger . debug ( f \"Iteration { iterations } \" ) logger . debug ( f \"prev: { len ( prev_unresolved ) } ; current: { len ( unresolved ) } \" ) logger . debug ( \" \\n - \" + \" \\n - \" . join ( sorted ( unresolved & prev_unresolved ))) return unresolved , iterations def resolve_module_aliases ( # noqa: WPS231 self , obj : Object , only_exported : bool = True , only_known_modules : bool = True , seen : set | None = None , ) -> set [ str ]: \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. seen: Used to avoid infinite recursion. Returns: True if everything was resolved, False otherwise. \"\"\" unresolved = set () expanded = {} to_remove = [] seen = seen or set () seen . add ( obj . path ) # iterate a first time to expand wildcards for member in obj . members . values (): if member . is_alias and member . wildcard : # type: ignore[union-attr] # we know it's an alias package = member . wildcard . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] if obj . package . path != package and package not in self . modules_collection : try : self . load_module ( package , try_relative_path = False ) except ImportError as error : logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) else : expanded . update ( self . _expand_wildcard ( member )) # type: ignore[arg-type] to_remove . append ( member . name ) for name in to_remove : del obj [ name ] # noqa: WPS420 for new_member in expanded . values (): if new_member . is_alias and not new_member . wildcard : # type: ignore[union-attr] try : alias = Alias ( new_member . name , new_member . target ) # type: ignore[union-attr] except AliasResolutionError : alias = Alias ( new_member . name , new_member . _target_path ) # type: ignore[union-attr] # noqa: WPS437 except CyclicAliasError as error : # noqa: WPS440 logger . debug ( str ( error )) else : alias = Alias ( new_member . name , new_member ) obj [ new_member . name ] = alias # iterate a second time to resolve aliases and recurse for member in obj . members . values (): # noqa: WPS440 if member . is_alias : if member . wildcard or member . resolved : # type: ignore[union-attr] continue if only_exported and not member . is_explicitely_exported : continue try : member . resolve_target () # type: ignore[union-attr] except AliasResolutionError as error : # noqa: WPS440 path = member . path target = error . target_path # type: ignore[union-attr] # noqa: WPS437 logger . debug ( f \"Alias resolution error for { path } -> { target } \" ) unresolved . add ( path ) package = target . split ( \".\" , 1 )[ 0 ] load_module = ( not only_known_modules and obj . package . path != package and package not in self . modules_collection ) if load_module : try : # noqa: WPS505 self . load_module ( package , try_relative_path = False ) except ImportError as error : # noqa: WPS440 logger . debug ( f \"Could not follow alias { member . path } : { error } \" ) except CyclicAliasError as error : logger . debug ( str ( error )) else : logger . debug ( f \"Alias { member . path } was resolved to { member . target . path } \" ) # type: ignore[union-attr] elif member . kind in { Kind . MODULE , Kind . CLASS } and member . path not in seen : unresolved |= self . resolve_module_aliases ( member , only_exported , only_known_modules , seen ) # type: ignore[arg-type] return unresolved def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) if module_path . is_dir (): module = self . _create_module ( module_name , module_path ) elif module_path . suffix == \".py\" : code = module_path . read_text () module = self . _visit_module ( code , module_name , module_path , parent ) else : module = self . _inspect_module ( module_name , module_path , parent ) if submodules : self . _load_submodules ( module ) return module def _load_submodules ( self , module : Module ) -> None : for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ): self . _load_submodule ( module , subparts , subpath ) def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : try : member_parent = self . _member_parent ( module , subparts , subpath ) except UnimportableModuleError as error : logger . debug ( f \" { error } . Missing __init__ module?\" ) return try : # noqa: WPS225 member_parent [ subparts [ - 1 ]] = self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent ) except SyntaxError : message = traceback . format_exc ( limit = 0 ) . replace ( \"SyntaxError: invalid syntax\" , \"\" ) . strip () logger . error ( f \"Syntax error: { message } \" ) except ImportError as error : # noqa: WPS440 logger . error ( f \"Import error: { error } \" ) except UnicodeDecodeError as error : # noqa: WPS440 logger . error ( f \"UnicodeDecodeError when loading { subpath } : { error } \" ) except OSError as error : # noqa: WPS440 logger . error ( f \"OSError when loading { subpath } : { error } \" ) def _create_module ( self , module_name : str , module_path : Path ) -> Module : return Module ( module_name , filepath = module_path , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) def _visit_module ( self , code : str , module_name : str , module_path : Path , parent : Module | None = None ) -> Module : self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) return visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) def _inspect_module ( self , module_name : str , filepath : Path | None = None , parent : Module | None = None ) -> Module : try : return inspect ( module_name , filepath = filepath , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) except SystemExit as error : raise ImportError ( f \"Importing ' { module_name } ' raised a system exit\" ) from error def _member_parent ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> Module : parent_parts = subparts [: - 1 ] try : return module [ parent_parts ] except KeyError : if module . is_namespace_package or module . is_namespace_subpackage : member_parent = Module ( subparts [ 0 ], filepath = subpath . parent , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) module [ parent_parts ] = member_parent return member_parent raise UnimportableModuleError ( f \" { subpath } is not importable\" ) def _expand_wildcard ( self , wildcard_obj : Alias ) -> dict [ str , Object | Alias ]: module = self . modules_collection [ wildcard_obj . wildcard ] # type: ignore[index] # we know it's a wildcard explicitely = \"__all__\" in module . members return { name : imported_member for name , imported_member in module . members . items () if imported_member . is_exported ( explicitely = explicitely ) }","title":"GriffeLoader"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.docstring_options","text":"","title":"docstring_options"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.docstring_parser","text":"","title":"docstring_parser"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.extensions","text":"","title":"extensions"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.lines_collection","text":"","title":"lines_collection"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.modules_collection","text":"","title":"modules_collection"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.__init__","text":"Initialize the loader. Parameters: extensions ( Extensions | None ) \u2013 The extensions to use. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/loader.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , extensions : Extensions | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the loader. Parameters: extensions: The extensions to use. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" self . extensions : Extensions = extensions or Extensions () self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () patch_ast ()","title":"__init__()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader._create_module","text":"Source code in griffe/loader.py 297 298 299 300 301 302 303 def _create_module ( self , module_name : str , module_path : Path ) -> Module : return Module ( module_name , filepath = module_path , lines_collection = self . lines_collection , modules_collection = self . modules_collection , )","title":"_create_module()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader._expand_wildcard","text":"Source code in griffe/loader.py 349 350 351 352 353 354 355 356 def _expand_wildcard ( self , wildcard_obj : Alias ) -> dict [ str , Object | Alias ]: module = self . modules_collection [ wildcard_obj . wildcard ] # type: ignore[index] # we know it's a wildcard explicitely = \"__all__\" in module . members return { name : imported_member for name , imported_member in module . members . items () if imported_member . is_exported ( explicitely = explicitely ) }","title":"_expand_wildcard()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader._inspect_module","text":"Source code in griffe/loader.py 319 320 321 322 323 324 325 326 327 328 329 330 331 def _inspect_module ( self , module_name : str , filepath : Path | None = None , parent : Module | None = None ) -> Module : try : return inspect ( module_name , filepath = filepath , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , ) except SystemExit as error : raise ImportError ( f \"Importing ' { module_name } ' raised a system exit\" ) from error","title":"_inspect_module()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader._load_module_path","text":"Source code in griffe/loader.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def _load_module_path ( self , module_name : str , module_path : Path , submodules : bool = True , parent : Module | None = None , ) -> Module : logger . debug ( f \"Loading path { module_path } \" ) if module_path . is_dir (): module = self . _create_module ( module_name , module_path ) elif module_path . suffix == \".py\" : code = module_path . read_text () module = self . _visit_module ( code , module_name , module_path , parent ) else : module = self . _inspect_module ( module_name , module_path , parent ) if submodules : self . _load_submodules ( module ) return module","title":"_load_module_path()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader._load_submodule","text":"Source code in griffe/loader.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def _load_submodule ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> None : try : member_parent = self . _member_parent ( module , subparts , subpath ) except UnimportableModuleError as error : logger . debug ( f \" { error } . Missing __init__ module?\" ) return try : # noqa: WPS225 member_parent [ subparts [ - 1 ]] = self . _load_module_path ( subparts [ - 1 ], subpath , submodules = False , parent = member_parent ) except SyntaxError : message = traceback . format_exc ( limit = 0 ) . replace ( \"SyntaxError: invalid syntax\" , \"\" ) . strip () logger . error ( f \"Syntax error: { message } \" ) except ImportError as error : # noqa: WPS440 logger . error ( f \"Import error: { error } \" ) except UnicodeDecodeError as error : # noqa: WPS440 logger . error ( f \"UnicodeDecodeError when loading { subpath } : { error } \" ) except OSError as error : # noqa: WPS440 logger . error ( f \"OSError when loading { subpath } : { error } \" )","title":"_load_submodule()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader._load_submodules","text":"Source code in griffe/loader.py 273 274 275 def _load_submodules ( self , module : Module ) -> None : for subparts , subpath in sorted ( iter_submodules ( module . filepath ), key = _module_depth ): self . _load_submodule ( module , subparts , subpath )","title":"_load_submodules()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader._member_parent","text":"Source code in griffe/loader.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def _member_parent ( self , module : Module , subparts : NamePartsType , subpath : Path ) -> Module : parent_parts = subparts [: - 1 ] try : return module [ parent_parts ] except KeyError : if module . is_namespace_package or module . is_namespace_subpackage : member_parent = Module ( subparts [ 0 ], filepath = subpath . parent , lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) module [ parent_parts ] = member_parent return member_parent raise UnimportableModuleError ( f \" { subpath } is not importable\" )","title":"_member_parent()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader._visit_module","text":"Source code in griffe/loader.py 305 306 307 308 309 310 311 312 313 314 315 316 317 def _visit_module ( self , code : str , module_name : str , module_path : Path , parent : Module | None = None ) -> Module : self . lines_collection [ module_path ] = code . splitlines ( keepends = False ) return visit ( module_name , filepath = module_path , code = code , extensions = self . extensions , parent = parent , docstring_parser = self . docstring_parser , docstring_options = self . docstring_options , lines_collection = self . lines_collection , modules_collection = self . modules_collection , )","title":"_visit_module()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.load_module","text":"Load a module. Parameters: module ( str | Path ) \u2013 The module name or path. submodules ( bool ) \u2013 Whether to recurse on the submodules. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path. Returns: Module \u2013 A module. Source code in griffe/loader.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def load_module ( self , module : str | Path , submodules : bool = True , search_paths : Sequence [ str | Path ] | None = None , try_relative_path : bool = True , ) -> Module : \"\"\"Load a module. Parameters: module: The module name or path. submodules: Whether to recurse on the submodules. search_paths: The paths to search into. try_relative_path: Whether to try finding the module as a relative path. Returns: A module. \"\"\" if module in _builtin_modules : logger . debug ( f \" { module } is a builtin module: inspecting\" ) module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : try : module_name , top_module_name , top_module_path = _top_name_and_path ( module , search_paths , try_relative_path ) except ModuleNotFoundError : logger . debug ( f \"Could not find { module } : trying inspection\" ) module_name = module top_module = self . _inspect_module ( module ) # type: ignore[arg-type] else : logger . debug ( f \"Found { module } : visiting\" ) top_module = self . _load_module_path ( top_module_name , top_module_path , submodules = submodules ) self . modules_collection [ top_module . path ] = top_module return self . modules_collection [ module_name ] # type: ignore[index]","title":"load_module()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_aliases","text":"Resolve aliases. Parameters: only_exported ( bool ) \u2013 When true, only try to resolve an alias if it is explicitely exported. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to resolve aliases. max_iterations ( int | None ) \u2013 Maximum number of iterations on the loader modules collection. Returns: tuple [ set [ str ], int ] \u2013 The unresolved aliases and the number of iterations done. Source code in griffe/loader.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def resolve_aliases ( # noqa: WPS231 self , only_exported : bool = True , only_known_modules : bool = True , max_iterations : int | None = None , ) -> tuple [ set [ str ], int ]: \"\"\"Resolve aliases. Parameters: only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. max_iterations: Maximum number of iterations on the loader modules collection. Returns: The unresolved aliases and the number of iterations done. \"\"\" if max_iterations is None : max_iterations = float ( \"inf\" ) # type: ignore[assignment] prev_unresolved : set [ str ] = set () unresolved : set [ str ] = set ( \"0\" ) # init to enter loop iterations = 0 collection = self . modules_collection . members while unresolved and unresolved != prev_unresolved and iterations < max_iterations : # type: ignore[operator] prev_unresolved = unresolved unresolved = set () iterations += 1 for module_name in list ( collection . keys ()): module = collection [ module_name ] unresolved |= self . resolve_module_aliases ( module , only_exported , only_known_modules ) logger . debug ( f \"Iteration { iterations } \" ) logger . debug ( f \"prev: { len ( prev_unresolved ) } ; current: { len ( unresolved ) } \" ) logger . debug ( \" \\n - \" + \" \\n - \" . join ( sorted ( unresolved & prev_unresolved ))) return unresolved , iterations","title":"resolve_aliases()"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_module_aliases","text":"Follow aliases: try to recursively resolve all found aliases. Parameters: obj ( Object ) \u2013 The object and its members to recurse on. only_exported ( bool ) \u2013 When true, only try to resolve an alias if it is explicitely exported. only_known_modules ( bool ) \u2013 When true, don't try to load unspecified modules to resolve aliases. seen ( set | None ) \u2013 Used to avoid infinite recursion. Returns: set [ str ] \u2013 True if everything was resolved, False otherwise. Source code in griffe/loader.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def resolve_module_aliases ( # noqa: WPS231 self , obj : Object , only_exported : bool = True , only_known_modules : bool = True , seen : set | None = None , ) -> set [ str ]: \"\"\"Follow aliases: try to recursively resolve all found aliases. Parameters: obj: The object and its members to recurse on. only_exported: When true, only try to resolve an alias if it is explicitely exported. only_known_modules: When true, don't try to load unspecified modules to resolve aliases. seen: Used to avoid infinite recursion. Returns: True if everything was resolved, False otherwise. \"\"\" unresolved = set () expanded = {} to_remove = [] seen = seen or set () seen . add ( obj . path ) # iterate a first time to expand wildcards for member in obj . members . values (): if member . is_alias and member . wildcard : # type: ignore[union-attr] # we know it's an alias package = member . wildcard . split ( \".\" , 1 )[ 0 ] # type: ignore[union-attr] if obj . package . path != package and package not in self . modules_collection : try : self . load_module ( package , try_relative_path = False ) except ImportError as error : logger . debug ( f \"Could not expand wildcard import { member . name } in { obj . path } : { error } \" ) else : expanded . update ( self . _expand_wildcard ( member )) # type: ignore[arg-type] to_remove . append ( member . name ) for name in to_remove : del obj [ name ] # noqa: WPS420 for new_member in expanded . values (): if new_member . is_alias and not new_member . wildcard : # type: ignore[union-attr] try : alias = Alias ( new_member . name , new_member . target ) # type: ignore[union-attr] except AliasResolutionError : alias = Alias ( new_member . name , new_member . _target_path ) # type: ignore[union-attr] # noqa: WPS437 except CyclicAliasError as error : # noqa: WPS440 logger . debug ( str ( error )) else : alias = Alias ( new_member . name , new_member ) obj [ new_member . name ] = alias # iterate a second time to resolve aliases and recurse for member in obj . members . values (): # noqa: WPS440 if member . is_alias : if member . wildcard or member . resolved : # type: ignore[union-attr] continue if only_exported and not member . is_explicitely_exported : continue try : member . resolve_target () # type: ignore[union-attr] except AliasResolutionError as error : # noqa: WPS440 path = member . path target = error . target_path # type: ignore[union-attr] # noqa: WPS437 logger . debug ( f \"Alias resolution error for { path } -> { target } \" ) unresolved . add ( path ) package = target . split ( \".\" , 1 )[ 0 ] load_module = ( not only_known_modules and obj . package . path != package and package not in self . modules_collection ) if load_module : try : # noqa: WPS505 self . load_module ( package , try_relative_path = False ) except ImportError as error : # noqa: WPS440 logger . debug ( f \"Could not follow alias { member . path } : { error } \" ) except CyclicAliasError as error : logger . debug ( str ( error )) else : logger . debug ( f \"Alias { member . path } was resolved to { member . target . path } \" ) # type: ignore[union-attr] elif member . kind in { Kind . MODULE , Kind . CLASS } and member . path not in seen : unresolved |= self . resolve_module_aliases ( member , only_exported , only_known_modules , seen ) # type: ignore[arg-type] return unresolved","title":"resolve_module_aliases()"},{"location":"reference/griffe/loader/#griffe.loader._filter_py_modules","text":"Source code in griffe/loader.py 524 525 526 527 528 529 530 def _filter_py_modules ( path : Path ) -> Iterator [ Path ]: for root , dirs , files in os . walk ( path , topdown = True ): # optimization: modify dirs in-place to exclude __pycache__ directories dirs [:] = [ dir for dir in dirs if dir != \"__pycache__\" ] # noqa: WPS362 for relfile in files : if os . path . splitext ( relfile )[ 1 ] in _extensions_set : yield Path ( root , relfile )","title":"_filter_py_modules()"},{"location":"reference/griffe/loader/#griffe.loader._get_async_reader","text":"Source code in griffe/loader.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @lru_cache ( maxsize = 1 ) def _get_async_reader (): try : # noqa: WPS503 (false-positive) from aiofiles import open as aopen except ModuleNotFoundError : logger . warning ( \"aiofiles is not installed, fallback to blocking read\" ) async def _read_async ( path ): # noqa: WPS430 return path . read_text () else : async def _read_async ( path ): # noqa: WPS430,WPS440 async with aopen ( path ) as fd : return await fd . read () return _read_async","title":"_get_async_reader()"},{"location":"reference/griffe/loader/#griffe.loader._handle_pth_file","text":"Source code in griffe/loader.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 def _handle_pth_file ( path ): # support for .pth files pointing to a directory instructions = path . read_text () . strip ( \" \\n \" ) . split ( \";\" ) filepaths = [ # TODO: handle .py[cod] and .so files? Path ( instructions [ 0 ], path . stem , \"__init__.py\" ), Path ( instructions [ 0 ], path . stem ), # namespace packages, try last ] for choice in filepaths : if choice . exists (): return choice # support for .pth files written by PDM, using editables module_name = path . stem if instructions [ 0 ] == f \"import _ { module_name } \" : editables_lines = path . with_name ( f \"_ { module_name } .py\" ) . read_text () . splitlines ( keepends = False ) # example line: F.map_module('griffe', '/media/data/dev/griffe/src/griffe/__init__.py') # TODO: write something more robust new_path = Path ( editables_lines [ - 1 ] . split ( \"'\" )[ 3 ]) if new_path . exists (): return new_path raise UnhandledPthFileError ( path )","title":"_handle_pth_file()"},{"location":"reference/griffe/loader/#griffe.loader._module_depth","text":"Source code in griffe/loader.py 572 573 def _module_depth ( name_parts_and_path : NamePartsAndPathType ) -> int : return len ( name_parts_and_path [ 0 ])","title":"_module_depth()"},{"location":"reference/griffe/loader/#griffe.loader._module_name_path","text":"Source code in griffe/loader.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def _module_name_path ( path : Path ) -> tuple [ str , Path ]: # noqa: WPS231 if path . is_dir (): for ext in _accepted_py_module_extensions : module_path = path / f \"__init__ { ext } \" if module_path . exists (): return path . name , module_path raise FileNotFoundError if path . exists (): if path . stem == \"__init__\" : if path . parent . is_absolute (): return path . parent . name , path return path . parent . resolve () . name , path return path . stem , path raise FileNotFoundError","title":"_module_name_path()"},{"location":"reference/griffe/loader/#griffe.loader._top_name_and_path","text":"Source code in griffe/loader.py 359 360 361 362 363 364 365 366 367 368 369 370 def _top_name_and_path ( module : str | Path , search_paths : Sequence [ str | Path ] | None = None , try_relative_path : bool = True , ) -> tuple [ str , str , Path ]: module_name , module_path = find_module_or_path ( module , search_paths , try_relative_path ) module_parts = module_name . split ( \".\" ) top_module_name = module_parts [ 0 ] top_module_path = module_path for _ in range ( len ( module_parts ) - 1 ): top_module_path = top_module_path . parent return module_name , top_module_name , top_module_path","title":"_top_name_and_path()"},{"location":"reference/griffe/loader/#griffe.loader.find_module","text":"Find a module in a given list of paths or in sys.path . Parameters: module_name ( str ) \u2013 The module name. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. Raises: ModuleNotFoundError \u2013 When the module cannot be found. Returns: Path \u2013 The module file path. Source code in griffe/loader.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def find_module ( module_name : str , search_paths : Sequence [ str | Path ] | None = None ) -> Path : # noqa: WPS231 \"\"\"Find a module in a given list of paths or in `sys.path`. Parameters: module_name: The module name. search_paths: The paths to search into. Raises: ModuleNotFoundError: When the module cannot be found. Returns: The module file path. \"\"\" # optimization: pre-compute Paths to relieve CPU when joining paths search = [ path if isinstance ( path , Path ) else Path ( path ) for path in search_paths or sys . path ] parts = module_name . split ( \".\" ) # always search a .pth file first using the first part for path in search : top_pth = Path ( f \" { parts [ 0 ] } .pth\" ) abs_top_pth = path / top_pth if abs_top_pth . exists (): with suppress ( UnhandledPthFileError ): location = _handle_pth_file ( abs_top_pth ) if location . suffix : location = location . parent search = [ location . parent ] # TODO: possible optimization # always break if exists? break # resume regular search filepaths = [ # TODO: handle .py[cod] and .so files? Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .pth\" ), Path ( * parts ), # namespace packages, try last ] for path in search : # noqa: WPS440 for choice in filepaths : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): if abs_path . name . endswith ( \".pth\" ): try : return _handle_pth_file ( abs_path ) except UnhandledPthFileError as error : raise ModuleNotFoundError ( module_name ) from error return abs_path raise ModuleNotFoundError ( module_name )","title":"find_module()"},{"location":"reference/griffe/loader/#griffe.loader.find_module_or_path","text":"Find the name and path of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module ( str | Path ) \u2013 The module name or path. search_paths ( Sequence [ str | Path ] | None ) \u2013 The paths to search into. try_relative_path ( bool ) \u2013 Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError \u2013 When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist ModuleNotFoundError \u2013 When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file Returns: tuple [ str , Path ] \u2013 The name of the module (or package) and its path. Source code in griffe/loader.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 def find_module_or_path ( module : str | Path , search_paths : Sequence [ str | Path ] | None = None , try_relative_path : bool = True , ) -> tuple [ str , Path ]: \"\"\"Find the name and path of a module. If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths. Parameters: module: The module name or path. search_paths: The paths to search into. try_relative_path: Whether to try finding the module as a relative path, when the given module is not already a path. Raises: FileNotFoundError: When a Path was passed and the module could not be found: - the directory has no `__init__.py` file in it - the path does not exist ModuleNotFoundError: When a string was passed and the module could not be found: - no `module/__init__.py` - no `module.py` - no `module.pth` - no `module` directory (namespace packages) - or unsupported .pth file Returns: The name of the module (or package) and its path. \"\"\" if isinstance ( module , Path ): # programatically passed a Path, try only that module_name , module_path = _module_name_path ( module ) elif try_relative_path : # passed a string (from CLI or Python code), try both try : module_name , module_path = _module_name_path ( Path ( module )) except FileNotFoundError : module_name = module module_path = find_module ( module_name , search_paths = search_paths ) else : module_name = module module_path = find_module ( module_name , search_paths = search_paths ) return module_name , module_path","title":"find_module_or_path()"},{"location":"reference/griffe/loader/#griffe.loader.iter_submodules","text":"Iterate on a module's submodules, if any. Parameters: path ( Path ) \u2013 The module path. Yields: name_parts ( tuple [ str , Ellipsis] ) \u2013 The parts of a submodule name. filepath ( Path ) \u2013 A submodule filepath. Source code in griffe/loader.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 def iter_submodules ( path : Path ) -> Iterator [ NamePartsAndPathType ]: # noqa: WPS231,WPS234 \"\"\"Iterate on a module's submodules, if any. Parameters: path: The module path. Yields: name_parts (tuple[str, ...]): The parts of a submodule name. filepath (Path): A submodule filepath. \"\"\" if path . stem == \"__init__\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix in _extensions_set : return for subpath in _filter_py_modules ( path ): rel_subpath = subpath . relative_to ( path ) py_file = rel_subpath . suffix == \".py\" stem = rel_subpath . stem if not py_file : # .py[cod] and .so files look like `name.cpython-38-x86_64-linux-gnu.ext` stem = stem . split ( \".\" , 1 )[ 0 ] if stem == \"__init__\" : # optimization: since it's a relative path, # if it has only one part and is named __init__, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath elif py_file : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath else : yield rel_subpath . with_name ( stem ) . parts , subpath","title":"iter_submodules()"},{"location":"reference/griffe/logger/","text":"This module contains logging utilities. We provide the patch_loggers function so dependant libraries can patch loggers as they see fit. For example, to fit in the MkDocs logging configuration and prefix each log message with the module name: import logging from griffe.logger import patch_loggers class LoggerAdapter ( logging . LoggerAdapter ): def __init__ ( self , prefix , logger ): super () . __init__ ( logger , {}) self . prefix = prefix def process ( self , msg , kwargs ): return f \" { self . prefix } : { msg } \" , kwargs def get_logger ( name ): logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) return LoggerAdapter ( name , logger ) patch_loggers ( get_logger ) _Logger \u00a4 Source code in griffe/logger.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class _Logger : _default_logger : Any = logging . getLogger _instances : dict [ str , _Logger ] = {} def __init__ ( self , name : str ): # default logger that can be patched by third-party self . _logger = self . __class__ . _default_logger ( name ) # noqa: WPS437 # register instance self . _instances [ name ] = self def __getattr__ ( self , name : str ) -> Any : # forward everything to the logger return getattr ( self . _logger , name ) @classmethod def _patch_loggers ( cls , get_logger_func ): # patch current instances for name , instance in cls . _instances . items (): instance . _logger = get_logger_func ( name ) # noqa: WPS437 # future instances will be patched as well cls . _default_logger = get_logger_func _default_logger : Any = logging . getLogger \u00a4 _instances : dict [ str , _Logger ] = {} \u00a4 _logger = self . __class__ . _default_logger ( name ) \u00a4 __getattr__ ( self , name ) \u00a4 Source code in griffe/logger.py 48 49 50 def __getattr__ ( self , name : str ) -> Any : # forward everything to the logger return getattr ( self . _logger , name ) __init__ ( self , name ) \u00a4 Source code in griffe/logger.py 42 43 44 45 46 def __init__ ( self , name : str ): # default logger that can be patched by third-party self . _logger = self . __class__ . _default_logger ( name ) # noqa: WPS437 # register instance self . _instances [ name ] = self _patch_loggers ( cls , get_logger_func ) \u00a4 Source code in griffe/logger.py 52 53 54 55 56 57 58 @classmethod def _patch_loggers ( cls , get_logger_func ): # patch current instances for name , instance in cls . _instances . items (): instance . _logger = get_logger_func ( name ) # noqa: WPS437 # future instances will be patched as well cls . _default_logger = get_logger_func get_logger ( name ) \u00a4 Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: _Logger \u2013 The logger. Source code in griffe/logger.py 61 62 63 64 65 66 67 68 69 70 def get_logger ( name : str ) -> _Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return _Logger ( name ) patch_loggers ( get_logger_func ) \u00a4 Patch loggers. Parameters: get_logger_func ( Callable [[ str ], Any ] ) \u2013 A function accepting a name as parameter and returning a logger. Source code in griffe/logger.py 73 74 75 76 77 78 79 def patch_loggers ( get_logger_func : Callable [[ str ], Any ]) -> None : \"\"\"Patch loggers. Parameters: get_logger_func: A function accepting a name as parameter and returning a logger. \"\"\" _Logger . _patch_loggers ( get_logger_func ) # noqa: WPS437","title":"logger"},{"location":"reference/griffe/logger/#griffe.logger._Logger","text":"Source code in griffe/logger.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class _Logger : _default_logger : Any = logging . getLogger _instances : dict [ str , _Logger ] = {} def __init__ ( self , name : str ): # default logger that can be patched by third-party self . _logger = self . __class__ . _default_logger ( name ) # noqa: WPS437 # register instance self . _instances [ name ] = self def __getattr__ ( self , name : str ) -> Any : # forward everything to the logger return getattr ( self . _logger , name ) @classmethod def _patch_loggers ( cls , get_logger_func ): # patch current instances for name , instance in cls . _instances . items (): instance . _logger = get_logger_func ( name ) # noqa: WPS437 # future instances will be patched as well cls . _default_logger = get_logger_func","title":"_Logger"},{"location":"reference/griffe/logger/#griffe.logger._Logger._default_logger","text":"","title":"_default_logger"},{"location":"reference/griffe/logger/#griffe.logger._Logger._instances","text":"","title":"_instances"},{"location":"reference/griffe/logger/#griffe.logger._Logger._logger","text":"","title":"_logger"},{"location":"reference/griffe/logger/#griffe.logger._Logger.__getattr__","text":"Source code in griffe/logger.py 48 49 50 def __getattr__ ( self , name : str ) -> Any : # forward everything to the logger return getattr ( self . _logger , name )","title":"__getattr__()"},{"location":"reference/griffe/logger/#griffe.logger._Logger.__init__","text":"Source code in griffe/logger.py 42 43 44 45 46 def __init__ ( self , name : str ): # default logger that can be patched by third-party self . _logger = self . __class__ . _default_logger ( name ) # noqa: WPS437 # register instance self . _instances [ name ] = self","title":"__init__()"},{"location":"reference/griffe/logger/#griffe.logger._Logger._patch_loggers","text":"Source code in griffe/logger.py 52 53 54 55 56 57 58 @classmethod def _patch_loggers ( cls , get_logger_func ): # patch current instances for name , instance in cls . _instances . items (): instance . _logger = get_logger_func ( name ) # noqa: WPS437 # future instances will be patched as well cls . _default_logger = get_logger_func","title":"_patch_loggers()"},{"location":"reference/griffe/logger/#griffe.logger.get_logger","text":"Create and return a new logger instance. Parameters: name ( str ) \u2013 The logger name. Returns: _Logger \u2013 The logger. Source code in griffe/logger.py 61 62 63 64 65 66 67 68 69 70 def get_logger ( name : str ) -> _Logger : \"\"\"Create and return a new logger instance. Parameters: name: The logger name. Returns: The logger. \"\"\" return _Logger ( name )","title":"get_logger()"},{"location":"reference/griffe/logger/#griffe.logger.patch_loggers","text":"Patch loggers. Parameters: get_logger_func ( Callable [[ str ], Any ] ) \u2013 A function accepting a name as parameter and returning a logger. Source code in griffe/logger.py 73 74 75 76 77 78 79 def patch_loggers ( get_logger_func : Callable [[ str ], Any ]) -> None : \"\"\"Patch loggers. Parameters: get_logger_func: A function accepting a name as parameter and returning a logger. \"\"\" _Logger . _patch_loggers ( get_logger_func ) # noqa: WPS437","title":"patch_loggers()"},{"location":"reference/griffe/mixins/","text":"This module contains some mixins classes about accessing and setting members. DelMembersMixin \u00a4 This mixin adds a __delitem__ method to a class. Source code in griffe/mixins.py 41 42 43 44 45 46 47 48 49 50 class DelMembersMixin : \"\"\"This mixin adds a `__delitem__` method to a class.\"\"\" def __delitem__ ( self , key : str | Sequence [ str ]) -> None : # noqa: WPS603 parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] del self . members [ name ] # type: ignore[attr-defined] # noqa: WPS420 else : del self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined] # noqa: WPS420 __delitem__ ( self , key ) \u00a4 Source code in griffe/mixins.py 44 45 46 47 48 49 50 def __delitem__ ( self , key : str | Sequence [ str ]) -> None : # noqa: WPS603 parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] del self . members [ name ] # type: ignore[attr-defined] # noqa: WPS420 else : del self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined] # noqa: WPS420 GetMembersMixin \u00a4 This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance. Source code in griffe/mixins.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class GetMembersMixin : \"\"\"This mixin adds a `__getitem__` method to a class. It makes it easier to access members of an object. The method expects a `members` attribute/property to be available on the instance. \"\"\" def __getitem__ ( self , key : str | Sequence [ str ]) -> Any : if isinstance ( key , str ): if not key : return self parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : return self if len ( parts ) == 1 : return self . members [ parts [ 0 ]] # type: ignore[attr-defined] return self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined] __getitem__ ( self , key ) \u00a4 Source code in griffe/mixins.py 15 16 17 18 19 20 21 22 23 24 25 26 def __getitem__ ( self , key : str | Sequence [ str ]) -> Any : if isinstance ( key , str ): if not key : return self parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : return self if len ( parts ) == 1 : return self . members [ parts [ 0 ]] # type: ignore[attr-defined] return self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined] ObjectAliasMixin \u00a4 A mixin for methods that appear both in objects and aliases, unchanged. Source code in griffe/mixins.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 class ObjectAliasMixin : \"\"\"A mixin for methods that appear both in objects and aliases, unchanged.\"\"\" def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined] @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined] is_explicitely_exported ( self ) \u00a4 Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 111 112 113 114 115 116 117 118 @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) is_exported ( self , explicitely = True ) \u00a4 Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 100 101 102 103 104 105 106 107 108 109 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined] is_implicitely_exported ( self ) \u00a4 Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 120 121 122 123 124 125 126 127 @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined] SetCollectionMembersMixin ( DelMembersMixin ) \u00a4 This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its _modules_collection attribute is set as well. Source code in griffe/mixins.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class SetCollectionMembersMixin ( DelMembersMixin ): \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `_modules_collection` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] for alias in self . members [ name ] . aliases . values (): # type: ignore[attr-defined] alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . _modules_collection = self # noqa: WPS437 else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined] __setitem__ ( self , key , value ) \u00a4 Source code in griffe/mixins.py 84 85 86 87 88 89 90 91 92 93 94 def __setitem__ ( self , key : str | Sequence [ str ], value ): parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] for alias in self . members [ name ] . aliases . values (): # type: ignore[attr-defined] alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . _modules_collection = self # noqa: WPS437 else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined] SetMembersMixin ( DelMembersMixin ) \u00a4 This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well. Source code in griffe/mixins.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class SetMembersMixin ( DelMembersMixin ): \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `parent` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ) -> None : parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] member = self . members [ name ] # type: ignore[attr-defined] if not member . is_alias : for alias in member . aliases . values (): alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . parent = self else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined] __setitem__ ( self , key , value ) \u00a4 Source code in griffe/mixins.py 61 62 63 64 65 66 67 68 69 70 71 72 73 def __setitem__ ( self , key : str | Sequence [ str ], value ) -> None : parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] member = self . members [ name ] # type: ignore[attr-defined] if not member . is_alias : for alias in member . aliases . values (): alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . parent = self else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined] _get_parts ( key ) \u00a4 Source code in griffe/mixins.py 29 30 31 32 33 34 35 36 37 38 def _get_parts ( key : str | Sequence [ str ]) -> Sequence [ str ]: if isinstance ( key , str ): if not key : raise ValueError ( \"cannot set self (empty key)\" ) parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : raise ValueError ( \"cannot set self (empty parts)\" ) return parts","title":"mixins"},{"location":"reference/griffe/mixins/#griffe.mixins.DelMembersMixin","text":"This mixin adds a __delitem__ method to a class. Source code in griffe/mixins.py 41 42 43 44 45 46 47 48 49 50 class DelMembersMixin : \"\"\"This mixin adds a `__delitem__` method to a class.\"\"\" def __delitem__ ( self , key : str | Sequence [ str ]) -> None : # noqa: WPS603 parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] del self . members [ name ] # type: ignore[attr-defined] # noqa: WPS420 else : del self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined] # noqa: WPS420","title":"DelMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.DelMembersMixin.__delitem__","text":"Source code in griffe/mixins.py 44 45 46 47 48 49 50 def __delitem__ ( self , key : str | Sequence [ str ]) -> None : # noqa: WPS603 parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] del self . members [ name ] # type: ignore[attr-defined] # noqa: WPS420 else : del self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined] # noqa: WPS420","title":"__delitem__()"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin","text":"This mixin adds a __getitem__ method to a class. It makes it easier to access members of an object. The method expects a members attribute/property to be available on the instance. Source code in griffe/mixins.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class GetMembersMixin : \"\"\"This mixin adds a `__getitem__` method to a class. It makes it easier to access members of an object. The method expects a `members` attribute/property to be available on the instance. \"\"\" def __getitem__ ( self , key : str | Sequence [ str ]) -> Any : if isinstance ( key , str ): if not key : return self parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : return self if len ( parts ) == 1 : return self . members [ parts [ 0 ]] # type: ignore[attr-defined] return self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined]","title":"GetMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin.__getitem__","text":"Source code in griffe/mixins.py 15 16 17 18 19 20 21 22 23 24 25 26 def __getitem__ ( self , key : str | Sequence [ str ]) -> Any : if isinstance ( key , str ): if not key : return self parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : return self if len ( parts ) == 1 : return self . members [ parts [ 0 ]] # type: ignore[attr-defined] return self . members [ parts [ 0 ]][ parts [ 1 ]] # type: ignore[attr-defined]","title":"__getitem__()"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin","text":"A mixin for methods that appear both in objects and aliases, unchanged. Source code in griffe/mixins.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 class ObjectAliasMixin : \"\"\"A mixin for methods that appear both in objects and aliases, unchanged.\"\"\" def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined] @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True ) @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined]","title":"ObjectAliasMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_explicitely_exported","text":"Tell if this object/alias is explicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 111 112 113 114 115 116 117 118 @property def is_explicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is explicitely exported by its parent. Returns: True or False. \"\"\" return self . is_exported ( explicitely = True )","title":"is_explicitely_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_exported","text":"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely ( bool ) \u2013 Whether to only return True when __all__ is defined. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 100 101 102 103 104 105 106 107 108 109 def is_exported ( self , explicitely : bool = True ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Parameters: explicitely: Whether to only return True when `__all__` is defined. Returns: True or False. \"\"\" return self . parent . member_is_exported ( self , explicitely = explicitely ) # type: ignore[attr-defined]","title":"is_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_implicitely_exported","text":"Tell if this object/alias is implicitely exported by its parent. Returns: bool \u2013 True or False. Source code in griffe/mixins.py 120 121 122 123 124 125 126 127 @property def is_implicitely_exported ( self ) -> bool : \"\"\"Tell if this object/alias is implicitely exported by its parent. Returns: True or False. \"\"\" return self . parent . exports is None # type: ignore[attr-defined]","title":"is_implicitely_exported()"},{"location":"reference/griffe/mixins/#griffe.mixins.SetCollectionMembersMixin","text":"This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its _modules_collection attribute is set as well. Source code in griffe/mixins.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class SetCollectionMembersMixin ( DelMembersMixin ): \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `_modules_collection` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ): parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] for alias in self . members [ name ] . aliases . values (): # type: ignore[attr-defined] alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . _modules_collection = self # noqa: WPS437 else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined]","title":"SetCollectionMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.SetCollectionMembersMixin.__setitem__","text":"Source code in griffe/mixins.py 84 85 86 87 88 89 90 91 92 93 94 def __setitem__ ( self , key : str | Sequence [ str ], value ): parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] for alias in self . members [ name ] . aliases . values (): # type: ignore[attr-defined] alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . _modules_collection = self # noqa: WPS437 else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined]","title":"__setitem__()"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin","text":"This mixin adds a __setitem__ method to a class. It makes it easier to set members of an object. The method expects a members attribute/property to be available on the instance. Each time a member is set, its parent attribute is set as well. Source code in griffe/mixins.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class SetMembersMixin ( DelMembersMixin ): \"\"\"This mixin adds a `__setitem__` method to a class. It makes it easier to set members of an object. The method expects a `members` attribute/property to be available on the instance. Each time a member is set, its `parent` attribute is set as well. \"\"\" def __setitem__ ( self , key : str | Sequence [ str ], value ) -> None : parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] member = self . members [ name ] # type: ignore[attr-defined] if not member . is_alias : for alias in member . aliases . values (): alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . parent = self else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined]","title":"SetMembersMixin"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin.__setitem__","text":"Source code in griffe/mixins.py 61 62 63 64 65 66 67 68 69 70 71 72 73 def __setitem__ ( self , key : str | Sequence [ str ], value ) -> None : parts = _get_parts ( key ) if len ( parts ) == 1 : name = parts [ 0 ] if name in self . members : # type: ignore[attr-defined] member = self . members [ name ] # type: ignore[attr-defined] if not member . is_alias : for alias in member . aliases . values (): alias . target = value self . members [ name ] = value # type: ignore[attr-defined] value . parent = self else : self . members [ parts [ 0 ]][ parts [ 1 ]] = value # type: ignore[attr-defined]","title":"__setitem__()"},{"location":"reference/griffe/mixins/#griffe.mixins._get_parts","text":"Source code in griffe/mixins.py 29 30 31 32 33 34 35 36 37 38 def _get_parts ( key : str | Sequence [ str ]) -> Sequence [ str ]: if isinstance ( key , str ): if not key : raise ValueError ( \"cannot set self (empty key)\" ) parts = key . split ( \".\" , 1 ) else : parts = list ( key ) if not parts : raise ValueError ( \"cannot set self (empty parts)\" ) return parts","title":"_get_parts()"},{"location":"reference/griffe/agents/","text":"These modules contain the different agents that are able to extract data.","title":"agents"},{"location":"reference/griffe/agents/base/","text":"This module contains the base classes for dealing with extensions. BaseInspector \u00a4 The base class for inspectors. Source code in griffe/agents/base.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class BaseInspector : \"\"\"The base class for inspectors.\"\"\" def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node ) def generic_inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\" generic_inspect ( self , node ) \u00a4 Inspect the children of a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect (its children). Source code in griffe/agents/base.py 40 41 42 43 44 45 def generic_inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\" inspect ( self , node ) \u00a4 Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/base.py 32 33 34 35 36 37 38 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node ) BaseVisitor \u00a4 The base class for visitors. Source code in griffe/agents/base.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class BaseVisitor : \"\"\"The base class for visitors.\"\"\" def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined] def generic_visit ( self , node : ast . AST ) -> None : \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\" generic_visit ( self , node ) \u00a4 Visit the children of a node. Parameters: node ( ast . AST ) \u2013 The node to visit (its children). Source code in griffe/agents/base.py 21 22 23 24 25 26 def generic_visit ( self , node : ast . AST ) -> None : \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\" visit ( self , node ) \u00a4 Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/base.py 13 14 15 16 17 18 19 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined]","title":"base"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector","text":"The base class for inspectors. Source code in griffe/agents/base.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class BaseInspector : \"\"\"The base class for inspectors.\"\"\" def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node ) def generic_inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\"","title":"BaseInspector"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.generic_inspect","text":"Inspect the children of a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect (its children). Source code in griffe/agents/base.py 40 41 42 43 44 45 def generic_inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect the children of a node. Parameters: node: The node to inspect (its children). \"\"\"","title":"generic_inspect()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.inspect","text":"Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/base.py 32 33 34 35 36 37 38 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , self . generic_inspect )( node )","title":"inspect()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor","text":"The base class for visitors. Source code in griffe/agents/base.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class BaseVisitor : \"\"\"The base class for visitors.\"\"\" def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined] def generic_visit ( self , node : ast . AST ) -> None : \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\"","title":"BaseVisitor"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.generic_visit","text":"Visit the children of a node. Parameters: node ( ast . AST ) \u2013 The node to visit (its children). Source code in griffe/agents/base.py 21 22 23 24 25 26 def generic_visit ( self , node : ast . AST ) -> None : \"\"\"Visit the children of a node. Parameters: node: The node to visit (its children). \"\"\"","title":"generic_visit()"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.visit","text":"Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/base.py 13 14 15 16 17 18 19 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , self . generic_visit )( node ) # type: ignore[attr-defined]","title":"visit()"},{"location":"reference/griffe/agents/inspector/","text":"This module defines introspection mechanisms. Sometimes we cannot get the source code of a module or an object, typically built-in modules like itertools . The only way to know what they are made of is to actually import them and inspect their contents. Sometimes, even if the source code is available, loading the object is desired because it was created or modified dynamically, and our node visitor is not powerful enough to infer all these dynamic modifications. In this case, we always try to visit the code first, and only then we load the object to update the data with introspection. This module exposes a public function, inspect() , which inspects the module using inspect.getmembers() , and returns a new Module instance, populating its members recursively, by using a NodeVisitor -like class. The inspection agent works similarly to the regular \"node visitor\" agent, in that it maintains a state with the current object being handled, and recursively handle its members. _kind_map = { SignatureParameter . POSITIONAL_ONLY : ParameterKind . positional_only , SignatureParameter . POSITIONAL_OR_KEYWORD : ParameterKind . positional_or_keyword , SignatureParameter . VAR_POSITIONAL : ParameterKind . var_positional , SignatureParameter . KEYWORD_ONLY : ParameterKind . keyword_only , SignatureParameter . VAR_KEYWORD : ParameterKind . var_keyword } \u00a4 empty = Signature . empty \u00a4 Inspector ( BaseInspector ) \u00a4 This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. Source code in griffe/agents/inspector.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 class Inspector ( BaseInspector ): # noqa: WPS338 \"\"\"This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. \"\"\" def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () def _get_docstring ( self , node : ObjectNode ) -> Docstring | None : value = getdoc ( node . obj ) if value is None : return None return Docstring ( value , parser = self . docstring_parser , parser_options = self . docstring_options , ) def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: A module instance. \"\"\" import_path = self . module_name if self . parent is not None : import_path = f \" { self . parent . path } . { import_path } \" value = dynamic_import ( import_path ) top_node = ObjectNode ( value , self . module_name ) self . inspect ( top_node ) return self . current . module def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node ) def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) for child in node . children : child_module = getmodule ( child . obj ) child_module_path = getattr ( child_module , \"__name__\" , None ) use_alias = ( child_module_path and child_module_path != self . current . module . path and not _force_inspect ( node . name , child_module_path ) ) if use_alias : if child_module is child . obj : target_path : str = child_module_path # type: ignore[assignment] else : child_name = getattr ( child . obj , \"__name__\" , child . name ) target_path = f \" { child_module_path } . { child_name } \" self . current [ child . name ] = Alias ( child . name , target_path ) else : self . inspect ( child ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node ) def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node ) def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment] def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" }) def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" }) def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" }) def inspect_builtin_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" }) def inspect_builtin_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" }) def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" }) def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ( AttributeError , ValueError , TokenError , TypeError ): parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter , parent = self . current ) for parameter in signature . parameters . values ()] ) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = _convert_object_to_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node ) def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO: to improve parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) try : value = repr ( node . obj ) except Exception : # could trigger anything value = None docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj ) current : Module | Class = None \u00a4 docstring_options : dict [ str , Any ] = docstring_options or {} \u00a4 docstring_parser : Parser | None = docstring_parser \u00a4 extensions : Extensions = extensions . attach_inspector ( self ) \u00a4 filepath : Path | None = filepath \u00a4 lines_collection : LinesCollection = lines_collection or LinesCollection () \u00a4 module_name : str = module_name \u00a4 parent : Module | None = parent \u00a4 __init__ ( self , module_name , filepath , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None ) \u00a4 Initialize the inspector. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path | None ) \u2013 The optional filepath. extensions ( Extensions ) \u2013 Extensions to use when inspecting. parent ( Module | None ) \u2013 The module parent. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Source code in griffe/agents/inspector.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () _get_docstring ( self , node ) \u00a4 Source code in griffe/agents/inspector.py 142 143 144 145 146 147 148 149 150 def _get_docstring ( self , node : ObjectNode ) -> Docstring | None : value = getdoc ( node . obj ) if value is None : return None return Docstring ( value , parser = self . docstring_parser , parser_options = self . docstring_options , ) generic_inspect ( self , node ) \u00a4 Extend the base generic inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) for child in node . children : child_module = getmodule ( child . obj ) child_module_path = getattr ( child_module , \"__name__\" , None ) use_alias = ( child_module_path and child_module_path != self . current . module . path and not _force_inspect ( node . name , child_module_path ) ) if use_alias : if child_module is child . obj : target_path : str = child_module_path # type: ignore[assignment] else : child_name = getattr ( child . obj , \"__name__\" , child . name ) target_path = f \" { child_module_path } . { child_name } \" self . current [ child . name ] = Alias ( child . name , target_path ) else : self . inspect ( child ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node ) get_module ( self ) \u00a4 Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: Module \u2013 A module instance. Source code in griffe/agents/inspector.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: A module instance. \"\"\" import_path = self . module_name if self . parent is not None : import_path = f \" { self . parent . path } . { import_path } \" value = dynamic_import ( import_path ) top_node = ObjectNode ( value , self . module_name ) self . inspect ( top_node ) return self . current . module handle_attribute ( self , node , annotation = None ) \u00a4 Handle an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. annotation ( str | Name | Expression | None ) \u2013 A potentiel annotation. Source code in griffe/agents/inspector.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO: to improve parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) try : value = repr ( node . obj ) except Exception : # could trigger anything value = None docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj ) handle_function ( self , node , labels = None ) \u00a4 Handle a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/inspector.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ( AttributeError , ValueError , TokenError , TypeError ): parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter , parent = self . current ) for parameter in signature . parameters . values ()] ) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = _convert_object_to_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function inspect ( self , node ) \u00a4 Extend the base inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 168 169 170 171 172 173 174 175 176 177 178 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node ) inspect_attribute ( self , node ) \u00a4 Inspect an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 356 357 358 359 360 361 362 def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node ) inspect_builtin_function ( self , node ) \u00a4 Inspect a builtin function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 292 293 294 295 296 297 298 def inspect_builtin_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) inspect_builtin_method ( self , node ) \u00a4 Inspect a builtin method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 268 269 270 271 272 273 274 def inspect_builtin_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) inspect_cached_property ( self , node ) \u00a4 Inspect a cached property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 308 309 310 311 312 313 314 def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" }) inspect_class ( self , node ) \u00a4 Inspect a class. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment] inspect_classmethod ( self , node ) \u00a4 Inspect a class method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 252 253 254 255 256 257 258 def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" }) inspect_coroutine ( self , node ) \u00a4 Inspect a coroutine. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 284 285 286 287 288 289 290 def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" }) inspect_function ( self , node ) \u00a4 Inspect a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 300 301 302 303 304 305 306 def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) inspect_method ( self , node ) \u00a4 Inspect a method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 276 277 278 279 280 281 282 def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) inspect_method_descriptor ( self , node ) \u00a4 Inspect a method descriptor. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 260 261 262 263 264 265 266 def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" }) inspect_module ( self , node ) \u00a4 Inspect a module. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node ) inspect_property ( self , node ) \u00a4 Inspect a property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 316 317 318 319 320 321 322 def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" }) inspect_staticmethod ( self , node ) \u00a4 Inspect a static method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 244 245 246 247 248 249 250 def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" }) _convert_object_to_annotation ( obj , parent ) \u00a4 Source code in griffe/agents/inspector.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def _convert_object_to_annotation ( obj , parent ): # even when *we* import future annotations, # the object from which we get a signature # can come from modules which did *not* import them, # so inspect.signature returns actual Python objects # that we must deal with if not isinstance ( obj , str ): if hasattr ( obj , \"__name__\" ): # simple types like int, str, custom classes, etc. obj = obj . __name__ else : # other, more complex types: hope for the best obj = repr ( obj ) try : annotation_node = compile ( obj , mode = \"eval\" , filename = \"<>\" , flags = ast . PyCF_ONLY_AST , optimize = 2 ) except SyntaxError : return obj return get_annotation ( annotation_node . body , parent = parent ) _convert_parameter ( parameter , parent ) \u00a4 Source code in griffe/agents/inspector.py 415 416 417 418 419 420 421 422 423 424 425 426 def _convert_parameter ( parameter , parent ): name = parameter . name if parameter . annotation is empty : annotation = None else : annotation = _convert_object_to_annotation ( parameter . annotation , parent = parent ) kind = _kind_map [ parameter . kind ] if parameter . default is empty : default = None else : default = repr ( parameter . default ) return Parameter ( name , annotation = annotation , kind = kind , default = default ) _force_inspect ( parent_module , child_module ) \u00a4 Source code in griffe/agents/inspector.py 91 92 93 94 95 96 97 98 99 100 101 102 def _force_inspect ( parent_module , child_module ): # Special case for builtin modules, example: # - `ast` does `from _ast import *` # - so we go and inspect `_ast` # - when iterating on its child, as usual, we check each child's real module # thanks to `inspect.getmodule` # - but in that case, `inspect.getmodule` returns `ast` for the children # - it puts us in a cycle # - so we break the cycle by ignoring inspect's result and inspecting the private module if parent_module . startswith ( \"_\" ): return parent_module [ 1 :] == child_module and parent_module in sys . builtin_module_names return False inspect ( module_name , * , filepath = None , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None ) \u00a4 Inspect a module. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path | None ) \u2013 The module file path. extensions ( Extensions | None ) \u2013 The extensions to use when inspecting the module. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/inspector.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def inspect ( module_name : str , * , filepath : Path | None = None , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Inspect a module. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. extensions: The extensions to use when inspecting the module. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" return Inspector ( module_name , filepath , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ()","title":"inspector"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector._kind_map","text":"","title":"_kind_map"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.empty","text":"","title":"empty"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector","text":"This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. Source code in griffe/agents/inspector.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 class Inspector ( BaseInspector ): # noqa: WPS338 \"\"\"This class is used to instantiate an inspector. Inspectors iterate on objects members to extract data from them. \"\"\" def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () def _get_docstring ( self , node : ObjectNode ) -> Docstring | None : value = getdoc ( node . obj ) if value is None : return None return Docstring ( value , parser = self . docstring_parser , parser_options = self . docstring_options , ) def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: A module instance. \"\"\" import_path = self . module_name if self . parent is not None : import_path = f \" { self . parent . path } . { import_path } \" value = dynamic_import ( import_path ) top_node = ObjectNode ( value , self . module_name ) self . inspect ( top_node ) return self . current . module def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node ) def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) for child in node . children : child_module = getmodule ( child . obj ) child_module_path = getattr ( child_module , \"__name__\" , None ) use_alias = ( child_module_path and child_module_path != self . current . module . path and not _force_inspect ( node . name , child_module_path ) ) if use_alias : if child_module is child . obj : target_path : str = child_module_path # type: ignore[assignment] else : child_name = getattr ( child . obj , \"__name__\" , child . name ) target_path = f \" { child_module_path } . { child_name } \" self . current [ child . name ] = Alias ( child . name , target_path ) else : self . inspect ( child ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node ) def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node ) def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment] def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" }) def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" }) def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" }) def inspect_builtin_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" }) def inspect_builtin_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" }) def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node ) def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" }) def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" }) def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ( AttributeError , ValueError , TokenError , TypeError ): parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter , parent = self . current ) for parameter in signature . parameters . values ()] ) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = _convert_object_to_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node ) def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO: to improve parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) try : value = repr ( node . obj ) except Exception : # could trigger anything value = None docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj )","title":"Inspector"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.current","text":"","title":"current"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.docstring_options","text":"","title":"docstring_options"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.docstring_parser","text":"","title":"docstring_parser"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.extensions","text":"","title":"extensions"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.filepath","text":"","title":"filepath"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.lines_collection","text":"","title":"lines_collection"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.module_name","text":"","title":"module_name"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.parent","text":"","title":"parent"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.__init__","text":"Initialize the inspector. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path | None ) \u2013 The optional filepath. extensions ( Extensions ) \u2013 Extensions to use when inspecting. parent ( Module | None ) \u2013 The module parent. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Source code in griffe/agents/inspector.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self , module_name : str , filepath : Path | None , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> None : \"\"\"Initialize the inspector. Parameters: module_name: The module name. filepath: The optional filepath. extensions: Extensions to use when inspecting. parent: The module parent. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path | None = filepath self . extensions : Extensions = extensions . attach_inspector ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection ()","title":"__init__()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector._get_docstring","text":"Source code in griffe/agents/inspector.py 142 143 144 145 146 147 148 149 150 def _get_docstring ( self , node : ObjectNode ) -> Docstring | None : value = getdoc ( node . obj ) if value is None : return None return Docstring ( value , parser = self . docstring_parser , parser_options = self . docstring_options , )","title":"_get_docstring()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.generic_inspect","text":"Extend the base generic inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def generic_inspect ( self , node : ObjectNode ) -> None : # noqa: WPS231 \"\"\"Extend the base generic inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_children_inspection : before_inspector . inspect ( node ) for child in node . children : child_module = getmodule ( child . obj ) child_module_path = getattr ( child_module , \"__name__\" , None ) use_alias = ( child_module_path and child_module_path != self . current . module . path and not _force_inspect ( node . name , child_module_path ) ) if use_alias : if child_module is child . obj : target_path : str = child_module_path # type: ignore[assignment] else : child_name = getattr ( child . obj , \"__name__\" , child . name ) target_path = f \" { child_module_path } . { child_name } \" self . current [ child . name ] = Alias ( child . name , target_path ) else : self . inspect ( child ) for after_inspector in self . extensions . after_children_inspection : after_inspector . inspect ( node )","title":"generic_inspect()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.get_module","text":"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: Module \u2013 A module instance. Source code in griffe/agents/inspector.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this inspector. This method triggers a complete inspection of the module members. Returns: A module instance. \"\"\" import_path = self . module_name if self . parent is not None : import_path = f \" { self . parent . path } . { import_path } \" value = dynamic_import ( import_path ) top_node = ObjectNode ( value , self . module_name ) self . inspect ( top_node ) return self . current . module","title":"get_module()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_attribute","text":"Handle an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. annotation ( str | Name | Expression | None ) \u2013 A potentiel annotation. Source code in griffe/agents/inspector.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def handle_attribute ( self , node : ObjectNode , annotation : str | Name | Expression | None = None ): # noqa: WPS231 \"\"\"Handle an attribute. Parameters: node: The node to inspect. annotation: A potentiel annotation. \"\"\" # TODO: to improve parent = self . current labels : set [ str ] = set () if parent . kind is ObjectKind . MODULE : labels . add ( \"module\" ) elif parent . kind is ObjectKind . CLASS : labels . add ( \"class\" ) elif parent . kind is ObjectKind . FUNCTION : if parent . name != \"__init__\" : return parent = parent . parent labels . add ( \"instance\" ) try : value = repr ( node . obj ) except Exception : # could trigger anything value = None docstring = self . _get_docstring ( node ) attribute = Attribute ( name = node . name , value = value , annotation = annotation , # lineno=node.lineno, # endlineno=node.end_lineno, docstring = docstring , ) attribute . labels |= labels parent [ node . name ] = attribute if node . name == \"__all__\" : parent . exports = set ( node . obj )","title":"handle_attribute()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_function","text":"Handle a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/inspector.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def handle_function ( self , node : ObjectNode , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function. Parameters: node: The node to inspect. labels: Labels to add to the data object. \"\"\" try : signature = getsignature ( node . obj ) except ( AttributeError , ValueError , TokenError , TypeError ): parameters = None returns = None else : parameters = Parameters ( * [ _convert_parameter ( parameter , parent = self . current ) for parameter in signature . parameters . values ()] ) return_annotation = signature . return_annotation if return_annotation is empty : returns = None else : returns = _convert_object_to_annotation ( return_annotation , parent = self . current ) function = Function ( name = node . name , parameters = parameters , returns = returns , docstring = self . _get_docstring ( node ), ) if labels : function . labels |= labels self . current [ node . name ] = function","title":"handle_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect","text":"Extend the base inspection with extensions. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 168 169 170 171 172 173 174 175 176 177 178 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Extend the base inspection with extensions. Parameters: node: The node to inspect. \"\"\" for before_inspector in self . extensions . before_inspection : before_inspector . inspect ( node ) super () . inspect ( node ) for after_inspector in self . extensions . after_inspection : after_inspector . inspect ( node )","title":"inspect()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_attribute","text":"Inspect an attribute. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 356 357 358 359 360 361 362 def inspect_attribute ( self , node : ObjectNode ) -> None : \"\"\"Inspect an attribute. Parameters: node: The node to inspect. \"\"\" self . handle_attribute ( node )","title":"inspect_attribute()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_function","text":"Inspect a builtin function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 292 293 294 295 296 297 298 def inspect_builtin_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" })","title":"inspect_builtin_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_method","text":"Inspect a builtin method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 268 269 270 271 272 273 274 def inspect_builtin_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a builtin method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"builtin\" })","title":"inspect_builtin_method()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_cached_property","text":"Inspect a cached property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 308 309 310 311 312 313 314 def inspect_cached_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a cached property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"cached property\" })","title":"inspect_cached_property()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_class","text":"Inspect a class. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def inspect_class ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class. Parameters: node: The node to inspect. \"\"\" bases = [ base . __name__ for base in node . obj . __bases__ if base is not object ] # noqa: WPS609 class_ = Class ( name = node . name , docstring = self . _get_docstring ( node ), bases = bases , ) self . current [ node . name ] = class_ self . current = class_ self . generic_inspect ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"inspect_class()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_classmethod","text":"Inspect a class method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 252 253 254 255 256 257 258 def inspect_classmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a class method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"staticmethod\" })","title":"inspect_classmethod()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_coroutine","text":"Inspect a coroutine. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 284 285 286 287 288 289 290 def inspect_coroutine ( self , node : ObjectNode ) -> None : \"\"\"Inspect a coroutine. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"async\" })","title":"inspect_coroutine()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_function","text":"Inspect a function. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 300 301 302 303 304 305 306 def inspect_function ( self , node : ObjectNode ) -> None : \"\"\"Inspect a function. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node )","title":"inspect_function()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method","text":"Inspect a method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 276 277 278 279 280 281 282 def inspect_method ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node )","title":"inspect_method()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method_descriptor","text":"Inspect a method descriptor. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 260 261 262 263 264 265 266 def inspect_method_descriptor ( self , node : ObjectNode ) -> None : \"\"\"Inspect a method descriptor. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"method descriptor\" })","title":"inspect_method_descriptor()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_module","text":"Inspect a module. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def inspect_module ( self , node : ObjectNode ) -> None : \"\"\"Inspect a module. Parameters: node: The node to inspect. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , ) self . generic_inspect ( node )","title":"inspect_module()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_property","text":"Inspect a property. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 316 317 318 319 320 321 322 def inspect_property ( self , node : ObjectNode ) -> None : \"\"\"Inspect a property. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"property\" })","title":"inspect_property()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_staticmethod","text":"Inspect a static method. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/inspector.py 244 245 246 247 248 249 250 def inspect_staticmethod ( self , node : ObjectNode ) -> None : \"\"\"Inspect a static method. Parameters: node: The node to inspect. \"\"\" self . handle_function ( node , { \"classmethod\" })","title":"inspect_staticmethod()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector._convert_object_to_annotation","text":"Source code in griffe/agents/inspector.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def _convert_object_to_annotation ( obj , parent ): # even when *we* import future annotations, # the object from which we get a signature # can come from modules which did *not* import them, # so inspect.signature returns actual Python objects # that we must deal with if not isinstance ( obj , str ): if hasattr ( obj , \"__name__\" ): # simple types like int, str, custom classes, etc. obj = obj . __name__ else : # other, more complex types: hope for the best obj = repr ( obj ) try : annotation_node = compile ( obj , mode = \"eval\" , filename = \"<>\" , flags = ast . PyCF_ONLY_AST , optimize = 2 ) except SyntaxError : return obj return get_annotation ( annotation_node . body , parent = parent )","title":"_convert_object_to_annotation()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector._convert_parameter","text":"Source code in griffe/agents/inspector.py 415 416 417 418 419 420 421 422 423 424 425 426 def _convert_parameter ( parameter , parent ): name = parameter . name if parameter . annotation is empty : annotation = None else : annotation = _convert_object_to_annotation ( parameter . annotation , parent = parent ) kind = _kind_map [ parameter . kind ] if parameter . default is empty : default = None else : default = repr ( parameter . default ) return Parameter ( name , annotation = annotation , kind = kind , default = default )","title":"_convert_parameter()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector._force_inspect","text":"Source code in griffe/agents/inspector.py 91 92 93 94 95 96 97 98 99 100 101 102 def _force_inspect ( parent_module , child_module ): # Special case for builtin modules, example: # - `ast` does `from _ast import *` # - so we go and inspect `_ast` # - when iterating on its child, as usual, we check each child's real module # thanks to `inspect.getmodule` # - but in that case, `inspect.getmodule` returns `ast` for the children # - it puts us in a cycle # - so we break the cycle by ignoring inspect's result and inspecting the private module if parent_module . startswith ( \"_\" ): return parent_module [ 1 :] == child_module and parent_module in sys . builtin_module_names return False","title":"_force_inspect()"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.inspect","text":"Inspect a module. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path | None ) \u2013 The module file path. extensions ( Extensions | None ) \u2013 The extensions to use when inspecting the module. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/inspector.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def inspect ( module_name : str , * , filepath : Path | None = None , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , ) -> Module : \"\"\"Inspect a module. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. extensions: The extensions to use when inspecting the module. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. Returns: The module, with its members populated. \"\"\" return Inspector ( module_name , filepath , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , ) . get_module ()","title":"inspect()"},{"location":"reference/griffe/agents/nodes/","text":"This module contains utilities for extracting information from nodes. _node_annotation_map : dict [ Type , Callable [[ Any , Module | Class ], str | Name | Expression ]] = { NodeAttribute : _get_attribute_annotation , NodeBinOp : _get_binop_annotation , NodeBitAnd : _get_bitand_annotation , NodeBitOr : _get_bitor_annotation , NodeCall : _get_call_annotation , NodeConstant : _get_constant_annotation , NodeEllipsis : _get_ellipsis_annotation , NodeIfExp : _get_ifexp_annotation , NodeList : _get_list_annotation , NodeName : _get_name_annotation , NodeSubscript : _get_subscript_annotation , NodeTuple : _get_tuple_annotation } \u00a4 _node_name_map : dict [ Type , Callable [[ Any ], str ]] = { NodeName : _get_name_name , NodeAttribute : _get_attribute_name } \u00a4 _node_names_map : dict [ Type , Callable [[ Any ], list [ str ]]] = { NodeAssign : _get_assign_names , NodeAnnAssign : _get_annassign_names } \u00a4 _node_value_map : dict [ Type , Callable [[ Any ], str ]] = { type ( None ): lambda _ : repr ( None ), NodeAdd : _get_add_value , NodeAnd : _get_and_value , NodeArguments : _get_arguments_value , NodeAttribute : _get_attribute_value , NodeBinOp : _get_binop_value , NodeBitAnd : _get_bitand_value , NodeBitOr : _get_bitor_value , NodeBitXor : _get_bitxor_value , NodeBoolOp : _get_boolop_value , NodeCall : _get_call_value , NodeCompare : _get_compare_value , NodeComprehension : _get_comprehension_value , NodeConstant : _get_constant_value , NodeDictComp : _get_dictcomp_value , NodeDict : _get_dict_value , NodeDiv : _get_div_value , NodeEllipsis : _get_ellipsis_value , NodeEq : _get_eq_value , NodeFloorDiv : _get_floordiv_value , NodeFormattedValue : _get_formatted_value , NodeGeneratorExp : _get_generatorexp_value , NodeGtE : _get_gte_value , NodeGt : _get_gt_value , NodeIfExp : _get_ifexp_value , NodeIn : _get_in_value , NodeInvert : _get_invert_value , NodeIs : _get_is_value , NodeIsNot : _get_isnot_value , NodeJoinedStr : _get_joinedstr_value , NodeKeyword : _get_keyword_value , NodeLambda : _get_lambda_value , NodeListComp : _get_listcomp_value , NodeList : _get_list_value , NodeLShift : _get_lshift_value , NodeLtE : _get_lte_value , NodeLt : _get_lt_value , NodeMod : _get_mod_value , NodeMult : _get_mult_value , NodeName : _get_name_value , NodeNotEq : _get_noteq_value , NodeNot : _get_not_value , NodeNotIn : _get_notin_value , NodeOr : _get_or_value , NodePow : _get_pow_value , NodeRShift : _get_rshift_value , NodeSetComp : _get_setcomp_value , NodeSet : _get_set_value , NodeSlice : _get_slice_value , NodeStarred : _get_starred_value , NodeSub : _get_sub_value , NodeSubscript : _get_subscript_value , NodeTuple : _get_tuple_value , NodeUAdd : _get_uadd_value , NodeUnaryOp : _get_unaryop_value , NodeUSub : _get_usub_value , NodeYield : _get_yield_value } \u00a4 ASTNode \u00a4 This class is dynamically added to the bases of each AST node class. Source code in griffe/agents/nodes.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 class ASTNode : \"\"\"This class is dynamically added to the bases of each AST node class.\"\"\" parent : ASTNode # TODO: remove once Python 3.7 support is dropped if sys . version_info < ( 3 , 8 ): # noqa: WPS604 end_lineno = property ( lambda node : None ) @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower () @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ] @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :] @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ] @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error end_lineno = property ( lambda node : None ) \u00a4 parent : ASTNode = None \u00a4 children ( self ) \u00a4 Build and return the children of this node. Returns: Sequence [ ASTNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children first_child ( self ) \u00a4 Return the first child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error kind ( self ) \u00a4 Return the kind of this node. Returns: str \u2013 The node kind. Source code in griffe/agents/nodes.py 104 105 106 107 108 109 110 111 @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower () last_child ( self ) \u00a4 Return the lasts child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error next ( self ) \u00a4 Return the next sibling of this node. Raises: LastNodeError \u2013 When the node does not have next siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error next_siblings ( self ) \u00a4 Return the next siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The next siblings. Source code in griffe/agents/nodes.py 162 163 164 165 166 167 168 169 170 171 @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :] position ( self ) \u00a4 Tell the position of this node amongst its siblings. Raises: RootNodeError \u2013 When the node doesn't have a parent. Returns: int \u2013 The node position amongst its siblings. Source code in griffe/agents/nodes.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error previous ( self ) \u00a4 Return the previous sibling of this node. Raises: LastNodeError \u2013 When the node does not have previous siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error previous_siblings ( self ) \u00a4 Return the previous siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The previous siblings. Source code in griffe/agents/nodes.py 151 152 153 154 155 156 157 158 159 160 @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ] siblings ( self ) \u00a4 Return the siblings of this node. Returns: Sequence [ ASTNode ] \u2013 The siblings. Source code in griffe/agents/nodes.py 173 174 175 176 177 178 179 180 @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ] ObjectKind ( enum . Enum ) \u00a4 Enumeration for the different kinds of objects. Source code in griffe/agents/nodes.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 class ObjectKind ( enum . Enum ): \"\"\"Enumeration for the different kinds of objects.\"\"\" MODULE : str = \"module\" CLASS : str = \"class\" STATICMETHOD : str = \"staticmethod\" CLASSMETHOD : str = \"classmethod\" METHOD_DESCRIPTOR : str = \"method_descriptor\" METHOD : str = \"method\" BUILTIN_METHOD : str = \"builtin_method\" COROUTINE : str = \"coroutine\" FUNCTION : str = \"function\" BUILTIN_FUNCTION : str = \"builtin_function\" CACHED_PROPERTY : str = \"cached_property\" PROPERTY : str = \"property\" ATTRIBUTE : str = \"attribute\" def __str__ ( self ) -> str : return self . value ATTRIBUTE : str = 'attribute' \u00a4 BUILTIN_FUNCTION : str = 'builtin_function' \u00a4 BUILTIN_METHOD : str = 'builtin_method' \u00a4 CACHED_PROPERTY : str = 'cached_property' \u00a4 CLASS : str = 'class' \u00a4 CLASSMETHOD : str = 'classmethod' \u00a4 COROUTINE : str = 'coroutine' \u00a4 FUNCTION : str = 'function' \u00a4 METHOD : str = 'method' \u00a4 METHOD_DESCRIPTOR : str = 'method_descriptor' \u00a4 MODULE : str = 'module' \u00a4 PROPERTY : str = 'property' \u00a4 STATICMETHOD : str = 'staticmethod' \u00a4 __str__ ( self ) \u00a4 Source code in griffe/agents/nodes.py 260 261 def __str__ ( self ) -> str : return self . value ObjectNode \u00a4 Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj ( Any ) \u2013 The actual Python object. name ( str ) \u2013 The Python object's name. parent ( ObjectNode | None ) \u2013 The parent node. Source code in griffe/agents/nodes.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class ObjectNode : \"\"\"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj: The actual Python object. name: The Python object's name. parent: The parent node. \"\"\" # low level stuff known to cause issues when resolving aliases exclude_specials = { \"__builtins__\" , \"__loader__\" , \"__spec__\" } def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent def __repr__ ( self ) -> str : return f \"ObjectNode(name= { self . name !r} )\" @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_builtin_method : return ObjectKind . BUILTIN_METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_builtin_function : return ObjectKind . BUILTIN_FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( name , member ): children . append ( ObjectNode ( member , name , parent = self )) return children @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj ) @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj ) @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj ) @cached_property def is_builtin_function ( self ) -> bool : \"\"\" Tell if this node's object is a builtin function. Returns: If this node's object is a builtin function. \"\"\" return inspect . isbuiltin ( self . obj ) @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj ) @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property ) @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class ) @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type ) @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj ) @cached_property def is_builtin_method ( self ) -> bool : \"\"\" Tell if this node's object is a builtin method. Returns: If this node's object is a builtin method. \"\"\" return self . is_builtin_function and self . parent_is_class @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod ) @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod ) @cached_property def _ids ( self ) -> set [ int ]: if self . parent is None : return { id ( self . obj )} return { id ( self . obj )} | self . parent . _ids # noqa: WPS437 def _pick_member ( self , name : str , member : Any ) -> bool : return ( name not in self . exclude_specials and member is not type and member is not object and id ( member ) not in self . _ids ) exclude_specials = { '__builtins__' , '__loader__' , '__spec__' } \u00a4 name : str = name \u00a4 obj : Any = obj \u00a4 parent : ObjectNode | None = parent \u00a4 __init__ ( self , obj , name , parent = None ) \u00a4 Initialize the object. Parameters: obj ( Any ) \u2013 A Python object. name ( str ) \u2013 The object's name. parent ( ObjectNode | None ) \u2013 The object's parent node. Source code in griffe/agents/nodes.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent __repr__ ( self ) \u00a4 Source code in griffe/agents/nodes.py 303 304 def __repr__ ( self ) -> str : return f \"ObjectNode(name= { self . name !r} )\" _ids ( self ) \u00a4 Source code in griffe/agents/nodes.py 498 499 500 501 502 @cached_property def _ids ( self ) -> set [ int ]: if self . parent is None : return { id ( self . obj )} return { id ( self . obj )} | self . parent . _ids # noqa: WPS437 _pick_member ( self , name , member ) \u00a4 Source code in griffe/agents/nodes.py 504 505 506 507 508 509 510 def _pick_member ( self , name : str , member : Any ) -> bool : return ( name not in self . exclude_specials and member is not type and member is not object and id ( member ) not in self . _ids ) children ( self ) \u00a4 Build and return the children of this node. Returns: Sequence [ ObjectNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 339 340 341 342 343 344 345 346 347 348 349 350 @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( name , member ): children . append ( ObjectNode ( member , name , parent = self )) return children is_builtin_function ( self ) \u00a4 Tell if this node's object is a builtin function. Returns: bool \u2013 If this node's object is a builtin function. Source code in griffe/agents/nodes.py 382 383 384 385 386 387 388 389 390 @cached_property def is_builtin_function ( self ) -> bool : \"\"\" Tell if this node's object is a builtin function. Returns: If this node's object is a builtin function. \"\"\" return inspect . isbuiltin ( self . obj ) is_builtin_method ( self ) \u00a4 Tell if this node's object is a builtin method. Returns: bool \u2013 If this node's object is a builtin method. Source code in griffe/agents/nodes.py 456 457 458 459 460 461 462 463 464 @cached_property def is_builtin_method ( self ) -> bool : \"\"\" Tell if this node's object is a builtin method. Returns: If this node's object is a builtin method. \"\"\" return self . is_builtin_function and self . parent_is_class is_cached_property ( self ) \u00a4 Tell if this node's object is a cached property. Returns: bool \u2013 If this node's object is a cached property. Source code in griffe/agents/nodes.py 412 413 414 415 416 417 418 419 420 @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property ) is_class ( self ) \u00a4 Tell if this node's object is a class. Returns: bool \u2013 If this node's object is a class. Source code in griffe/agents/nodes.py 362 363 364 365 366 367 368 369 370 @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj ) is_classmethod ( self ) \u00a4 Tell if this node's object is a classmethod. Returns: bool \u2013 If this node's object is a classmethod. Source code in griffe/agents/nodes.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod ) is_coroutine ( self ) \u00a4 Tell if this node's object is a coroutine. Returns: bool \u2013 If this node's object is a coroutine. Source code in griffe/agents/nodes.py 392 393 394 395 396 397 398 399 400 @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj ) is_function ( self ) \u00a4 Tell if this node's object is a function. Returns: bool \u2013 If this node's object is a function. Source code in griffe/agents/nodes.py 372 373 374 375 376 377 378 379 380 @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj ) is_method ( self ) \u00a4 Tell if this node's object is a method. Returns: bool \u2013 If this node's object is a method. Source code in griffe/agents/nodes.py 432 433 434 435 436 437 438 439 440 441 @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type ) is_method_descriptor ( self ) \u00a4 Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: bool \u2013 If this node's object is a method descriptor. Source code in griffe/agents/nodes.py 443 444 445 446 447 448 449 450 451 452 453 454 @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj ) is_module ( self ) \u00a4 Tell if this node's object is a module. Returns: bool \u2013 The root of the tree. Source code in griffe/agents/nodes.py 352 353 354 355 356 357 358 359 360 @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj ) is_property ( self ) \u00a4 Tell if this node's object is a property. Returns: bool \u2013 If this node's object is a property. Source code in griffe/agents/nodes.py 402 403 404 405 406 407 408 409 410 @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property is_staticmethod ( self ) \u00a4 Tell if this node's object is a staticmethod. Returns: bool \u2013 If this node's object is a staticmethod. Source code in griffe/agents/nodes.py 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod ) kind ( self ) \u00a4 Return the kind of this node. Returns: ObjectKind \u2013 The node kind. Source code in griffe/agents/nodes.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_builtin_method : return ObjectKind . BUILTIN_METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_builtin_function : return ObjectKind . BUILTIN_FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE parent_is_class ( self ) \u00a4 Tell if the object of this node's parent is a class. Returns: bool \u2013 If the object of this node's parent is a class. Source code in griffe/agents/nodes.py 422 423 424 425 426 427 428 429 430 @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class ) _get_add_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 714 715 def _get_add_value ( node : NodeAdd ) -> str : return \"+\" _get_and_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 718 719 def _get_and_value ( node : NodeAnd ) -> str : return \" and \" _get_annassign_names ( node ) \u00a4 Source code in griffe/agents/nodes.py 1120 1121 1122 def _get_annassign_names ( node : NodeAnnAssign ) -> list [ str ]: name = get_name ( node . target ) return [ name ] if name else [] _get_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 662 663 def _get_annotation ( node : AST , parent : Module | Class ) -> str | Name | Expression : return _node_annotation_map [ type ( node )]( node , parent ) _get_arguments_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 722 723 def _get_arguments_value ( node : NodeArguments ) -> str : return \", \" . join ( arg . arg for arg in node . args ) _get_assign_names ( node ) \u00a4 Source code in griffe/agents/nodes.py 1115 1116 1117 def _get_assign_names ( node : NodeAssign ) -> list [ str ]: names = ( get_name ( target ) for target in node . targets ) return [ name for name in names if name ] _get_attribute_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 551 552 553 554 555 556 557 558 def _get_attribute_annotation ( node : NodeAttribute , parent : Module | Class ) -> Expression : left = _get_annotation ( node . value , parent ) def resolver (): # noqa: WPS430 return f \" { left . full } . { node . attr } \" right = Name ( node . attr , resolver ) return Expression ( left , \".\" , right ) _get_attribute_name ( node ) \u00a4 Source code in griffe/agents/nodes.py 1089 1090 def _get_attribute_name ( node : NodeAttribute ) -> str : return f \" { get_name ( node . value ) } . { node . attr } \" _get_attribute_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 726 727 def _get_attribute_value ( node : NodeAttribute ) -> str : return f \" { get_value ( node . value ) } . { node . attr } \" _get_binop_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 561 562 563 564 def _get_binop_annotation ( node : NodeBinOp , parent : Module | Class ) -> Expression : left = _get_annotation ( node . left , parent ) right = _get_annotation ( node . right , parent ) return Expression ( left , _get_annotation ( node . op , parent ), right ) _get_binop_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 730 731 def _get_binop_value ( node : NodeBinOp ) -> str : return f \" { get_value ( node . left ) } { get_value ( node . op ) } { get_value ( node . right ) } \" _get_bitand_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 567 568 def _get_bitand_annotation ( node : NodeBitAnd , parent : Module | Class ) -> str : return \" & \" _get_bitand_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 738 739 def _get_bitand_value ( node : NodeBitAnd ) -> str : return \"&\" _get_bitor_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 571 572 def _get_bitor_annotation ( node : NodeBitOr , parent : Module | Class ) -> str : return \" | \" _get_bitor_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 734 735 def _get_bitor_value ( node : NodeBitOr ) -> str : return \"|\" _get_bitxor_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 742 743 def _get_bitxor_value ( node : NodeBitXor ) -> str : return \"^\" _get_boolop_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 746 747 def _get_boolop_value ( node : NodeBoolOp ) -> str : return get_value ( node . op ) . join ( get_value ( value ) for value in node . values ) _get_bytes_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 1057 1058 def _get_bytes_value ( node : NodeBytes ) -> str : return repr ( node . s ) _get_call_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 575 576 577 578 579 580 581 582 583 584 585 586 587 def _get_call_annotation ( node : NodeCall , parent : Module | Class ) -> Expression : posargs = Expression ( * [ _get_annotation ( arg , parent ) for arg in node . args ]) kwargs = Expression ( * [ _get_annotation ( kwarg , parent ) for kwarg in node . keywords ]) args : Expression | str if posargs and kwargs : args = Expression ( posargs , \", \" , kwargs ) elif posargs : args = posargs elif kwargs : args = kwargs else : args = \"\" return Expression ( _get_annotation ( node . func , parent ), \"(\" , args , \")\" ) _get_call_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 750 751 752 753 754 755 756 757 758 759 760 761 def _get_call_value ( node : NodeCall ) -> str : posargs = \", \" . join ( get_value ( arg ) for arg in node . args ) kwargs = \", \" . join ( get_value ( kwarg ) for kwarg in node . keywords ) if posargs and kwargs : args = f \" { posargs } , { kwargs } \" elif posargs : args = posargs elif kwargs : args = kwargs else : args = \"\" return f \" { get_value ( node . func ) } ( { args } )\" _get_compare_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 764 765 766 767 768 def _get_compare_value ( node : NodeCompare ) -> str : left = get_value ( node . left ) ops = [ get_value ( op ) for op in node . ops ] comparators = [ get_value ( comparator ) for comparator in node . comparators ] return f \" { left } \" + \" \" . join ( f \" { op } { comp } \" for op , comp in zip ( ops , comparators )) _get_comprehension_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 771 772 773 774 775 776 777 778 779 780 def _get_comprehension_value ( node : NodeComprehension ) -> str : target = get_value ( node . target ) iterable = get_value ( node . iter ) conditions = [ get_value ( condition ) for condition in node . ifs ] value = f \"for { target } in { iterable } \" if conditions : value = f \" { value } if \" + \" if \" . join ( conditions ) if node . is_async : value = f \"async { value } \" return value _get_constant_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 590 591 def _get_constant_annotation ( node : NodeConstant , parent : Module | Class ) -> str : return repr ( node . value ) _get_constant_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 783 784 def _get_constant_value ( node : NodeConstant ) -> str : return repr ( node . value ) _get_constant_value_no_repr ( node ) \u00a4 Source code in griffe/agents/nodes.py 787 788 def _get_constant_value_no_repr ( node : NodeConstant ) -> str : return node . value _get_dict_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 791 792 793 794 def _get_dict_value ( node : NodeDict ) -> str : pairs = zip ( node . keys , node . values ) gen = ( f \" { 'None' if key is None else get_value ( key ) } : { get_value ( value ) } \" for key , value in pairs ) # noqa: WPS509 return \"{\" + \", \" . join ( gen ) + \"}\" _get_dictcomp_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 797 798 799 800 801 def _get_dictcomp_value ( node : NodeDictComp ) -> str : key = get_value ( node . key ) value = get_value ( node . value ) generators = [ get_value ( gen ) for gen in node . generators ] return f \" {{ { key } : { value } \" + \" \" . join ( generators ) + \"}\" _get_div_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 804 805 def _get_div_value ( node : NodeDiv ) -> str : return \"/\" _get_ellipsis_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 594 595 def _get_ellipsis_annotation ( node : NodeEllipsis , parent : Module | Class ) -> str : return \"...\" _get_ellipsis_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 808 809 def _get_ellipsis_value ( node : NodeEllipsis ) -> str : return \"...\" _get_eq_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 812 813 def _get_eq_value ( node : NodeEq ) -> str : return \"==\" _get_floordiv_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 816 817 def _get_floordiv_value ( node : NodeFloorDiv ) -> str : return \"//\" _get_formatted_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 820 821 def _get_formatted_value ( node : NodeFormattedValue ) -> str : return f \" {{ { get_value ( node . value ) } }} \" _get_generatorexp_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 824 825 826 827 def _get_generatorexp_value ( node : NodeGeneratorExp ) -> str : element = get_value ( node . elt ) generators = [ get_value ( gen ) for gen in node . generators ] return f \" { element } \" + \" \" . join ( generators ) _get_gt_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 834 835 def _get_gt_value ( node : NodeNotEq ) -> str : return \">\" _get_gte_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 830 831 def _get_gte_value ( node : NodeNotEq ) -> str : return \">=\" _get_ifexp_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 598 599 600 601 602 603 604 605 def _get_ifexp_annotation ( node : NodeIfExp , parent : Module | Class ) -> Expression : return Expression ( _get_annotation ( node . body , parent ), \" if \" , _get_annotation ( node . test , parent ), \" else\" , _get_annotation ( node . orelse , parent ), ) _get_ifexp_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 838 839 def _get_ifexp_value ( node : NodeIfExp ) -> str : return f \" { get_value ( node . body ) } if { get_value ( node . test ) } else { get_value ( node . orelse ) } \" _get_in_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 846 847 def _get_in_value ( node : NodeIn ) -> str : return \"in\" _get_index_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 644 645 def _get_index_annotation ( node : NodeIndex , parent : Module | Class ) -> str | Name | Expression : return _get_annotation ( node . value , parent ) _get_index_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 1048 1049 def _get_index_value ( node : NodeIndex ) -> str : return get_value ( node . value ) _get_invert_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 842 843 def _get_invert_value ( node : NodeInvert ) -> str : return \"~\" _get_is_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 850 851 def _get_is_value ( node : NodeIs ) -> str : return \"is\" _get_isnot_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 854 855 def _get_isnot_value ( node : NodeIsNot ) -> str : return \"is not\" _get_joinedstr_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 858 859 860 861 862 def _get_joinedstr_value ( node : NodeJoinedStr ) -> str : _node_value_map [ NodeConstant ] = _get_constant_value_no_repr result = repr ( \"\" . join ( get_value ( value ) for value in node . values )) _node_value_map [ NodeConstant ] = _get_constant_value return result _get_keyword_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 865 866 def _get_keyword_value ( node : NodeKeyword ) -> str : return f \" { node . arg } = { get_value ( node . value ) } \" _get_lambda_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 869 870 def _get_lambda_value ( node : NodeLambda ) -> str : return f \"lambda { get_value ( node . args ) } : { get_value ( node . body ) } \" _get_list_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 608 609 def _get_list_annotation ( node : NodeList , parent : Module | Class ) -> Expression : return Expression ( \"[\" , * _join ([ _get_annotation ( el , parent ) for el in node . elts ], \", \" ), \"]\" ) _get_list_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 873 874 def _get_list_value ( node : NodeList ) -> str : return \"[\" + \", \" . join ( get_value ( el ) for el in node . elts ) + \"]\" _get_listcomp_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 877 878 879 880 def _get_listcomp_value ( node : NodeListComp ) -> str : element = get_value ( node . elt ) generators = [ get_value ( gen ) for gen in node . generators ] return f \"[ { element } \" + \" \" . join ( generators ) + \"]\" _get_lshift_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 883 884 def _get_lshift_value ( node : NodeLShift ) -> str : return \"<<\" _get_lt_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 891 892 def _get_lt_value ( node : NodeNotEq ) -> str : return \"<\" _get_lte_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 887 888 def _get_lte_value ( node : NodeNotEq ) -> str : return \"<=\" _get_mod_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 895 896 def _get_mod_value ( node : NodeMod ) -> str : return \"%\" _get_mult_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 899 900 def _get_mult_value ( node : NodeMult ) -> str : return \"*\" _get_name_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 612 613 def _get_name_annotation ( node : NodeName , parent : Module | Class ) -> Name : return Name ( node . id , partial ( parent . resolve , node . id )) _get_name_name ( node ) \u00a4 Source code in griffe/agents/nodes.py 1093 1094 def _get_name_name ( node : NodeName ) -> str : return node . id _get_name_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 903 904 def _get_name_value ( node : NodeName ) -> str : return node . id _get_nameconstant_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 652 653 def _get_nameconstant_annotation ( node : NodeNameConstant , parent : Module | Class ) -> str | Name | Expression : return repr ( node . value ) _get_nameconstant_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 1060 1061 def _get_nameconstant_value ( node : NodeNameConstant ) -> str : return repr ( node . value ) _get_not_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 907 908 def _get_not_value ( node : NodeNot ) -> str : return \"not \" _get_noteq_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 911 912 def _get_noteq_value ( node : NodeNotEq ) -> str : return \"!=\" _get_notin_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 915 916 def _get_notin_value ( node : NodeNotIn ) -> str : return \"not in\" _get_num_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 1063 1064 def _get_num_value ( node : NodeNum ) -> str : return repr ( node . n ) _get_or_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 919 920 def _get_or_value ( node : NodeOr ) -> str : return \" or \" _get_pow_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 923 924 def _get_pow_value ( node : NodePow ) -> str : return \"**\" _get_rshift_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 927 928 def _get_rshift_value ( node : NodeRShift ) -> str : return \">>\" _get_set_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 931 932 def _get_set_value ( node : NodeSet ) -> str : return \"{\" + \", \" . join ( get_value ( el ) for el in node . elts ) + \"}\" _get_setcomp_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 935 936 937 938 def _get_setcomp_value ( node : NodeSetComp ) -> str : element = get_value ( node . elt ) generators = [ get_value ( gen ) for gen in node . generators ] return f \" {{ { element } \" + \" \" . join ( generators ) + \"}\" _get_slice_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 941 942 943 944 945 def _get_slice_value ( node : NodeSlice ) -> str : value = f \" { get_value ( node . lower ) if node . lower else '' } : { get_value ( node . upper ) if node . upper else '' } \" if node . step : value = f \" { value } : { get_value ( node . step ) } \" return value _get_starred_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 948 949 def _get_starred_value ( node : NodeStarred ) -> str : return get_value ( node . value ) _get_str_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 655 656 def _get_str_annotation ( node : NodeStr , parent : Module | Class ) -> str : return node . s _get_str_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 1066 1067 def _get_str_value ( node : NodeStr ) -> str : return repr ( node . s ) _get_sub_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 952 953 def _get_sub_value ( node : NodeSub ) -> str : return \"-\" _get_subscript_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 616 617 618 619 def _get_subscript_annotation ( node : NodeSubscript , parent : Module | Class ) -> Expression : left = _get_annotation ( node . value , parent ) subscript = _get_annotation ( node . slice , parent ) return Expression ( left , \"[\" , subscript , \"]\" ) _get_subscript_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 956 957 958 959 960 def _get_subscript_value ( node : NodeSubscript ) -> str : subscript = get_value ( node . slice ) if isinstance ( subscript , str ): subscript = subscript . strip ( \"()\" ) return f \" { get_value ( node . value ) } [ { subscript } ]\" _get_tuple_annotation ( node , parent ) \u00a4 Source code in griffe/agents/nodes.py 622 623 def _get_tuple_annotation ( node : NodeTuple , parent : Module | Class ) -> Expression : return Expression ( * _join ([ _get_annotation ( el , parent ) for el in node . elts ], \", \" )) _get_tuple_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 963 964 def _get_tuple_value ( node : NodeTuple ) -> str : return \"(\" + \", \" . join ( get_value ( el ) for el in node . elts ) + \")\" _get_uadd_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 967 968 def _get_uadd_value ( node : NodeUAdd ) -> str : return \"+\" _get_unaryop_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 971 972 def _get_unaryop_value ( node : NodeUnaryOp ) -> str : return f \" { get_value ( node . op ) }{ get_value ( node . operand ) } \" _get_usub_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 975 976 def _get_usub_value ( node : NodeUSub ) -> str : return \"-\" _get_yield_value ( node ) \u00a4 Source code in griffe/agents/nodes.py 979 980 981 982 def _get_yield_value ( node : NodeYield ) -> str : if node . value is None : return repr ( None ) return get_value ( node . value ) _join ( sequence , item ) \u00a4 Source code in griffe/agents/nodes.py 513 514 515 516 517 518 519 def _join ( sequence , item ): if not sequence : return [] new_sequence = [ sequence [ 0 ]] for element in sequence [ 1 :]: new_sequence . extend (( item , element )) return new_sequence get_annotation ( node , parent ) \u00a4 Extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 666 667 668 669 670 671 672 673 674 675 676 677 678 def get_annotation ( node : AST | None , parent : Module | Class ) -> str | Name | Expression | None : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" if node is None : return None return _get_annotation ( node , parent ) get_docstring ( node , strict = False ) \u00a4 Extract a docstring. Parameters: node ( AST ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/agents/nodes.py 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 def get_docstring ( node : AST , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore[attr-defined] doc = node . body [ 0 ] . value # type: ignore[attr-defined] else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno # type: ignore[attr-defined] if isinstance ( doc , NodeStr ): return doc . s , doc . lineno , doc . end_lineno # type: ignore[attr-defined] return None , None , None get_instance_names ( node ) \u00a4 Extract names from an assignment node, only for instance attributes. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 def get_instance_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )] get_name ( node ) \u00a4 Extract name from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: str \u2013 A list of names. Source code in griffe/agents/nodes.py 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 def get_name ( node : AST ) -> str : \"\"\"Extract name from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_name_map [ type ( node )]( node ) get_names ( node ) \u00a4 Extract names from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 def get_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map [ type ( node )]( node ) get_parameter_default ( node , filepath , lines_collection ) \u00a4 Extract the default value of a function parameter. Parameters: node ( AST ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/agents/nodes.py 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 def get_parameter_default ( node : AST , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None if isinstance ( node , NodeConstant ): return repr ( node . value ) if isinstance ( node , NodeName ): return node . id if node . lineno == node . end_lineno : # type: ignore[attr-defined] return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # type: ignore[attr-defined] # TODO: handle multiple line defaults return None get_value ( node ) \u00a4 Extract a complex value as a string. Parameters: node ( AST ) \u2013 The node to extract the value from. Returns: str \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 def get_value ( node : AST ) -> str : \"\"\"Extract a complex value as a string. Parameters: node: The node to extract the value from. Returns: The unparsed code of the node. \"\"\" return _node_value_map [ type ( node )]( node ) parse__all__ ( node ) \u00a4 Get the values declared in __all__ . Parameters: node ( NodeAssign ) \u2013 The assignment node. Returns: set [ str ] \u2013 A set of names. Source code in griffe/agents/nodes.py 537 538 539 540 541 542 543 544 545 546 def parse__all__ ( node : NodeAssign ) -> set [ str ]: # noqa: WPS116,WPS120,WPS440 \"\"\"Get the values declared in `__all__`. Parameters: node: The assignment node. Returns: A set of names. \"\"\" return { elt . value for elt in node . value . elts } # type: ignore[attr-defined]","title":"nodes"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._node_annotation_map","text":"","title":"_node_annotation_map"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._node_name_map","text":"","title":"_node_name_map"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._node_names_map","text":"","title":"_node_names_map"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._node_value_map","text":"","title":"_node_value_map"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode","text":"This class is dynamically added to the bases of each AST node class. Source code in griffe/agents/nodes.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 class ASTNode : \"\"\"This class is dynamically added to the bases of each AST node class.\"\"\" parent : ASTNode # TODO: remove once Python 3.7 support is dropped if sys . version_info < ( 3 , 8 ): # noqa: WPS604 end_lineno = property ( lambda node : None ) @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower () @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ] @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :] @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ] @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error","title":"ASTNode"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.end_lineno","text":"","title":"end_lineno"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.parent","text":"","title":"parent"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.children","text":"Build and return the children of this node. Returns: Sequence [ ASTNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @cached_property # noqa: WPS231 def children ( self ) -> Sequence [ ASTNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for field_name in self . _fields : # type: ignore[attr-defined] # noqa: WPS437 try : field = getattr ( self , field_name ) except AttributeError : continue if isinstance ( field , ASTNode ): field . parent = self children . append ( field ) elif isinstance ( field , list ): for child in field : if isinstance ( child , ASTNode ): child . parent = self children . append ( child ) return children","title":"children()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.first_child","text":"Return the first child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 @cached_property def first_child ( self ) -> ASTNode : \"\"\"Return the first child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ 0 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error","title":"first_child()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.kind","text":"Return the kind of this node. Returns: str \u2013 The node kind. Source code in griffe/agents/nodes.py 104 105 106 107 108 109 110 111 @cached_property def kind ( self ) -> str : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" return self . __class__ . __name__ . lower ()","title":"kind()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.last_child","text":"Return the lasts child of this node. Raises: LastNodeError \u2013 When the node does not have children. Returns: ASTNode \u2013 The child. Source code in griffe/agents/nodes.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @cached_property def last_child ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the lasts child of this node. Raises: LastNodeError: When the node does not have children. Returns: The child. \"\"\" try : return self . children [ - 1 ] except IndexError as error : raise LastNodeError ( \"there are no children node\" ) from error","title":"last_child()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next","text":"Return the next sibling of this node. Raises: LastNodeError \u2013 When the node does not have next siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 @cached_property # noqa: A003 def next ( self ) -> ASTNode : # noqa: A003 \"\"\"Return the next sibling of this node. Raises: LastNodeError: When the node does not have next siblings. Returns: The sibling. \"\"\" try : return self . next_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no next node\" ) from error","title":"next()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next_siblings","text":"Return the next siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The next siblings. Source code in griffe/agents/nodes.py 162 163 164 165 166 167 168 169 170 171 @cached_property def next_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the next siblings of this node, starting from the closest. Returns: The next siblings. \"\"\" if self . position == len ( self . parent . children ) - 1 : return [] return self . parent . children [ self . position + 1 :]","title":"next_siblings()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.position","text":"Tell the position of this node amongst its siblings. Raises: RootNodeError \u2013 When the node doesn't have a parent. Returns: int \u2013 The node position amongst its siblings. Source code in griffe/agents/nodes.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @cached_property def position ( self ) -> int : \"\"\"Tell the position of this node amongst its siblings. Raises: RootNodeError: When the node doesn't have a parent. Returns: The node position amongst its siblings. \"\"\" try : return self . parent . children . index ( self ) except AttributeError as error : raise RootNodeError ( \"the root node does not have a parent, nor siblings, nor a position\" ) from error","title":"position()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous","text":"Return the previous sibling of this node. Raises: LastNodeError \u2013 When the node does not have previous siblings. Returns: ASTNode \u2013 The sibling. Source code in griffe/agents/nodes.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @cached_property def previous ( self ) -> ASTNode : \"\"\"Return the previous sibling of this node. Raises: LastNodeError: When the node does not have previous siblings. Returns: The sibling. \"\"\" try : return self . previous_siblings [ 0 ] except IndexError as error : raise LastNodeError ( \"there is no previous node\" ) from error","title":"previous()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous_siblings","text":"Return the previous siblings of this node, starting from the closest. Returns: Sequence [ ASTNode ] \u2013 The previous siblings. Source code in griffe/agents/nodes.py 151 152 153 154 155 156 157 158 159 160 @cached_property def previous_siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the previous siblings of this node, starting from the closest. Returns: The previous siblings. \"\"\" if self . position == 0 : return [] return self . parent . children [ self . position - 1 :: - 1 ]","title":"previous_siblings()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.siblings","text":"Return the siblings of this node. Returns: Sequence [ ASTNode ] \u2013 The siblings. Source code in griffe/agents/nodes.py 173 174 175 176 177 178 179 180 @cached_property def siblings ( self ) -> Sequence [ ASTNode ]: \"\"\"Return the siblings of this node. Returns: The siblings. \"\"\" return [ * reversed ( self . previous_siblings ), * self . next_siblings ]","title":"siblings()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind","text":"Enumeration for the different kinds of objects. Source code in griffe/agents/nodes.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 class ObjectKind ( enum . Enum ): \"\"\"Enumeration for the different kinds of objects.\"\"\" MODULE : str = \"module\" CLASS : str = \"class\" STATICMETHOD : str = \"staticmethod\" CLASSMETHOD : str = \"classmethod\" METHOD_DESCRIPTOR : str = \"method_descriptor\" METHOD : str = \"method\" BUILTIN_METHOD : str = \"builtin_method\" COROUTINE : str = \"coroutine\" FUNCTION : str = \"function\" BUILTIN_FUNCTION : str = \"builtin_function\" CACHED_PROPERTY : str = \"cached_property\" PROPERTY : str = \"property\" ATTRIBUTE : str = \"attribute\" def __str__ ( self ) -> str : return self . value","title":"ObjectKind"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.ATTRIBUTE","text":"","title":"ATTRIBUTE"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.BUILTIN_FUNCTION","text":"","title":"BUILTIN_FUNCTION"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.BUILTIN_METHOD","text":"","title":"BUILTIN_METHOD"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.CACHED_PROPERTY","text":"","title":"CACHED_PROPERTY"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.CLASS","text":"","title":"CLASS"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.CLASSMETHOD","text":"","title":"CLASSMETHOD"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.COROUTINE","text":"","title":"COROUTINE"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.FUNCTION","text":"","title":"FUNCTION"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.METHOD","text":"","title":"METHOD"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.METHOD_DESCRIPTOR","text":"","title":"METHOD_DESCRIPTOR"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.MODULE","text":"","title":"MODULE"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.PROPERTY","text":"","title":"PROPERTY"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.STATICMETHOD","text":"","title":"STATICMETHOD"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.__str__","text":"Source code in griffe/agents/nodes.py 260 261 def __str__ ( self ) -> str : return self . value","title":"__str__()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode","text":"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj ( Any ) \u2013 The actual Python object. name ( str ) \u2013 The Python object's name. parent ( ObjectNode | None ) \u2013 The parent node. Source code in griffe/agents/nodes.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class ObjectNode : \"\"\"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. Attributes: obj: The actual Python object. name: The Python object's name. parent: The parent node. \"\"\" # low level stuff known to cause issues when resolving aliases exclude_specials = { \"__builtins__\" , \"__loader__\" , \"__spec__\" } def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent def __repr__ ( self ) -> str : return f \"ObjectNode(name= { self . name !r} )\" @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_builtin_method : return ObjectKind . BUILTIN_METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_builtin_function : return ObjectKind . BUILTIN_FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( name , member ): children . append ( ObjectNode ( member , name , parent = self )) return children @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj ) @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj ) @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj ) @cached_property def is_builtin_function ( self ) -> bool : \"\"\" Tell if this node's object is a builtin function. Returns: If this node's object is a builtin function. \"\"\" return inspect . isbuiltin ( self . obj ) @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj ) @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property ) @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class ) @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type ) @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj ) @cached_property def is_builtin_method ( self ) -> bool : \"\"\" Tell if this node's object is a builtin method. Returns: If this node's object is a builtin method. \"\"\" return self . is_builtin_function and self . parent_is_class @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod ) @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod ) @cached_property def _ids ( self ) -> set [ int ]: if self . parent is None : return { id ( self . obj )} return { id ( self . obj )} | self . parent . _ids # noqa: WPS437 def _pick_member ( self , name : str , member : Any ) -> bool : return ( name not in self . exclude_specials and member is not type and member is not object and id ( member ) not in self . _ids )","title":"ObjectNode"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.exclude_specials","text":"","title":"exclude_specials"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.name","text":"","title":"name"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.obj","text":"","title":"obj"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.parent","text":"","title":"parent"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.__init__","text":"Initialize the object. Parameters: obj ( Any ) \u2013 A Python object. name ( str ) \u2013 The object's name. parent ( ObjectNode | None ) \u2013 The object's parent node. Source code in griffe/agents/nodes.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def __init__ ( self , obj : Any , name : str , parent : ObjectNode | None = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj self . name : str = name self . parent : ObjectNode | None = parent","title":"__init__()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.__repr__","text":"Source code in griffe/agents/nodes.py 303 304 def __repr__ ( self ) -> str : return f \"ObjectNode(name= { self . name !r} )\"","title":"__repr__()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode._ids","text":"Source code in griffe/agents/nodes.py 498 499 500 501 502 @cached_property def _ids ( self ) -> set [ int ]: if self . parent is None : return { id ( self . obj )} return { id ( self . obj )} | self . parent . _ids # noqa: WPS437","title":"_ids()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode._pick_member","text":"Source code in griffe/agents/nodes.py 504 505 506 507 508 509 510 def _pick_member ( self , name : str , member : Any ) -> bool : return ( name not in self . exclude_specials and member is not type and member is not object and id ( member ) not in self . _ids )","title":"_pick_member()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.children","text":"Build and return the children of this node. Returns: Sequence [ ObjectNode ] \u2013 A list of children. Source code in griffe/agents/nodes.py 339 340 341 342 343 344 345 346 347 348 349 350 @cached_property def children ( self ) -> Sequence [ ObjectNode ]: # noqa: WPS231 \"\"\"Build and return the children of this node. Returns: A list of children. \"\"\" children = [] for name , member in inspect . getmembers ( self . obj ): if self . _pick_member ( name , member ): children . append ( ObjectNode ( member , name , parent = self )) return children","title":"children()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_function","text":"Tell if this node's object is a builtin function. Returns: bool \u2013 If this node's object is a builtin function. Source code in griffe/agents/nodes.py 382 383 384 385 386 387 388 389 390 @cached_property def is_builtin_function ( self ) -> bool : \"\"\" Tell if this node's object is a builtin function. Returns: If this node's object is a builtin function. \"\"\" return inspect . isbuiltin ( self . obj )","title":"is_builtin_function()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_method","text":"Tell if this node's object is a builtin method. Returns: bool \u2013 If this node's object is a builtin method. Source code in griffe/agents/nodes.py 456 457 458 459 460 461 462 463 464 @cached_property def is_builtin_method ( self ) -> bool : \"\"\" Tell if this node's object is a builtin method. Returns: If this node's object is a builtin method. \"\"\" return self . is_builtin_function and self . parent_is_class","title":"is_builtin_method()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_cached_property","text":"Tell if this node's object is a cached property. Returns: bool \u2013 If this node's object is a cached property. Source code in griffe/agents/nodes.py 412 413 414 415 416 417 418 419 420 @cached_property def is_cached_property ( self ) -> bool : \"\"\" Tell if this node's object is a cached property. Returns: If this node's object is a cached property. \"\"\" return isinstance ( self . obj , cached_property )","title":"is_cached_property()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_class","text":"Tell if this node's object is a class. Returns: bool \u2013 If this node's object is a class. Source code in griffe/agents/nodes.py 362 363 364 365 366 367 368 369 370 @cached_property def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj )","title":"is_class()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_classmethod","text":"Tell if this node's object is a classmethod. Returns: bool \u2013 If this node's object is a classmethod. Source code in griffe/agents/nodes.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 @cached_property def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , classmethod )","title":"is_classmethod()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_coroutine","text":"Tell if this node's object is a coroutine. Returns: bool \u2013 If this node's object is a coroutine. Source code in griffe/agents/nodes.py 392 393 394 395 396 397 398 399 400 @cached_property def is_coroutine ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj )","title":"is_coroutine()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_function","text":"Tell if this node's object is a function. Returns: bool \u2013 If this node's object is a function. Source code in griffe/agents/nodes.py 372 373 374 375 376 377 378 379 380 @cached_property def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj )","title":"is_function()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method","text":"Tell if this node's object is a method. Returns: bool \u2013 If this node's object is a method. Source code in griffe/agents/nodes.py 432 433 434 435 436 437 438 439 440 441 @cached_property def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class and isinstance ( self . obj , function_type )","title":"is_method()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method_descriptor","text":"Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: bool \u2013 If this node's object is a method descriptor. Source code in griffe/agents/nodes.py 443 444 445 446 447 448 449 450 451 452 453 454 @cached_property def is_method_descriptor ( self ) -> bool : \"\"\" Tell if this node's object is a method descriptor. Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods. Returns: If this node's object is a method descriptor. \"\"\" return inspect . ismethoddescriptor ( self . obj )","title":"is_method_descriptor()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_module","text":"Tell if this node's object is a module. Returns: bool \u2013 The root of the tree. Source code in griffe/agents/nodes.py 352 353 354 355 356 357 358 359 360 @cached_property def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj )","title":"is_module()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_property","text":"Tell if this node's object is a property. Returns: bool \u2013 If this node's object is a property. Source code in griffe/agents/nodes.py 402 403 404 405 406 407 408 409 410 @cached_property def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) or self . is_cached_property","title":"is_property()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_staticmethod","text":"Tell if this node's object is a staticmethod. Returns: bool \u2013 If this node's object is a staticmethod. Source code in griffe/agents/nodes.py 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 @cached_property def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if self . parent is None : return False try : self_from_parent = self . parent . obj . __dict__ . get ( self . name , None ) # noqa: WPS609 except AttributeError : return False return self . parent_is_class and isinstance ( self_from_parent , staticmethod )","title":"is_staticmethod()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.kind","text":"Return the kind of this node. Returns: ObjectKind \u2013 The node kind. Source code in griffe/agents/nodes.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 @cached_property def kind ( self ) -> ObjectKind : \"\"\"Return the kind of this node. Returns: The node kind. \"\"\" if self . is_module : return ObjectKind . MODULE if self . is_class : return ObjectKind . CLASS if self . is_staticmethod : return ObjectKind . STATICMETHOD if self . is_classmethod : return ObjectKind . CLASSMETHOD if self . is_method_descriptor : return ObjectKind . METHOD_DESCRIPTOR if self . is_method : return ObjectKind . METHOD if self . is_builtin_method : return ObjectKind . BUILTIN_METHOD if self . is_coroutine : return ObjectKind . COROUTINE if self . is_function : return ObjectKind . FUNCTION if self . is_builtin_function : return ObjectKind . BUILTIN_FUNCTION if self . is_cached_property : return ObjectKind . CACHED_PROPERTY if self . is_property : return ObjectKind . PROPERTY return ObjectKind . ATTRIBUTE","title":"kind()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.parent_is_class","text":"Tell if the object of this node's parent is a class. Returns: bool \u2013 If the object of this node's parent is a class. Source code in griffe/agents/nodes.py 422 423 424 425 426 427 428 429 430 @cached_property def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class )","title":"parent_is_class()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_add_value","text":"Source code in griffe/agents/nodes.py 714 715 def _get_add_value ( node : NodeAdd ) -> str : return \"+\"","title":"_get_add_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_and_value","text":"Source code in griffe/agents/nodes.py 718 719 def _get_and_value ( node : NodeAnd ) -> str : return \" and \"","title":"_get_and_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_annassign_names","text":"Source code in griffe/agents/nodes.py 1120 1121 1122 def _get_annassign_names ( node : NodeAnnAssign ) -> list [ str ]: name = get_name ( node . target ) return [ name ] if name else []","title":"_get_annassign_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_annotation","text":"Source code in griffe/agents/nodes.py 662 663 def _get_annotation ( node : AST , parent : Module | Class ) -> str | Name | Expression : return _node_annotation_map [ type ( node )]( node , parent )","title":"_get_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_arguments_value","text":"Source code in griffe/agents/nodes.py 722 723 def _get_arguments_value ( node : NodeArguments ) -> str : return \", \" . join ( arg . arg for arg in node . args )","title":"_get_arguments_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_assign_names","text":"Source code in griffe/agents/nodes.py 1115 1116 1117 def _get_assign_names ( node : NodeAssign ) -> list [ str ]: names = ( get_name ( target ) for target in node . targets ) return [ name for name in names if name ]","title":"_get_assign_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_attribute_annotation","text":"Source code in griffe/agents/nodes.py 551 552 553 554 555 556 557 558 def _get_attribute_annotation ( node : NodeAttribute , parent : Module | Class ) -> Expression : left = _get_annotation ( node . value , parent ) def resolver (): # noqa: WPS430 return f \" { left . full } . { node . attr } \" right = Name ( node . attr , resolver ) return Expression ( left , \".\" , right )","title":"_get_attribute_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_attribute_name","text":"Source code in griffe/agents/nodes.py 1089 1090 def _get_attribute_name ( node : NodeAttribute ) -> str : return f \" { get_name ( node . value ) } . { node . attr } \"","title":"_get_attribute_name()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_attribute_value","text":"Source code in griffe/agents/nodes.py 726 727 def _get_attribute_value ( node : NodeAttribute ) -> str : return f \" { get_value ( node . value ) } . { node . attr } \"","title":"_get_attribute_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_binop_annotation","text":"Source code in griffe/agents/nodes.py 561 562 563 564 def _get_binop_annotation ( node : NodeBinOp , parent : Module | Class ) -> Expression : left = _get_annotation ( node . left , parent ) right = _get_annotation ( node . right , parent ) return Expression ( left , _get_annotation ( node . op , parent ), right )","title":"_get_binop_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_binop_value","text":"Source code in griffe/agents/nodes.py 730 731 def _get_binop_value ( node : NodeBinOp ) -> str : return f \" { get_value ( node . left ) } { get_value ( node . op ) } { get_value ( node . right ) } \"","title":"_get_binop_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_bitand_annotation","text":"Source code in griffe/agents/nodes.py 567 568 def _get_bitand_annotation ( node : NodeBitAnd , parent : Module | Class ) -> str : return \" & \"","title":"_get_bitand_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_bitand_value","text":"Source code in griffe/agents/nodes.py 738 739 def _get_bitand_value ( node : NodeBitAnd ) -> str : return \"&\"","title":"_get_bitand_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_bitor_annotation","text":"Source code in griffe/agents/nodes.py 571 572 def _get_bitor_annotation ( node : NodeBitOr , parent : Module | Class ) -> str : return \" | \"","title":"_get_bitor_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_bitor_value","text":"Source code in griffe/agents/nodes.py 734 735 def _get_bitor_value ( node : NodeBitOr ) -> str : return \"|\"","title":"_get_bitor_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_bitxor_value","text":"Source code in griffe/agents/nodes.py 742 743 def _get_bitxor_value ( node : NodeBitXor ) -> str : return \"^\"","title":"_get_bitxor_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_boolop_value","text":"Source code in griffe/agents/nodes.py 746 747 def _get_boolop_value ( node : NodeBoolOp ) -> str : return get_value ( node . op ) . join ( get_value ( value ) for value in node . values )","title":"_get_boolop_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_bytes_value","text":"Source code in griffe/agents/nodes.py 1057 1058 def _get_bytes_value ( node : NodeBytes ) -> str : return repr ( node . s )","title":"_get_bytes_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_call_annotation","text":"Source code in griffe/agents/nodes.py 575 576 577 578 579 580 581 582 583 584 585 586 587 def _get_call_annotation ( node : NodeCall , parent : Module | Class ) -> Expression : posargs = Expression ( * [ _get_annotation ( arg , parent ) for arg in node . args ]) kwargs = Expression ( * [ _get_annotation ( kwarg , parent ) for kwarg in node . keywords ]) args : Expression | str if posargs and kwargs : args = Expression ( posargs , \", \" , kwargs ) elif posargs : args = posargs elif kwargs : args = kwargs else : args = \"\" return Expression ( _get_annotation ( node . func , parent ), \"(\" , args , \")\" )","title":"_get_call_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_call_value","text":"Source code in griffe/agents/nodes.py 750 751 752 753 754 755 756 757 758 759 760 761 def _get_call_value ( node : NodeCall ) -> str : posargs = \", \" . join ( get_value ( arg ) for arg in node . args ) kwargs = \", \" . join ( get_value ( kwarg ) for kwarg in node . keywords ) if posargs and kwargs : args = f \" { posargs } , { kwargs } \" elif posargs : args = posargs elif kwargs : args = kwargs else : args = \"\" return f \" { get_value ( node . func ) } ( { args } )\"","title":"_get_call_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_compare_value","text":"Source code in griffe/agents/nodes.py 764 765 766 767 768 def _get_compare_value ( node : NodeCompare ) -> str : left = get_value ( node . left ) ops = [ get_value ( op ) for op in node . ops ] comparators = [ get_value ( comparator ) for comparator in node . comparators ] return f \" { left } \" + \" \" . join ( f \" { op } { comp } \" for op , comp in zip ( ops , comparators ))","title":"_get_compare_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_comprehension_value","text":"Source code in griffe/agents/nodes.py 771 772 773 774 775 776 777 778 779 780 def _get_comprehension_value ( node : NodeComprehension ) -> str : target = get_value ( node . target ) iterable = get_value ( node . iter ) conditions = [ get_value ( condition ) for condition in node . ifs ] value = f \"for { target } in { iterable } \" if conditions : value = f \" { value } if \" + \" if \" . join ( conditions ) if node . is_async : value = f \"async { value } \" return value","title":"_get_comprehension_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_constant_annotation","text":"Source code in griffe/agents/nodes.py 590 591 def _get_constant_annotation ( node : NodeConstant , parent : Module | Class ) -> str : return repr ( node . value )","title":"_get_constant_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_constant_value","text":"Source code in griffe/agents/nodes.py 783 784 def _get_constant_value ( node : NodeConstant ) -> str : return repr ( node . value )","title":"_get_constant_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_constant_value_no_repr","text":"Source code in griffe/agents/nodes.py 787 788 def _get_constant_value_no_repr ( node : NodeConstant ) -> str : return node . value","title":"_get_constant_value_no_repr()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_dict_value","text":"Source code in griffe/agents/nodes.py 791 792 793 794 def _get_dict_value ( node : NodeDict ) -> str : pairs = zip ( node . keys , node . values ) gen = ( f \" { 'None' if key is None else get_value ( key ) } : { get_value ( value ) } \" for key , value in pairs ) # noqa: WPS509 return \"{\" + \", \" . join ( gen ) + \"}\"","title":"_get_dict_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_dictcomp_value","text":"Source code in griffe/agents/nodes.py 797 798 799 800 801 def _get_dictcomp_value ( node : NodeDictComp ) -> str : key = get_value ( node . key ) value = get_value ( node . value ) generators = [ get_value ( gen ) for gen in node . generators ] return f \" {{ { key } : { value } \" + \" \" . join ( generators ) + \"}\"","title":"_get_dictcomp_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_div_value","text":"Source code in griffe/agents/nodes.py 804 805 def _get_div_value ( node : NodeDiv ) -> str : return \"/\"","title":"_get_div_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_ellipsis_annotation","text":"Source code in griffe/agents/nodes.py 594 595 def _get_ellipsis_annotation ( node : NodeEllipsis , parent : Module | Class ) -> str : return \"...\"","title":"_get_ellipsis_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_ellipsis_value","text":"Source code in griffe/agents/nodes.py 808 809 def _get_ellipsis_value ( node : NodeEllipsis ) -> str : return \"...\"","title":"_get_ellipsis_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_eq_value","text":"Source code in griffe/agents/nodes.py 812 813 def _get_eq_value ( node : NodeEq ) -> str : return \"==\"","title":"_get_eq_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_floordiv_value","text":"Source code in griffe/agents/nodes.py 816 817 def _get_floordiv_value ( node : NodeFloorDiv ) -> str : return \"//\"","title":"_get_floordiv_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_formatted_value","text":"Source code in griffe/agents/nodes.py 820 821 def _get_formatted_value ( node : NodeFormattedValue ) -> str : return f \" {{ { get_value ( node . value ) } }} \"","title":"_get_formatted_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_generatorexp_value","text":"Source code in griffe/agents/nodes.py 824 825 826 827 def _get_generatorexp_value ( node : NodeGeneratorExp ) -> str : element = get_value ( node . elt ) generators = [ get_value ( gen ) for gen in node . generators ] return f \" { element } \" + \" \" . join ( generators )","title":"_get_generatorexp_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_gt_value","text":"Source code in griffe/agents/nodes.py 834 835 def _get_gt_value ( node : NodeNotEq ) -> str : return \">\"","title":"_get_gt_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_gte_value","text":"Source code in griffe/agents/nodes.py 830 831 def _get_gte_value ( node : NodeNotEq ) -> str : return \">=\"","title":"_get_gte_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_ifexp_annotation","text":"Source code in griffe/agents/nodes.py 598 599 600 601 602 603 604 605 def _get_ifexp_annotation ( node : NodeIfExp , parent : Module | Class ) -> Expression : return Expression ( _get_annotation ( node . body , parent ), \" if \" , _get_annotation ( node . test , parent ), \" else\" , _get_annotation ( node . orelse , parent ), )","title":"_get_ifexp_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_ifexp_value","text":"Source code in griffe/agents/nodes.py 838 839 def _get_ifexp_value ( node : NodeIfExp ) -> str : return f \" { get_value ( node . body ) } if { get_value ( node . test ) } else { get_value ( node . orelse ) } \"","title":"_get_ifexp_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_in_value","text":"Source code in griffe/agents/nodes.py 846 847 def _get_in_value ( node : NodeIn ) -> str : return \"in\"","title":"_get_in_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_index_annotation","text":"Source code in griffe/agents/nodes.py 644 645 def _get_index_annotation ( node : NodeIndex , parent : Module | Class ) -> str | Name | Expression : return _get_annotation ( node . value , parent )","title":"_get_index_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_index_value","text":"Source code in griffe/agents/nodes.py 1048 1049 def _get_index_value ( node : NodeIndex ) -> str : return get_value ( node . value )","title":"_get_index_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_invert_value","text":"Source code in griffe/agents/nodes.py 842 843 def _get_invert_value ( node : NodeInvert ) -> str : return \"~\"","title":"_get_invert_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_is_value","text":"Source code in griffe/agents/nodes.py 850 851 def _get_is_value ( node : NodeIs ) -> str : return \"is\"","title":"_get_is_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_isnot_value","text":"Source code in griffe/agents/nodes.py 854 855 def _get_isnot_value ( node : NodeIsNot ) -> str : return \"is not\"","title":"_get_isnot_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_joinedstr_value","text":"Source code in griffe/agents/nodes.py 858 859 860 861 862 def _get_joinedstr_value ( node : NodeJoinedStr ) -> str : _node_value_map [ NodeConstant ] = _get_constant_value_no_repr result = repr ( \"\" . join ( get_value ( value ) for value in node . values )) _node_value_map [ NodeConstant ] = _get_constant_value return result","title":"_get_joinedstr_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_keyword_value","text":"Source code in griffe/agents/nodes.py 865 866 def _get_keyword_value ( node : NodeKeyword ) -> str : return f \" { node . arg } = { get_value ( node . value ) } \"","title":"_get_keyword_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_lambda_value","text":"Source code in griffe/agents/nodes.py 869 870 def _get_lambda_value ( node : NodeLambda ) -> str : return f \"lambda { get_value ( node . args ) } : { get_value ( node . body ) } \"","title":"_get_lambda_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_list_annotation","text":"Source code in griffe/agents/nodes.py 608 609 def _get_list_annotation ( node : NodeList , parent : Module | Class ) -> Expression : return Expression ( \"[\" , * _join ([ _get_annotation ( el , parent ) for el in node . elts ], \", \" ), \"]\" )","title":"_get_list_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_list_value","text":"Source code in griffe/agents/nodes.py 873 874 def _get_list_value ( node : NodeList ) -> str : return \"[\" + \", \" . join ( get_value ( el ) for el in node . elts ) + \"]\"","title":"_get_list_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_listcomp_value","text":"Source code in griffe/agents/nodes.py 877 878 879 880 def _get_listcomp_value ( node : NodeListComp ) -> str : element = get_value ( node . elt ) generators = [ get_value ( gen ) for gen in node . generators ] return f \"[ { element } \" + \" \" . join ( generators ) + \"]\"","title":"_get_listcomp_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_lshift_value","text":"Source code in griffe/agents/nodes.py 883 884 def _get_lshift_value ( node : NodeLShift ) -> str : return \"<<\"","title":"_get_lshift_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_lt_value","text":"Source code in griffe/agents/nodes.py 891 892 def _get_lt_value ( node : NodeNotEq ) -> str : return \"<\"","title":"_get_lt_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_lte_value","text":"Source code in griffe/agents/nodes.py 887 888 def _get_lte_value ( node : NodeNotEq ) -> str : return \"<=\"","title":"_get_lte_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_mod_value","text":"Source code in griffe/agents/nodes.py 895 896 def _get_mod_value ( node : NodeMod ) -> str : return \"%\"","title":"_get_mod_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_mult_value","text":"Source code in griffe/agents/nodes.py 899 900 def _get_mult_value ( node : NodeMult ) -> str : return \"*\"","title":"_get_mult_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_name_annotation","text":"Source code in griffe/agents/nodes.py 612 613 def _get_name_annotation ( node : NodeName , parent : Module | Class ) -> Name : return Name ( node . id , partial ( parent . resolve , node . id ))","title":"_get_name_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_name_name","text":"Source code in griffe/agents/nodes.py 1093 1094 def _get_name_name ( node : NodeName ) -> str : return node . id","title":"_get_name_name()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_name_value","text":"Source code in griffe/agents/nodes.py 903 904 def _get_name_value ( node : NodeName ) -> str : return node . id","title":"_get_name_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_nameconstant_annotation","text":"Source code in griffe/agents/nodes.py 652 653 def _get_nameconstant_annotation ( node : NodeNameConstant , parent : Module | Class ) -> str | Name | Expression : return repr ( node . value )","title":"_get_nameconstant_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_nameconstant_value","text":"Source code in griffe/agents/nodes.py 1060 1061 def _get_nameconstant_value ( node : NodeNameConstant ) -> str : return repr ( node . value )","title":"_get_nameconstant_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_not_value","text":"Source code in griffe/agents/nodes.py 907 908 def _get_not_value ( node : NodeNot ) -> str : return \"not \"","title":"_get_not_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_noteq_value","text":"Source code in griffe/agents/nodes.py 911 912 def _get_noteq_value ( node : NodeNotEq ) -> str : return \"!=\"","title":"_get_noteq_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_notin_value","text":"Source code in griffe/agents/nodes.py 915 916 def _get_notin_value ( node : NodeNotIn ) -> str : return \"not in\"","title":"_get_notin_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_num_value","text":"Source code in griffe/agents/nodes.py 1063 1064 def _get_num_value ( node : NodeNum ) -> str : return repr ( node . n )","title":"_get_num_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_or_value","text":"Source code in griffe/agents/nodes.py 919 920 def _get_or_value ( node : NodeOr ) -> str : return \" or \"","title":"_get_or_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_pow_value","text":"Source code in griffe/agents/nodes.py 923 924 def _get_pow_value ( node : NodePow ) -> str : return \"**\"","title":"_get_pow_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_rshift_value","text":"Source code in griffe/agents/nodes.py 927 928 def _get_rshift_value ( node : NodeRShift ) -> str : return \">>\"","title":"_get_rshift_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_set_value","text":"Source code in griffe/agents/nodes.py 931 932 def _get_set_value ( node : NodeSet ) -> str : return \"{\" + \", \" . join ( get_value ( el ) for el in node . elts ) + \"}\"","title":"_get_set_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_setcomp_value","text":"Source code in griffe/agents/nodes.py 935 936 937 938 def _get_setcomp_value ( node : NodeSetComp ) -> str : element = get_value ( node . elt ) generators = [ get_value ( gen ) for gen in node . generators ] return f \" {{ { element } \" + \" \" . join ( generators ) + \"}\"","title":"_get_setcomp_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_slice_value","text":"Source code in griffe/agents/nodes.py 941 942 943 944 945 def _get_slice_value ( node : NodeSlice ) -> str : value = f \" { get_value ( node . lower ) if node . lower else '' } : { get_value ( node . upper ) if node . upper else '' } \" if node . step : value = f \" { value } : { get_value ( node . step ) } \" return value","title":"_get_slice_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_starred_value","text":"Source code in griffe/agents/nodes.py 948 949 def _get_starred_value ( node : NodeStarred ) -> str : return get_value ( node . value )","title":"_get_starred_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_str_annotation","text":"Source code in griffe/agents/nodes.py 655 656 def _get_str_annotation ( node : NodeStr , parent : Module | Class ) -> str : return node . s","title":"_get_str_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_str_value","text":"Source code in griffe/agents/nodes.py 1066 1067 def _get_str_value ( node : NodeStr ) -> str : return repr ( node . s )","title":"_get_str_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_sub_value","text":"Source code in griffe/agents/nodes.py 952 953 def _get_sub_value ( node : NodeSub ) -> str : return \"-\"","title":"_get_sub_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_subscript_annotation","text":"Source code in griffe/agents/nodes.py 616 617 618 619 def _get_subscript_annotation ( node : NodeSubscript , parent : Module | Class ) -> Expression : left = _get_annotation ( node . value , parent ) subscript = _get_annotation ( node . slice , parent ) return Expression ( left , \"[\" , subscript , \"]\" )","title":"_get_subscript_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_subscript_value","text":"Source code in griffe/agents/nodes.py 956 957 958 959 960 def _get_subscript_value ( node : NodeSubscript ) -> str : subscript = get_value ( node . slice ) if isinstance ( subscript , str ): subscript = subscript . strip ( \"()\" ) return f \" { get_value ( node . value ) } [ { subscript } ]\"","title":"_get_subscript_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_tuple_annotation","text":"Source code in griffe/agents/nodes.py 622 623 def _get_tuple_annotation ( node : NodeTuple , parent : Module | Class ) -> Expression : return Expression ( * _join ([ _get_annotation ( el , parent ) for el in node . elts ], \", \" ))","title":"_get_tuple_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_tuple_value","text":"Source code in griffe/agents/nodes.py 963 964 def _get_tuple_value ( node : NodeTuple ) -> str : return \"(\" + \", \" . join ( get_value ( el ) for el in node . elts ) + \")\"","title":"_get_tuple_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_uadd_value","text":"Source code in griffe/agents/nodes.py 967 968 def _get_uadd_value ( node : NodeUAdd ) -> str : return \"+\"","title":"_get_uadd_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_unaryop_value","text":"Source code in griffe/agents/nodes.py 971 972 def _get_unaryop_value ( node : NodeUnaryOp ) -> str : return f \" { get_value ( node . op ) }{ get_value ( node . operand ) } \"","title":"_get_unaryop_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_usub_value","text":"Source code in griffe/agents/nodes.py 975 976 def _get_usub_value ( node : NodeUSub ) -> str : return \"-\"","title":"_get_usub_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._get_yield_value","text":"Source code in griffe/agents/nodes.py 979 980 981 982 def _get_yield_value ( node : NodeYield ) -> str : if node . value is None : return repr ( None ) return get_value ( node . value )","title":"_get_yield_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes._join","text":"Source code in griffe/agents/nodes.py 513 514 515 516 517 518 519 def _join ( sequence , item ): if not sequence : return [] new_sequence = [ sequence [ 0 ]] for element in sequence [ 1 :]: new_sequence . extend (( item , element )) return new_sequence","title":"_join()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_annotation","text":"Extract a resolvable annotation. Parameters: node ( AST | None ) \u2013 The annotation node. parent ( Module | Class ) \u2013 The parent used to resolve the name. Returns: str | Name | Expression | None \u2013 A string or resovable name or expression. Source code in griffe/agents/nodes.py 666 667 668 669 670 671 672 673 674 675 676 677 678 def get_annotation ( node : AST | None , parent : Module | Class ) -> str | Name | Expression | None : \"\"\"Extract a resolvable annotation. Parameters: node: The annotation node. parent: The parent used to resolve the name. Returns: A string or resovable name or expression. \"\"\" if node is None : return None return _get_annotation ( node , parent )","title":"get_annotation()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_docstring","text":"Extract a docstring. Parameters: node ( AST ) \u2013 The node to extract the docstring from. strict ( bool ) \u2013 Whether to skip searching the body (functions). Returns: tuple [ str | None, int | None, int | None] \u2013 A tuple with the value and line numbers of the docstring. Source code in griffe/agents/nodes.py 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 def get_docstring ( node : AST , strict : bool = False , ) -> tuple [ str | None , int | None , int | None ]: \"\"\"Extract a docstring. Parameters: node: The node to extract the docstring from. strict: Whether to skip searching the body (functions). Returns: A tuple with the value and line numbers of the docstring. \"\"\" # TODO: possible optimization using a type map if isinstance ( node , NodeExpr ): doc = node . value elif node . body and isinstance ( node . body [ 0 ], NodeExpr ) and not strict : # type: ignore[attr-defined] doc = node . body [ 0 ] . value # type: ignore[attr-defined] else : return None , None , None if isinstance ( doc , NodeConstant ) and isinstance ( doc . value , str ): return doc . value , doc . lineno , doc . end_lineno # type: ignore[attr-defined] if isinstance ( doc , NodeStr ): return doc . s , doc . lineno , doc . end_lineno # type: ignore[attr-defined] return None , None , None","title":"get_docstring()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_instance_names","text":"Extract names from an assignment node, only for instance attributes. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 def get_instance_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node, only for instance attributes. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return [ name . split ( \".\" , 1 )[ 1 ] for name in get_names ( node ) if name . startswith ( \"self.\" )]","title":"get_instance_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_name","text":"Extract name from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: str \u2013 A list of names. Source code in griffe/agents/nodes.py 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 def get_name ( node : AST ) -> str : \"\"\"Extract name from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_name_map [ type ( node )]( node )","title":"get_name()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_names","text":"Extract names from an assignment node. Parameters: node ( AST ) \u2013 The node to extract names from. Returns: list [ str ] \u2013 A list of names. Source code in griffe/agents/nodes.py 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 def get_names ( node : AST ) -> list [ str ]: \"\"\"Extract names from an assignment node. Parameters: node: The node to extract names from. Returns: A list of names. \"\"\" return _node_names_map [ type ( node )]( node )","title":"get_names()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_parameter_default","text":"Extract the default value of a function parameter. Parameters: node ( AST ) \u2013 The node to extract the default value from. filepath ( Path ) \u2013 The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection ( LinesCollection ) \u2013 A collection of source code lines. Returns: str | None \u2013 The default value as a string. Source code in griffe/agents/nodes.py 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 def get_parameter_default ( node : AST , filepath : Path , lines_collection : LinesCollection ) -> str | None : \"\"\"Extract the default value of a function parameter. Parameters: node: The node to extract the default value from. filepath: The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection. lines_collection: A collection of source code lines. Returns: The default value as a string. \"\"\" if node is None : return None if isinstance ( node , NodeConstant ): return repr ( node . value ) if isinstance ( node , NodeName ): return node . id if node . lineno == node . end_lineno : # type: ignore[attr-defined] return lines_collection [ filepath ][ node . lineno - 1 ][ node . col_offset : node . end_col_offset ] # type: ignore[attr-defined] # TODO: handle multiple line defaults return None","title":"get_parameter_default()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_value","text":"Extract a complex value as a string. Parameters: node ( AST ) \u2013 The node to extract the value from. Returns: str \u2013 The unparsed code of the node. Source code in griffe/agents/nodes.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 def get_value ( node : AST ) -> str : \"\"\"Extract a complex value as a string. Parameters: node: The node to extract the value from. Returns: The unparsed code of the node. \"\"\" return _node_value_map [ type ( node )]( node )","title":"get_value()"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.parse__all__","text":"Get the values declared in __all__ . Parameters: node ( NodeAssign ) \u2013 The assignment node. Returns: set [ str ] \u2013 A set of names. Source code in griffe/agents/nodes.py 537 538 539 540 541 542 543 544 545 546 def parse__all__ ( node : NodeAssign ) -> set [ str ]: # noqa: WPS116,WPS120,WPS440 \"\"\"Get the values declared in `__all__`. Parameters: node: The assignment node. Returns: A set of names. \"\"\" return { elt . value for elt in node . value . elts } # type: ignore[attr-defined]","title":"parse__all__()"},{"location":"reference/griffe/agents/visitor/","text":"Code parsing and data extraction utilies. This module exposes a public function, visit() , which parses the module code using parse() , and returns a new Module instance, populating its members recursively, by using a NodeVisitor -like class. _patched = False \u00a4 Visitor ( BaseVisitor ) \u00a4 This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. Source code in griffe/agents/visitor.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class Visitor ( BaseVisitor ): # noqa: WPS338 \"\"\"This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. \"\"\" def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () def _get_docstring ( self , node : ast . AST , strict : bool = False ) -> Docstring | None : value , lineno , endlineno = get_docstring ( node , strict = strict ) if value is None : return None return Docstring ( value , lineno = lineno , endlineno = endlineno , parser = self . docstring_parser , parser_options = self . docstring_options , ) def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node ) def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node ) def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node ) def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node ) def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" }) def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name . split ( \".\" , 1 )[ 0 ] alias_name = name . asname or alias_path self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) def visit_importfrom ( self , node : ast . ImportFrom ) -> None : # noqa: WPS231 \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_name = name . asname or name . name level = node . level module_path = node . module if level > 0 : if module_path is None : level -= 1 parent : Module = self . current . module if parent . is_package or parent . is_subpackage : level -= 1 while level > 0 : parent = parent . parent # type: ignore[assignment] level -= 1 if module_path : module_path = f \" { parent . path } . { module_path } \" else : module_path = parent . path if alias_name == \"*\" : alias_name = module_path . replace ( \".\" , \"/\" ) + \"/*\" # type: ignore[union-attr] alias_path = module_path else : alias_path = f \" { module_path } . { name . name } \" self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , # type: ignore[arg-type] lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times: check for try/excepts # TODO: might be better to inspect if isinstance ( node . parent , ast . ExceptHandler ): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = parse__all__ ( node ) # type: ignore[arg-type] def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node ) def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current )) code : str = code \u00a4 current : Module | Class = None \u00a4 docstring_options : dict [ str , Any ] = docstring_options or {} \u00a4 docstring_parser : Parser | None = docstring_parser \u00a4 extensions : Extensions = extensions . attach_visitor ( self ) \u00a4 filepath : Path = filepath \u00a4 in_decorator : bool = False \u00a4 lines_collection : LinesCollection = lines_collection or LinesCollection () \u00a4 module_name : str = module_name \u00a4 modules_collection : ModulesCollection = modules_collection or ModulesCollection () \u00a4 parent : Module | None = parent \u00a4 __init__ ( self , module_name , filepath , code , extensions , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 Initialize the visitor. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path ) \u2013 The module filepath. code ( str ) \u2013 The module source code. extensions ( Extensions ) \u2013 The extensions to use when visiting. parent ( Module | None ) \u2013 An optional parent for the final module object. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/agents/visitor.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () _get_docstring ( self , node , strict = False ) \u00a4 Source code in griffe/agents/visitor.py 134 135 136 137 138 139 140 141 142 143 144 def _get_docstring ( self , node : ast . AST , strict : bool = False ) -> Docstring | None : value , lineno , endlineno = get_docstring ( node , strict = strict ) if value is None : return None return Docstring ( value , lineno = lineno , endlineno = endlineno , parser = self . docstring_parser , parser_options = self . docstring_options , ) generic_visit ( self , node ) \u00a4 Extend the base generic visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 172 173 174 175 176 177 178 179 180 181 182 183 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node ) get_module ( self ) \u00a4 Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: Module \u2013 A module instance. Source code in griffe/agents/visitor.py 146 147 148 149 150 151 152 153 154 155 156 157 158 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module handle_attribute ( self , node , annotation = None ) \u00a4 Handle an attribute (assignment) node. Parameters: node ( ast . Assign | ast . AnnAssign ) \u2013 The node to visit. annotation ( str | Name | Expression | None ) \u2013 A potential annotation. Source code in griffe/agents/visitor.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times: check for try/excepts # TODO: might be better to inspect if isinstance ( node . parent , ast . ExceptHandler ): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = parse__all__ ( node ) # type: ignore[arg-type] handle_function ( self , node , labels = None ) \u00a4 Handle a function definition node. Parameters: node ( ast . AsyncFunctionDef | ast . FunctionDef ) \u2013 The node to visit. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/visitor.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] visit ( self , node ) \u00a4 Extend the base visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 160 161 162 163 164 165 166 167 168 169 170 def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node ) visit_annassign ( self , node ) \u00a4 Visit an annotated assignment node. Parameters: node ( ast . AnnAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 502 503 504 505 506 507 508 def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current )) visit_assign ( self , node ) \u00a4 Visit an assignment node. Parameters: node ( ast . Assign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 494 495 496 497 498 499 500 def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node ) visit_asyncfunctiondef ( self , node ) \u00a4 Visit an async function definition node. Parameters: node ( ast . AsyncFunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 358 359 360 361 362 363 364 def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" }) visit_classdef ( self , node ) \u00a4 Visit a class definition node. Parameters: node ( ast . ClassDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] visit_functiondef ( self , node ) \u00a4 Visit a function definition node. Parameters: node ( ast . FunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 350 351 352 353 354 355 356 def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node ) visit_import ( self , node ) \u00a4 Visit an import node. Parameters: node ( ast . Import ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name . split ( \".\" , 1 )[ 0 ] alias_name = name . asname or alias_path self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) visit_importfrom ( self , node ) \u00a4 Visit an \"import from\" node. Parameters: node ( ast . ImportFrom ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def visit_importfrom ( self , node : ast . ImportFrom ) -> None : # noqa: WPS231 \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_name = name . asname or name . name level = node . level module_path = node . module if level > 0 : if module_path is None : level -= 1 parent : Module = self . current . module if parent . is_package or parent . is_subpackage : level -= 1 while level > 0 : parent = parent . parent # type: ignore[assignment] level -= 1 if module_path : module_path = f \" { parent . path } . { module_path } \" else : module_path = parent . path if alias_name == \"*\" : alias_name = module_path . replace ( \".\" , \"/\" ) + \"/*\" # type: ignore[union-attr] alias_path = module_path else : alias_path = f \" { module_path } . { name . name } \" self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , # type: ignore[arg-type] lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) visit_module ( self , node ) \u00a4 Visit a module node. Parameters: node ( ast . Module ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node ) patch_ast () \u00a4 Extend the base ast.AST class to provide more functionality. Source code in griffe/agents/visitor.py 514 515 516 517 518 519 520 521 522 523 def patch_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if ast . AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , ASTNode ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442 visit ( module_name , filepath , code , * , extensions = None , parent = None , docstring_parser = None , docstring_options = None , lines_collection = None , modules_collection = None ) \u00a4 Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/visitor.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def visit ( module_name : str , filepath : Path , code : str , * , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. Returns: The module, with its members populated. \"\"\" return Visitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , ) . get_module ()","title":"visitor"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor._patched","text":"","title":"_patched"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor","text":"This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. Source code in griffe/agents/visitor.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class Visitor ( BaseVisitor ): # noqa: WPS338 \"\"\"This class is used to instantiate a visitor. Visitors iterate on AST nodes to extract data from them. \"\"\" def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection () def _get_docstring ( self , node : ast . AST , strict : bool = False ) -> Docstring | None : value , lineno , endlineno = get_docstring ( node , strict = strict ) if value is None : return None return Docstring ( value , lineno = lineno , endlineno = endlineno , parser = self . docstring_parser , parser_options = self . docstring_options , ) def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node ) def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node ) def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node ) def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment] def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node ) def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" }) def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name . split ( \".\" , 1 )[ 0 ] alias_name = name . asname or alias_path self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) def visit_importfrom ( self , node : ast . ImportFrom ) -> None : # noqa: WPS231 \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_name = name . asname or name . name level = node . level module_path = node . module if level > 0 : if module_path is None : level -= 1 parent : Module = self . current . module if parent . is_package or parent . is_subpackage : level -= 1 while level > 0 : parent = parent . parent # type: ignore[assignment] level -= 1 if module_path : module_path = f \" { parent . path } . { module_path } \" else : module_path = parent . path if alias_name == \"*\" : alias_name = module_path . replace ( \".\" , \"/\" ) + \"/*\" # type: ignore[union-attr] alias_path = module_path else : alias_path = f \" { module_path } . { name . name } \" self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , # type: ignore[arg-type] lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node ) def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times: check for try/excepts # TODO: might be better to inspect if isinstance ( node . parent , ast . ExceptHandler ): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = parse__all__ ( node ) # type: ignore[arg-type] def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node ) def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current ))","title":"Visitor"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.code","text":"","title":"code"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.current","text":"","title":"current"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.docstring_options","text":"","title":"docstring_options"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.docstring_parser","text":"","title":"docstring_parser"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.extensions","text":"","title":"extensions"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.filepath","text":"","title":"filepath"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.in_decorator","text":"","title":"in_decorator"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.lines_collection","text":"","title":"lines_collection"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.module_name","text":"","title":"module_name"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.modules_collection","text":"","title":"modules_collection"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.parent","text":"","title":"parent"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.__init__","text":"Initialize the visitor. Parameters: module_name ( str ) \u2013 The module name. filepath ( Path ) \u2013 The module filepath. code ( str ) \u2013 The module source code. extensions ( Extensions ) \u2013 The extensions to use when visiting. parent ( Module | None ) \u2013 An optional parent for the final module object. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. docstring_options ( dict [ str , Any ] | None ) \u2013 The docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Source code in griffe/agents/visitor.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def __init__ ( self , module_name : str , filepath : Path , code : str , extensions : Extensions , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> None : \"\"\"Initialize the visitor. Parameters: module_name: The module name. filepath: The module filepath. code: The module source code. extensions: The extensions to use when visiting. parent: An optional parent for the final module object. docstring_parser: The docstring parser to use. docstring_options: The docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. \"\"\" super () . __init__ () self . module_name : str = module_name self . filepath : Path = filepath self . code : str = code self . extensions : Extensions = extensions . attach_visitor ( self ) self . parent : Module | None = parent self . current : Module | Class = None # type: ignore[assignment] self . in_decorator : bool = False self . docstring_parser : Parser | None = docstring_parser self . docstring_options : dict [ str , Any ] = docstring_options or {} self . lines_collection : LinesCollection = lines_collection or LinesCollection () self . modules_collection : ModulesCollection = modules_collection or ModulesCollection ()","title":"__init__()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor._get_docstring","text":"Source code in griffe/agents/visitor.py 134 135 136 137 138 139 140 141 142 143 144 def _get_docstring ( self , node : ast . AST , strict : bool = False ) -> Docstring | None : value , lineno , endlineno = get_docstring ( node , strict = strict ) if value is None : return None return Docstring ( value , lineno = lineno , endlineno = endlineno , parser = self . docstring_parser , parser_options = self . docstring_options , )","title":"_get_docstring()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.generic_visit","text":"Extend the base generic visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 172 173 174 175 176 177 178 179 180 181 182 183 def generic_visit ( self , node : ast . AST ) -> None : # noqa: WPS231 \"\"\"Extend the base generic visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_children_visit : before_visitor . visit ( node ) for child in node . children : # type: ignore[attr-defined] # noqa: WPS437 self . visit ( child ) for after_visitor in self . extensions . after_children_visit : after_visitor . visit ( node )","title":"generic_visit()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.get_module","text":"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: Module \u2013 A module instance. Source code in griffe/agents/visitor.py 146 147 148 149 150 151 152 153 154 155 156 157 158 def get_module ( self ) -> Module : \"\"\"Build and return the object representing the module attached to this visitor. This method triggers a complete visit of the module nodes. Returns: A module instance. \"\"\" # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements # TODO: with options, could use optimize=2 to remove docstrings top_node = compile ( self . code , mode = \"exec\" , filename = str ( self . filepath ), flags = ast . PyCF_ONLY_AST , optimize = 1 ) self . visit ( top_node ) return self . current . module","title":"get_module()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_attribute","text":"Handle an attribute (assignment) node. Parameters: node ( ast . Assign | ast . AnnAssign ) \u2013 The node to visit. annotation ( str | Name | Expression | None ) \u2013 A potential annotation. Source code in griffe/agents/visitor.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def handle_attribute ( # noqa: WPS231 self , node : ast . Assign | ast . AnnAssign , annotation : str | Name | Expression | None = None , ): \"\"\"Handle an attribute (assignment) node. Parameters: node: The node to visit. annotation: A potential annotation. \"\"\" parent = self . current labels = set () if parent . kind is Kind . MODULE : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"module\" ) elif parent . kind is Kind . CLASS : try : names = get_names ( node ) except KeyError : # unsupported nodes, like subscript return labels . add ( \"class\" ) elif parent . kind is Kind . FUNCTION : if parent . name != \"__init__\" : return try : names = get_instance_names ( node ) except KeyError : # unsupported nodes, like subscript return parent = parent . parent # type: ignore[assignment] labels . add ( \"instance\" ) if not names : return value = get_value ( node . value ) # type: ignore[arg-type] try : docstring = self . _get_docstring ( node . next , strict = True ) # type: ignore[union-attr] except ( LastNodeError , AttributeError ): docstring = None for name in names : # TODO: handle assigns like x.y = z # we need to resolve x.y and add z in its member if \".\" in name : continue if name in parent . members : # assigning multiple times: check for try/excepts # TODO: might be better to inspect if isinstance ( node . parent , ast . ExceptHandler ): # type: ignore[union-attr] continue # prefer \"no-exception\" case attribute = Attribute ( name = name , value = value , annotation = annotation , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[union-attr] docstring = docstring , ) attribute . labels |= labels parent [ name ] = attribute if name == \"__all__\" : with suppress ( AttributeError ): parent . exports = parse__all__ ( node ) # type: ignore[arg-type]","title":"handle_attribute()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_function","text":"Handle a function definition node. Parameters: node ( ast . AsyncFunctionDef | ast . FunctionDef ) \u2013 The node to visit. labels ( set | None ) \u2013 Labels to add to the data object. Source code in griffe/agents/visitor.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def handle_function ( self , node : ast . AsyncFunctionDef | ast . FunctionDef , labels : set | None = None ): # noqa: WPS231 \"\"\"Handle a function definition node. Parameters: node: The node to visit. labels: Labels to add to the data object. \"\"\" labels = labels or set () # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle parameters parameters = Parameters () annotation : str | Name | Expression | None # TODO: remove once Python 3.7 support is dropped try : posonlyargs = node . args . posonlyargs # type: ignore[attr-defined] except AttributeError : posonlyargs = [] # TODO: probably some optimizations to do here args_kinds_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( ( * zip_longest ( posonlyargs , # type: ignore[attr-defined] [], fillvalue = ParameterKind . positional_only , ), * zip_longest ( node . args . args , [], fillvalue = ParameterKind . positional_or_keyword ), ), ), reversed ( node . args . defaults ), fillvalue = None , ), ) ) for ( arg , kind ), default in args_kinds_defaults : annotation = get_annotation ( arg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( arg . arg , annotation = annotation , kind = kind , default = default )) if node . args . vararg : annotation = get_annotation ( node . args . vararg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"* { node . args . vararg . arg } \" , annotation = annotation , kind = ParameterKind . var_positional , default = \"()\" , ) ) # TODO: probably some optimizations to do here kwargs_defaults = reversed ( ( * zip_longest ( # noqa: WPS356 reversed ( node . args . kwonlyargs ), reversed ( node . args . kw_defaults ), fillvalue = None , ), ) ) for kwarg , default in kwargs_defaults : # noqa: WPS440 annotation = get_annotation ( kwarg . annotation , parent = self . current ) default = get_parameter_default ( default , self . filepath , self . lines_collection ) parameters . add ( Parameter ( kwarg . arg , annotation = annotation , kind = ParameterKind . keyword_only , default = default ) ) if node . args . kwarg : annotation = get_annotation ( node . args . kwarg . annotation , parent = self . current ) parameters . add ( Parameter ( f \"** { node . args . kwarg . arg } \" , annotation = annotation , kind = ParameterKind . var_keyword , default = \" {} \" , # noqa: P103 ) ) function = Function ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[union-attr] parameters = parameters , returns = get_annotation ( node . returns , parent = self . current ), decorators = decorators , docstring = self . _get_docstring ( node ), ) self . current [ node . name ] = function function . labels |= labels if self . current . kind is Kind . CLASS and function . name == \"__init__\" : self . current = function # type: ignore[assignment] # temporary assign a function self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"handle_function()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit","text":"Extend the base visit with extensions. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 160 161 162 163 164 165 166 167 168 169 170 def visit ( self , node : ast . AST ) -> None : \"\"\"Extend the base visit with extensions. Parameters: node: The node to visit. \"\"\" for before_visitor in self . extensions . before_visit : before_visitor . visit ( node ) super () . visit ( node ) for after_visitor in self . extensions . after_visit : after_visitor . visit ( node )","title":"visit()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_annassign","text":"Visit an annotated assignment node. Parameters: node ( ast . AnnAssign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 502 503 504 505 506 507 508 def visit_annassign ( self , node : ast . AnnAssign ) -> None : \"\"\"Visit an annotated assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node , get_annotation ( node . annotation , parent = self . current ))","title":"visit_annassign()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_assign","text":"Visit an assignment node. Parameters: node ( ast . Assign ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 494 495 496 497 498 499 500 def visit_assign ( self , node : ast . Assign ) -> None : \"\"\"Visit an assignment node. Parameters: node: The node to visit. \"\"\" self . handle_attribute ( node )","title":"visit_assign()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_asyncfunctiondef","text":"Visit an async function definition node. Parameters: node ( ast . AsyncFunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 358 359 360 361 362 363 364 def visit_asyncfunctiondef ( self , node : ast . AsyncFunctionDef ) -> None : \"\"\"Visit an async function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node , labels = { \"async\" })","title":"visit_asyncfunctiondef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_classdef","text":"Visit a class definition node. Parameters: node ( ast . ClassDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def visit_classdef ( self , node : ast . ClassDef ) -> None : \"\"\"Visit a class definition node. Parameters: node: The node to visit. \"\"\" # handle decorators decorators = [] if node . decorator_list : lineno = node . decorator_list [ 0 ] . lineno self . in_decorator = True for decorator_node in node . decorator_list : decorators . append ( Decorator ( decorator_node . lineno , decorator_node . end_lineno )) # type: ignore[attr-defined] self . visit ( decorator_node ) self . in_decorator = False else : lineno = node . lineno # handle base classes bases = [] if node . bases : for base in node . bases : bases . append ( get_annotation ( base , self . current )) class_ = Class ( name = node . name , lineno = lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] docstring = self . _get_docstring ( node ), decorators = decorators , bases = bases , # type: ignore[arg-type] ) self . current [ node . name ] = class_ self . current = class_ self . generic_visit ( node ) self . current = self . current . parent # type: ignore[assignment]","title":"visit_classdef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_functiondef","text":"Visit a function definition node. Parameters: node ( ast . FunctionDef ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 350 351 352 353 354 355 356 def visit_functiondef ( self , node : ast . FunctionDef ) -> None : \"\"\"Visit a function definition node. Parameters: node: The node to visit. \"\"\" self . handle_function ( node )","title":"visit_functiondef()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_import","text":"Visit an import node. Parameters: node ( ast . Import ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def visit_import ( self , node : ast . Import ) -> None : \"\"\"Visit an import node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_path = name . name . split ( \".\" , 1 )[ 0 ] alias_name = name . asname or alias_path self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node )","title":"visit_import()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_importfrom","text":"Visit an \"import from\" node. Parameters: node ( ast . ImportFrom ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def visit_importfrom ( self , node : ast . ImportFrom ) -> None : # noqa: WPS231 \"\"\"Visit an \"import from\" node. Parameters: node: The node to visit. \"\"\" for name in node . names : alias_name = name . asname or name . name level = node . level module_path = node . module if level > 0 : if module_path is None : level -= 1 parent : Module = self . current . module if parent . is_package or parent . is_subpackage : level -= 1 while level > 0 : parent = parent . parent # type: ignore[assignment] level -= 1 if module_path : module_path = f \" { parent . path } . { module_path } \" else : module_path = parent . path if alias_name == \"*\" : alias_name = module_path . replace ( \".\" , \"/\" ) + \"/*\" # type: ignore[union-attr] alias_path = module_path else : alias_path = f \" { module_path } . { name . name } \" self . current . imports [ alias_name ] = alias_path self . current [ alias_name ] = Alias ( alias_name , alias_path , # type: ignore[arg-type] lineno = node . lineno , endlineno = node . end_lineno , # type: ignore[attr-defined] ) self . generic_visit ( node )","title":"visit_importfrom()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_module","text":"Visit a module node. Parameters: node ( ast . Module ) \u2013 The node to visit. Source code in griffe/agents/visitor.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def visit_module ( self , node : ast . Module ) -> None : \"\"\"Visit a module node. Parameters: node: The node to visit. \"\"\" self . current = Module ( name = self . module_name , filepath = self . filepath , parent = self . parent , docstring = self . _get_docstring ( node ), lines_collection = self . lines_collection , modules_collection = self . modules_collection , ) self . generic_visit ( node )","title":"visit_module()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.patch_ast","text":"Extend the base ast.AST class to provide more functionality. Source code in griffe/agents/visitor.py 514 515 516 517 518 519 520 521 522 523 def patch_ast () -> None : \"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\" global _patched # noqa: WPS420 if _patched : return for name , member in inspect . getmembers ( ast ): if name != \"AST\" and inspect . isclass ( member ): if ast . AST in member . __bases__ : # noqa: WPS609 member . __bases__ = ( * member . __bases__ , ASTNode ) # noqa: WPS609 _patched = True # noqa: WPS122,WPS442","title":"patch_ast()"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.visit","text":"Parse and visit a module file. Parameters: module_name ( str ) \u2013 The module name (as when importing [from] it). filepath ( Path ) \u2013 The module file path. code ( str ) \u2013 The module contents. extensions ( Extensions | None ) \u2013 The extensions to use when visiting the AST. parent ( Module | None ) \u2013 The optional parent of this module. docstring_parser ( Parser | None ) \u2013 The docstring parser to use. By default, no parsing is done. docstring_options ( dict [ str , Any ] | None ) \u2013 Additional docstring parsing options. lines_collection ( LinesCollection | None ) \u2013 A collection of source code lines. modules_collection ( ModulesCollection | None ) \u2013 A collection of modules. Returns: Module \u2013 The module, with its members populated. Source code in griffe/agents/visitor.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def visit ( module_name : str , filepath : Path , code : str , * , extensions : Extensions | None = None , parent : Module | None = None , docstring_parser : Parser | None = None , docstring_options : dict [ str , Any ] | None = None , lines_collection : LinesCollection | None = None , modules_collection : ModulesCollection | None = None , ) -> Module : \"\"\"Parse and visit a module file. Parameters: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. parent: The optional parent of this module. docstring_parser: The docstring parser to use. By default, no parsing is done. docstring_options: Additional docstring parsing options. lines_collection: A collection of source code lines. modules_collection: A collection of modules. Returns: The module, with its members populated. \"\"\" return Visitor ( module_name , filepath , code , extensions or Extensions (), parent , docstring_parser = docstring_parser , docstring_options = docstring_options , lines_collection = lines_collection , modules_collection = modules_collection , ) . get_module ()","title":"visit()"},{"location":"reference/griffe/agents/extensions/","text":"This module is the public interface to import elements from the base. Extension = Union [ VisitorExtension , InspectorExtension ] \u00a4 __all__ = [ 'Extensions' , 'Extension' , 'InspectorExtension' , 'VisitorExtension' , 'When' , 'load_extension' , 'load_extensions' ] \u00a4 Extensions \u00a4 This class helps iterating on extensions that should run at different times. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class Extensions : \"\"\"This class helps iterating on extensions that should run at different times.\"\"\" def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ] _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) \u00a4 _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) \u00a4 __init__ ( self , * extensions ) \u00a4 Initialize the extensions container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 97 98 99 100 101 102 103 104 105 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) add ( self , * extensions ) \u00a4 Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 107 108 109 110 111 112 113 114 115 116 117 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) after_children_inspection ( self ) \u00a4 Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 201 202 203 204 205 206 207 208 @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] after_children_visit ( self ) \u00a4 Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 165 166 167 168 169 170 171 172 @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] after_inspection ( self ) \u00a4 Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 210 211 212 213 214 215 216 217 @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ] after_visit ( self ) \u00a4 Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 174 175 176 177 178 179 180 181 @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] attach_inspector ( self , parent_inspector ) \u00a4 Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 133 134 135 136 137 138 139 140 141 142 143 144 145 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self attach_visitor ( self , parent_visitor ) \u00a4 Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 119 120 121 122 123 124 125 126 127 128 129 130 131 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self before_children_inspection ( self ) \u00a4 Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 192 193 194 195 196 197 198 199 @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] before_children_visit ( self ) \u00a4 Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 156 157 158 159 160 161 162 163 @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] before_inspection ( self ) \u00a4 Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 183 184 185 186 187 188 189 190 @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] before_visit ( self ) \u00a4 Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 147 148 149 150 151 152 153 154 @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] InspectorExtension ( BaseInspector ) \u00a4 The object inspector extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class InspectorExtension ( BaseInspector ): \"\"\"The object inspector extension base class, to inherit from.\"\"\" when : When def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment] def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node ) inspector : Inspector = None \u00a4 when : When = None \u00a4 __init__ ( self ) \u00a4 Initialize the inspector extension. Source code in griffe/agents/extensions/base.py 69 70 71 72 def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment] attach ( self , inspector ) \u00a4 Attach the parent inspector to this extension. Parameters: inspector ( Inspector ) \u2013 The parent inspector. Source code in griffe/agents/extensions/base.py 74 75 76 77 78 79 80 def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector inspect ( self , node ) \u00a4 Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/extensions/base.py 82 83 84 85 86 87 88 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node ) VisitorExtension ( BaseVisitor ) \u00a4 The node visitor extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class VisitorExtension ( BaseVisitor ): \"\"\"The node visitor extension base class, to inherit from.\"\"\" when : When def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment] def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined] visitor : Visitor = None \u00a4 when : When = None \u00a4 __init__ ( self ) \u00a4 Initialize the visitor extension. Source code in griffe/agents/extensions/base.py 42 43 44 45 def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment] attach ( self , visitor ) \u00a4 Attach the parent visitor to this extension. Parameters: visitor ( Visitor ) \u2013 The parent visitor. Source code in griffe/agents/extensions/base.py 47 48 49 50 51 52 53 def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor visit ( self , node ) \u00a4 Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/extensions/base.py 55 56 57 58 59 60 61 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined] When ( enum . Enum ) \u00a4 This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class When ( enum . Enum ): \"\"\"This enumeration contains the different times at which an extension is used. Attributes: before_all: For each node, before the visit/inspection. before_children: For each node, after the visit has started, and before the children visit/inspection. after_children: For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all: For each node, after the visit/inspection. \"\"\" before_all : int = 1 before_children : int = 2 after_children : int = 3 after_all : int = 4 after_all : int = 4 \u00a4 after_children : int = 3 \u00a4 before_all : int = 1 \u00a4 before_children : int = 2 \u00a4 load_extension ( extension ) \u00a4 Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Raises: ExtensionNotLoadedError \u2013 When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Raises: ExtensionNotLoadedError: When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" try : ext_module = dynamic_import ( import_path ) except ModuleNotFoundError as error : raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' could not be found\" ) from error try : return ext_module . Extension ( ** options ) except AttributeError as error : # noqa: WPS440 raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' has no 'Extension' attribute\" ) from error load_extensions ( exts ) \u00a4 Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"extensions"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.Extension","text":"","title":"Extension"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.__all__","text":"","title":"__all__"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.Extensions","text":"This class helps iterating on extensions that should run at different times. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class Extensions : \"\"\"This class helps iterating on extensions that should run at different times.\"\"\" def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions ) def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension ) def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ] @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ] @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ] @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ] @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ] @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ] @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ] @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ]","title":"Extensions"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions._inspectors","text":"","title":"_inspectors"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions._visitors","text":"","title":"_visitors"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.__init__","text":"Initialize the extensions container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 97 98 99 100 101 102 103 104 105 def __init__ ( self , * extensions : Extension ) -> None : \"\"\"Initialize the extensions container. Parameters: *extensions: The extensions to add. \"\"\" self . _visitors : dict [ When , list [ VisitorExtension ]] = defaultdict ( list ) self . _inspectors : dict [ When , list [ InspectorExtension ]] = defaultdict ( list ) self . add ( * extensions )","title":"__init__()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.add","text":"Add extensions to this container. Parameters: *extensions ( Extension ) \u2013 The extensions to add. Source code in griffe/agents/extensions/base.py 107 108 109 110 111 112 113 114 115 116 117 def add ( self , * extensions : Extension ) -> None : \"\"\"Add extensions to this container. Parameters: *extensions: The extensions to add. \"\"\" for extension in extensions : if isinstance ( extension , VisitorExtension ): self . _visitors [ extension . when ] . append ( extension ) else : self . _inspectors [ extension . when ] . append ( extension )","title":"add()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_children_inspection","text":"Return the inspectors that run after the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 201 202 203 204 205 206 207 208 @property def after_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_children ]","title":"after_children_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_children_visit","text":"Return the visitors that run after the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 165 166 167 168 169 170 171 172 @property def after_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_children ]","title":"after_children_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_inspection","text":"Return the inspectors that run after the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 210 211 212 213 214 215 216 217 @property def after_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run after the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . after_all ]","title":"after_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.after_visit","text":"Return the visitors that run after the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 174 175 176 177 178 179 180 181 @property def after_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run after the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . after_all ]","title":"after_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.attach_inspector","text":"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector ( Inspector ) \u2013 The parent inspector, leading the inspection. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 133 134 135 136 137 138 139 140 141 142 143 144 145 def attach_inspector ( self , parent_inspector : Inspector ) -> Extensions : \"\"\"Attach a parent inspector to the inspector extensions. Parameters: parent_inspector: The parent inspector, leading the inspection. Returns: Self, conveniently. \"\"\" for when in self . _inspectors . keys (): for inspector in self . _inspectors [ when ]: inspector . attach ( parent_inspector ) return self","title":"attach_inspector()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.attach_visitor","text":"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor ( Visitor ) \u2013 The parent visitor, leading the visit. Returns: Extensions \u2013 Self, conveniently. Source code in griffe/agents/extensions/base.py 119 120 121 122 123 124 125 126 127 128 129 130 131 def attach_visitor ( self , parent_visitor : Visitor ) -> Extensions : \"\"\"Attach a parent visitor to the visitor extensions. Parameters: parent_visitor: The parent visitor, leading the visit. Returns: Self, conveniently. \"\"\" for when in self . _visitors . keys (): for visitor in self . _visitors [ when ]: visitor . attach ( parent_visitor ) return self","title":"attach_visitor()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_children_inspection","text":"Return the inspectors that run before the children inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 192 193 194 195 196 197 198 199 @property def before_children_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the children inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_children ]","title":"before_children_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_children_visit","text":"Return the visitors that run before the children visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 156 157 158 159 160 161 162 163 @property def before_children_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the children visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_children ]","title":"before_children_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_inspection","text":"Return the inspectors that run before the inspection. Returns: list [ InspectorExtension ] \u2013 Inspectors. Source code in griffe/agents/extensions/base.py 183 184 185 186 187 188 189 190 @property def before_inspection ( self ) -> list [ InspectorExtension ]: \"\"\"Return the inspectors that run before the inspection. Returns: Inspectors. \"\"\" return self . _inspectors [ When . before_all ]","title":"before_inspection()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.Extensions.before_visit","text":"Return the visitors that run before the visit. Returns: list [ VisitorExtension ] \u2013 Visitors. Source code in griffe/agents/extensions/base.py 147 148 149 150 151 152 153 154 @property def before_visit ( self ) -> list [ VisitorExtension ]: \"\"\"Return the visitors that run before the visit. Returns: Visitors. \"\"\" return self . _visitors [ When . before_all ]","title":"before_visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.InspectorExtension","text":"The object inspector extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class InspectorExtension ( BaseInspector ): \"\"\"The object inspector extension base class, to inherit from.\"\"\" when : When def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment] def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node )","title":"InspectorExtension"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.InspectorExtension.inspector","text":"","title":"inspector"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.InspectorExtension.when","text":"","title":"when"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.InspectorExtension.__init__","text":"Initialize the inspector extension. Source code in griffe/agents/extensions/base.py 69 70 71 72 def __init__ ( self ) -> None : \"\"\"Initialize the inspector extension.\"\"\" super () . __init__ () self . inspector : Inspector = None # type: ignore[assignment]","title":"__init__()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.InspectorExtension.attach","text":"Attach the parent inspector to this extension. Parameters: inspector ( Inspector ) \u2013 The parent inspector. Source code in griffe/agents/extensions/base.py 74 75 76 77 78 79 80 def attach ( self , inspector : Inspector ) -> None : \"\"\"Attach the parent inspector to this extension. Parameters: inspector: The parent inspector. \"\"\" self . inspector = inspector","title":"attach()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.InspectorExtension.inspect","text":"Inspect a node. Parameters: node ( ObjectNode ) \u2013 The node to inspect. Source code in griffe/agents/extensions/base.py 82 83 84 85 86 87 88 def inspect ( self , node : ObjectNode ) -> None : \"\"\"Inspect a node. Parameters: node: The node to inspect. \"\"\" getattr ( self , f \"inspect_ { node . kind } \" , lambda _ : None )( node )","title":"inspect()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.VisitorExtension","text":"The node visitor extension base class, to inherit from. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class VisitorExtension ( BaseVisitor ): \"\"\"The node visitor extension base class, to inherit from.\"\"\" when : When def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment] def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined]","title":"VisitorExtension"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.VisitorExtension.visitor","text":"","title":"visitor"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.VisitorExtension.when","text":"","title":"when"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.VisitorExtension.__init__","text":"Initialize the visitor extension. Source code in griffe/agents/extensions/base.py 42 43 44 45 def __init__ ( self ) -> None : \"\"\"Initialize the visitor extension.\"\"\" super () . __init__ () self . visitor : Visitor = None # type: ignore[assignment]","title":"__init__()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.VisitorExtension.attach","text":"Attach the parent visitor to this extension. Parameters: visitor ( Visitor ) \u2013 The parent visitor. Source code in griffe/agents/extensions/base.py 47 48 49 50 51 52 53 def attach ( self , visitor : Visitor ) -> None : \"\"\"Attach the parent visitor to this extension. Parameters: visitor: The parent visitor. \"\"\" self . visitor = visitor","title":"attach()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.VisitorExtension.visit","text":"Visit a node. Parameters: node ( ast . AST ) \u2013 The node to visit. Source code in griffe/agents/extensions/base.py 55 56 57 58 59 60 61 def visit ( self , node : ast . AST ) -> None : \"\"\"Visit a node. Parameters: node: The node to visit. \"\"\" getattr ( self , f \"visit_ { node . kind } \" , lambda _ : None )( node ) # type: ignore[attr-defined]","title":"visit()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.When","text":"This enumeration contains the different times at which an extension is used. Attributes: before_all ( int ) \u2013 For each node, before the visit/inspection. before_children ( int ) \u2013 For each node, after the visit has started, and before the children visit/inspection. after_children ( int ) \u2013 For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all ( int ) \u2013 For each node, after the visit/inspection. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class When ( enum . Enum ): \"\"\"This enumeration contains the different times at which an extension is used. Attributes: before_all: For each node, before the visit/inspection. before_children: For each node, after the visit has started, and before the children visit/inspection. after_children: For each node, after the children have been visited/inspected, and before finishing the visit/inspection. after_all: For each node, after the visit/inspection. \"\"\" before_all : int = 1 before_children : int = 2 after_children : int = 3 after_all : int = 4","title":"When"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.When.after_all","text":"","title":"after_all"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.When.after_children","text":"","title":"after_children"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.When.before_all","text":"","title":"before_all"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.base.When.before_children","text":"","title":"before_children"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.load_extension","text":"Load a configured extension. Parameters: extension ( str | dict [ str , Any ] | Extension | Type [ Extension ] ) \u2013 An extension, with potential configuration options. Raises: ExtensionNotLoadedError \u2013 When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: Extension \u2013 An extension instance. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def load_extension ( extension : str | dict [ str , Any ] | Extension | Type [ Extension ]) -> Extension : \"\"\"Load a configured extension. Parameters: extension: An extension, with potential configuration options. Raises: ExtensionNotLoadedError: When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback. Returns: An extension instance. \"\"\" if isinstance ( extension , ( VisitorExtension , InspectorExtension )): return extension if isclass ( extension ) and issubclass ( extension , ( VisitorExtension , InspectorExtension )): # type: ignore[arg-type] return extension () # type: ignore[operator] if isinstance ( extension , dict ): import_path , options = next ( iter ( extension . items ())) else : # we consider it's a string import_path = str ( extension ) options = {} if import_path in builtin_extensions : import_path = f \"griffe.agents.extensions. { import_path } \" try : ext_module = dynamic_import ( import_path ) except ModuleNotFoundError as error : raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' could not be found\" ) from error try : return ext_module . Extension ( ** options ) except AttributeError as error : # noqa: WPS440 raise ExtensionNotLoadedError ( f \"Extension module ' { import_path } ' has no 'Extension' attribute\" ) from error","title":"load_extension()"},{"location":"reference/griffe/agents/extensions/#griffe.agents.extensions.load_extensions","text":"Load configured extensions. Parameters: exts ( Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]] ) \u2013 A sequence of extension, with potential configuration options. Returns: Extensions \u2013 An extensions container. Source code in griffe/agents/extensions/base.py 3 4 5 6 7 8 9 10 11 12 13 14 15 def load_extensions ( exts : Sequence [ str | dict [ str , Any ] | Extension | Type [ Extension ]]) -> Extensions : # noqa: WPS231 \"\"\"Load configured extensions. Parameters: exts: A sequence of extension, with potential configuration options. Returns: An extensions container. \"\"\" extensions = Extensions () for extension in exts : extensions . add ( load_extension ( extension )) return extensions","title":"load_extensions()"},{"location":"reference/griffe/agents/extensions/hybrid/","text":"This extension provides an hybrid behavior while loading data. Extension = HybridExtension \u00a4 logger = get_logger ( __name__ ) \u00a4 HybridExtension ( VisitorExtension ) \u00a4 Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. Source code in griffe/agents/extensions/hybrid.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class HybridExtension ( VisitorExtension ): \"\"\"Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. \"\"\" when = When . after_all def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ () def attach ( self , visitor : Visitor ) -> None : # noqa: D102 super () . attach ( visitor ) self . _extension . attach ( visitor ) # type: ignore[arg-type] # tolerate hybrid behavior def visit ( self , node : ast . AST ) -> None : # noqa: D102 try : just_visited = self . visitor . current [ node . name ] # type: ignore[attr-defined] except ( KeyError , AttributeError , TypeError ): return if just_visited . is_alias : return try : value = dynamic_import ( just_visited . path ) except AttributeError : # can happen when an object is defined conditionally, # for example based on the Python version return object_node = ObjectNode ( value , name = node . name ) # type: ignore[attr-defined] self . _extension . inspect ( object_node ) _extension : InspectorExtension = load_extension ( extension ) \u00a4 when = When . after_all \u00a4 __init__ ( self , extension ) \u00a4 Initialize the extension. Parameters: extension ( str | dict [ str , Any ] ) \u2013 The name or configuration of another extension. Raises: ExtensionError \u2013 When the passed extension is not an inspector extension. Source code in griffe/agents/extensions/hybrid.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ () attach ( self , visitor ) \u00a4 Source code in griffe/agents/extensions/hybrid.py 51 52 53 def attach ( self , visitor : Visitor ) -> None : # noqa: D102 super () . attach ( visitor ) self . _extension . attach ( visitor ) # type: ignore[arg-type] # tolerate hybrid behavior visit ( self , node ) \u00a4 Source code in griffe/agents/extensions/hybrid.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def visit ( self , node : ast . AST ) -> None : # noqa: D102 try : just_visited = self . visitor . current [ node . name ] # type: ignore[attr-defined] except ( KeyError , AttributeError , TypeError ): return if just_visited . is_alias : return try : value = dynamic_import ( just_visited . path ) except AttributeError : # can happen when an object is defined conditionally, # for example based on the Python version return object_node = ObjectNode ( value , name = node . name ) # type: ignore[attr-defined] self . _extension . inspect ( object_node )","title":"hybrid"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.Extension","text":"","title":"Extension"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.logger","text":"","title":"logger"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension","text":"Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. Source code in griffe/agents/extensions/hybrid.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class HybridExtension ( VisitorExtension ): \"\"\"Inspect during a visit. This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data. Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data. \"\"\" when = When . after_all def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ () def attach ( self , visitor : Visitor ) -> None : # noqa: D102 super () . attach ( visitor ) self . _extension . attach ( visitor ) # type: ignore[arg-type] # tolerate hybrid behavior def visit ( self , node : ast . AST ) -> None : # noqa: D102 try : just_visited = self . visitor . current [ node . name ] # type: ignore[attr-defined] except ( KeyError , AttributeError , TypeError ): return if just_visited . is_alias : return try : value = dynamic_import ( just_visited . path ) except AttributeError : # can happen when an object is defined conditionally, # for example based on the Python version return object_node = ObjectNode ( value , name = node . name ) # type: ignore[attr-defined] self . _extension . inspect ( object_node )","title":"HybridExtension"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension._extension","text":"","title":"_extension"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension.when","text":"","title":"when"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension.__init__","text":"Initialize the extension. Parameters: extension ( str | dict [ str , Any ] ) \u2013 The name or configuration of another extension. Raises: ExtensionError \u2013 When the passed extension is not an inspector extension. Source code in griffe/agents/extensions/hybrid.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , extension : str | dict [ str , Any ]) -> None : \"\"\"Initialize the extension. Parameters: extension: The name or configuration of another extension. Raises: ExtensionError: When the passed extension is not an inspector extension. \"\"\" self . _extension : InspectorExtension = load_extension ( extension ) # type: ignore[assignment] if not isinstance ( self . _extension , InspectorExtension ): raise ExtensionError ( \"the 'hybrid' extension only accepts inspector extensions. \" \"If you want to use a visitor extension, just add it normally \" \"to your extensions configuration, without using 'hybrid'.\" ) super () . __init__ ()","title":"__init__()"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension.attach","text":"Source code in griffe/agents/extensions/hybrid.py 51 52 53 def attach ( self , visitor : Visitor ) -> None : # noqa: D102 super () . attach ( visitor ) self . _extension . attach ( visitor ) # type: ignore[arg-type] # tolerate hybrid behavior","title":"attach()"},{"location":"reference/griffe/agents/extensions/hybrid/#griffe.agents.extensions.hybrid.HybridExtension.visit","text":"Source code in griffe/agents/extensions/hybrid.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def visit ( self , node : ast . AST ) -> None : # noqa: D102 try : just_visited = self . visitor . current [ node . name ] # type: ignore[attr-defined] except ( KeyError , AttributeError , TypeError ): return if just_visited . is_alias : return try : value = dynamic_import ( just_visited . path ) except AttributeError : # can happen when an object is defined conditionally, # for example based on the Python version return object_node = ObjectNode ( value , name = node . name ) # type: ignore[attr-defined] self . _extension . inspect ( object_node )","title":"visit()"},{"location":"reference/griffe/docstrings/","text":"This module exposes objects related to docstrings. __all__ = [ 'Parser' , 'parse' ] \u00a4 Parser ( enum . Enum ) \u00a4 Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\" google = 'google' \u00a4 numpy = 'numpy' \u00a4 rst = 'rst' \u00a4 parse ( docstring , parser , ** options ) \u00a4 Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"docstrings"},{"location":"reference/griffe/docstrings/#griffe.docstrings.__all__","text":"","title":"__all__"},{"location":"reference/griffe/docstrings/#griffe.docstrings.Parser","text":"Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\"","title":"Parser"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parsers.Parser.google","text":"","title":"google"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parsers.Parser.numpy","text":"","title":"numpy"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parsers.Parser.rst","text":"","title":"rst"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parse","text":"Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/dataclasses/","text":"This module contains the dataclasses related to docstrings. DocstringAdmonition \u00a4 This base class represents admonitions. Attributes: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class DocstringAdmonition : \"\"\"This base class represents admonitions. Attributes: kind: The admonition kind. contents: The admonition contents. \"\"\" def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , } contents : str = contents \u00a4 kind : str = kind \u00a4 __init__ ( self , * , kind , contents ) \u00a4 Initialize the admonition. Parameters: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 71 72 73 74 75 76 77 78 79 def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents as_dict ( self , ** kwargs ) \u00a4 Return this admonition's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , } DocstringAttribute ( DocstringNamedElement ) \u00a4 This class represents a documented module/class attribute. Source code in griffe/docstrings/dataclasses.py 209 210 class DocstringAttribute ( DocstringNamedElement ): \"\"\"This class represents a documented module/class attribute.\"\"\" DocstringElement \u00a4 This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class DocstringElement : \"\"\"This base class represents annotated, nameless elements. Attributes: annotation: The element annotation, if any. description: The element description. \"\"\" def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , } annotation : str | Name | Expression | None = annotation \u00a4 description : str = description \u00a4 __init__ ( self , * , description , annotation = None ) \u00a4 Initialize the element. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 104 105 106 107 108 109 110 111 112 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , } DocstringNamedElement ( DocstringElement ) \u00a4 This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Source code in griffe/docstrings/dataclasses.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 class DocstringNamedElement ( DocstringElement ): \"\"\"This base class represents annotated, named elements. Attributes: name: The element name. value: The element value, as a string, if any. \"\"\" def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base name : str = name \u00a4 value : str | None = value \u00a4 __init__ ( self , name , * , description , annotation = None , value = None ) \u00a4 Initialize the element. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value as_dict ( self , ** kwargs ) \u00a4 Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base DocstringParameter ( DocstringNamedElement ) \u00a4 This class represent a documented function parameter. Source code in griffe/docstrings/dataclasses.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class DocstringParameter ( DocstringNamedElement ): \"\"\"This class represent a documented function parameter.\"\"\" @property def default ( self ): \"\"\"Return the default value of this parameter. Returns: The parameter's default. \"\"\" return self . value @default . setter def default ( self , value ): self . value = value default ( self , value ) \u00a4 Source code in griffe/docstrings/dataclasses.py 204 205 206 @default . setter def default ( self , value ): self . value = value DocstringRaise ( DocstringElement ) \u00a4 This class represents a documented raise value. Source code in griffe/docstrings/dataclasses.py 172 173 class DocstringRaise ( DocstringElement ): \"\"\"This class represents a documented raise value.\"\"\" DocstringReceive ( DocstringNamedElement ) \u00a4 This class represents a documented receive value. Source code in griffe/docstrings/dataclasses.py 188 189 class DocstringReceive ( DocstringNamedElement ): \"\"\"This class represents a documented receive value.\"\"\" DocstringReturn ( DocstringNamedElement ) \u00a4 This class represents a documented return value. Source code in griffe/docstrings/dataclasses.py 180 181 class DocstringReturn ( DocstringNamedElement ): \"\"\"This class represents a documented return value.\"\"\" DocstringSection \u00a4 Placeholder. Source code in griffe/docstrings/dataclasses.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class DocstringSection : \"\"\"Placeholder.\"\"\" def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base kind : DocstringSectionKind = kind \u00a4 title : str | None = title \u00a4 value : Any = value \u00a4 __init__ ( self , kind , value , title = None ) \u00a4 Initialize the section. Parameters: kind ( DocstringSectionKind ) \u2013 The section kind. value ( Any ) \u2013 The section value. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title as_dict ( self , ** kwargs ) \u00a4 Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base DocstringSectionKind ( enum . Enum ) \u00a4 The possible section kinds. Source code in griffe/docstrings/dataclasses.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DocstringSectionKind ( enum . Enum ): \"\"\"The possible section kinds.\"\"\" text = \"text\" parameters = \"parameters\" other_parameters = \"other parameters\" raises = \"raises\" warns = \"warns\" returns = \"returns\" yields = \"yields\" receives = \"receives\" examples = \"examples\" attributes = \"attributes\" deprecated = \"deprecated\" admonition = \"admonition\" admonition = 'admonition' \u00a4 attributes = 'attributes' \u00a4 deprecated = 'deprecated' \u00a4 examples = 'examples' \u00a4 other_parameters = 'other parameters' \u00a4 parameters = 'parameters' \u00a4 raises = 'raises' \u00a4 receives = 'receives' \u00a4 returns = 'returns' \u00a4 text = 'text' \u00a4 warns = 'warns' \u00a4 yields = 'yields' \u00a4 DocstringWarn ( DocstringElement ) \u00a4 This class represents a documented warn value. Source code in griffe/docstrings/dataclasses.py 176 177 class DocstringWarn ( DocstringElement ): \"\"\"This class represents a documented warn value.\"\"\" DocstringYield ( DocstringNamedElement ) \u00a4 This class represents a documented yield value. Source code in griffe/docstrings/dataclasses.py 184 185 class DocstringYield ( DocstringNamedElement ): \"\"\"This class represents a documented yield value.\"\"\"","title":"dataclasses"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition","text":"This base class represents admonitions. Attributes: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class DocstringAdmonition : \"\"\"This base class represents admonitions. Attributes: kind: The admonition kind. contents: The admonition contents. \"\"\" def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , }","title":"DocstringAdmonition"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.contents","text":"","title":"contents"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.kind","text":"","title":"kind"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.__init__","text":"Initialize the admonition. Parameters: kind ( str ) \u2013 The admonition kind. contents ( str ) \u2013 The admonition contents. Source code in griffe/docstrings/dataclasses.py 71 72 73 74 75 76 77 78 79 def __init__ ( self , * , kind : str , contents : str ) -> None : \"\"\"Initialize the admonition. Parameters: kind: The admonition kind. contents: The admonition contents. \"\"\" self . kind : str = kind self . contents : str = contents","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.as_dict","text":"Return this admonition's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this admonition's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"kind\" : self . kind , \"contents\" : self . contents , }","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAttribute","text":"This class represents a documented module/class attribute. Source code in griffe/docstrings/dataclasses.py 209 210 class DocstringAttribute ( DocstringNamedElement ): \"\"\"This class represents a documented module/class attribute.\"\"\"","title":"DocstringAttribute"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement","text":"This base class represents annotated, nameless elements. Attributes: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class DocstringElement : \"\"\"This base class represents annotated, nameless elements. Attributes: annotation: The element annotation, if any. description: The element description. \"\"\" def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , }","title":"DocstringElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.annotation","text":"","title":"annotation"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.description","text":"","title":"description"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.__init__","text":"Initialize the element. Parameters: annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. description ( str ) \u2013 The element description. Source code in griffe/docstrings/dataclasses.py 104 105 106 107 108 109 110 111 112 def __init__ ( self , * , description : str , annotation : str | Name | Expression | None = None ) -> None : \"\"\"Initialize the element. Parameters: annotation: The element annotation, if any. description: The element description. \"\"\" self . description : str = description self . annotation : str | Name | Expression | None = annotation","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.as_dict","text":"Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" return { \"annotation\" : self . annotation , \"description\" : self . description , }","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement","text":"This base class represents annotated, named elements. Attributes: name ( str ) \u2013 The element name. value ( str | None ) \u2013 The element value, as a string, if any. Source code in griffe/docstrings/dataclasses.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 class DocstringNamedElement ( DocstringElement ): \"\"\"This base class represents annotated, named elements. Attributes: name: The element name. value: The element value, as a string, if any. \"\"\" def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base","title":"DocstringNamedElement"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.name","text":"","title":"name"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.value","text":"","title":"value"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.__init__","text":"Initialize the element. Parameters: name ( str ) \u2013 The element name. description ( str ) \u2013 The element description. annotation ( str | Name | Expression | None ) \u2013 The element annotation, if any. value ( str | None ) \u2013 The element value, as a string. Source code in griffe/docstrings/dataclasses.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def __init__ ( self , name : str , * , description : str , annotation : str | Name | Expression | None = None , value : str | None = None ) -> None : \"\"\"Initialize the element. Parameters: name: The element name. description: The element description. annotation: The element annotation, if any. value: The element value, as a string. \"\"\" super () . __init__ ( description = description , annotation = annotation ) self . name : str = name self . value : str | None = value","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.as_dict","text":"Return this element's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this element's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , ** super () . as_dict ( ** kwargs )} if self . value is not None : base [ \"value\" ] = self . value return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter","text":"This class represent a documented function parameter. Source code in griffe/docstrings/dataclasses.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class DocstringParameter ( DocstringNamedElement ): \"\"\"This class represent a documented function parameter.\"\"\" @property def default ( self ): \"\"\"Return the default value of this parameter. Returns: The parameter's default. \"\"\" return self . value @default . setter def default ( self , value ): self . value = value","title":"DocstringParameter"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter.default","text":"Source code in griffe/docstrings/dataclasses.py 204 205 206 @default . setter def default ( self , value ): self . value = value","title":"default()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringRaise","text":"This class represents a documented raise value. Source code in griffe/docstrings/dataclasses.py 172 173 class DocstringRaise ( DocstringElement ): \"\"\"This class represents a documented raise value.\"\"\"","title":"DocstringRaise"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReceive","text":"This class represents a documented receive value. Source code in griffe/docstrings/dataclasses.py 188 189 class DocstringReceive ( DocstringNamedElement ): \"\"\"This class represents a documented receive value.\"\"\"","title":"DocstringReceive"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReturn","text":"This class represents a documented return value. Source code in griffe/docstrings/dataclasses.py 180 181 class DocstringReturn ( DocstringNamedElement ): \"\"\"This class represents a documented return value.\"\"\"","title":"DocstringReturn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection","text":"Placeholder. Source code in griffe/docstrings/dataclasses.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class DocstringSection : \"\"\"Placeholder.\"\"\" def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base","title":"DocstringSection"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.kind","text":"","title":"kind"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.title","text":"","title":"title"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.value","text":"","title":"value"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.__init__","text":"Initialize the section. Parameters: kind ( DocstringSectionKind ) \u2013 The section kind. value ( Any ) \u2013 The section value. title ( str | None ) \u2013 An optional title. Source code in griffe/docstrings/dataclasses.py 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , kind : DocstringSectionKind , value : Any , title : str | None = None ) -> None : \"\"\"Initialize the section. Parameters: kind: The section kind. value: The section value. title: An optional title. \"\"\" self . kind : DocstringSectionKind = kind self . value : Any = value self . title : str | None = title","title":"__init__()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.as_dict","text":"Return this section's data as a dictionary. Parameters: **kwargs ( Any ) \u2013 Additional serialization options. Returns: dict [ str , Any ] \u2013 A dictionary. Source code in griffe/docstrings/dataclasses.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def as_dict ( self , ** kwargs : Any ) -> dict [ str , Any ]: \"\"\"Return this section's data as a dictionary. Parameters: **kwargs: Additional serialization options. Returns: A dictionary. \"\"\" if hasattr ( self . value , \"as_dict\" ): serialized_value = self . value . as_dict ( ** kwargs ) else : serialized_value = self . value base = { \"kind\" : self . kind . value , \"value\" : serialized_value } if self . title : base [ \"title\" ] = self . title return base","title":"as_dict()"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind","text":"The possible section kinds. Source code in griffe/docstrings/dataclasses.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DocstringSectionKind ( enum . Enum ): \"\"\"The possible section kinds.\"\"\" text = \"text\" parameters = \"parameters\" other_parameters = \"other parameters\" raises = \"raises\" warns = \"warns\" returns = \"returns\" yields = \"yields\" receives = \"receives\" examples = \"examples\" attributes = \"attributes\" deprecated = \"deprecated\" admonition = \"admonition\"","title":"DocstringSectionKind"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.admonition","text":"","title":"admonition"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.attributes","text":"","title":"attributes"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.deprecated","text":"","title":"deprecated"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.examples","text":"","title":"examples"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.other_parameters","text":"","title":"other_parameters"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.parameters","text":"","title":"parameters"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.raises","text":"","title":"raises"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.receives","text":"","title":"receives"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.returns","text":"","title":"returns"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.text","text":"","title":"text"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.warns","text":"","title":"warns"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind.yields","text":"","title":"yields"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringWarn","text":"This class represents a documented warn value. Source code in griffe/docstrings/dataclasses.py 176 177 class DocstringWarn ( DocstringElement ): \"\"\"This class represents a documented warn value.\"\"\"","title":"DocstringWarn"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringYield","text":"This class represents a documented yield value. Source code in griffe/docstrings/dataclasses.py 184 185 class DocstringYield ( DocstringNamedElement ): \"\"\"This class represents a documented yield value.\"\"\"","title":"DocstringYield"},{"location":"reference/griffe/docstrings/google/","text":"This module defines functions to parse Google-style docstrings into structured data. BlockItem = Tuple [ int , List [ str ]] \u00a4 BlockItems = List [ BlockItem ] \u00a4 ItemsBlock = Tuple [ BlockItems , int ] \u00a4 _RE_ADMONITION : Pattern = re . compile ( '^(?P<type>[ \\\\ w][ \\\\ s \\\\ w-]*):( \\\\ s+(?P<title>[^ \\\\ s].*))?$' , re . I ) \u00a4 Regular expression to match admonitions, of the form TYPE: [TITLE] . _RE_NAME_ANNOTATION_DESCRIPTION : Pattern = re . compile ( '^(?:(?P<name> \\\\ w+)? \\\\ s*(?: \\\\ ((?P<type>.+) \\\\ ))?: \\\\ s*)?(?P<desc>.*)$' ) \u00a4 Regular expression to match name (type): Description in docstrings sections items. _section_kind = { 'args' : DocstringSectionKind . parameters , 'arguments' : DocstringSectionKind . parameters , 'params' : DocstringSectionKind . parameters , 'parameters' : DocstringSectionKind . parameters , 'keyword args' : DocstringSectionKind . other_parameters , 'keyword parameters' : DocstringSectionKind . other_parameters , 'other args' : DocstringSectionKind . other_parameters , 'other parameters' : DocstringSectionKind . other_parameters , 'raises' : DocstringSectionKind . raises , 'exceptions' : DocstringSectionKind . raises , 'returns' : DocstringSectionKind . returns , 'yields' : DocstringSectionKind . yields , 'examples' : DocstringSectionKind . examples , 'attributes' : DocstringSectionKind . attributes } \u00a4 _section_reader = { DocstringSectionKind . parameters : _read_parameters_section , DocstringSectionKind . other_parameters : _read_other_parameters_section , DocstringSectionKind . raises : _read_raises_section , DocstringSectionKind . warns : _read_warns_section , DocstringSectionKind . examples : _read_examples_section , DocstringSectionKind . attributes : _read_attributes_section , DocstringSectionKind . returns : _read_returns_section , DocstringSectionKind . yields : _read_yields_section , DocstringSectionKind . receives : _read_receives_section , DocstringSectionKind . deprecated : _read_deprecated_section } \u00a4 _warn = warning ( __name__ ) \u00a4 _is_empty_line ( line ) \u00a4 Source code in griffe/docstrings/google.py 494 495 def _is_empty_line ( line ) -> bool : return not line . strip () _read_attributes_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def _read_attributes_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 attributes = [] block , new_offset = _read_block_items ( docstring , offset ) annotation : str | Name | Expression | None for line_number , attr_lines in block : try : name_with_type , description = attr_lines [ 0 ] . split ( \":\" , 1 ) except ValueError : _warn ( docstring , line_number , f \"Failed to get 'name: description' pair from ' { attr_lines [ 0 ] } '\" ) continue description = \" \\n \" . join ([ description . lstrip (), * attr_lines [ 1 :]]) . rstrip ( \" \\n \" ) if \" \" in name_with_type : name , annotation = name_with_type . split ( \" \" , 1 ) annotation = annotation . strip ( \"()\" ) if annotation . endswith ( \", optional\" ): annotation = annotation [: - 10 ] # try to compile the annotation to transform it into an expression with suppress ( SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] else : name = name_with_type try : annotation = docstring . parent . attributes [ name ] . annotation # type: ignore[union-attr] except ( AttributeError , KeyError ): annotation = None attributes . append ( DocstringAttribute ( name = name , annotation = annotation , description = description )) if attributes : return DocstringSection ( DocstringSectionKind . attributes , attributes ), new_offset _warn ( docstring , new_offset , f \"Empty attributes section at line { offset } \" ) return None , new_offset _read_block ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def _read_block ( docstring : Docstring , offset : int ) -> tuple [ str , int ]: lines = docstring . lines if offset >= len ( lines ): return \"\" , offset new_offset = offset block : list [ str ] = [] # skip first empty lines while _is_empty_line ( lines [ new_offset ]): new_offset += 1 # get initial indent indent = len ( lines [ new_offset ]) - len ( lines [ new_offset ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return \"\" , new_offset - 1 # start processing first item block . append ( lines [ new_offset ] . lstrip ()) new_offset += 1 # loop on next lines while new_offset < len ( lines ) and ( lines [ new_offset ] . startswith ( indent * \" \" ) or _is_empty_line ( lines [ new_offset ])): block . append ( lines [ new_offset ][ indent :]) new_offset += 1 return \" \\n \" . join ( block ) . rstrip ( \" \\n \" ), new_offset - 1 _read_block_items ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def _read_block_items ( docstring : Docstring , offset : int ) -> ItemsBlock : # noqa: WPS231 lines = docstring . lines if offset >= len ( lines ): return [], offset new_offset = offset items : BlockItems = [] # skip first empty lines while _is_empty_line ( lines [ new_offset ]): new_offset += 1 # get initial indent indent = len ( lines [ new_offset ]) - len ( lines [ new_offset ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return [], new_offset - 1 # start processing first item current_item = ( new_offset , [ lines [ new_offset ][ indent :]]) new_offset += 1 # loop on next lines while new_offset < len ( lines ): line = lines [ new_offset ] if line . startswith ( indent * 2 * \" \" ): # continuation line current_item [ 1 ] . append ( line [ indent * 2 :]) elif line . startswith (( indent + 1 ) * \" \" ): # indent between initial and continuation: append but warn cont_indent = len ( line ) - len ( line . lstrip ()) current_item [ 1 ] . append ( line [ cont_indent :]) _warn ( docstring , new_offset , f \"Confusing indentation for continuation line { new_offset + 1 } in docstring, \" f \"should be { indent } * 2 = { indent * 2 } spaces, not { cont_indent } \" , ) elif line . startswith ( indent * \" \" ): # indent equal to initial one: new item items . append ( current_item ) current_item = ( new_offset , [ line [ indent :]]) elif _is_empty_line ( line ): # empty line: preserve it in the current item current_item [ 1 ] . append ( \"\" ) else : # indent lower than initial one: end of section break new_offset += 1 if current_item : items . append ( current_item ) return items , new_offset - 1 _read_deprecated_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def _read_deprecated_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: text , new_offset = _read_block ( docstring , offset ) # early exit if there is no text in the yield section if not text : _warn ( docstring , new_offset , f \"Empty deprecated section at line { offset } \" ) return None , new_offset # check the presence of a name and description, separated by a semi-colon try : version , text = text . split ( \":\" , 1 ) except ValueError : _warn ( docstring , new_offset , f \"Could not parse version, text at line { offset } \" ) return None , new_offset version = version . lstrip () description = text . lstrip () return ( DocstringSection ( DocstringSectionKind . deprecated , ( version , description )), new_offset , ) _read_examples_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def _read_examples_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 text , new_offset = _read_block ( docstring , offset ) sub_sections = [] in_code_example = False in_code_block = False current_text : list [ str ] = [] current_example : list [ str ] = [] for line in text . split ( \" \\n \" ): if _is_empty_line ( line ): if in_code_example : if current_example : sub_sections . append (( DocstringSectionKind . examples , \" \\n \" . join ( current_example ))) current_example = [] in_code_example = False else : current_text . append ( line ) elif in_code_example : current_example . append ( line ) elif line . startswith ( \"```\" ): in_code_block = not in_code_block # noqa: WPS434 current_text . append ( line ) elif in_code_block : current_text . append ( line ) elif line . startswith ( \">>>\" ): if current_text : sub_sections . append (( DocstringSectionKind . text , \" \\n \" . join ( current_text ) . rstrip ( \" \\n \" ))) current_text = [] in_code_example = True current_example . append ( line ) else : current_text . append ( line ) if current_text : sub_sections . append (( DocstringSectionKind . text , \" \\n \" . join ( current_text ) . rstrip ( \" \\n \" ))) elif current_example : sub_sections . append (( DocstringSectionKind . examples , \" \\n \" . join ( current_example ))) if sub_sections : return DocstringSection ( DocstringSectionKind . examples , sub_sections ), new_offset _warn ( docstring , new_offset , f \"Empty examples section at line { offset } \" ) return None , new_offset _read_other_parameters_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 211 212 213 214 215 216 217 218 def _read_other_parameters_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: parameters , new_offset = _read_parameters ( docstring , offset ) if parameters : return DocstringSection ( DocstringSectionKind . other_parameters , parameters ), new_offset _warn ( docstring , new_offset , f \"Empty other parameters section at line { offset } \" ) return None , new_offset _read_parameters ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def _read_parameters ( docstring : Docstring , offset : int ) -> tuple [ list [ DocstringParameter ], int ]: # noqa: WPS231 parameters = [] annotation : str | Name | Expression | None block , new_offset = _read_block_items ( docstring , offset ) for line_number , param_lines in block : # check the presence of a name and description, separated by a semi-colon try : name_with_type , description = param_lines [ 0 ] . split ( \":\" , 1 ) except ValueError : _warn ( docstring , line_number , f \"Failed to get 'name: description' pair from ' { param_lines [ 0 ] } '\" ) continue description = \" \\n \" . join ([ description . lstrip (), * param_lines [ 1 :]]) . rstrip ( \" \\n \" ) # use the type given after the parameter name, if any if \" \" in name_with_type : name , annotation = name_with_type . split ( \" \" , 1 ) annotation = annotation . strip ( \"()\" ) if annotation . endswith ( \", optional\" ): annotation = annotation [: - 10 ] # try to compile the annotation to transform it into an expression with suppress ( SyntaxError , AttributeError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] else : name = name_with_type # try to use the annotation from the signature try : annotation = docstring . parent . parameters [ name ] . annotation # type: ignore[union-attr] except ( AttributeError , KeyError ): annotation = None try : default = docstring . parent . parameters [ name ] . default # type: ignore[union-attr] except ( AttributeError , KeyError ): default = None if annotation is None : _warn ( docstring , line_number , f \"No type or annotation for parameter ' { name } '\" ) parameters . append ( DocstringParameter ( name = name , value = default , annotation = annotation , description = description )) return parameters , new_offset _read_parameters_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 201 202 203 204 205 206 207 208 def _read_parameters_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: parameters , new_offset = _read_parameters ( docstring , offset ) if parameters : return DocstringSection ( DocstringSectionKind . parameters , parameters ), new_offset _warn ( docstring , new_offset , f \"Empty parameters section at line { offset } \" ) return None , new_offset _read_raises_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def _read_raises_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: exceptions = [] block , new_offset = _read_block_items ( docstring , offset ) for line_number , exception_lines in block : try : annotation , description = exception_lines [ 0 ] . split ( \": \" , 1 ) except ValueError : _warn ( docstring , line_number , f \"Failed to get 'exception: description' pair from ' { exception_lines [ 0 ] } '\" ) else : description = \" \\n \" . join ([ description . lstrip (), * exception_lines [ 1 :]]) . rstrip ( \" \\n \" ) exceptions . append ( DocstringRaise ( annotation = annotation , description = description )) if exceptions : return DocstringSection ( DocstringSectionKind . raises , exceptions ), new_offset _warn ( docstring , new_offset , f \"Empty exceptions section at line { offset } \" ) return None , new_offset _read_receives_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def _read_receives_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 receives = [] block , new_offset = _read_block_items ( docstring , offset ) for index , ( line_number , receive_lines ) in enumerate ( block ): # noqa: B007 (will be used later) match = _RE_NAME_ANNOTATION_DESCRIPTION . match ( receive_lines [ 0 ]) if not match : _warn ( docstring , line_number , f \"Failed to get name, annotation or description from ' { receive_lines [ 0 ] } '\" ) continue name , annotation , description = match . groups () description = \" \\n \" . join ([ description . lstrip (), * receive_lines [ 1 :]]) . rstrip ( \" \\n \" ) if annotation and docstring . parent is not None : # try to compile the annotation to transform it into an expression with suppress ( SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] # else: # try to retrieve the annotation from the docstring parent # TODO: support getting receive part and exploding tuple (in a generator/iterator) # with suppress(AttributeError, KeyError): # annotation = docstring.parent.returns # type: ignore[union-attr] # if len(block) > 1: # if annotation.is_tuple: # annotation = annotation.tuple_item(index) if annotation is None : received_value = repr ( name ) or index _warn ( docstring , line_number , f \"No type or annotation for received value { received_value } \" ) receives . append ( DocstringReceive ( name = name or \"\" , annotation = annotation , description = description )) if receives : return DocstringSection ( DocstringSectionKind . receives , receives ), new_offset _warn ( docstring , new_offset , f \"Empty receives section at line { offset } \" ) return None , new_offset _read_returns_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def _read_returns_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 returns = [] block , new_offset = _read_block_items ( docstring , offset ) for index , ( line_number , return_lines ) in enumerate ( block ): match = _RE_NAME_ANNOTATION_DESCRIPTION . match ( return_lines [ 0 ]) if not match : _warn ( docstring , line_number , f \"Failed to get name, annotation or description from ' { return_lines [ 0 ] } '\" ) continue name , annotation , description = match . groups () description = \" \\n \" . join ([ description . lstrip (), * return_lines [ 1 :]]) . rstrip ( \" \\n \" ) if annotation and docstring . parent is not None : # try to compile the annotation to transform it into an expression with suppress ( SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] else : # try to retrieve the annotation from the docstring parent with suppress ( AttributeError , KeyError ): annotation = docstring . parent . returns # type: ignore[union-attr] if len ( block ) > 1 : if annotation . is_tuple : annotation = annotation . tuple_item ( index ) if annotation is None : returned_value = repr ( name ) or index _warn ( docstring , line_number , f \"No type or annotation for returned value { returned_value } \" ) returns . append ( DocstringReturn ( name = name or \"\" , annotation = annotation , description = description )) if returns : return DocstringSection ( DocstringSectionKind . returns , returns ), new_offset _warn ( docstring , new_offset , f \"Empty returns section at line { offset } \" ) return None , new_offset _read_warns_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def _read_warns_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: warns = [] block , new_offset = _read_block_items ( docstring , offset ) for line_number , warning_lines in block : try : annotation , description = warning_lines [ 0 ] . split ( \": \" , 1 ) except ValueError : _warn ( docstring , line_number , f \"Failed to get 'warning: description' pair from ' { warning_lines [ 0 ] } '\" ) else : description = \" \\n \" . join ([ description . lstrip (), * warning_lines [ 1 :]]) . rstrip ( \" \\n \" ) warns . append ( DocstringWarn ( annotation = annotation , description = description )) if warns : return DocstringSection ( DocstringSectionKind . warns , warns ), new_offset _warn ( docstring , new_offset , f \"Empty warns section at line { offset } \" ) return None , new_offset _read_yields_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/google.py 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def _read_yields_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 yields = [] block , new_offset = _read_block_items ( docstring , offset ) for index , ( line_number , yield_lines ) in enumerate ( block ): # noqa: B007 (will be used later) match = _RE_NAME_ANNOTATION_DESCRIPTION . match ( yield_lines [ 0 ]) if not match : _warn ( docstring , line_number , f \"Failed to get name, annotation or description from ' { yield_lines [ 0 ] } '\" ) continue name , annotation , description = match . groups () description = \" \\n \" . join ([ description . lstrip (), * yield_lines [ 1 :]]) . rstrip ( \" \\n \" ) if annotation and docstring . parent is not None : # try to compile the annotation to transform it into an expression with suppress ( SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] else : # try to retrieve the annotation from the docstring parent with suppress ( AttributeError , KeyError ): annotation = docstring . parent . returns # type: ignore[union-attr] # TODO: support getting yield part and exploding tuple (in a generator/iterator) # if len(block) > 1: # if annotation.is_tuple: # annotation = annotation.tuple_item(index) if annotation is None : yielded_value = repr ( name ) or index _warn ( docstring , line_number , f \"No type or annotation for yielded value { yielded_value } \" ) yields . append ( DocstringYield ( name = name or \"\" , annotation = annotation , description = description )) if yields : return DocstringSection ( DocstringSectionKind . yields , yields ), new_offset _warn ( docstring , new_offset , f \"Empty yields section at line { offset } \" ) return None , new_offset parse ( docstring , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : # TODO: once Python 3.7 is dropped, use walrus operator match = _RE_ADMONITION . match ( lines [ offset ]) if match : groups = match . groupdict () title = groups [ \"title\" ] admonition_type = groups [ \"type\" ] if admonition_type . lower () in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type . lower ()]] section , offset = reader ( docstring , offset + 1 ) if section : section . title = title sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : if title is None and \" \" in admonition_type : title = admonition_type admonition_type = \"note\" sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type . lower (), contents = contents ), title = title , ) ) else : offset -= 1 with suppress ( IndexError ): current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"google"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.BlockItem","text":"","title":"BlockItem"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.BlockItems","text":"","title":"BlockItems"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.ItemsBlock","text":"","title":"ItemsBlock"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._RE_ADMONITION","text":"Regular expression to match admonitions, of the form TYPE: [TITLE] .","title":"_RE_ADMONITION"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._RE_NAME_ANNOTATION_DESCRIPTION","text":"Regular expression to match name (type): Description in docstrings sections items.","title":"_RE_NAME_ANNOTATION_DESCRIPTION"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._section_kind","text":"","title":"_section_kind"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._section_reader","text":"","title":"_section_reader"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._warn","text":"","title":"_warn"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._is_empty_line","text":"Source code in griffe/docstrings/google.py 494 495 def _is_empty_line ( line ) -> bool : return not line . strip ()","title":"_is_empty_line()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_attributes_section","text":"Source code in griffe/docstrings/google.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def _read_attributes_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 attributes = [] block , new_offset = _read_block_items ( docstring , offset ) annotation : str | Name | Expression | None for line_number , attr_lines in block : try : name_with_type , description = attr_lines [ 0 ] . split ( \":\" , 1 ) except ValueError : _warn ( docstring , line_number , f \"Failed to get 'name: description' pair from ' { attr_lines [ 0 ] } '\" ) continue description = \" \\n \" . join ([ description . lstrip (), * attr_lines [ 1 :]]) . rstrip ( \" \\n \" ) if \" \" in name_with_type : name , annotation = name_with_type . split ( \" \" , 1 ) annotation = annotation . strip ( \"()\" ) if annotation . endswith ( \", optional\" ): annotation = annotation [: - 10 ] # try to compile the annotation to transform it into an expression with suppress ( SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] else : name = name_with_type try : annotation = docstring . parent . attributes [ name ] . annotation # type: ignore[union-attr] except ( AttributeError , KeyError ): annotation = None attributes . append ( DocstringAttribute ( name = name , annotation = annotation , description = description )) if attributes : return DocstringSection ( DocstringSectionKind . attributes , attributes ), new_offset _warn ( docstring , new_offset , f \"Empty attributes section at line { offset } \" ) return None , new_offset","title":"_read_attributes_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_block","text":"Source code in griffe/docstrings/google.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def _read_block ( docstring : Docstring , offset : int ) -> tuple [ str , int ]: lines = docstring . lines if offset >= len ( lines ): return \"\" , offset new_offset = offset block : list [ str ] = [] # skip first empty lines while _is_empty_line ( lines [ new_offset ]): new_offset += 1 # get initial indent indent = len ( lines [ new_offset ]) - len ( lines [ new_offset ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return \"\" , new_offset - 1 # start processing first item block . append ( lines [ new_offset ] . lstrip ()) new_offset += 1 # loop on next lines while new_offset < len ( lines ) and ( lines [ new_offset ] . startswith ( indent * \" \" ) or _is_empty_line ( lines [ new_offset ])): block . append ( lines [ new_offset ][ indent :]) new_offset += 1 return \" \\n \" . join ( block ) . rstrip ( \" \\n \" ), new_offset - 1","title":"_read_block()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_block_items","text":"Source code in griffe/docstrings/google.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def _read_block_items ( docstring : Docstring , offset : int ) -> ItemsBlock : # noqa: WPS231 lines = docstring . lines if offset >= len ( lines ): return [], offset new_offset = offset items : BlockItems = [] # skip first empty lines while _is_empty_line ( lines [ new_offset ]): new_offset += 1 # get initial indent indent = len ( lines [ new_offset ]) - len ( lines [ new_offset ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return [], new_offset - 1 # start processing first item current_item = ( new_offset , [ lines [ new_offset ][ indent :]]) new_offset += 1 # loop on next lines while new_offset < len ( lines ): line = lines [ new_offset ] if line . startswith ( indent * 2 * \" \" ): # continuation line current_item [ 1 ] . append ( line [ indent * 2 :]) elif line . startswith (( indent + 1 ) * \" \" ): # indent between initial and continuation: append but warn cont_indent = len ( line ) - len ( line . lstrip ()) current_item [ 1 ] . append ( line [ cont_indent :]) _warn ( docstring , new_offset , f \"Confusing indentation for continuation line { new_offset + 1 } in docstring, \" f \"should be { indent } * 2 = { indent * 2 } spaces, not { cont_indent } \" , ) elif line . startswith ( indent * \" \" ): # indent equal to initial one: new item items . append ( current_item ) current_item = ( new_offset , [ line [ indent :]]) elif _is_empty_line ( line ): # empty line: preserve it in the current item current_item [ 1 ] . append ( \"\" ) else : # indent lower than initial one: end of section break new_offset += 1 if current_item : items . append ( current_item ) return items , new_offset - 1","title":"_read_block_items()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_deprecated_section","text":"Source code in griffe/docstrings/google.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def _read_deprecated_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: text , new_offset = _read_block ( docstring , offset ) # early exit if there is no text in the yield section if not text : _warn ( docstring , new_offset , f \"Empty deprecated section at line { offset } \" ) return None , new_offset # check the presence of a name and description, separated by a semi-colon try : version , text = text . split ( \":\" , 1 ) except ValueError : _warn ( docstring , new_offset , f \"Could not parse version, text at line { offset } \" ) return None , new_offset version = version . lstrip () description = text . lstrip () return ( DocstringSection ( DocstringSectionKind . deprecated , ( version , description )), new_offset , )","title":"_read_deprecated_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_examples_section","text":"Source code in griffe/docstrings/google.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def _read_examples_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 text , new_offset = _read_block ( docstring , offset ) sub_sections = [] in_code_example = False in_code_block = False current_text : list [ str ] = [] current_example : list [ str ] = [] for line in text . split ( \" \\n \" ): if _is_empty_line ( line ): if in_code_example : if current_example : sub_sections . append (( DocstringSectionKind . examples , \" \\n \" . join ( current_example ))) current_example = [] in_code_example = False else : current_text . append ( line ) elif in_code_example : current_example . append ( line ) elif line . startswith ( \"```\" ): in_code_block = not in_code_block # noqa: WPS434 current_text . append ( line ) elif in_code_block : current_text . append ( line ) elif line . startswith ( \">>>\" ): if current_text : sub_sections . append (( DocstringSectionKind . text , \" \\n \" . join ( current_text ) . rstrip ( \" \\n \" ))) current_text = [] in_code_example = True current_example . append ( line ) else : current_text . append ( line ) if current_text : sub_sections . append (( DocstringSectionKind . text , \" \\n \" . join ( current_text ) . rstrip ( \" \\n \" ))) elif current_example : sub_sections . append (( DocstringSectionKind . examples , \" \\n \" . join ( current_example ))) if sub_sections : return DocstringSection ( DocstringSectionKind . examples , sub_sections ), new_offset _warn ( docstring , new_offset , f \"Empty examples section at line { offset } \" ) return None , new_offset","title":"_read_examples_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_other_parameters_section","text":"Source code in griffe/docstrings/google.py 211 212 213 214 215 216 217 218 def _read_other_parameters_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: parameters , new_offset = _read_parameters ( docstring , offset ) if parameters : return DocstringSection ( DocstringSectionKind . other_parameters , parameters ), new_offset _warn ( docstring , new_offset , f \"Empty other parameters section at line { offset } \" ) return None , new_offset","title":"_read_other_parameters_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_parameters","text":"Source code in griffe/docstrings/google.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def _read_parameters ( docstring : Docstring , offset : int ) -> tuple [ list [ DocstringParameter ], int ]: # noqa: WPS231 parameters = [] annotation : str | Name | Expression | None block , new_offset = _read_block_items ( docstring , offset ) for line_number , param_lines in block : # check the presence of a name and description, separated by a semi-colon try : name_with_type , description = param_lines [ 0 ] . split ( \":\" , 1 ) except ValueError : _warn ( docstring , line_number , f \"Failed to get 'name: description' pair from ' { param_lines [ 0 ] } '\" ) continue description = \" \\n \" . join ([ description . lstrip (), * param_lines [ 1 :]]) . rstrip ( \" \\n \" ) # use the type given after the parameter name, if any if \" \" in name_with_type : name , annotation = name_with_type . split ( \" \" , 1 ) annotation = annotation . strip ( \"()\" ) if annotation . endswith ( \", optional\" ): annotation = annotation [: - 10 ] # try to compile the annotation to transform it into an expression with suppress ( SyntaxError , AttributeError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] else : name = name_with_type # try to use the annotation from the signature try : annotation = docstring . parent . parameters [ name ] . annotation # type: ignore[union-attr] except ( AttributeError , KeyError ): annotation = None try : default = docstring . parent . parameters [ name ] . default # type: ignore[union-attr] except ( AttributeError , KeyError ): default = None if annotation is None : _warn ( docstring , line_number , f \"No type or annotation for parameter ' { name } '\" ) parameters . append ( DocstringParameter ( name = name , value = default , annotation = annotation , description = description )) return parameters , new_offset","title":"_read_parameters()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_parameters_section","text":"Source code in griffe/docstrings/google.py 201 202 203 204 205 206 207 208 def _read_parameters_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: parameters , new_offset = _read_parameters ( docstring , offset ) if parameters : return DocstringSection ( DocstringSectionKind . parameters , parameters ), new_offset _warn ( docstring , new_offset , f \"Empty parameters section at line { offset } \" ) return None , new_offset","title":"_read_parameters_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_raises_section","text":"Source code in griffe/docstrings/google.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def _read_raises_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: exceptions = [] block , new_offset = _read_block_items ( docstring , offset ) for line_number , exception_lines in block : try : annotation , description = exception_lines [ 0 ] . split ( \": \" , 1 ) except ValueError : _warn ( docstring , line_number , f \"Failed to get 'exception: description' pair from ' { exception_lines [ 0 ] } '\" ) else : description = \" \\n \" . join ([ description . lstrip (), * exception_lines [ 1 :]]) . rstrip ( \" \\n \" ) exceptions . append ( DocstringRaise ( annotation = annotation , description = description )) if exceptions : return DocstringSection ( DocstringSectionKind . raises , exceptions ), new_offset _warn ( docstring , new_offset , f \"Empty exceptions section at line { offset } \" ) return None , new_offset","title":"_read_raises_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_receives_section","text":"Source code in griffe/docstrings/google.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def _read_receives_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 receives = [] block , new_offset = _read_block_items ( docstring , offset ) for index , ( line_number , receive_lines ) in enumerate ( block ): # noqa: B007 (will be used later) match = _RE_NAME_ANNOTATION_DESCRIPTION . match ( receive_lines [ 0 ]) if not match : _warn ( docstring , line_number , f \"Failed to get name, annotation or description from ' { receive_lines [ 0 ] } '\" ) continue name , annotation , description = match . groups () description = \" \\n \" . join ([ description . lstrip (), * receive_lines [ 1 :]]) . rstrip ( \" \\n \" ) if annotation and docstring . parent is not None : # try to compile the annotation to transform it into an expression with suppress ( SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] # else: # try to retrieve the annotation from the docstring parent # TODO: support getting receive part and exploding tuple (in a generator/iterator) # with suppress(AttributeError, KeyError): # annotation = docstring.parent.returns # type: ignore[union-attr] # if len(block) > 1: # if annotation.is_tuple: # annotation = annotation.tuple_item(index) if annotation is None : received_value = repr ( name ) or index _warn ( docstring , line_number , f \"No type or annotation for received value { received_value } \" ) receives . append ( DocstringReceive ( name = name or \"\" , annotation = annotation , description = description )) if receives : return DocstringSection ( DocstringSectionKind . receives , receives ), new_offset _warn ( docstring , new_offset , f \"Empty receives section at line { offset } \" ) return None , new_offset","title":"_read_receives_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_returns_section","text":"Source code in griffe/docstrings/google.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def _read_returns_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 returns = [] block , new_offset = _read_block_items ( docstring , offset ) for index , ( line_number , return_lines ) in enumerate ( block ): match = _RE_NAME_ANNOTATION_DESCRIPTION . match ( return_lines [ 0 ]) if not match : _warn ( docstring , line_number , f \"Failed to get name, annotation or description from ' { return_lines [ 0 ] } '\" ) continue name , annotation , description = match . groups () description = \" \\n \" . join ([ description . lstrip (), * return_lines [ 1 :]]) . rstrip ( \" \\n \" ) if annotation and docstring . parent is not None : # try to compile the annotation to transform it into an expression with suppress ( SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] else : # try to retrieve the annotation from the docstring parent with suppress ( AttributeError , KeyError ): annotation = docstring . parent . returns # type: ignore[union-attr] if len ( block ) > 1 : if annotation . is_tuple : annotation = annotation . tuple_item ( index ) if annotation is None : returned_value = repr ( name ) or index _warn ( docstring , line_number , f \"No type or annotation for returned value { returned_value } \" ) returns . append ( DocstringReturn ( name = name or \"\" , annotation = annotation , description = description )) if returns : return DocstringSection ( DocstringSectionKind . returns , returns ), new_offset _warn ( docstring , new_offset , f \"Empty returns section at line { offset } \" ) return None , new_offset","title":"_read_returns_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_warns_section","text":"Source code in griffe/docstrings/google.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def _read_warns_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: warns = [] block , new_offset = _read_block_items ( docstring , offset ) for line_number , warning_lines in block : try : annotation , description = warning_lines [ 0 ] . split ( \": \" , 1 ) except ValueError : _warn ( docstring , line_number , f \"Failed to get 'warning: description' pair from ' { warning_lines [ 0 ] } '\" ) else : description = \" \\n \" . join ([ description . lstrip (), * warning_lines [ 1 :]]) . rstrip ( \" \\n \" ) warns . append ( DocstringWarn ( annotation = annotation , description = description )) if warns : return DocstringSection ( DocstringSectionKind . warns , warns ), new_offset _warn ( docstring , new_offset , f \"Empty warns section at line { offset } \" ) return None , new_offset","title":"_read_warns_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google._read_yields_section","text":"Source code in griffe/docstrings/google.py 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def _read_yields_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # noqa: WPS231 yields = [] block , new_offset = _read_block_items ( docstring , offset ) for index , ( line_number , yield_lines ) in enumerate ( block ): # noqa: B007 (will be used later) match = _RE_NAME_ANNOTATION_DESCRIPTION . match ( yield_lines [ 0 ]) if not match : _warn ( docstring , line_number , f \"Failed to get name, annotation or description from ' { yield_lines [ 0 ] } '\" ) continue name , annotation , description = match . groups () description = \" \\n \" . join ([ description . lstrip (), * yield_lines [ 1 :]]) . rstrip ( \" \\n \" ) if annotation and docstring . parent is not None : # try to compile the annotation to transform it into an expression with suppress ( SyntaxError ): code = compile ( annotation , mode = \"eval\" , filename = \"\" , flags = PyCF_ONLY_AST , optimize = 2 ) annotation = code . body and get_annotation ( code . body , parent = docstring . parent ) # type: ignore[arg-type] else : # try to retrieve the annotation from the docstring parent with suppress ( AttributeError , KeyError ): annotation = docstring . parent . returns # type: ignore[union-attr] # TODO: support getting yield part and exploding tuple (in a generator/iterator) # if len(block) > 1: # if annotation.is_tuple: # annotation = annotation.tuple_item(index) if annotation is None : yielded_value = repr ( name ) or index _warn ( docstring , line_number , f \"No type or annotation for yielded value { yielded_value } \" ) yields . append ( DocstringYield ( name = name or \"\" , annotation = annotation , description = description )) if yields : return DocstringSection ( DocstringSectionKind . yields , yields ), new_offset _warn ( docstring , new_offset , f \"Empty yields section at line { offset } \" ) return None , new_offset","title":"_read_yields_section()"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/google.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines offset = 0 while offset < len ( lines ): line_lower = lines [ offset ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ offset ]) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ offset ]) else : # TODO: once Python 3.7 is dropped, use walrus operator match = _RE_ADMONITION . match ( lines [ offset ]) if match : groups = match . groupdict () title = groups [ \"title\" ] admonition_type = groups [ \"type\" ] if admonition_type . lower () in _section_kind : if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ), ) ) current_section = [] reader = _section_reader [ _section_kind [ admonition_type . lower ()]] section , offset = reader ( docstring , offset + 1 ) if section : section . title = title sections . append ( section ) else : contents , offset = _read_block ( docstring , offset + 1 ) if contents : if title is None and \" \" in admonition_type : title = admonition_type admonition_type = \"note\" sections . append ( DocstringSection ( kind = DocstringSectionKind . admonition , value = DocstringAdmonition ( kind = admonition_type . lower (), contents = contents ), title = title , ) ) else : offset -= 1 with suppress ( IndexError ): current_section . append ( lines [ offset ]) else : current_section . append ( lines [ offset ]) offset += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/markdown/","text":"This module defines functions and classes to parse Markdown docstrings into structured data.","title":"markdown"},{"location":"reference/griffe/docstrings/numpy/","text":"This module defines functions to parse Numpy-style docstrings into structured data. Based on https://numpydoc.readthedocs.io/en/latest/format.html , it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification. Rejected as non particularly Pythonic or useful as sections: See also: this section feels too subjective (specially crafted as a standard for Numpy itself), and there are may ways to reference related items in a docstring, depending on the chosen markup. Methods: with a good documentation renderer, methods are easily made accessible or hidden. Griffe also has a goal of making the merging of inherited methods configurable (on/off). Rejected as naturally handled by the user-chosen markup: Warnings: this is just markup. Notes: again, just markup. References: again, just markup. The following sections are supported: Deprecated (revisited): we expect a title instead of an RST directive. Python has support for deprecating things, so it feels natural to structure deprecations. Parameters: obviously. Returns: obviously. Yields: obviously. Receives: less used than Yields, but very natural/Pythonic as well. Other parameters: used here as documentation for keyword parameters. Raises: obviously. Warns: less used than Raises, but very natural/Pythonic as well. Examples: obviously. Special handling for non-code-blocks >>> . Attributes: obviously. _RE_CB : str = ' \\\\ }' \u00a4 _RE_NAME : str = '[_a-z][_a-z0-9]*' \u00a4 _RE_NATURAL_TYPE : str = '[_a-z0-9 (). \\'\\\\ \"-]+' \u00a4 _RE_OB : str = ' \\\\ {' \u00a4 _RE_PARAMETER : Pattern = re . compile ( ' \\n (?P<names> {_RE_NAME} (?:, \\\\ s {_RE_NAME} )*) \\n (?: \\n \\\\ s: \\\\ s \\n (?: \\n (?: {_RE_OB} (?P<choices>.+) {_RE_CB} )| \\n (?: \\n (?P<type> {_RE_NATURAL_TYPE} ) \\n (?:, \\\\ soptional)? \\n (?: \\n , \\\\ sdefault \\\\ s*[:=] \\\\ s* \\n (?P<default>.+) \\n )? \\n ) \\n ) \\n )? \\n ' , re . IGNORECASE | re . VERBOSE ) \u00a4 _RE_RECEIVES : Pattern = _RE_YIELDS \u00a4 _RE_RETURNS : Pattern = re . compile ( '^(?:(?P<name> {_RE_NAME} ) : )?(?P<type> {_RE_NATURAL_TYPE} )' , re . IGNORECASE ) \u00a4 _RE_YIELDS : Pattern = _RE_RETURNS \u00a4 _section_kind = { 'deprecated' : DocstringSectionKind . deprecated , 'parameters' : DocstringSectionKind . parameters , 'other parameters' : DocstringSectionKind . other_parameters , 'returns' : DocstringSectionKind . returns , 'yields' : DocstringSectionKind . yields , 'receives' : DocstringSectionKind . receives , 'raises' : DocstringSectionKind . raises , 'warns' : DocstringSectionKind . warns , 'examples' : DocstringSectionKind . examples , 'attributes' : DocstringSectionKind . attributes } \u00a4 _section_reader = { DocstringSectionKind . parameters : _read_parameters_section , DocstringSectionKind . other_parameters : _read_other_parameters_section , DocstringSectionKind . deprecated : _read_deprecated_section , DocstringSectionKind . raises : _read_raises_section , DocstringSectionKind . warns : _read_warns_section , DocstringSectionKind . examples : _read_examples_section , DocstringSectionKind . attributes : _read_attributes_section , DocstringSectionKind . returns : _read_returns_section , DocstringSectionKind . yields : _read_yields_section , DocstringSectionKind . receives : _read_receives_section } \u00a4 _warn = warning ( __name__ ) \u00a4 _is_dash_line ( line ) \u00a4 Source code in griffe/docstrings/numpy.py 83 84 def _is_dash_line ( line ) -> bool : return not _is_empty_line ( line ) and _is_empty_line ( line . replace ( \"-\" , \"\" )) _is_empty_line ( line ) \u00a4 Source code in griffe/docstrings/numpy.py 79 80 def _is_empty_line ( line ) -> bool : return not line . strip () _read_attributes_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def _read_attributes_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # attributes (for classes) # NAME( : TYPE)? # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty attributes section at line { offset } \" ) return None , index annotation : str | None attributes = [] for item in items : name_type = item [ 0 ] if \" : \" in name_type : name , annotation = name_type . split ( \" : \" , 1 ) else : name = name_type annotation = None text = dedent ( \" \\n \" . join ( item [ 1 :])) attributes . append ( DocstringAttribute ( name = name , annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . attributes , attributes ), index _read_block ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def _read_block ( docstring : Docstring , offset : int ) -> tuple [ str , int ]: lines = docstring . lines if offset >= len ( lines ): return \"\" , offset index = offset block : list [ str ] = [] # skip first empty lines while _is_empty_line ( lines [ index ]): index += 1 while index < len ( lines ) and not ( _is_empty_line ( lines [ index ]) and _is_dash_line ( lines [ index + 1 ])): block . append ( lines [ index ]) index += 1 return \" \\n \" . join ( block ) . rstrip ( \" \\n \" ), index - 1 _read_block_items ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def _read_block_items ( docstring : Docstring , offset : int ) -> tuple [ list [ list [ str ]], int ]: # noqa: WPS231 lines = docstring . lines if offset >= len ( lines ): return [], offset index = offset items : list [ list [ str ]] = [] # skip first empty lines while _is_empty_line ( lines [ index ]): index += 1 previous_was_empty = False # start processing first item current_item = [ lines [ index ]] index += 1 # loop on next lines while index < len ( lines ): line = lines [ index ] if line . startswith ( 4 * \" \" ): # continuation line current_item . append ( line . lstrip ()) previous_was_empty = False elif line . startswith ( \" \" ): # indent between initial and continuation: append but warn cont_indent = len ( line ) - len ( line . lstrip ()) current_item . append ( line [ cont_indent :]) _warn ( docstring , index , f \"Confusing indentation for continuation line { index + 1 } in docstring, \" f \"should be 4 spaces, not { cont_indent } \" , ) previous_was_empty = False elif _is_empty_line ( line ): # empty line: preserve it in the current item current_item . append ( \"\" ) previous_was_empty = True else : if previous_was_empty : break # new item items . append ( current_item ) current_item = [ line ] previous_was_empty = False index += 1 if current_item : items . append ( current_item ) return items , index - 1 _read_deprecated_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def _read_deprecated_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # deprecated # SINCE_VERSION # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty deprecated section at line { offset } \" ) return None , index if len ( items ) > 1 : _warn ( docstring , index , f \"Too many deprecated items at { offset } \" ) item = items [ 0 ] version = item [ 0 ] text = dedent ( \" \\n \" . join ( item [ 1 :])) return DocstringSection ( DocstringSectionKind . deprecated , ( version , text )), index _read_examples_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 def _read_examples_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: text , index = _read_block ( docstring , offset ) sub_sections = [] in_code_example = False in_code_block = False current_text : list [ str ] = [] current_example : list [ str ] = [] for line in text . split ( \" \\n \" ): if _is_empty_line ( line ): if in_code_example : if current_example : sub_sections . append (( DocstringSectionKind . examples , \" \\n \" . join ( current_example ))) current_example = [] in_code_example = False else : current_text . append ( line ) elif in_code_example : current_example . append ( line ) elif line . startswith ( \"```\" ): in_code_block = not in_code_block # noqa: WPS434 current_text . append ( line ) elif in_code_block : current_text . append ( line ) elif line . startswith ( \">>>\" ): if current_text : sub_sections . append (( DocstringSectionKind . text , \" \\n \" . join ( current_text ) . rstrip ( \" \\n \" ))) current_text = [] in_code_example = True current_example . append ( line ) else : current_text . append ( line ) if current_text : sub_sections . append (( DocstringSectionKind . text , \" \\n \" . join ( current_text ) . rstrip ( \" \\n \" ))) elif current_example : sub_sections . append (( DocstringSectionKind . examples , \" \\n \" . join ( current_example ))) if sub_sections : return DocstringSection ( DocstringSectionKind . examples , sub_sections ), index _warn ( docstring , index , f \"Empty examples section at line { offset } \" ) return None , index _read_other_parameters_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 254 255 256 257 258 259 260 261 def _read_other_parameters_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: parameters , index = _read_parameters ( docstring , offset ) if parameters : return DocstringSection ( DocstringSectionKind . other_parameters , parameters ), index _warn ( docstring , index , f \"Empty other parameters section at line { offset } \" ) return None , index _read_parameters ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def _read_parameters ( docstring : Docstring , offset : int ) -> tuple [ list [ DocstringParameter ], int ]: # noqa: WPS231 parameters = [] annotation : str | Name | Expression | None items , index = _read_block_items ( docstring , offset ) for item in items : match = _RE_PARAMETER . match ( item [ 0 ]) if not match : _warn ( docstring , index , f \"Could not parse line ' { item [ 0 ] } '\" ) continue names = match . group ( \"names\" ) . split ( \", \" ) annotation = match . group ( \"type\" ) choices = match . group ( \"choices\" ) if choices : choices = choices . split ( \", \" , 1 ) default = choices [ 0 ] else : default = match . group ( \"default\" ) if len ( item ) > 1 : description = \" \\n \" . join ( item [ 1 :]) . rstrip () else : description = \"\" if annotation is None : # try to use the annotation from the signature for name in names : with suppress ( AttributeError , KeyError ): annotation = docstring . parent . parameters [ name ] . annotation # type: ignore[union-attr] break else : _warn ( docstring , index , f \"No types or annotations for parameters { names } \" ) if default is None : for name in names : try : default = docstring . parent . parameters [ name ] . default # type: ignore[union-attr] break except ( AttributeError , KeyError ): pass for name in names : parameters . append ( DocstringParameter ( name , value = default , annotation = annotation , description = description )) return parameters , index _read_parameters_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 244 245 246 247 248 249 250 251 def _read_parameters_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: parameters , index = _read_parameters ( docstring , offset ) if parameters : return DocstringSection ( DocstringSectionKind . parameters , parameters ), index _warn ( docstring , index , f \"Empty parameters section at line { offset } \" ) return None , index _read_raises_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def _read_raises_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # raises # EXCEPTION # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty raises section at line { offset } \" ) return None , index raises = [] for item in items : annotation = item [ 0 ] text = dedent ( \" \\n \" . join ( item [ 1 :])) raises . append ( DocstringRaise ( annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . raises , raises ), index _read_receives_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def _read_receives_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # receives # (NAME : )?TYPE # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty receives section at line { offset } \" ) return None , index receives = [] for item in items : match = _RE_RECEIVES . match ( item [ 0 ]) if not match : _warn ( docstring , index , f \"Could not parse line ' { item [ 0 ] } '\" ) continue name , annotation = match . groups () text = dedent ( \" \\n \" . join ( item [ 1 :])) receives . append ( DocstringReceive ( name = name or \"\" , annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . receives , receives ), index _read_returns_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def _read_returns_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # returns # (NAME : )?TYPE # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty returns section at line { offset } \" ) return None , index returns = [] for item in items : match = _RE_RETURNS . match ( item [ 0 ]) if not match : _warn ( docstring , index , f \"Could not parse line ' { item [ 0 ] } '\" ) continue name , annotation = match . groups () text = dedent ( \" \\n \" . join ( item [ 1 :])) returns . append ( DocstringReturn ( name = name or \"\" , annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . returns , returns ), index _read_warns_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def _read_warns_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # warns # WARNING # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty warns section at line { offset } \" ) return None , index warns = [] for item in items : annotation = item [ 0 ] text = dedent ( \" \\n \" . join ( item [ 1 :])) warns . append ( DocstringWarn ( annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . warns , warns ), index _read_yields_section ( docstring , offset ) \u00a4 Source code in griffe/docstrings/numpy.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def _read_yields_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # yields # (NAME : )?TYPE # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty yields section at line { offset } \" ) return None , index yields = [] for item in items : match = _RE_YIELDS . match ( item [ 0 ]) if not match : _warn ( docstring , index , f \"Could not parse line ' { item [ 0 ] } '\" ) continue name , annotation = match . groups () text = dedent ( \" \\n \" . join ( item [ 1 :])) yields . append ( DocstringYield ( name = name or \"\" , annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . yields , yields ), index parse ( docstring , ** options ) \u00a4 Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"numpy"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._RE_CB","text":"","title":"_RE_CB"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._RE_NAME","text":"","title":"_RE_NAME"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._RE_NATURAL_TYPE","text":"","title":"_RE_NATURAL_TYPE"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._RE_OB","text":"","title":"_RE_OB"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._RE_PARAMETER","text":"","title":"_RE_PARAMETER"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._RE_RECEIVES","text":"","title":"_RE_RECEIVES"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._RE_RETURNS","text":"","title":"_RE_RETURNS"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._RE_YIELDS","text":"","title":"_RE_YIELDS"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._section_kind","text":"","title":"_section_kind"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._section_reader","text":"","title":"_section_reader"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._warn","text":"","title":"_warn"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._is_dash_line","text":"Source code in griffe/docstrings/numpy.py 83 84 def _is_dash_line ( line ) -> bool : return not _is_empty_line ( line ) and _is_empty_line ( line . replace ( \"-\" , \"\" ))","title":"_is_dash_line()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._is_empty_line","text":"Source code in griffe/docstrings/numpy.py 79 80 def _is_empty_line ( line ) -> bool : return not line . strip ()","title":"_is_empty_line()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_attributes_section","text":"Source code in griffe/docstrings/numpy.py 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def _read_attributes_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # attributes (for classes) # NAME( : TYPE)? # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty attributes section at line { offset } \" ) return None , index annotation : str | None attributes = [] for item in items : name_type = item [ 0 ] if \" : \" in name_type : name , annotation = name_type . split ( \" : \" , 1 ) else : name = name_type annotation = None text = dedent ( \" \\n \" . join ( item [ 1 :])) attributes . append ( DocstringAttribute ( name = name , annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . attributes , attributes ), index","title":"_read_attributes_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_block","text":"Source code in griffe/docstrings/numpy.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def _read_block ( docstring : Docstring , offset : int ) -> tuple [ str , int ]: lines = docstring . lines if offset >= len ( lines ): return \"\" , offset index = offset block : list [ str ] = [] # skip first empty lines while _is_empty_line ( lines [ index ]): index += 1 while index < len ( lines ) and not ( _is_empty_line ( lines [ index ]) and _is_dash_line ( lines [ index + 1 ])): block . append ( lines [ index ]) index += 1 return \" \\n \" . join ( block ) . rstrip ( \" \\n \" ), index - 1","title":"_read_block()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_block_items","text":"Source code in griffe/docstrings/numpy.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def _read_block_items ( docstring : Docstring , offset : int ) -> tuple [ list [ list [ str ]], int ]: # noqa: WPS231 lines = docstring . lines if offset >= len ( lines ): return [], offset index = offset items : list [ list [ str ]] = [] # skip first empty lines while _is_empty_line ( lines [ index ]): index += 1 previous_was_empty = False # start processing first item current_item = [ lines [ index ]] index += 1 # loop on next lines while index < len ( lines ): line = lines [ index ] if line . startswith ( 4 * \" \" ): # continuation line current_item . append ( line . lstrip ()) previous_was_empty = False elif line . startswith ( \" \" ): # indent between initial and continuation: append but warn cont_indent = len ( line ) - len ( line . lstrip ()) current_item . append ( line [ cont_indent :]) _warn ( docstring , index , f \"Confusing indentation for continuation line { index + 1 } in docstring, \" f \"should be 4 spaces, not { cont_indent } \" , ) previous_was_empty = False elif _is_empty_line ( line ): # empty line: preserve it in the current item current_item . append ( \"\" ) previous_was_empty = True else : if previous_was_empty : break # new item items . append ( current_item ) current_item = [ line ] previous_was_empty = False index += 1 if current_item : items . append ( current_item ) return items , index - 1","title":"_read_block_items()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_deprecated_section","text":"Source code in griffe/docstrings/numpy.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def _read_deprecated_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # deprecated # SINCE_VERSION # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty deprecated section at line { offset } \" ) return None , index if len ( items ) > 1 : _warn ( docstring , index , f \"Too many deprecated items at { offset } \" ) item = items [ 0 ] version = item [ 0 ] text = dedent ( \" \\n \" . join ( item [ 1 :])) return DocstringSection ( DocstringSectionKind . deprecated , ( version , text )), index","title":"_read_deprecated_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_examples_section","text":"Source code in griffe/docstrings/numpy.py 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 def _read_examples_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: text , index = _read_block ( docstring , offset ) sub_sections = [] in_code_example = False in_code_block = False current_text : list [ str ] = [] current_example : list [ str ] = [] for line in text . split ( \" \\n \" ): if _is_empty_line ( line ): if in_code_example : if current_example : sub_sections . append (( DocstringSectionKind . examples , \" \\n \" . join ( current_example ))) current_example = [] in_code_example = False else : current_text . append ( line ) elif in_code_example : current_example . append ( line ) elif line . startswith ( \"```\" ): in_code_block = not in_code_block # noqa: WPS434 current_text . append ( line ) elif in_code_block : current_text . append ( line ) elif line . startswith ( \">>>\" ): if current_text : sub_sections . append (( DocstringSectionKind . text , \" \\n \" . join ( current_text ) . rstrip ( \" \\n \" ))) current_text = [] in_code_example = True current_example . append ( line ) else : current_text . append ( line ) if current_text : sub_sections . append (( DocstringSectionKind . text , \" \\n \" . join ( current_text ) . rstrip ( \" \\n \" ))) elif current_example : sub_sections . append (( DocstringSectionKind . examples , \" \\n \" . join ( current_example ))) if sub_sections : return DocstringSection ( DocstringSectionKind . examples , sub_sections ), index _warn ( docstring , index , f \"Empty examples section at line { offset } \" ) return None , index","title":"_read_examples_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_other_parameters_section","text":"Source code in griffe/docstrings/numpy.py 254 255 256 257 258 259 260 261 def _read_other_parameters_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: parameters , index = _read_parameters ( docstring , offset ) if parameters : return DocstringSection ( DocstringSectionKind . other_parameters , parameters ), index _warn ( docstring , index , f \"Empty other parameters section at line { offset } \" ) return None , index","title":"_read_other_parameters_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_parameters","text":"Source code in griffe/docstrings/numpy.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def _read_parameters ( docstring : Docstring , offset : int ) -> tuple [ list [ DocstringParameter ], int ]: # noqa: WPS231 parameters = [] annotation : str | Name | Expression | None items , index = _read_block_items ( docstring , offset ) for item in items : match = _RE_PARAMETER . match ( item [ 0 ]) if not match : _warn ( docstring , index , f \"Could not parse line ' { item [ 0 ] } '\" ) continue names = match . group ( \"names\" ) . split ( \", \" ) annotation = match . group ( \"type\" ) choices = match . group ( \"choices\" ) if choices : choices = choices . split ( \", \" , 1 ) default = choices [ 0 ] else : default = match . group ( \"default\" ) if len ( item ) > 1 : description = \" \\n \" . join ( item [ 1 :]) . rstrip () else : description = \"\" if annotation is None : # try to use the annotation from the signature for name in names : with suppress ( AttributeError , KeyError ): annotation = docstring . parent . parameters [ name ] . annotation # type: ignore[union-attr] break else : _warn ( docstring , index , f \"No types or annotations for parameters { names } \" ) if default is None : for name in names : try : default = docstring . parent . parameters [ name ] . default # type: ignore[union-attr] break except ( AttributeError , KeyError ): pass for name in names : parameters . append ( DocstringParameter ( name , value = default , annotation = annotation , description = description )) return parameters , index","title":"_read_parameters()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_parameters_section","text":"Source code in griffe/docstrings/numpy.py 244 245 246 247 248 249 250 251 def _read_parameters_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: parameters , index = _read_parameters ( docstring , offset ) if parameters : return DocstringSection ( DocstringSectionKind . parameters , parameters ), index _warn ( docstring , index , f \"Empty parameters section at line { offset } \" ) return None , index","title":"_read_parameters_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_raises_section","text":"Source code in griffe/docstrings/numpy.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def _read_raises_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # raises # EXCEPTION # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty raises section at line { offset } \" ) return None , index raises = [] for item in items : annotation = item [ 0 ] text = dedent ( \" \\n \" . join ( item [ 1 :])) raises . append ( DocstringRaise ( annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . raises , raises ), index","title":"_read_raises_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_receives_section","text":"Source code in griffe/docstrings/numpy.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def _read_receives_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # receives # (NAME : )?TYPE # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty receives section at line { offset } \" ) return None , index receives = [] for item in items : match = _RE_RECEIVES . match ( item [ 0 ]) if not match : _warn ( docstring , index , f \"Could not parse line ' { item [ 0 ] } '\" ) continue name , annotation = match . groups () text = dedent ( \" \\n \" . join ( item [ 1 :])) receives . append ( DocstringReceive ( name = name or \"\" , annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . receives , receives ), index","title":"_read_receives_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_returns_section","text":"Source code in griffe/docstrings/numpy.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def _read_returns_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # returns # (NAME : )?TYPE # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty returns section at line { offset } \" ) return None , index returns = [] for item in items : match = _RE_RETURNS . match ( item [ 0 ]) if not match : _warn ( docstring , index , f \"Could not parse line ' { item [ 0 ] } '\" ) continue name , annotation = match . groups () text = dedent ( \" \\n \" . join ( item [ 1 :])) returns . append ( DocstringReturn ( name = name or \"\" , annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . returns , returns ), index","title":"_read_returns_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_warns_section","text":"Source code in griffe/docstrings/numpy.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def _read_warns_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # warns # WARNING # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty warns section at line { offset } \" ) return None , index warns = [] for item in items : annotation = item [ 0 ] text = dedent ( \" \\n \" . join ( item [ 1 :])) warns . append ( DocstringWarn ( annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . warns , warns ), index","title":"_read_warns_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy._read_yields_section","text":"Source code in griffe/docstrings/numpy.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def _read_yields_section ( docstring : Docstring , offset : int ) -> tuple [ DocstringSection | None , int ]: # yields # (NAME : )?TYPE # TEXT? items , index = _read_block_items ( docstring , offset ) if not items : _warn ( docstring , index , f \"Empty yields section at line { offset } \" ) return None , index yields = [] for item in items : match = _RE_YIELDS . match ( item [ 0 ]) if not match : _warn ( docstring , index , f \"Could not parse line ' { item [ 0 ] } '\" ) continue name , annotation = match . groups () text = dedent ( \" \\n \" . join ( item [ 1 :])) yields . append ( DocstringYield ( name = name or \"\" , annotation = annotation , description = text )) return DocstringSection ( DocstringSectionKind . yields , yields ), index","title":"_read_yields_section()"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy.parse","text":"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/numpy.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 def parse ( # noqa: WPS231 docstring : Docstring , ** options : Any , ) -> list [ DocstringSection ]: \"\"\"Parse a docstring. This function iterates on lines of a docstring to build sections. It then returns this list of sections. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" sections = [] current_section = [] in_code_block = False lines = docstring . lines index = 0 while index < len ( lines ): line_lower = lines [ index ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ index ]) elif line_lower in _section_kind and _is_dash_line ( lines [ index + 1 ]): if current_section : if any ( current_section ): sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" )) ) current_section = [] reader = _section_reader [ _section_kind [ line_lower ]] section , index = reader ( docstring , index + 2 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ index ]) else : current_section . append ( lines [ index ]) index += 1 if current_section : sections . append ( DocstringSection ( DocstringSectionKind . text , \" \\n \" . join ( current_section ) . rstrip ( \" \\n \" ))) return sections","title":"parse()"},{"location":"reference/griffe/docstrings/parsers/","text":"This module imports all the defined parsers. parsers = { Parser . google : parse_google , Parser . rst : parse_rst , Parser . numpy : parse_numpy } \u00a4 Parser ( enum . Enum ) \u00a4 Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 24 25 26 27 28 29 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\" google = 'google' \u00a4 numpy = 'numpy' \u00a4 rst = 'rst' \u00a4 parse ( docstring , parser , ** options ) \u00a4 Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parsers"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.parsers","text":"","title":"parsers"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser","text":"Enumeration for the different docstring parsers. Source code in griffe/docstrings/parsers.py 24 25 26 27 28 29 class Parser ( enum . Enum ): \"\"\"Enumeration for the different docstring parsers.\"\"\" google = \"google\" rst = \"rst\" numpy = \"numpy\"","title":"Parser"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser.google","text":"","title":"google"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser.numpy","text":"","title":"numpy"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser.rst","text":"","title":"rst"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.parse","text":"Parse the docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. parser ( Parser | None ) \u2013 The docstring parser to use. If None, return a single text section. **options ( Any ) \u2013 The options accepted by the parser. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/parsers.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def parse ( docstring : Docstring , parser : Parser | None , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse the docstring. Parameters: docstring: The docstring to parse. parser: The docstring parser to use. If None, return a single text section. **options: The options accepted by the parser. Returns: A list of docstring sections. \"\"\" if parser : return parsers [ parser ]( docstring , ** options ) return [ DocstringSection ( DocstringSectionKind . text , docstring . value )]","title":"parse()"},{"location":"reference/griffe/docstrings/rst/","text":"This module defines functions to parse RST-style docstrings into structured data. Credits to Patrick Lannigan ( @plannigan ) who originally added the parser in the pytkdocs project . See https://github.com/mkdocstrings/pytkdocs/pull/71 . ATTRIBUTE_NAMES = frozenset (( 'var' , 'ivar' , 'cvar' )) \u00a4 ATTRIBUTE_TYPE_NAMES = frozenset (( 'vartype' )) \u00a4 EXCEPTION_NAMES = frozenset (( 'raises' , 'raise' , 'except' , 'exception' )) \u00a4 PARAM_NAMES = frozenset (( 'param' , 'parameter' , 'arg' , 'argument' , 'key' , 'keyword' )) \u00a4 PARAM_TYPE_NAMES = frozenset (( 'type' )) \u00a4 RETURN_NAMES = frozenset (( 'returns' , 'return' )) \u00a4 RETURN_TYPE_NAMES = frozenset (( 'rtype' )) \u00a4 _warn = warning ( __name__ ) \u00a4 field_types = [ FieldType ( PARAM_TYPE_NAMES , _read_parameter_type ), FieldType ( PARAM_NAMES , _read_parameter ), FieldType ( ATTRIBUTE_TYPE_NAMES , _read_attribute_type ), FieldType ( ATTRIBUTE_NAMES , _read_attribute ), FieldType ( EXCEPTION_NAMES , _read_exception ), FieldType ( RETURN_NAMES , _read_return ), FieldType ( RETURN_TYPE_NAMES , _read_return_type )] \u00a4 FieldType \u00a4 Maps directive names to parser functions. Source code in griffe/docstrings/rst.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @dataclass ( frozen = True ) class FieldType : \"\"\"Maps directive names to parser functions.\"\"\" names : FrozenSet [ str ] reader : Callable [[ Docstring , int , ParsedValues ], int ] def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names ) names : FrozenSet [ str ] = None \u00a4 reader : Callable [[ Docstring , int , ParsedValues ], int ] = None \u00a4 matches ( self , line ) \u00a4 Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/rst.py 47 48 49 50 51 52 53 54 55 56 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names ) ParsedDirective \u00a4 Directive information that has been parsed from a docstring. Source code in griffe/docstrings/rst.py 59 60 61 62 63 64 65 66 67 @dataclass class ParsedDirective : \"\"\"Directive information that has been parsed from a docstring.\"\"\" line : str next_index : int directive_parts : list [ str ] value : str invalid : bool = False directive_parts : list [ str ] = None \u00a4 invalid : bool = False \u00a4 line : str = None \u00a4 next_index : int = None \u00a4 value : str = None \u00a4 ParsedValues \u00a4 Values parsed from the docstring to be used to produce sections. Source code in griffe/docstrings/rst.py 70 71 72 73 74 75 76 77 78 79 80 81 @dataclass class ParsedValues : \"\"\"Values parsed from the docstring to be used to produce sections.\"\"\" description : list [ str ] = field ( default_factory = list ) parameters : dict [ str , DocstringParameter ] = field ( default_factory = dict ) param_types : dict [ str , str ] = field ( default_factory = dict ) attributes : dict [ str , DocstringAttribute ] = field ( default_factory = dict ) attribute_types : dict [ str , str ] = field ( default_factory = dict ) exceptions : list [ DocstringRaise ] = field ( default_factory = list ) return_value : DocstringReturn | None = None return_type : str | None = None attribute_types : dict [ str , str ] = field ( default_factory = dict ) \u00a4 attributes : dict [ str , DocstringAttribute ] = field ( default_factory = dict ) \u00a4 description : list [ str ] = field ( default_factory = list ) \u00a4 exceptions : list [ DocstringRaise ] = field ( default_factory = list ) \u00a4 param_types : dict [ str , str ] = field ( default_factory = dict ) \u00a4 parameters : dict [ str , DocstringParameter ] = field ( default_factory = dict ) \u00a4 return_type : str | None = None \u00a4 return_value : DocstringReturn | None = None \u00a4 _consolidate_continuation_lines ( lines , offset ) \u00a4 Convert a docstring field into a single line if a line continuation exists. Parameters: lines ( list [ str ] ) \u2013 The docstring lines. offset ( int ) \u2013 The line number to start at. Returns: tuple [ str , int ] \u2013 A tuple containing the continued lines as a single string and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def _consolidate_continuation_lines ( lines : list [ str ], offset : int ) -> tuple [ str , int ]: \"\"\" Convert a docstring field into a single line if a line continuation exists. Parameters: lines: The docstring lines. offset: The line number to start at. Returns: A tuple containing the continued lines as a single string and the index at which to continue parsing. \"\"\" curr_line_index = offset block = [ lines [ curr_line_index ] . lstrip ()] # start processing after first item curr_line_index += 1 while curr_line_index < len ( lines ) and not lines [ curr_line_index ] . startswith ( \":\" ): block . append ( lines [ curr_line_index ] . lstrip ()) curr_line_index += 1 return \" \" . join ( block ) . rstrip ( \" \\n \" ), curr_line_index - 1 _consolidate_descriptive_type ( descriptive_type ) \u00a4 Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type ( str ) \u2013 Descriptions of an item's type. Returns: str \u2013 Type signature for descriptive type. Source code in griffe/docstrings/rst.py 438 439 440 441 442 443 444 445 446 447 448 449 def _consolidate_descriptive_type ( descriptive_type : str ) -> str : \"\"\"Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type: Descriptions of an item's type. Returns: Type signature for descriptive type. \"\"\" return descriptive_type . replace ( \" or \" , \" | \" ) _determine_param_annotation ( docstring , name , directive_type , parsed_values ) \u00a4 Source code in griffe/docstrings/rst.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def _determine_param_annotation ( docstring : Docstring , name : str , directive_type : str | None , parsed_values : ParsedValues ) -> Any : # Annotation precedence: # - in-line directive type # - \"type\" directive type # - signature annotation # - none annotation : str | Name | Expression | None = None parsed_param_type = parsed_values . param_types . get ( name ) if parsed_param_type is not None : annotation = parsed_param_type if directive_type is not None : annotation = directive_type if directive_type is not None and parsed_param_type is not None : _warn ( docstring , 0 , f \"Duplicate parameter information for ' { name } '\" ) if annotation is None : try : annotation = docstring . parent . parameters [ name . lstrip ()] . annotation # type: ignore[union-attr] except ( AttributeError , KeyError ): _warn ( docstring , 0 , f \"No matching parameter for ' { name } '\" ) return annotation _determine_param_default ( docstring , name ) \u00a4 Source code in griffe/docstrings/rst.py 157 158 159 160 161 def _determine_param_default ( docstring : Docstring , name : str ) -> str | None : try : return docstring . parent . parameters [ name . lstrip ()] . default # type: ignore[union-attr] except ( AttributeError , KeyError ): return None _parse_directive ( docstring , offset ) \u00a4 Source code in griffe/docstrings/rst.py 403 404 405 406 407 408 409 410 411 412 def _parse_directive ( docstring : Docstring , offset : int ) -> ParsedDirective : line , next_index = _consolidate_continuation_lines ( docstring . lines , offset ) try : _ , directive , value = line . split ( \":\" , 2 ) except ValueError : _warn ( docstring , 0 , f \"Failed to get ':directive: value' pair from ' { line } '\" ) return ParsedDirective ( line , next_index , [], \"\" , invalid = True ) value = value . strip () return ParsedDirective ( line , next_index , directive . split ( \" \" ), value ) _parsed_values_to_sections ( parsed_values ) \u00a4 Source code in griffe/docstrings/rst.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def _parsed_values_to_sections ( parsed_values : ParsedValues ) -> list [ DocstringSection ]: text = \" \\n \" . join ( _strip_blank_lines ( parsed_values . description )) result = [ DocstringSection ( DocstringSectionKind . text , text )] if parsed_values . parameters : param_values = list ( parsed_values . parameters . values ()) result . append ( DocstringSection ( DocstringSectionKind . parameters , param_values )) if parsed_values . attributes : attribute_values = list ( parsed_values . attributes . values ()) result . append ( DocstringSection ( DocstringSectionKind . attributes , attribute_values )) if parsed_values . return_value is not None : result . append ( DocstringSection ( DocstringSectionKind . returns , parsed_values . return_value )) if parsed_values . exceptions : result . append ( DocstringSection ( DocstringSectionKind . raises , parsed_values . exceptions )) return result _read_attribute ( docstring , offset , parsed_values ) \u00a4 Parse an attribute value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def _read_attribute ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an attribute value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index annotation : str | Name | Expression | None = None # Annotation precedence: # - \"vartype\" directive type # - annotation in the parent # - none parsed_attribute_type = parsed_values . attribute_types . get ( name ) if parsed_attribute_type is not None : annotation = parsed_attribute_type else : # try to use the annotation from the parent with suppress ( AttributeError , KeyError ): annotation = docstring . parent . attributes [ name ] . annotation # type: ignore[union-attr] if name in parsed_values . attributes : _warn ( docstring , 0 , f \"Duplicate attribute entry for ' { name } '\" ) else : parsed_values . attributes [ name ] = DocstringAttribute ( name = name , annotation = annotation , description = parsed_directive . value , ) return parsed_directive . next_index _read_attribute_type ( docstring , offset , parsed_values ) \u00a4 Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def _read_attribute_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index attribute_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : attribute_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get attribute name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . attribute_types [ attribute_name ] = attribute_type attribute = parsed_values . attributes . get ( attribute_name ) if attribute is not None : if attribute . annotation is None : attribute . annotation = attribute_type else : _warn ( docstring , 0 , f \"Duplicate attribute information for ' { attribute_name } '\" ) return parsed_directive . next_index _read_exception ( docstring , offset , parsed_values ) \u00a4 Parse an exception value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 A tuple containing a DocstringSection (or None ) and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def _read_exception ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an exception value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: A tuple containing a `DocstringSection` (or `None`) and the index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : ex_type = parsed_directive . directive_parts [ 1 ] parsed_values . exceptions . append ( DocstringRaise ( annotation = ex_type , description = parsed_directive . value )) else : _warn ( docstring , 0 , f \"Failed to parse exception directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index _read_parameter ( docstring , offset , parsed_values ) \u00a4 Parse a parameter value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def _read_parameter ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index directive_type = None if len ( parsed_directive . directive_parts ) == 2 : # no type info name = parsed_directive . directive_parts [ 1 ] elif len ( parsed_directive . directive_parts ) == 3 : directive_type = parsed_directive . directive_parts [ 1 ] name = parsed_directive . directive_parts [ 2 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index if name in parsed_values . parameters : _warn ( docstring , 0 , f \"Duplicate parameter entry for ' { name } '\" ) return parsed_directive . next_index annotation = _determine_param_annotation ( docstring , name , directive_type , parsed_values ) default = _determine_param_default ( docstring , name ) parsed_values . parameters [ name ] = DocstringParameter ( name = name , annotation = annotation , description = parsed_directive . value , value = default , ) return parsed_directive . next_index _read_parameter_type ( docstring , offset , parsed_values ) \u00a4 Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def _read_parameter_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index param_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : param_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get parameter name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . param_types [ param_name ] = param_type param = parsed_values . parameters . get ( param_name ) if param is not None : if param . annotation is None : param . annotation = param_type else : _warn ( docstring , 0 , f \"Duplicate parameter information for ' { param_name } '\" ) return parsed_directive . next_index _read_return ( docstring , offset , parsed_values ) \u00a4 Parse an return value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def _read_return ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index # Annotation precedence: # - \"rtype\" directive type # - signature annotation # - None annotation : str | Name | Expression | None if parsed_values . return_type is not None : annotation = parsed_values . return_type else : try : annotation = docstring . parent . returns # type: ignore[union-attr] except AttributeError : _warn ( docstring , 0 , f \"No return type or annotation at ' { parsed_directive . line } '\" ) annotation = None # TODO: maybe support names parsed_values . return_value = DocstringReturn ( name = \"\" , annotation = annotation , description = parsed_directive . value ) return parsed_directive . next_index _read_return_type ( docstring , offset , parsed_values ) \u00a4 Parse an return type value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def _read_return_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return type value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index return_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) parsed_values . return_type = return_type return_value = parsed_values . return_value if return_value is not None : return_value . annotation = return_type return parsed_directive . next_index _strip_blank_lines ( lines ) \u00a4 Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines ( list [ str ] ) \u2013 Lines to be stripped. Returns: list [ str ] \u2013 A list with the same contents, with any blank lines at the start or end removed. Source code in griffe/docstrings/rst.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 def _strip_blank_lines ( lines : list [ str ]) -> list [ str ]: \"\"\"Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines: Lines to be stripped. Returns: A list with the same contents, with any blank lines at the start or end removed. \"\"\" if not lines : return lines # remove blank lines from the start and end content_found = False initial_content = 0 final_content = 0 for index , line in enumerate ( lines ): if line == \"\" or line . isspace (): if not content_found : initial_content += 1 else : content_found = True final_content = index return lines [ initial_content : final_content + 1 ] parse ( docstring , ** options ) \u00a4 Parse an RST-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/rst.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse an RST-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore[misc,operator] break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"rst"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ATTRIBUTE_NAMES","text":"","title":"ATTRIBUTE_NAMES"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ATTRIBUTE_TYPE_NAMES","text":"","title":"ATTRIBUTE_TYPE_NAMES"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.EXCEPTION_NAMES","text":"","title":"EXCEPTION_NAMES"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.PARAM_NAMES","text":"","title":"PARAM_NAMES"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.PARAM_TYPE_NAMES","text":"","title":"PARAM_TYPE_NAMES"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.RETURN_NAMES","text":"","title":"RETURN_NAMES"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.RETURN_TYPE_NAMES","text":"","title":"RETURN_TYPE_NAMES"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._warn","text":"","title":"_warn"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.field_types","text":"","title":"field_types"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.FieldType","text":"Maps directive names to parser functions. Source code in griffe/docstrings/rst.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @dataclass ( frozen = True ) class FieldType : \"\"\"Maps directive names to parser functions.\"\"\" names : FrozenSet [ str ] reader : Callable [[ Docstring , int , ParsedValues ], int ] def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names )","title":"FieldType"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.FieldType.names","text":"","title":"names"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.FieldType.reader","text":"","title":"reader"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.FieldType.matches","text":"Check if a line matches the field type. Parameters: line ( str ) \u2013 Line to check against Returns: bool \u2013 True if the line matches the field type, False otherwise. Source code in griffe/docstrings/rst.py 47 48 49 50 51 52 53 54 55 56 def matches ( self , line : str ) -> bool : \"\"\"Check if a line matches the field type. Parameters: line: Line to check against Returns: True if the line matches the field type, False otherwise. \"\"\" return any ( line . startswith ( f \": { name } \" ) for name in self . names )","title":"matches()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedDirective","text":"Directive information that has been parsed from a docstring. Source code in griffe/docstrings/rst.py 59 60 61 62 63 64 65 66 67 @dataclass class ParsedDirective : \"\"\"Directive information that has been parsed from a docstring.\"\"\" line : str next_index : int directive_parts : list [ str ] value : str invalid : bool = False","title":"ParsedDirective"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedDirective.directive_parts","text":"","title":"directive_parts"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedDirective.invalid","text":"","title":"invalid"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedDirective.line","text":"","title":"line"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedDirective.next_index","text":"","title":"next_index"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedDirective.value","text":"","title":"value"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues","text":"Values parsed from the docstring to be used to produce sections. Source code in griffe/docstrings/rst.py 70 71 72 73 74 75 76 77 78 79 80 81 @dataclass class ParsedValues : \"\"\"Values parsed from the docstring to be used to produce sections.\"\"\" description : list [ str ] = field ( default_factory = list ) parameters : dict [ str , DocstringParameter ] = field ( default_factory = dict ) param_types : dict [ str , str ] = field ( default_factory = dict ) attributes : dict [ str , DocstringAttribute ] = field ( default_factory = dict ) attribute_types : dict [ str , str ] = field ( default_factory = dict ) exceptions : list [ DocstringRaise ] = field ( default_factory = list ) return_value : DocstringReturn | None = None return_type : str | None = None","title":"ParsedValues"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues.attribute_types","text":"","title":"attribute_types"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues.attributes","text":"","title":"attributes"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues.description","text":"","title":"description"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues.exceptions","text":"","title":"exceptions"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues.param_types","text":"","title":"param_types"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues.parameters","text":"","title":"parameters"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues.return_type","text":"","title":"return_type"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.ParsedValues.return_value","text":"","title":"return_value"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._consolidate_continuation_lines","text":"Convert a docstring field into a single line if a line continuation exists. Parameters: lines ( list [ str ] ) \u2013 The docstring lines. offset ( int ) \u2013 The line number to start at. Returns: tuple [ str , int ] \u2013 A tuple containing the continued lines as a single string and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def _consolidate_continuation_lines ( lines : list [ str ], offset : int ) -> tuple [ str , int ]: \"\"\" Convert a docstring field into a single line if a line continuation exists. Parameters: lines: The docstring lines. offset: The line number to start at. Returns: A tuple containing the continued lines as a single string and the index at which to continue parsing. \"\"\" curr_line_index = offset block = [ lines [ curr_line_index ] . lstrip ()] # start processing after first item curr_line_index += 1 while curr_line_index < len ( lines ) and not lines [ curr_line_index ] . startswith ( \":\" ): block . append ( lines [ curr_line_index ] . lstrip ()) curr_line_index += 1 return \" \" . join ( block ) . rstrip ( \" \\n \" ), curr_line_index - 1","title":"_consolidate_continuation_lines()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._consolidate_descriptive_type","text":"Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type ( str ) \u2013 Descriptions of an item's type. Returns: str \u2013 Type signature for descriptive type. Source code in griffe/docstrings/rst.py 438 439 440 441 442 443 444 445 446 447 448 449 def _consolidate_descriptive_type ( descriptive_type : str ) -> str : \"\"\"Convert type descriptions with \"or\" into respective type signature. \"x or y\" -> \"x | y\" Parameters: descriptive_type: Descriptions of an item's type. Returns: Type signature for descriptive type. \"\"\" return descriptive_type . replace ( \" or \" , \" | \" )","title":"_consolidate_descriptive_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._determine_param_annotation","text":"Source code in griffe/docstrings/rst.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def _determine_param_annotation ( docstring : Docstring , name : str , directive_type : str | None , parsed_values : ParsedValues ) -> Any : # Annotation precedence: # - in-line directive type # - \"type\" directive type # - signature annotation # - none annotation : str | Name | Expression | None = None parsed_param_type = parsed_values . param_types . get ( name ) if parsed_param_type is not None : annotation = parsed_param_type if directive_type is not None : annotation = directive_type if directive_type is not None and parsed_param_type is not None : _warn ( docstring , 0 , f \"Duplicate parameter information for ' { name } '\" ) if annotation is None : try : annotation = docstring . parent . parameters [ name . lstrip ()] . annotation # type: ignore[union-attr] except ( AttributeError , KeyError ): _warn ( docstring , 0 , f \"No matching parameter for ' { name } '\" ) return annotation","title":"_determine_param_annotation()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._determine_param_default","text":"Source code in griffe/docstrings/rst.py 157 158 159 160 161 def _determine_param_default ( docstring : Docstring , name : str ) -> str | None : try : return docstring . parent . parameters [ name . lstrip ()] . default # type: ignore[union-attr] except ( AttributeError , KeyError ): return None","title":"_determine_param_default()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._parse_directive","text":"Source code in griffe/docstrings/rst.py 403 404 405 406 407 408 409 410 411 412 def _parse_directive ( docstring : Docstring , offset : int ) -> ParsedDirective : line , next_index = _consolidate_continuation_lines ( docstring . lines , offset ) try : _ , directive , value = line . split ( \":\" , 2 ) except ValueError : _warn ( docstring , 0 , f \"Failed to get ':directive: value' pair from ' { line } '\" ) return ParsedDirective ( line , next_index , [], \"\" , invalid = True ) value = value . strip () return ParsedDirective ( line , next_index , directive . split ( \" \" ), value )","title":"_parse_directive()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._parsed_values_to_sections","text":"Source code in griffe/docstrings/rst.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def _parsed_values_to_sections ( parsed_values : ParsedValues ) -> list [ DocstringSection ]: text = \" \\n \" . join ( _strip_blank_lines ( parsed_values . description )) result = [ DocstringSection ( DocstringSectionKind . text , text )] if parsed_values . parameters : param_values = list ( parsed_values . parameters . values ()) result . append ( DocstringSection ( DocstringSectionKind . parameters , param_values )) if parsed_values . attributes : attribute_values = list ( parsed_values . attributes . values ()) result . append ( DocstringSection ( DocstringSectionKind . attributes , attribute_values )) if parsed_values . return_value is not None : result . append ( DocstringSection ( DocstringSectionKind . returns , parsed_values . return_value )) if parsed_values . exceptions : result . append ( DocstringSection ( DocstringSectionKind . raises , parsed_values . exceptions )) return result","title":"_parsed_values_to_sections()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_attribute","text":"Parse an attribute value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def _read_attribute ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an attribute value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index annotation : str | Name | Expression | None = None # Annotation precedence: # - \"vartype\" directive type # - annotation in the parent # - none parsed_attribute_type = parsed_values . attribute_types . get ( name ) if parsed_attribute_type is not None : annotation = parsed_attribute_type else : # try to use the annotation from the parent with suppress ( AttributeError , KeyError ): annotation = docstring . parent . attributes [ name ] . annotation # type: ignore[union-attr] if name in parsed_values . attributes : _warn ( docstring , 0 , f \"Duplicate attribute entry for ' { name } '\" ) else : parsed_values . attributes [ name ] = DocstringAttribute ( name = name , annotation = annotation , description = parsed_directive . value , ) return parsed_directive . next_index","title":"_read_attribute()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_attribute_type","text":"Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def _read_attribute_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index attribute_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : attribute_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get attribute name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . attribute_types [ attribute_name ] = attribute_type attribute = parsed_values . attributes . get ( attribute_name ) if attribute is not None : if attribute . annotation is None : attribute . annotation = attribute_type else : _warn ( docstring , 0 , f \"Duplicate attribute information for ' { attribute_name } '\" ) return parsed_directive . next_index","title":"_read_attribute_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_exception","text":"Parse an exception value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 A tuple containing a DocstringSection (or None ) and the index at which to continue parsing. Source code in griffe/docstrings/rst.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def _read_exception ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an exception value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: A tuple containing a `DocstringSection` (or `None`) and the index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index if len ( parsed_directive . directive_parts ) == 2 : ex_type = parsed_directive . directive_parts [ 1 ] parsed_values . exceptions . append ( DocstringRaise ( annotation = ex_type , description = parsed_directive . value )) else : _warn ( docstring , 0 , f \"Failed to parse exception directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index","title":"_read_exception()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_parameter","text":"Parse a parameter value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def _read_parameter ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index directive_type = None if len ( parsed_directive . directive_parts ) == 2 : # no type info name = parsed_directive . directive_parts [ 1 ] elif len ( parsed_directive . directive_parts ) == 3 : directive_type = parsed_directive . directive_parts [ 1 ] name = parsed_directive . directive_parts [ 2 ] else : _warn ( docstring , 0 , f \"Failed to parse field directive from ' { parsed_directive . line } '\" ) return parsed_directive . next_index if name in parsed_values . parameters : _warn ( docstring , 0 , f \"Duplicate parameter entry for ' { name } '\" ) return parsed_directive . next_index annotation = _determine_param_annotation ( docstring , name , directive_type , parsed_values ) default = _determine_param_default ( docstring , name ) parsed_values . parameters [ name ] = DocstringParameter ( name = name , annotation = annotation , description = parsed_directive . value , value = default , ) return parsed_directive . next_index","title":"_read_parameter()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_parameter_type","text":"Parse a parameter type. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def _read_parameter_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse a parameter type. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index param_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) if len ( parsed_directive . directive_parts ) == 2 : param_name = parsed_directive . directive_parts [ 1 ] else : _warn ( docstring , 0 , f \"Failed to get parameter name from ' { parsed_directive . line } '\" ) return parsed_directive . next_index parsed_values . param_types [ param_name ] = param_type param = parsed_values . parameters . get ( param_name ) if param is not None : if param . annotation is None : param . annotation = param_type else : _warn ( docstring , 0 , f \"Duplicate parameter information for ' { param_name } '\" ) return parsed_directive . next_index","title":"_read_parameter_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_return","text":"Parse an return value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def _read_return ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index # Annotation precedence: # - \"rtype\" directive type # - signature annotation # - None annotation : str | Name | Expression | None if parsed_values . return_type is not None : annotation = parsed_values . return_type else : try : annotation = docstring . parent . returns # type: ignore[union-attr] except AttributeError : _warn ( docstring , 0 , f \"No return type or annotation at ' { parsed_directive . line } '\" ) annotation = None # TODO: maybe support names parsed_values . return_value = DocstringReturn ( name = \"\" , annotation = annotation , description = parsed_directive . value ) return parsed_directive . next_index","title":"_read_return()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._read_return_type","text":"Parse an return type value. Parameters: docstring ( Docstring ) \u2013 The docstring. offset ( int ) \u2013 The line number to start at. Returns: int \u2013 Index at which to continue parsing. Source code in griffe/docstrings/rst.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def _read_return_type ( docstring : Docstring , offset : int , parsed_values : ParsedValues ) -> int : \"\"\" Parse an return type value. Parameters: docstring: The docstring. offset: The line number to start at. Returns: Index at which to continue parsing. \"\"\" parsed_directive = _parse_directive ( docstring , offset ) if parsed_directive . invalid : return parsed_directive . next_index return_type = _consolidate_descriptive_type ( parsed_directive . value . strip ()) parsed_values . return_type = return_type return_value = parsed_values . return_value if return_value is not None : return_value . annotation = return_type return parsed_directive . next_index","title":"_read_return_type()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst._strip_blank_lines","text":"Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines ( list [ str ] ) \u2013 Lines to be stripped. Returns: list [ str ] \u2013 A list with the same contents, with any blank lines at the start or end removed. Source code in griffe/docstrings/rst.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 def _strip_blank_lines ( lines : list [ str ]) -> list [ str ]: \"\"\"Remove lines with no text or only whitespace characters from the start and end of the list. Parameters: lines: Lines to be stripped. Returns: A list with the same contents, with any blank lines at the start or end removed. \"\"\" if not lines : return lines # remove blank lines from the start and end content_found = False initial_content = 0 final_content = 0 for index , line in enumerate ( lines ): if line == \"\" or line . isspace (): if not content_found : initial_content += 1 else : content_found = True final_content = index return lines [ initial_content : final_content + 1 ]","title":"_strip_blank_lines()"},{"location":"reference/griffe/docstrings/rst/#griffe.docstrings.rst.parse","text":"Parse an RST-styled docstring. Parameters: docstring ( Docstring ) \u2013 The docstring to parse. **options ( Any ) \u2013 Additional parsing options. Returns: list [ DocstringSection ] \u2013 A list of docstring sections. Source code in griffe/docstrings/rst.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def parse ( docstring : Docstring , ** options : Any ) -> list [ DocstringSection ]: \"\"\"Parse an RST-styled docstring. Parameters: docstring: The docstring to parse. **options: Additional parsing options. Returns: A list of docstring sections. \"\"\" parsed_values = ParsedValues () lines = docstring . lines curr_line_index = 0 while curr_line_index < len ( lines ): line = lines [ curr_line_index ] for field_type in field_types : if field_type . matches ( line ): # https://github.com/python/mypy/issues/5485 curr_line_index = field_type . reader ( docstring , curr_line_index , parsed_values ) # type: ignore[misc,operator] break else : parsed_values . description . append ( line ) curr_line_index += 1 return _parsed_values_to_sections ( parsed_values )","title":"parse()"},{"location":"reference/griffe/docstrings/utils/","text":"This module contains utilities for docstrings parsers. warning ( name ) \u00a4 Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore[union-attr] except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { ( docstring . lineno or 0 ) + offset } : { message } \" ) return warn","title":"utils"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.warning","text":"Create and return a warn function. Parameters: name ( str ) \u2013 The logger name. Returns: Callable [[ Docstring , int , str ], None] \u2013 A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Parameters of the returned function: docstring ( Docstring ) \u2013 The docstring object. offset ( int ) \u2013 The offset in the docstring lines. message ( str ) \u2013 The message to log. Source code in griffe/docstrings/utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def warning ( name : str ) -> Callable [[ Docstring , int , str ], None ]: \"\"\"Create and return a warn function. Parameters: name: The logger name. Returns: A function used to log parsing warnings. This function logs a warning message by prefixing it with the filepath and line number. Other parameters: Parameters of the returned function: docstring (Docstring): The docstring object. offset (int): The offset in the docstring lines. message (str): The message to log. \"\"\" logger = get_logger ( name ) def warn ( docstring : Docstring , offset : int , message : str ) -> None : # noqa: WPS430 try : prefix = docstring . parent . relative_filepath # type: ignore[union-attr] except AttributeError : prefix = \"<module>\" logger . warning ( f \" { prefix } : { ( docstring . lineno or 0 ) + offset } : { message } \" ) return warn","title":"warning()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}