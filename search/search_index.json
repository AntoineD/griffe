{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"griffe \u00a4 Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. Requirements \u00a4 griffe requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12 Installation \u00a4 With pip : python3.6 -m pip install griffe With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 griffe","title":"Overview"},{"location":"#griffe","text":"Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.","title":"griffe"},{"location":"#requirements","text":"griffe requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install griffe With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 griffe","title":"Installation"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.1.0 - 2021-09-09 \u00a4 Compare with first commit Features \u00a4 Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#010-2021-09-09","text":"Compare with first commit","title":"0.1.0 - 2021-09-09"},{"location":"changelog/#features","text":"Add initial code ( 8cbdf7a by Timoth\u00e9e Mazzucotelli). Generate project from copier-pdm template ( 7ea73ad by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd griffe make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run griffe [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build griffe . Thank you! python | pdm | copier-pdm Direct dependencies \u00a4 -e | autoflake | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | toml | wps-light Indirect dependencies \u00a4 ansimarkup | appdirs | astor | astunparse | atomicwrites | attrs | bandit | click | colorama | coverage | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | regex | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | typed-ast | typing-extensions | watchdog | wheel | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build griffe . Thank you! python | pdm | copier-pdm","title":"Credits"},{"location":"credits/#direct-dependencies","text":"-e | autoflake | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | toml | wps-light","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | appdirs | astor | astunparse | atomicwrites | attrs | bandit | click | colorama | coverage | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | importlib-metadata | iniconfig | jinja2 | markdown | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mypy-extensions | packaging | pathspec | pbr | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | regex | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | typed-ast | typing-extensions | watchdog | wheel | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2021, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"griffe __init__.py __main__.py cli.py collections.py dataclasses.py encoders.py extensions __init__.py base.py loader.py logger.py visitor.py","title":"SUMMARY"},{"location":"reference/__init__/","text":"griffe package. Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.","title":"__init__.py"},{"location":"reference/__main__/","text":"Entry-point module, in case you use python -m griffe . Why does this file exist, and why __main__ ? For more info, read: https://www.python.org/dev/peps/pep-0338/ https://docs.python.org/3/using/cmdline.html#cmdoption-m","title":"__main__.py"},{"location":"reference/cli/","text":"Module that contains the command line application. get_parser () \u00a4 Return the program argument parser. Returns: Type Description argparse.ArgumentParser The argument parser for the program. Source code in griffe/cli.py def get_parser () -> argparse . ArgumentParser : \"\"\" Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser main ( args = None ) \u00a4 Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: Name Type Description Default args list[str] | None Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in griffe/cli.py def main ( args : list [ str ] | None = None ) -> int : \"\"\" Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) # type: ignore extensions = Extensions () loader = GriffeLoader ( extensions = extensions ) modules = [] for package in opts . packages : modules . append ( loader . load_module ( package )) serialized = json . dumps ( modules , cls = Encoder , indent = 2 , full = True ) print ( serialized ) return 0","title":"cli.py"},{"location":"reference/cli/#griffe.cli.get_parser","text":"Return the program argument parser. Returns: Type Description argparse.ArgumentParser The argument parser for the program. Source code in griffe/cli.py def get_parser () -> argparse . ArgumentParser : \"\"\" Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"griffe\" ) parser . add_argument ( \"packages\" , metavar = \"PACKAGE\" , nargs = \"+\" , help = \"Packages to find and parse.\" ) return parser","title":"get_parser()"},{"location":"reference/cli/#griffe.cli.main","text":"Run the main program. This function is executed when you type griffe or python -m griffe . Parameters: Name Type Description Default args list[str] | None Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in griffe/cli.py def main ( args : list [ str ] | None = None ) -> int : \"\"\" Run the main program. This function is executed when you type `griffe` or `python -m griffe`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts : argparse . Namespace = parser . parse_args ( args ) # type: ignore extensions = Extensions () loader = GriffeLoader ( extensions = extensions ) modules = [] for package in opts . packages : modules . append ( loader . load_module ( package )) serialized = json . dumps ( modules , cls = Encoder , indent = 2 , full = True ) print ( serialized ) return 0","title":"main()"},{"location":"reference/collections/","text":"This module stores collections of data, useful during parsing. lines_collection : dict \u00a4 A simple dictionary containing lines of modules. It will probably be made more powerful later.","title":"collections.py"},{"location":"reference/collections/#griffe.collections.lines_collection","text":"A simple dictionary containing lines of modules. It will probably be made more powerful later.","title":"lines_collection"},{"location":"reference/dataclasses/","text":"This module contains the data classes that represent Python objects. The different objects are modules, classes, functions, and data (variables like module/class/instance attributes). Class ( Object ) \u00a4 The class representing a Python class. Data ( Object ) \u00a4 The class representing a Python module/class/instance attribute. Function ( Object ) \u00a4 The class representing a Python function. Kind ( Enum ) \u00a4 Enumeration of the different objects kinds. Attributes: Name Type Description MODULE str The module kind. CLASS str The class kind. FUNCTION str The function kind. DATA str The data kind. Module ( Object ) \u00a4 The class representing a Python module. filepath : Path | None property readonly \u00a4 Get the file path of this module. Returns: Type Description Path | None The module's file path. is_folder : bool property readonly \u00a4 Tell if this module is a non-importable folder. Returns: Type Description bool True or False. is_init_module : bool property readonly \u00a4 Tell if this module is an __init__.py module. Returns: Type Description bool True or False. is_namespace_package : bool property readonly \u00a4 Tell if this module is a namespace package (top folder, no __init__.py ). Returns: Type Description bool True or False. is_namespace_subpackage : bool property readonly \u00a4 Tell if this module is a namespace subpackage. Returns: Type Description bool True or False. is_package : bool property readonly \u00a4 Tell if this module is a package (top module). Returns: Type Description bool True or False. is_subpackage : bool property readonly \u00a4 Tell if this module is a subpackage. Returns: Type Description bool True or False. __init__ ( self , * args , * , filepath = None , ** kwargs ) special \u00a4 Initialize the module. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () filepath Path | None The module file path. It can be null for namespace packages or non-importable folders. None **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , filepath : Path | None = None , ** kwargs ) -> None : \"\"\"Initialize the module. Arguments: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path. It can be null for namespace packages or non-importable folders. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath = filepath as_dict ( self , full = False ) \u00a4 Return this module's data as a dictionary. Parameters: Name Type Description Default full bool Whether to return full info, or just base info. False Returns: Type Description dict A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , full : bool = False ) -> dict : \"\"\"Return this module's data as a dictionary. Arguments: full: Whether to return full info, or just base info. Returns: A dictionary. \"\"\" base = super () . as_dict ( full = full ) base [ \"filepath\" ] = str ( self . filepath ) if self . filepath else None return base Object \u00a4 An abstract class representing a Python object. Attributes: Name Type Description kind Kind The object kind. name str The object name. lineno int | None The object starting line, or None for modules. Lines start at 1.. endlineno int | None The object ending line (inclusive), or None for modules.. parent Module | Class | None The object parent, or None if it is the top module. members dict[str, Module | Class | Function | Data] The object members. labels set[str] The object labels. filepath : Path | None property readonly \u00a4 Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Type Description Path | None A file path. module : Module property readonly \u00a4 Return the parent module of this object. Exceptions: Type Description ValueError When the object is not a module and does not have a parent. Returns: Type Description Module The parent module. path : str property readonly \u00a4 Return the dotted path / import path of this object. Returns: Type Description str A dotted path. __init__ ( self , name , lineno = None , endlineno = None ) special \u00a4 Initialize the object. Parameters: Name Type Description Default name str The object name, as declared in the code. required lineno int | None The object starting line, or None for modules. Lines start at 1. None endlineno int | None The object ending line (inclusive), or None for modules. None Source code in griffe/dataclasses.py def __init__ ( self , name : str , lineno : int | None = None , endlineno : int | None = None ) -> None : \"\"\"Initialize the object. Arguments: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | None = None self . members : dict [ str , Module | Class | Function | Data ] = {} self . labels : set [ str ] = set () as_dict ( self , full = False ) \u00a4 Return this object's data as a dictionary. Parameters: Name Type Description Default full bool Whether to return full info, or just base info. False Returns: Type Description dict A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , full : bool = False ) -> dict : \"\"\"Return this object's data as a dictionary. Arguments: full: Whether to return full info, or just base info. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , \"members\" : [ member . as_dict ( full ) for member in self . members . values ()], \"labels\" : self . labels , \"kind\" : self . kind , } if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if full : base . update ( { \"filepath\" : str ( self . filepath ), \"path\" : self . path , } ) return base","title":"dataclasses.py"},{"location":"reference/dataclasses/#griffe.dataclasses.Class","text":"The class representing a Python class.","title":"Class"},{"location":"reference/dataclasses/#griffe.dataclasses.Data","text":"The class representing a Python module/class/instance attribute.","title":"Data"},{"location":"reference/dataclasses/#griffe.dataclasses.Function","text":"The class representing a Python function.","title":"Function"},{"location":"reference/dataclasses/#griffe.dataclasses.Kind","text":"Enumeration of the different objects kinds. Attributes: Name Type Description MODULE str The module kind. CLASS str The class kind. FUNCTION str The function kind. DATA str The data kind.","title":"Kind"},{"location":"reference/dataclasses/#griffe.dataclasses.Module","text":"The class representing a Python module.","title":"Module"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.filepath","text":"Get the file path of this module. Returns: Type Description Path | None The module's file path.","title":"filepath"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_folder","text":"Tell if this module is a non-importable folder. Returns: Type Description bool True or False.","title":"is_folder"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_init_module","text":"Tell if this module is an __init__.py module. Returns: Type Description bool True or False.","title":"is_init_module"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_namespace_package","text":"Tell if this module is a namespace package (top folder, no __init__.py ). Returns: Type Description bool True or False.","title":"is_namespace_package"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_namespace_subpackage","text":"Tell if this module is a namespace subpackage. Returns: Type Description bool True or False.","title":"is_namespace_subpackage"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_package","text":"Tell if this module is a package (top module). Returns: Type Description bool True or False.","title":"is_package"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.is_subpackage","text":"Tell if this module is a subpackage. Returns: Type Description bool True or False.","title":"is_subpackage"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.__init__","text":"Initialize the module. Parameters: Name Type Description Default *args See griffe.dataclasses.Object . () filepath Path | None The module file path. It can be null for namespace packages or non-importable folders. None **kwargs See griffe.dataclasses.Object . {} Source code in griffe/dataclasses.py def __init__ ( self , * args , filepath : Path | None = None , ** kwargs ) -> None : \"\"\"Initialize the module. Arguments: *args: See [`griffe.dataclasses.Object`][]. filepath: The module file path. It can be null for namespace packages or non-importable folders. **kwargs: See [`griffe.dataclasses.Object`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _filepath = filepath","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Module.as_dict","text":"Return this module's data as a dictionary. Parameters: Name Type Description Default full bool Whether to return full info, or just base info. False Returns: Type Description dict A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , full : bool = False ) -> dict : \"\"\"Return this module's data as a dictionary. Arguments: full: Whether to return full info, or just base info. Returns: A dictionary. \"\"\" base = super () . as_dict ( full = full ) base [ \"filepath\" ] = str ( self . filepath ) if self . filepath else None return base","title":"as_dict()"},{"location":"reference/dataclasses/#griffe.dataclasses.Object","text":"An abstract class representing a Python object. Attributes: Name Type Description kind Kind The object kind. name str The object name. lineno int | None The object starting line, or None for modules. Lines start at 1.. endlineno int | None The object ending line (inclusive), or None for modules.. parent Module | Class | None The object parent, or None if it is the top module. members dict[str, Module | Class | Function | Data] The object members. labels set[str] The object labels.","title":"Object"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.filepath","text":"Return the file path where this object was defined. It should never return None for non-module objects, as they should always have a parent module. If not, self.module would trigger a ValueError anyway. If it does return None, it means the tree was not built correctly. Returns: Type Description Path | None A file path.","title":"filepath"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.module","text":"Return the parent module of this object. Exceptions: Type Description ValueError When the object is not a module and does not have a parent. Returns: Type Description Module The parent module.","title":"module"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.path","text":"Return the dotted path / import path of this object. Returns: Type Description str A dotted path.","title":"path"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.__init__","text":"Initialize the object. Parameters: Name Type Description Default name str The object name, as declared in the code. required lineno int | None The object starting line, or None for modules. Lines start at 1. None endlineno int | None The object ending line (inclusive), or None for modules. None Source code in griffe/dataclasses.py def __init__ ( self , name : str , lineno : int | None = None , endlineno : int | None = None ) -> None : \"\"\"Initialize the object. Arguments: name: The object name, as declared in the code. lineno: The object starting line, or None for modules. Lines start at 1. endlineno: The object ending line (inclusive), or None for modules. \"\"\" self . name : str = name self . lineno : int | None = lineno self . endlineno : int | None = endlineno self . parent : Module | Class | None = None self . members : dict [ str , Module | Class | Function | Data ] = {} self . labels : set [ str ] = set ()","title":"__init__()"},{"location":"reference/dataclasses/#griffe.dataclasses.Object.as_dict","text":"Return this object's data as a dictionary. Parameters: Name Type Description Default full bool Whether to return full info, or just base info. False Returns: Type Description dict A dictionary. Source code in griffe/dataclasses.py def as_dict ( self , full : bool = False ) -> dict : \"\"\"Return this object's data as a dictionary. Arguments: full: Whether to return full info, or just base info. Returns: A dictionary. \"\"\" base = { \"name\" : self . name , \"members\" : [ member . as_dict ( full ) for member in self . members . values ()], \"labels\" : self . labels , \"kind\" : self . kind , } if self . lineno : base [ \"lineno\" ] = self . lineno if self . endlineno : base [ \"endlineno\" ] = self . endlineno if full : base . update ( { \"filepath\" : str ( self . filepath ), \"path\" : self . path , } ) return base","title":"as_dict()"},{"location":"reference/encoders/","text":"This module contains data encoders/serializers and decoders/deserializers. The available formats are: JSON: see the encoder and decoder . Encoder ( JSONEncoder ) \u00a4 JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json . dumps ( ... , cls = Encoder , full = True , ** kwargs ) __init__ ( self , * args , * , full = False , ** kwargs ) special \u00a4 Initialize the encoder. Parameters: Name Type Description Default *args See json.JSONEncoder . () full Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. False **kwargs See json.JSONEncoder . {} Source code in griffe/encoders.py def __init__ ( self , * args , full = False , ** kwargs ) -> None : \"\"\"Initialize the encoder. Arguments: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full = full default ( self , obj ) \u00a4 Return a serializable representation of the given object. Parameters: Name Type Description Default obj Any The object to serialize. required Returns: Type Description Any A serializable representation. Source code in griffe/encoders.py def default ( self , obj : Any ) -> Any : \"\"\"Return a serializable representation of the given object. Arguments: obj: The object to serialize. Returns: A serializable representation. \"\"\" if hasattr ( obj , \"as_dict\" ): return obj . as_dict ( self . full ) if isinstance ( obj , Kind ): return obj . value if isinstance ( obj , set ): return list ( obj ) return super () . default ( obj ) decoder ( obj_dict ) \u00a4 Decode dictionaries as data classes. The [ json.loads ] method walks the tree from bottom to top. Parameters: Name Type Description Default obj_dict The dictionary to decode. required Returns: Type Description Module | Class | Function | Data An instance of a data class. Source code in griffe/encoders.py def decoder ( obj_dict ) -> Module | Class | Function | Data : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`] method walks the tree from bottom to top. Arguments: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( obj_dict [ \"name\" ], obj_dict [ \"lineno\" ], obj_dict [ \"endlineno\" ], Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( obj_dict [ \"name\" ], obj_dict [ \"lineno\" ], obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( obj_dict [ \"name\" ], obj_dict [ \"lineno\" ], obj_dict [ \"endlineno\" ]) elif kind == Kind . DATA : return Data ( obj_dict [ \"name\" ], obj_dict [ \"lineno\" ], obj_dict [ \"endlineno\" ]) return obj_dict","title":"encoders.py"},{"location":"reference/encoders/#griffe.encoders.Encoder","text":"JSON encoder. JSON encoders are not used directly, but through the json.dump or json.dumps methods. Examples: >>> import json >>> from griffe.encoders import Encoder >>> json . dumps ( ... , cls = Encoder , full = True , ** kwargs )","title":"Encoder"},{"location":"reference/encoders/#griffe.encoders.Encoder.__init__","text":"Initialize the encoder. Parameters: Name Type Description Default *args See json.JSONEncoder . () full Whether to dump full data or base data. If you plan to reload the data in Python memory using the decoder , you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. False **kwargs See json.JSONEncoder . {} Source code in griffe/encoders.py def __init__ ( self , * args , full = False , ** kwargs ) -> None : \"\"\"Initialize the encoder. Arguments: *args: See [`json.JSONEncoder`][]. full: Whether to dump full data or base data. If you plan to reload the data in Python memory using the [decoder][griffe.encoders.decoder], you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data. **kwargs: See [`json.JSONEncoder`][]. \"\"\" super () . __init__ ( * args , ** kwargs ) self . full = full","title":"__init__()"},{"location":"reference/encoders/#griffe.encoders.Encoder.default","text":"Return a serializable representation of the given object. Parameters: Name Type Description Default obj Any The object to serialize. required Returns: Type Description Any A serializable representation. Source code in griffe/encoders.py def default ( self , obj : Any ) -> Any : \"\"\"Return a serializable representation of the given object. Arguments: obj: The object to serialize. Returns: A serializable representation. \"\"\" if hasattr ( obj , \"as_dict\" ): return obj . as_dict ( self . full ) if isinstance ( obj , Kind ): return obj . value if isinstance ( obj , set ): return list ( obj ) return super () . default ( obj )","title":"default()"},{"location":"reference/encoders/#griffe.encoders.decoder","text":"Decode dictionaries as data classes. The [ json.loads ] method walks the tree from bottom to top. Parameters: Name Type Description Default obj_dict The dictionary to decode. required Returns: Type Description Module | Class | Function | Data An instance of a data class. Source code in griffe/encoders.py def decoder ( obj_dict ) -> Module | Class | Function | Data : # noqa: WPS231 \"\"\"Decode dictionaries as data classes. The [`json.loads`] method walks the tree from bottom to top. Arguments: obj_dict: The dictionary to decode. Returns: An instance of a data class. \"\"\" if \"kind\" in obj_dict : kind = Kind ( obj_dict [ \"kind\" ]) if kind == Kind . MODULE : module = Module ( obj_dict [ \"name\" ], obj_dict [ \"lineno\" ], obj_dict [ \"endlineno\" ], Path ( obj_dict [ \"filepath\" ])) for module_member in obj_dict . get ( \"members\" , []): module [ module_member . name ] = module_member return module elif kind == Kind . CLASS : class_ = Class ( obj_dict [ \"name\" ], obj_dict [ \"lineno\" ], obj_dict [ \"endlineno\" ]) for class_member in obj_dict . get ( \"members\" , []): class_ [ class_member . name ] = class_member return class_ elif kind == Kind . FUNCTION : return Function ( obj_dict [ \"name\" ], obj_dict [ \"lineno\" ], obj_dict [ \"endlineno\" ]) elif kind == Kind . DATA : return Data ( obj_dict [ \"name\" ], obj_dict [ \"lineno\" ], obj_dict [ \"endlineno\" ]) return obj_dict","title":"decoder()"},{"location":"reference/loader/","text":"This module contains the code allowing to find module and load their data. This is the entrypoint to use griffe programatically: from griffe.loader import GriffeLoader griffe = GriffeLoader () fastapi = griffe . load_module ( \"fastapi\" ) You can pass extensions to the loader to augment its capacities: from griffe.loader import GriffeLoader from griffe.extensions import Extension , Extensions # import extensions from some.package import TheirExtension # or define your own class ClassStartsAtOddLineNumberExtension ( Extension ): def visit_ClassDef ( self , node ) -> None : if node . lineno % 2 == 1 : self . visitor . current . labels . add ( \"starts at odd line number\" ) extensions = Extensions () extensions . add_pre_visitor ( TheirExtension ) extensions . add_post_visitor ( ClassStartsAtOddLineNumberExtension ) griffe = GriffeLoader ( extensions = extensions ) fastapi = griffe . load_module ( \"fastapi\" ) GriffeLoader \u00a4 The griffe loader, allowing to load data from modules. Attributes: Name Type Description extensions The extensions to use. __init__ ( self , extensions = None ) special \u00a4 Initialize the loader. Parameters: Name Type Description Default extensions Extensions | None The extensions to use. None Source code in griffe/loader.py def __init__ ( self , extensions : Extensions | None = None ) -> None : \"\"\"Initialize the loader. Arguments: extensions: The extensions to use. \"\"\" self . extensions = extensions or Extensions () load_module ( self , module_name , recursive = True ) \u00a4 Load a module. Parameters: Name Type Description Default module_name str The module name. required recursive bool Whether to recurse on the submodules. True Returns: Type Description Module A module. Source code in griffe/loader.py def load_module ( self , module_name : str , recursive : bool = True ) -> Module : \"\"\"Load a module. Arguments: module_name: The module name. recursive: Whether to recurse on the submodules. Returns: A module. \"\"\" module_path = find_module ( module_name ) return self . _load_module_path ( module_name , module_path , recursive = recursive ) find_module ( module_name , search_paths = None ) \u00a4 Find a module in a given list of paths or in sys.path . Parameters: Name Type Description Default module_name str The module name. required search_paths list[str] The paths to seach into. None Exceptions: Type Description ImportError When the module cannot be found. Returns: Type Description Path The module file path. Source code in griffe/loader.py def find_module ( module_name : str , search_paths : list [ str ] = None ) -> Path : \"\"\"Find a module in a given list of paths or in `sys.path`. Arguments: module_name: The module name. search_paths: The paths to seach into. Raises: ImportError: When the module cannot be found. Returns: The module file path. \"\"\" if search_paths is None : search_paths = sys . path # optimization: pre-compute Paths to relieve CPU when joining paths search = [ Path ( path ) for path in search_paths ] parts = module_name . split ( \".\" ) filenames = [ Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), ] for path in search : for choice in filenames : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): return abs_path raise ImportError ( module_name ) iter_submodules ( path ) \u00a4 Iterate on a module's submodules, if any. Parameters: Name Type Description Default path The module path. required Yields This generator yields tuples containing the parts of the submodule name as well as its filepath. Source code in griffe/loader.py def iter_submodules ( path ) -> Iterator [ tuple [ list [ str ], Path ]]: # noqa: WPS234 \"\"\"Iterate on a module's submodules, if any. Arguments: path: The module path. Yields: This generator yields tuples containing the parts of the submodule name as well as its filepath. \"\"\" if path . name == \"__init__.py\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix == \".py\" : return for subpath in path . rglob ( \"*.py\" ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . name == \"__init__.py\" : # optimization: since it's a relative path, # if it has only one part and is named __init__.py, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath else : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath","title":"loader.py"},{"location":"reference/loader/#griffe.loader.GriffeLoader","text":"The griffe loader, allowing to load data from modules. Attributes: Name Type Description extensions The extensions to use.","title":"GriffeLoader"},{"location":"reference/loader/#griffe.loader.GriffeLoader.__init__","text":"Initialize the loader. Parameters: Name Type Description Default extensions Extensions | None The extensions to use. None Source code in griffe/loader.py def __init__ ( self , extensions : Extensions | None = None ) -> None : \"\"\"Initialize the loader. Arguments: extensions: The extensions to use. \"\"\" self . extensions = extensions or Extensions ()","title":"__init__()"},{"location":"reference/loader/#griffe.loader.GriffeLoader.load_module","text":"Load a module. Parameters: Name Type Description Default module_name str The module name. required recursive bool Whether to recurse on the submodules. True Returns: Type Description Module A module. Source code in griffe/loader.py def load_module ( self , module_name : str , recursive : bool = True ) -> Module : \"\"\"Load a module. Arguments: module_name: The module name. recursive: Whether to recurse on the submodules. Returns: A module. \"\"\" module_path = find_module ( module_name ) return self . _load_module_path ( module_name , module_path , recursive = recursive )","title":"load_module()"},{"location":"reference/loader/#griffe.loader.find_module","text":"Find a module in a given list of paths or in sys.path . Parameters: Name Type Description Default module_name str The module name. required search_paths list[str] The paths to seach into. None Exceptions: Type Description ImportError When the module cannot be found. Returns: Type Description Path The module file path. Source code in griffe/loader.py def find_module ( module_name : str , search_paths : list [ str ] = None ) -> Path : \"\"\"Find a module in a given list of paths or in `sys.path`. Arguments: module_name: The module name. search_paths: The paths to seach into. Raises: ImportError: When the module cannot be found. Returns: The module file path. \"\"\" if search_paths is None : search_paths = sys . path # optimization: pre-compute Paths to relieve CPU when joining paths search = [ Path ( path ) for path in search_paths ] parts = module_name . split ( \".\" ) filenames = [ Path ( * parts , \"__init__.py\" ), Path ( * parts [: - 1 ], f \" { parts [ - 1 ] } .py\" ), ] for path in search : for choice in filenames : abs_path = path / choice # optimization: just check if the file exists, # not if it's an actual file if abs_path . exists (): return abs_path raise ImportError ( module_name )","title":"find_module()"},{"location":"reference/loader/#griffe.loader.iter_submodules","text":"Iterate on a module's submodules, if any. Parameters: Name Type Description Default path The module path. required Yields This generator yields tuples containing the parts of the submodule name as well as its filepath. Source code in griffe/loader.py def iter_submodules ( path ) -> Iterator [ tuple [ list [ str ], Path ]]: # noqa: WPS234 \"\"\"Iterate on a module's submodules, if any. Arguments: path: The module path. Yields: This generator yields tuples containing the parts of the submodule name as well as its filepath. \"\"\" if path . name == \"__init__.py\" : path = path . parent # optimization: just check if the file name ends with .py # (to distinguish it from a directory), # not if it's an actual file elif path . suffix == \".py\" : return for subpath in path . rglob ( \"*.py\" ): rel_subpath = subpath . relative_to ( path ) if rel_subpath . name == \"__init__.py\" : # optimization: since it's a relative path, # if it has only one part and is named __init__.py, # it means it's the starting path # (no need to compare it against starting path) if len ( rel_subpath . parts ) == 1 : continue yield rel_subpath . parts [: - 1 ], subpath else : yield rel_subpath . with_suffix ( \"\" ) . parts , subpath","title":"iter_submodules()"},{"location":"reference/logger/","text":"This module contains logging utilities. We provide the get_logger function so dependant libraries can patch it as they see fit. For example, to fit in the MkDocs logging configuration and prefix each log message with the module name: import logging from griffe import logger as griffe_logger class LoggerAdapter ( logging . LoggerAdapter ): def __init__ ( self , prefix , logger ): super () . __init__ ( logger , {}) self . prefix = prefix def process ( self , msg , kwargs ): return f \" { self . prefix } : { msg } \" , kwargs def get_logger ( name ): logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) return LoggerAdapter ( name , logger ) griffe_logger . get_logger = get_logger get_logger ( name ) \u00a4 Create and return a new logger instance. Parameters: Name Type Description Default name str The logger name. required Returns: Type Description Logger The logger. Source code in griffe/logger.py def get_logger ( name : str ) -> logging . Logger : \"\"\"Create and return a new logger instance. Arguments: name: The logger name. Returns: The logger. \"\"\" return logging . getLogger ( name )","title":"logger.py"},{"location":"reference/logger/#griffe.logger.get_logger","text":"Create and return a new logger instance. Parameters: Name Type Description Default name str The logger name. required Returns: Type Description Logger The logger. Source code in griffe/logger.py def get_logger ( name : str ) -> logging . Logger : \"\"\"Create and return a new logger instance. Arguments: name: The logger name. Returns: The logger. \"\"\" return logging . getLogger ( name )","title":"get_logger()"},{"location":"reference/visitor/","text":"Code parsing and data extraction utilies. This module exposes a public function, visit() , which creates a new Module instance, parses the module code using ast.parse() , and populates the module and its members, recursively, by using a custom NodeVisitor class. We do not publicly expose the custom node visitor class to prevent usage mistakes: its instances are disposable as they maintain an internal state while walking the Abstract Syntax Tree, and therefore must not be reused. We make this transparent to the developer through visit() function. Node \u00a4 This class is a wrapper around AST nodes . It allows each node of the AST to know to its parent and siblings. Attributes: Name Type Description node ast.AST The actual AST node. parent Node The parent wrapped node (or a reference to self for the root). children list[Node] The children wrapped node. __init__ ( self , ast_node , parent = None ) special \u00a4 Initialize the node. Parameters: Name Type Description Default ast_node ast.AST The actual AST node. required parent Node | None The parent wrapped node. None Source code in griffe/visitor.py def __init__ ( self , ast_node : ast . AST , parent : Node | None = None ) -> None : \"\"\"Initialize the node. Arguments: ast_node: The actual AST node. parent: The parent wrapped node. \"\"\" if parent is None : parent = self self . node : ast . AST = ast_node self . parent : Node = parent self . children : list [ Node ] = [] visit ( module_name , filepath , code , extensions = None ) \u00a4 Parse and visit a module file. Parameters: Name Type Description Default module_name str The module name (as when importing [from] it). required filepath Path The module file path. required code str The module contents. required extensions Extensions | None The extensions to use when visiting the AST. None Returns: Type Description Module The module, with its members populated. Source code in griffe/visitor.py def visit ( module_name : str , filepath : Path , code : str , extensions : Extensions | None = None , ) -> Module : \"\"\"Parse and visit a module file. Arguments: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. Returns: The module, with its members populated. \"\"\" module = Module ( module_name , filepath = filepath ) # instantiating the visitor side-effects the module, # populating its members _Visitor ( module , ast . parse ( code ), extensions or Extensions ()) return module","title":"visitor.py"},{"location":"reference/visitor/#griffe.visitor.Node","text":"This class is a wrapper around AST nodes . It allows each node of the AST to know to its parent and siblings. Attributes: Name Type Description node ast.AST The actual AST node. parent Node The parent wrapped node (or a reference to self for the root). children list[Node] The children wrapped node.","title":"Node"},{"location":"reference/visitor/#griffe.visitor.Node.__init__","text":"Initialize the node. Parameters: Name Type Description Default ast_node ast.AST The actual AST node. required parent Node | None The parent wrapped node. None Source code in griffe/visitor.py def __init__ ( self , ast_node : ast . AST , parent : Node | None = None ) -> None : \"\"\"Initialize the node. Arguments: ast_node: The actual AST node. parent: The parent wrapped node. \"\"\" if parent is None : parent = self self . node : ast . AST = ast_node self . parent : Node = parent self . children : list [ Node ] = []","title":"__init__()"},{"location":"reference/visitor/#griffe.visitor.visit","text":"Parse and visit a module file. Parameters: Name Type Description Default module_name str The module name (as when importing [from] it). required filepath Path The module file path. required code str The module contents. required extensions Extensions | None The extensions to use when visiting the AST. None Returns: Type Description Module The module, with its members populated. Source code in griffe/visitor.py def visit ( module_name : str , filepath : Path , code : str , extensions : Extensions | None = None , ) -> Module : \"\"\"Parse and visit a module file. Arguments: module_name: The module name (as when importing [from] it). filepath: The module file path. code: The module contents. extensions: The extensions to use when visiting the AST. Returns: The module, with its members populated. \"\"\" module = Module ( module_name , filepath = filepath ) # instantiating the visitor side-effects the module, # populating its members _Visitor ( module , ast . parse ( code ), extensions or Extensions ()) return module","title":"visit()"},{"location":"reference/extensions/__init__/","text":"This module is the public interface to import elements from the base.","title":"__init__.py"},{"location":"reference/extensions/base/","text":"This module contains the base classes for dealing with extensions. Extension ( NodeVisitor ) \u00a4 The node visitor extension base class, to inherit from. __init__ ( self , main_visitor ) special \u00a4 Initialize the visitor extension. Parameters: Name Type Description Default main_visitor ast.NodeVisitor The main visitor. required Source code in griffe/extensions/base.py def __init__ ( self , main_visitor : ast . NodeVisitor ) -> None : \"\"\"Initialize the visitor extension. Arguments: main_visitor: The main visitor. \"\"\" super () . __init__ () self . visitor = main_visitor Extensions \u00a4 This class helps iterating on extensions that should run at different times. when_children_visit_starts : list [ Extension ] property readonly \u00a4 Return the visitors that run when the children visit starts. Returns: Type Description list[Extension] Visitors. when_children_visit_stops : list [ Extension ] property readonly \u00a4 Return the visitors that run when the children visit stops. Returns: Type Description list[Extension] Visitors. when_visit_starts : list [ Extension ] property readonly \u00a4 Return the visitors that run when the visit starts. Returns: Type Description list[Extension] Visitors. when_visit_stops : list [ Extension ] property readonly \u00a4 Return the visitors that run when the visit stops. Returns: Type Description list[Extension] Visitors. __init__ ( self ) special \u00a4 Initialize the extensions container. Source code in griffe/extensions/base.py def __init__ ( self ) -> None : \"\"\"Initialize the extensions container.\"\"\" self . _classes : list [ Type [ Extension ]] = [] self . _instances : dict [ When , list [ Extension ]] = {} add ( self , * extensions ) \u00a4 Add visitor extensions to this container. Parameters: Name Type Description Default *extensions Type[Extension] The extensions to add. () Source code in griffe/extensions/base.py def add ( self , * extensions : Type [ Extension ]) -> None : \"\"\"Add visitor extensions to this container. Arguments: *extensions: The extensions to add. \"\"\" self . _classes . extend ( extensions ) instantiate ( self , main_visitor ) \u00a4 Clear and instantiate the visitor classes. Parameters: Name Type Description Default main_visitor ast.NodeVisitor The main visitor, leading the visit. required Returns: Type Description Extensions Self, conveniently. Source code in griffe/extensions/base.py def instantiate ( self , main_visitor : ast . NodeVisitor ) -> Extensions : \"\"\"Clear and instantiate the visitor classes. Arguments: main_visitor: The main visitor, leading the visit. Returns: Self, conveniently. \"\"\" # clear instances for when in When : self . _instances [ when ] = [] # create instances for visitor_class in self . _classes : self . _instances [ visitor_class . when ] . append ( visitor_class ( main_visitor )) return self when ( self , when ) \u00a4 Return the visitors that run at the given time. Parameters: Name Type Description Default when When The selected time. required Returns: Type Description list[Extension] Visitors. Source code in griffe/extensions/base.py def when ( self , when : When ) -> list [ Extension ]: \"\"\"Return the visitors that run at the given time. Arguments: when: The selected time. Returns: Visitors. \"\"\" return self . _instances [ when ] When ( Enum ) \u00a4 This enumeration contains the different times at which an extension is used. Attributes: Name Type Description visit_starts int For each node, before starting the visit. children_visit_starts int For each node, after the visit has started, and before starting to visit children. children_visit_stops int For each node, after the children have been visited, and before finishing the visit. visit_stops int For each node, after finishing the visit.","title":"base.py"},{"location":"reference/extensions/base/#griffe.extensions.base.Extension","text":"The node visitor extension base class, to inherit from.","title":"Extension"},{"location":"reference/extensions/base/#griffe.extensions.base.Extension.__init__","text":"Initialize the visitor extension. Parameters: Name Type Description Default main_visitor ast.NodeVisitor The main visitor. required Source code in griffe/extensions/base.py def __init__ ( self , main_visitor : ast . NodeVisitor ) -> None : \"\"\"Initialize the visitor extension. Arguments: main_visitor: The main visitor. \"\"\" super () . __init__ () self . visitor = main_visitor","title":"__init__()"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions","text":"This class helps iterating on extensions that should run at different times.","title":"Extensions"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when_children_visit_starts","text":"Return the visitors that run when the children visit starts. Returns: Type Description list[Extension] Visitors.","title":"when_children_visit_starts"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when_children_visit_stops","text":"Return the visitors that run when the children visit stops. Returns: Type Description list[Extension] Visitors.","title":"when_children_visit_stops"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when_visit_starts","text":"Return the visitors that run when the visit starts. Returns: Type Description list[Extension] Visitors.","title":"when_visit_starts"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when_visit_stops","text":"Return the visitors that run when the visit stops. Returns: Type Description list[Extension] Visitors.","title":"when_visit_stops"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.__init__","text":"Initialize the extensions container. Source code in griffe/extensions/base.py def __init__ ( self ) -> None : \"\"\"Initialize the extensions container.\"\"\" self . _classes : list [ Type [ Extension ]] = [] self . _instances : dict [ When , list [ Extension ]] = {}","title":"__init__()"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.add","text":"Add visitor extensions to this container. Parameters: Name Type Description Default *extensions Type[Extension] The extensions to add. () Source code in griffe/extensions/base.py def add ( self , * extensions : Type [ Extension ]) -> None : \"\"\"Add visitor extensions to this container. Arguments: *extensions: The extensions to add. \"\"\" self . _classes . extend ( extensions )","title":"add()"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.instantiate","text":"Clear and instantiate the visitor classes. Parameters: Name Type Description Default main_visitor ast.NodeVisitor The main visitor, leading the visit. required Returns: Type Description Extensions Self, conveniently. Source code in griffe/extensions/base.py def instantiate ( self , main_visitor : ast . NodeVisitor ) -> Extensions : \"\"\"Clear and instantiate the visitor classes. Arguments: main_visitor: The main visitor, leading the visit. Returns: Self, conveniently. \"\"\" # clear instances for when in When : self . _instances [ when ] = [] # create instances for visitor_class in self . _classes : self . _instances [ visitor_class . when ] . append ( visitor_class ( main_visitor )) return self","title":"instantiate()"},{"location":"reference/extensions/base/#griffe.extensions.base.Extensions.when","text":"Return the visitors that run at the given time. Parameters: Name Type Description Default when When The selected time. required Returns: Type Description list[Extension] Visitors. Source code in griffe/extensions/base.py def when ( self , when : When ) -> list [ Extension ]: \"\"\"Return the visitors that run at the given time. Arguments: when: The selected time. Returns: Visitors. \"\"\" return self . _instances [ when ]","title":"when()"},{"location":"reference/extensions/base/#griffe.extensions.base.When","text":"This enumeration contains the different times at which an extension is used. Attributes: Name Type Description visit_starts int For each node, before starting the visit. children_visit_starts int For each node, after the visit has started, and before starting to visit children. children_visit_stops int For each node, after the children have been visited, and before finishing the visit. visit_stops int For each node, after finishing the visit.","title":"When"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}